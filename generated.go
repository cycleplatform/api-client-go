// Package cycle provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package cycle

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	HubAuthScopes    = "hubAuth.Scopes"
)

// Defines values for AccountStateCurrent.
const (
	AccountStateCurrentDeleted    AccountStateCurrent = "deleted"
	AccountStateCurrentDeleting   AccountStateCurrent = "deleting"
	AccountStateCurrentLive       AccountStateCurrent = "live"
	AccountStateCurrentNew        AccountStateCurrent = "new"
	AccountStateCurrentPurging    AccountStateCurrent = "purging"
	AccountStateCurrentSuspending AccountStateCurrent = "suspending"
)

// Defines values for ActivityEvent.
const (
	ActivityEventBillingInvoicePay                                      ActivityEvent = "billing.invoice.pay"
	ActivityEventBillingInvoiceTaskCredit                               ActivityEvent = "billing.invoice.task.credit"
	ActivityEventBillingInvoiceTaskPay                                  ActivityEvent = "billing.invoice.task.pay"
	ActivityEventBillingInvoiceTaskRefund                               ActivityEvent = "billing.invoice.task.refund"
	ActivityEventBillingInvoiceTaskVoid                                 ActivityEvent = "billing.invoice.task.void"
	ActivityEventBillingMethodCreate                                    ActivityEvent = "billing.method.create"
	ActivityEventBillingMethodDelete                                    ActivityEvent = "billing.method.delete"
	ActivityEventBillingMethodTaskDelete                                ActivityEvent = "billing.method.task.delete"
	ActivityEventBillingMethodUpdate                                    ActivityEvent = "billing.method.update"
	ActivityEventBillingOrderConfirm                                    ActivityEvent = "billing.order.confirm"
	ActivityEventBillingOrderTaskConfirm                                ActivityEvent = "billing.order.task.confirm"
	ActivityEventContainerBackupCreate                                  ActivityEvent = "container.backup.create"
	ActivityEventContainerBackupDelete                                  ActivityEvent = "container.backup.delete"
	ActivityEventContainerBackupRestore                                 ActivityEvent = "container.backup.restore"
	ActivityEventContainerBackupTaskDelete                              ActivityEvent = "container.backup.task.delete"
	ActivityEventContainerBackupTaskRestore                             ActivityEvent = "container.backup.task.restore"
	ActivityEventContainerCreate                                        ActivityEvent = "container.create"
	ActivityEventContainerDelete                                        ActivityEvent = "container.delete"
	ActivityEventContainerDeprecate                                     ActivityEvent = "container.deprecate"
	ActivityEventContainerFunctionTaskTrigger                           ActivityEvent = "container.function.task.trigger"
	ActivityEventContainerFunctionTrigger                               ActivityEvent = "container.function.trigger"
	ActivityEventContainerInitialize                                    ActivityEvent = "container.initialize"
	ActivityEventContainerInstanceDelete                                ActivityEvent = "container.instance.delete"
	ActivityEventContainerInstanceError                                 ActivityEvent = "container.instance.error"
	ActivityEventContainerInstanceHealthcheckFailed                     ActivityEvent = "container.instance.healthcheck.failed"
	ActivityEventContainerInstanceHealthcheckRestarted                  ActivityEvent = "container.instance.healthcheck.restarted"
	ActivityEventContainerInstanceMigrationRevert                       ActivityEvent = "container.instance.migration.revert"
	ActivityEventContainerInstanceMigrationStart                        ActivityEvent = "container.instance.migration.start"
	ActivityEventContainerInstanceSshLogin                              ActivityEvent = "container.instance.ssh.login"
	ActivityEventContainerInstanceTaskMigrationRevert                   ActivityEvent = "container.instance.task.migration.revert"
	ActivityEventContainerInstanceTaskMigrationStart                    ActivityEvent = "container.instance.task.migration.start"
	ActivityEventContainerInstanceTaskVolumeExtend                      ActivityEvent = "container.instance.task.volume.extend"
	ActivityEventContainerInstanceTrafficDrainReconfigure               ActivityEvent = "container.instance.traffic-drain.reconfigure"
	ActivityEventContainerInstanceVolumeExtend                          ActivityEvent = "container.instance.volume.extend"
	ActivityEventContainerInstancesAutoscaleDown                        ActivityEvent = "container.instances.autoscale.down"
	ActivityEventContainerInstancesAutoscaleUp                          ActivityEvent = "container.instances.autoscale.up"
	ActivityEventContainerInstancesCreate                               ActivityEvent = "container.instances.create"
	ActivityEventContainerInstancesDelete                               ActivityEvent = "container.instances.delete"
	ActivityEventContainerReconfigure                                   ActivityEvent = "container.reconfigure"
	ActivityEventContainerReimage                                       ActivityEvent = "container.reimage"
	ActivityEventContainerRestart                                       ActivityEvent = "container.restart"
	ActivityEventContainerScale                                         ActivityEvent = "container.scale"
	ActivityEventContainerStart                                         ActivityEvent = "container.start"
	ActivityEventContainerStop                                          ActivityEvent = "container.stop"
	ActivityEventContainerTaskDelete                                    ActivityEvent = "container.task.delete"
	ActivityEventContainerTaskReconfigure                               ActivityEvent = "container.task.reconfigure"
	ActivityEventContainerTaskReimage                                   ActivityEvent = "container.task.reimage"
	ActivityEventContainerTaskRestart                                   ActivityEvent = "container.task.restart"
	ActivityEventContainerTaskScale                                     ActivityEvent = "container.task.scale"
	ActivityEventContainerTaskStart                                     ActivityEvent = "container.task.start"
	ActivityEventContainerTaskStop                                      ActivityEvent = "container.task.stop"
	ActivityEventContainerTaskVolumesReconfigure                        ActivityEvent = "container.task.volumes.reconfigure"
	ActivityEventContainerUpdate                                        ActivityEvent = "container.update"
	ActivityEventContainerVolumesReconfigure                            ActivityEvent = "container.volumes.reconfigure"
	ActivityEventDnsCertificateAssociate                                ActivityEvent = "dns.certificate.associate"
	ActivityEventDnsCertificateCreate                                   ActivityEvent = "dns.certificate.create"
	ActivityEventDnsCertificateDeprecate                                ActivityEvent = "dns.certificate.deprecate"
	ActivityEventDnsCertificateTaskDeprecate                            ActivityEvent = "dns.certificate.task.deprecate"
	ActivityEventDnsZoneCreate                                          ActivityEvent = "dns.zone.create"
	ActivityEventDnsZoneDelete                                          ActivityEvent = "dns.zone.delete"
	ActivityEventDnsZoneRecordCertGenerate                              ActivityEvent = "dns.zone.record.cert.generate"
	ActivityEventDnsZoneRecordCertGenerateAuto                          ActivityEvent = "dns.zone.record.cert.generate.auto"
	ActivityEventDnsZoneRecordCreate                                    ActivityEvent = "dns.zone.record.create"
	ActivityEventDnsZoneRecordDelete                                    ActivityEvent = "dns.zone.record.delete"
	ActivityEventDnsZoneRecordTaskCertGenerate                          ActivityEvent = "dns.zone.record.task.cert.generate"
	ActivityEventDnsZoneRecordTaskDelete                                ActivityEvent = "dns.zone.record.task.delete"
	ActivityEventDnsZoneRecordUpdate                                    ActivityEvent = "dns.zone.record.update"
	ActivityEventDnsZoneTaskDelete                                      ActivityEvent = "dns.zone.task.delete"
	ActivityEventDnsZoneTaskVerify                                      ActivityEvent = "dns.zone.task.verify"
	ActivityEventDnsZoneUpdate                                          ActivityEvent = "dns.zone.update"
	ActivityEventDnsZoneVerify                                          ActivityEvent = "dns.zone.verify"
	ActivityEventEnvironmentCreate                                      ActivityEvent = "environment.create"
	ActivityEventEnvironmentDelete                                      ActivityEvent = "environment.delete"
	ActivityEventEnvironmentDeploymentStart                             ActivityEvent = "environment.deployment.start"
	ActivityEventEnvironmentDeploymentStop                              ActivityEvent = "environment.deployment.stop"
	ActivityEventEnvironmentDeploymentsPrune                            ActivityEvent = "environment.deployments.prune"
	ActivityEventEnvironmentDeploymentsReconfigure                      ActivityEvent = "environment.deployments.reconfigure"
	ActivityEventEnvironmentInitialize                                  ActivityEvent = "environment.initialize"
	ActivityEventEnvironmentMonitoringReconfigure                       ActivityEvent = "environment.monitoring.reconfigure"
	ActivityEventEnvironmentScopedVariableCreate                        ActivityEvent = "environment.scoped-variable.create"
	ActivityEventEnvironmentScopedVariableDelete                        ActivityEvent = "environment.scoped-variable.delete"
	ActivityEventEnvironmentScopedVariableTaskDelete                    ActivityEvent = "environment.scoped-variable.task.delete"
	ActivityEventEnvironmentScopedVariableUpdate                        ActivityEvent = "environment.scoped-variable.update"
	ActivityEventEnvironmentServicesDiscoveryReconfigure                ActivityEvent = "environment.services.discovery.reconfigure"
	ActivityEventEnvironmentServicesDiscoveryTaskReconfigure            ActivityEvent = "environment.services.discovery.task.reconfigure"
	ActivityEventEnvironmentServicesLbReconfigure                       ActivityEvent = "environment.services.lb.reconfigure"
	ActivityEventEnvironmentServicesLbTaskReconfigure                   ActivityEvent = "environment.services.lb.task.reconfigure"
	ActivityEventEnvironmentServicesSchedulerReconfigure                ActivityEvent = "environment.services.scheduler.reconfigure"
	ActivityEventEnvironmentServicesSchedulerTaskReconfigure            ActivityEvent = "environment.services.scheduler.task.reconfigure"
	ActivityEventEnvironmentServicesVpnLogin                            ActivityEvent = "environment.services.vpn.login"
	ActivityEventEnvironmentServicesVpnReconfigure                      ActivityEvent = "environment.services.vpn.reconfigure"
	ActivityEventEnvironmentServicesVpnReset                            ActivityEvent = "environment.services.vpn.reset"
	ActivityEventEnvironmentServicesVpnTaskReconfigure                  ActivityEvent = "environment.services.vpn.task.reconfigure"
	ActivityEventEnvironmentServicesVpnTaskReset                        ActivityEvent = "environment.services.vpn.task.reset"
	ActivityEventEnvironmentServicesVpnUserCreate                       ActivityEvent = "environment.services.vpn.user.create"
	ActivityEventEnvironmentStart                                       ActivityEvent = "environment.start"
	ActivityEventEnvironmentStop                                        ActivityEvent = "environment.stop"
	ActivityEventEnvironmentTaskDelete                                  ActivityEvent = "environment.task.delete"
	ActivityEventEnvironmentTaskDeploymentsReconfigure                  ActivityEvent = "environment.task.deployments.reconfigure"
	ActivityEventEnvironmentTaskInitialize                              ActivityEvent = "environment.task.initialize"
	ActivityEventEnvironmentTaskMonitoringReconfigure                   ActivityEvent = "environment.task.monitoring.reconfigure"
	ActivityEventEnvironmentTaskStart                                   ActivityEvent = "environment.task.start"
	ActivityEventEnvironmentTaskStop                                    ActivityEvent = "environment.task.stop"
	ActivityEventEnvironmentUpdate                                      ActivityEvent = "environment.update"
	ActivityEventHubApikeyCreate                                        ActivityEvent = "hub.apikey.create"
	ActivityEventHubApikeyDelete                                        ActivityEvent = "hub.apikey.delete"
	ActivityEventHubApikeyUpdate                                        ActivityEvent = "hub.apikey.update"
	ActivityEventHubCreate                                              ActivityEvent = "hub.create"
	ActivityEventHubImagesPrune                                         ActivityEvent = "hub.images.prune"
	ActivityEventHubInactive                                            ActivityEvent = "hub.inactive"
	ActivityEventHubIntegrationCreate                                   ActivityEvent = "hub.integration.create"
	ActivityEventHubIntegrationDelete                                   ActivityEvent = "hub.integration.delete"
	ActivityEventHubIntegrationTaskDelete                               ActivityEvent = "hub.integration.task.delete"
	ActivityEventHubIntegrationTaskVerify                               ActivityEvent = "hub.integration.task.verify"
	ActivityEventHubIntegrationUpdate                                   ActivityEvent = "hub.integration.update"
	ActivityEventHubMembershipCreate                                    ActivityEvent = "hub.membership.create"
	ActivityEventHubMembershipDelete                                    ActivityEvent = "hub.membership.delete"
	ActivityEventHubMembershipUpdate                                    ActivityEvent = "hub.membership.update"
	ActivityEventHubRoleCreate                                          ActivityEvent = "hub.role.create"
	ActivityEventHubRoleDelete                                          ActivityEvent = "hub.role.delete"
	ActivityEventHubRoleTaskDelete                                      ActivityEvent = "hub.role.task.delete"
	ActivityEventHubRoleUpdate                                          ActivityEvent = "hub.role.update"
	ActivityEventHubTaskDelete                                          ActivityEvent = "hub.task.delete"
	ActivityEventHubTaskImagesPrune                                     ActivityEvent = "hub.task.images.prune"
	ActivityEventHubUpdate                                              ActivityEvent = "hub.update"
	ActivityEventImageCreate                                            ActivityEvent = "image.create"
	ActivityEventImageDelete                                            ActivityEvent = "image.delete"
	ActivityEventImageImport                                            ActivityEvent = "image.import"
	ActivityEventImageSourceCreate                                      ActivityEvent = "image.source.create"
	ActivityEventImageSourceDelete                                      ActivityEvent = "image.source.delete"
	ActivityEventImageSourceTaskDelete                                  ActivityEvent = "image.source.task.delete"
	ActivityEventImageSourceUpdate                                      ActivityEvent = "image.source.update"
	ActivityEventImageTaskDelete                                        ActivityEvent = "image.task.delete"
	ActivityEventImageTaskImport                                        ActivityEvent = "image.task.import"
	ActivityEventImageUpdate                                            ActivityEvent = "image.update"
	ActivityEventInfrastructureAutoscaleGroupCreate                     ActivityEvent = "infrastructure.autoscale.group.create"
	ActivityEventInfrastructureAutoscaleGroupDelete                     ActivityEvent = "infrastructure.autoscale.group.delete"
	ActivityEventInfrastructureAutoscaleGroupTaskDelete                 ActivityEvent = "infrastructure.autoscale.group.task.delete"
	ActivityEventInfrastructureAutoscaleGroupUpdate                     ActivityEvent = "infrastructure.autoscale.group.update"
	ActivityEventInfrastructureClusterCreate                            ActivityEvent = "infrastructure.cluster.create"
	ActivityEventInfrastructureClusterDelete                            ActivityEvent = "infrastructure.cluster.delete"
	ActivityEventInfrastructureClusterFeaturesMonitoringTierReconfigure ActivityEvent = "infrastructure.cluster.features.monitoring.tier.reconfigure"
	ActivityEventInfrastructureClusterTaskDelete                        ActivityEvent = "infrastructure.cluster.task.delete"
	ActivityEventInfrastructureClusterUpdate                            ActivityEvent = "infrastructure.cluster.update"
	ActivityEventInfrastructureExternalVolumeCreate                     ActivityEvent = "infrastructure.external-volume.create"
	ActivityEventInfrastructureExternalVolumeDelete                     ActivityEvent = "infrastructure.external-volume.delete"
	ActivityEventInfrastructureExternalVolumeServersReconfigure         ActivityEvent = "infrastructure.external-volume.servers.reconfigure"
	ActivityEventInfrastructureExternalVolumeTaskDelete                 ActivityEvent = "infrastructure.external-volume.task.delete"
	ActivityEventInfrastructureExternalVolumeTaskServersReconfigure     ActivityEvent = "infrastructure.external-volume.task.servers.reconfigure"
	ActivityEventInfrastructureExternalVolumeUpdate                     ActivityEvent = "infrastructure.external-volume.update"
	ActivityEventInfrastructureIpsPoolCreate                            ActivityEvent = "infrastructure.ips.pool.create"
	ActivityEventInfrastructureIpsPoolTaskDelete                        ActivityEvent = "infrastructure.ips.pool.task.delete"
	ActivityEventInfrastructureProviderCreate                           ActivityEvent = "infrastructure.provider.create"
	ActivityEventInfrastructureProviderTaskDelete                       ActivityEvent = "infrastructure.provider.task.delete"
	ActivityEventInfrastructureProviderTaskVerify                       ActivityEvent = "infrastructure.provider.task.verify"
	ActivityEventInfrastructureProviderUpdate                           ActivityEvent = "infrastructure.provider.update"
	ActivityEventInfrastructureServerAuthReset                          ActivityEvent = "infrastructure.server.auth.reset"
	ActivityEventInfrastructureServerComputeRestart                     ActivityEvent = "infrastructure.server.compute.restart"
	ActivityEventInfrastructureServerComputeSpawnerRestart              ActivityEvent = "infrastructure.server.compute.spawner.restart"
	ActivityEventInfrastructureServerConsole                            ActivityEvent = "infrastructure.server.console"
	ActivityEventInfrastructureServerDelete                             ActivityEvent = "infrastructure.server.delete"
	ActivityEventInfrastructureServerEvacuationReset                    ActivityEvent = "infrastructure.server.evacuation.reset"
	ActivityEventInfrastructureServerEvacuationStart                    ActivityEvent = "infrastructure.server.evacuation.start"
	ActivityEventInfrastructureServerFeaturesReconfigure                ActivityEvent = "infrastructure.server.features.reconfigure"
	ActivityEventInfrastructureServerLive                               ActivityEvent = "infrastructure.server.live"
	ActivityEventInfrastructureServerPowerOff                           ActivityEvent = "infrastructure.server.power-off"
	ActivityEventInfrastructureServerProvision                          ActivityEvent = "infrastructure.server.provision"
	ActivityEventInfrastructureServerRestart                            ActivityEvent = "infrastructure.server.restart"
	ActivityEventInfrastructureServerServicesInternalApiThrottle        ActivityEvent = "infrastructure.server.services.internal-api.throttle"
	ActivityEventInfrastructureServerServicesSftpAuth                   ActivityEvent = "infrastructure.server.services.sftp.auth"
	ActivityEventInfrastructureServerServicesSftpLockdown               ActivityEvent = "infrastructure.server.services.sftp.lockdown"
	ActivityEventInfrastructureServerSharedfsReconfigure                ActivityEvent = "infrastructure.server.sharedfs.reconfigure"
	ActivityEventInfrastructureServerSshToken                           ActivityEvent = "infrastructure.server.ssh.token"
	ActivityEventInfrastructureServerTaskDelete                         ActivityEvent = "infrastructure.server.task.delete"
	ActivityEventInfrastructureServerTaskEvacuationReset                ActivityEvent = "infrastructure.server.task.evacuation.reset"
	ActivityEventInfrastructureServerTaskEvacuationStart                ActivityEvent = "infrastructure.server.task.evacuation.start"
	ActivityEventInfrastructureServerTaskFeaturesReconfigure            ActivityEvent = "infrastructure.server.task.features.reconfigure"
	ActivityEventInfrastructureServerTaskProvision                      ActivityEvent = "infrastructure.server.task.provision"
	ActivityEventInfrastructureServerTaskRestart                        ActivityEvent = "infrastructure.server.task.restart"
	ActivityEventInfrastructureServerTaskSharedfsReconfigure            ActivityEvent = "infrastructure.server.task.sharedfs.reconfigure"
	ActivityEventInfrastructureServerUnquarantine                       ActivityEvent = "infrastructure.server.unquarantine"
	ActivityEventInfrastructureServerUpdate                             ActivityEvent = "infrastructure.server.update"
	ActivityEventInfrastructureVirtualProvidersIsoCreate                ActivityEvent = "infrastructure.virtual-providers.iso.create"
	ActivityEventInfrastructureVirtualProvidersIsoDelete                ActivityEvent = "infrastructure.virtual-providers.iso.delete"
	ActivityEventInfrastructureVirtualProvidersIsoGenerate              ActivityEvent = "infrastructure.virtual-providers.iso.generate"
	ActivityEventInfrastructureVirtualProvidersIsoTaskDelete            ActivityEvent = "infrastructure.virtual-providers.iso.task.delete"
	ActivityEventInfrastructureVirtualProvidersIsoUpdate                ActivityEvent = "infrastructure.virtual-providers.iso.update"
	ActivityEventPipelineCreate                                         ActivityEvent = "pipeline.create"
	ActivityEventPipelineDelete                                         ActivityEvent = "pipeline.delete"
	ActivityEventPipelineKeyCreate                                      ActivityEvent = "pipeline.key.create"
	ActivityEventPipelineKeyDelete                                      ActivityEvent = "pipeline.key.delete"
	ActivityEventPipelineKeyUpdate                                      ActivityEvent = "pipeline.key.update"
	ActivityEventPipelineRunCompleted                                   ActivityEvent = "pipeline.run.completed"
	ActivityEventPipelineTaskDelete                                     ActivityEvent = "pipeline.task.delete"
	ActivityEventPipelineTaskTrigger                                    ActivityEvent = "pipeline.task.trigger"
	ActivityEventPipelineTrigger                                        ActivityEvent = "pipeline.trigger"
	ActivityEventPipelineUpdate                                         ActivityEvent = "pipeline.update"
	ActivityEventSdnNetworkCreate                                       ActivityEvent = "sdn.network.create"
	ActivityEventSdnNetworkTaskDelete                                   ActivityEvent = "sdn.network.task.delete"
	ActivityEventSdnNetworkTaskReconfigure                              ActivityEvent = "sdn.network.task.reconfigure"
	ActivityEventSdnNetworkUpdate                                       ActivityEvent = "sdn.network.update"
	ActivityEventStackBuildCreate                                       ActivityEvent = "stack.build.create"
	ActivityEventStackBuildDelete                                       ActivityEvent = "stack.build.delete"
	ActivityEventStackBuildDeploy                                       ActivityEvent = "stack.build.deploy"
	ActivityEventStackBuildGenerate                                     ActivityEvent = "stack.build.generate"
	ActivityEventStackBuildTaskDelete                                   ActivityEvent = "stack.build.task.delete"
	ActivityEventStackBuildTaskDeploy                                   ActivityEvent = "stack.build.task.deploy"
	ActivityEventStackBuildTaskGenerate                                 ActivityEvent = "stack.build.task.generate"
	ActivityEventStackCreate                                            ActivityEvent = "stack.create"
	ActivityEventStackDelete                                            ActivityEvent = "stack.delete"
	ActivityEventStackPrune                                             ActivityEvent = "stack.prune"
	ActivityEventStackTaskDelete                                        ActivityEvent = "stack.task.delete"
	ActivityEventStackTaskPrune                                         ActivityEvent = "stack.task.prune"
	ActivityEventStackUpdate                                            ActivityEvent = "stack.update"
	ActivityEventVirtualMachineCreate                                   ActivityEvent = "virtual-machine.create"
	ActivityEventVirtualMachineDelete                                   ActivityEvent = "virtual-machine.delete"
	ActivityEventVirtualMachineInitialize                               ActivityEvent = "virtual-machine.initialize"
	ActivityEventVirtualMachineIpAllocate                               ActivityEvent = "virtual-machine.ip.allocate"
	ActivityEventVirtualMachineIpUnallocate                             ActivityEvent = "virtual-machine.ip.unallocate"
	ActivityEventVirtualMachineReconfigure                              ActivityEvent = "virtual-machine.reconfigure"
	ActivityEventVirtualMachineRootpwChange                             ActivityEvent = "virtual-machine.rootpw.change"
	ActivityEventVirtualMachineSosLogin                                 ActivityEvent = "virtual-machine.sos.login"
	ActivityEventVirtualMachineSshKeyCreate                             ActivityEvent = "virtual-machine.ssh-key.create"
	ActivityEventVirtualMachineSshKeyDelete                             ActivityEvent = "virtual-machine.ssh-key.delete"
	ActivityEventVirtualMachineSshKeyTaskDelete                         ActivityEvent = "virtual-machine.ssh-key.task.delete"
	ActivityEventVirtualMachineSshKeyUpdate                             ActivityEvent = "virtual-machine.ssh-key.update"
	ActivityEventVirtualMachineStart                                    ActivityEvent = "virtual-machine.start"
	ActivityEventVirtualMachineStop                                     ActivityEvent = "virtual-machine.stop"
	ActivityEventVirtualMachineTaskDelete                               ActivityEvent = "virtual-machine.task.delete"
	ActivityEventVirtualMachineTaskIpAllocate                           ActivityEvent = "virtual-machine.task.ip.allocate"
	ActivityEventVirtualMachineTaskIpUnallocate                         ActivityEvent = "virtual-machine.task.ip.unallocate"
	ActivityEventVirtualMachineTaskReconfigure                          ActivityEvent = "virtual-machine.task.reconfigure"
	ActivityEventVirtualMachineTaskStart                                ActivityEvent = "virtual-machine.task.start"
	ActivityEventVirtualMachineTaskStop                                 ActivityEvent = "virtual-machine.task.stop"
	ActivityEventVirtualMachineTaskVolumesReconfigure                   ActivityEvent = "virtual-machine.task.volumes.reconfigure"
	ActivityEventVirtualMachineUpdate                                   ActivityEvent = "virtual-machine.update"
	ActivityEventVirtualMachineVolumesReconfigure                       ActivityEvent = "virtual-machine.volumes.reconfigure"
)

// Defines values for ActivityStatus.
const (
	ActivityStatusAlert   ActivityStatus = "alert"
	ActivityStatusError   ActivityStatus = "error"
	ActivityStatusInfo    ActivityStatus = "info"
	ActivityStatusRequest ActivityStatus = "request"
	ActivityStatusSuccess ActivityStatus = "success"
	ActivityStatusWarn    ActivityStatus = "warn"
)

// Defines values for ActivityUserType.
const (
	ActivityUserTypeAccount          ActivityUserType = "account"
	ActivityUserTypeApiKey           ActivityUserType = "api-key"
	ActivityUserTypeEmployee         ActivityUserType = "employee"
	ActivityUserTypeEnvironment      ActivityUserType = "environment"
	ActivityUserTypePlatform         ActivityUserType = "platform"
	ActivityUserTypePlatformPipeline ActivityUserType = "platform-pipeline"
	ActivityUserTypeVisitor          ActivityUserType = "visitor"
)

// Defines values for ActivityMonitorEvent.
const (
	ActivityMonitorEventDetection  ActivityMonitorEvent = "detection"
	ActivityMonitorEventNotice     ActivityMonitorEvent = "notice"
	ActivityMonitorEventPrevention ActivityMonitorEvent = "prevention"
	ActivityMonitorEventReaction   ActivityMonitorEvent = "reaction"
	ActivityMonitorEventSuggestion ActivityMonitorEvent = "suggestion"
)

// Defines values for ActivityMonitorLevel.
const (
	ActivityMonitorLevelCritical ActivityMonitorLevel = "critical"
	ActivityMonitorLevelHigh     ActivityMonitorLevel = "high"
	ActivityMonitorLevelInfo     ActivityMonitorLevel = "info"
	ActivityMonitorLevelLow      ActivityMonitorLevel = "low"
	ActivityMonitorLevelMedium   ActivityMonitorLevel = "medium"
)

// Defines values for ActivityMonitorState.
const (
	ActivityMonitorStateFlux        ActivityMonitorState = "flux"
	ActivityMonitorStateNone        ActivityMonitorState = "none"
	ActivityMonitorStateRecovered   ActivityMonitorState = "recovered"
	ActivityMonitorStateUnknown     ActivityMonitorState = "unknown"
	ActivityMonitorStateUnreachable ActivityMonitorState = "unreachable"
)

// Defines values for ActivitySecurityAttack.
const (
	ActivitySecurityAttackAccessElevation      ActivitySecurityAttack = "access-elevation"
	ActivitySecurityAttackAuthFailure          ActivitySecurityAttack = "auth-failure"
	ActivitySecurityAttackBruteForce           ActivitySecurityAttack = "brute-force"
	ActivitySecurityAttackExploitVulnerability ActivitySecurityAttack = "exploit-vulnerability"
	ActivitySecurityAttackNone                 ActivitySecurityAttack = "none"
	ActivitySecurityAttackServiceInterruption  ActivitySecurityAttack = "service-interruption"
	ActivitySecurityAttackSocialEngineer       ActivitySecurityAttack = "social-engineer"
)

// Defines values for ActivitySecurityEvent.
const (
	ActivitySecurityEventDetection  ActivitySecurityEvent = "detection"
	ActivitySecurityEventNotice     ActivitySecurityEvent = "notice"
	ActivitySecurityEventPrevention ActivitySecurityEvent = "prevention"
	ActivitySecurityEventReaction   ActivitySecurityEvent = "reaction"
	ActivitySecurityEventSuggestion ActivitySecurityEvent = "suggestion"
)

// Defines values for ActivitySecurityRisk.
const (
	ActivitySecurityRiskCritical ActivitySecurityRisk = "critical"
	ActivitySecurityRiskHigh     ActivitySecurityRisk = "high"
	ActivitySecurityRiskInfo     ActivitySecurityRisk = "info"
	ActivitySecurityRiskLow      ActivitySecurityRisk = "low"
	ActivitySecurityRiskMedium   ActivitySecurityRisk = "medium"
)

// Defines values for ActivitySecuritySurface.
const (
	ActivitySecuritySurfaceApi     ActivitySecuritySurface = "api"
	ActivitySecuritySurfaceFs      ActivitySecuritySurface = "fs"
	ActivitySecuritySurfaceNetwork ActivitySecuritySurface = "network"
	ActivitySecuritySurfaceService ActivitySecuritySurface = "service"
)

// Defines values for AnnouncementPriority.
const (
	AnnouncementPriorityHigh   AnnouncementPriority = "high"
	AnnouncementPriorityLow    AnnouncementPriority = "low"
	AnnouncementPriorityMedium AnnouncementPriority = "medium"
	AnnouncementPriorityNotice AnnouncementPriority = "notice"
	AnnouncementPrioritySevere AnnouncementPriority = "severe"
)

// Defines values for AnnouncementStateCurrent.
const (
	AnnouncementStateCurrentDeleted  AnnouncementStateCurrent = "deleted"
	AnnouncementStateCurrentDeleting AnnouncementStateCurrent = "deleting"
	AnnouncementStateCurrentLive     AnnouncementStateCurrent = "live"
)

// Defines values for ApiKeyCreatorStateCurrent.
const (
	ApiKeyCreatorStateCurrentDeleted  ApiKeyCreatorStateCurrent = "deleted"
	ApiKeyCreatorStateCurrentDeleting ApiKeyCreatorStateCurrent = "deleting"
	ApiKeyCreatorStateCurrentLive     ApiKeyCreatorStateCurrent = "live"
)

// Defines values for ApiKeyStateCurrent.
const (
	ApiKeyStateCurrentConfiguring ApiKeyStateCurrent = "configuring"
	ApiKeyStateCurrentDeleted     ApiKeyStateCurrent = "deleted"
	ApiKeyStateCurrentDeleting    ApiKeyStateCurrent = "deleting"
	ApiKeyStateCurrentInactive    ApiKeyStateCurrent = "inactive"
	ApiKeyStateCurrentLive        ApiKeyStateCurrent = "live"
	ApiKeyStateCurrentNew         ApiKeyStateCurrent = "new"
)

// Defines values for AutoScaleGroupStateCurrent.
const (
	AutoScaleGroupStateCurrentDeleted  AutoScaleGroupStateCurrent = "deleted"
	AutoScaleGroupStateCurrentDeleting AutoScaleGroupStateCurrent = "deleting"
	AutoScaleGroupStateCurrentLive     AutoScaleGroupStateCurrent = "live"
	AutoScaleGroupStateCurrentNew      AutoScaleGroupStateCurrent = "new"
)

// Defines values for AutoScaleGroupScaleDownMethod.
const (
	Fifo AutoScaleGroupScaleDownMethod = "fifo"
	Lifo AutoScaleGroupScaleDownMethod = "lifo"
)

// Defines values for BillingAmountTerm.
const (
	BillingAmountTermMonthly BillingAmountTerm = "monthly"
	BillingAmountTermOnce    BillingAmountTerm = "once"
	BillingAmountTermYearly  BillingAmountTerm = "yearly"
)

// Defines values for BillingImageStorageAdditionalGbTerm.
const (
	BillingImageStorageAdditionalGbTermMonthly BillingImageStorageAdditionalGbTerm = "monthly"
	BillingImageStorageAdditionalGbTermOnce    BillingImageStorageAdditionalGbTerm = "once"
	BillingImageStorageAdditionalGbTermYearly  BillingImageStorageAdditionalGbTerm = "yearly"
)

// Defines values for BillingOrderStateCurrent.
const (
	BillingOrderStateCurrentDeleted   BillingOrderStateCurrent = "deleted"
	BillingOrderStateCurrentDeleting  BillingOrderStateCurrent = "deleting"
	BillingOrderStateCurrentNew       BillingOrderStateCurrent = "new"
	BillingOrderStateCurrentProcessed BillingOrderStateCurrent = "processed"
)

// Defines values for BillingRamAdditionalGbTerm.
const (
	BillingRamAdditionalGbTermMonthly BillingRamAdditionalGbTerm = "monthly"
	BillingRamAdditionalGbTermOnce    BillingRamAdditionalGbTerm = "once"
	BillingRamAdditionalGbTermYearly  BillingRamAdditionalGbTerm = "yearly"
)

// Defines values for BillingServiceStateCurrent.
const (
	BillingServiceStateCurrentActive BillingServiceStateCurrent = "active"
)

// Defines values for BillingSummaryType.
const (
	Support BillingSummaryType = "support"
	Tier    BillingSummaryType = "tier"
)

// Defines values for BucketImageSourceTypeType.
const (
	BucketImageSourceTypeTypeBucket BucketImageSourceTypeType = "bucket"
)

// Defines values for Capability.
const (
	ApiKeysManage                     Capability = "api-keys-manage"
	ApionlyJobsView                   Capability = "apionly-jobs-view"
	ApionlyNotificationsListen        Capability = "apionly-notifications-listen"
	AutoscaleGroupsManage             Capability = "autoscale-groups-manage"
	AutoscaleGroupsView               Capability = "autoscale-groups-view"
	BillingCreditsView                Capability = "billing-credits-view"
	BillingInvoicesPay                Capability = "billing-invoices-pay"
	BillingInvoicesView               Capability = "billing-invoices-view"
	BillingMethodsManage              Capability = "billing-methods-manage"
	BillingServicesManage             Capability = "billing-services-manage"
	BillingServicesView               Capability = "billing-services-view"
	ClustersManage                    Capability = "clusters-manage"
	ClustersView                      Capability = "clusters-view"
	ContainersBackupsManage           Capability = "containers-backups-manage"
	ContainersBackupsView             Capability = "containers-backups-view"
	ContainersConsole                 Capability = "containers-console"
	ContainersDeploy                  Capability = "containers-deploy"
	ContainersFunctionsTrigger        Capability = "containers-functions-trigger"
	ContainersInstancesMigrate        Capability = "containers-instances-migrate"
	ContainersLock                    Capability = "containers-lock"
	ContainersManage                  Capability = "containers-manage"
	ContainersSsh                     Capability = "containers-ssh"
	ContainersView                    Capability = "containers-view"
	ContainersVolumesManage           Capability = "containers-volumes-manage"
	ContainersVolumesView             Capability = "containers-volumes-view"
	DnsCertsView                      Capability = "dns-certs-view"
	DnsManage                         Capability = "dns-manage"
	DnsView                           Capability = "dns-view"
	EnvironmentsDeploymentsManage     Capability = "environments-deployments-manage"
	EnvironmentsManage                Capability = "environments-manage"
	EnvironmentsScopedvariablesManage Capability = "environments-scopedvariables-manage"
	EnvironmentsScopedvariablesView   Capability = "environments-scopedvariables-view"
	EnvironmentsServicesManage        Capability = "environments-services-manage"
	EnvironmentsView                  Capability = "environments-view"
	EnvironmentsVpn                   Capability = "environments-vpn"
	EnvironmentsVpnManage             Capability = "environments-vpn-manage"
	ExternalVolumesManage             Capability = "external-volumes-manage"
	ExternalVolumesView               Capability = "external-volumes-view"
	HubsAuditlogView                  Capability = "hubs-auditlog-view"
	HubsDelete                        Capability = "hubs-delete"
	HubsIntegrationsManage            Capability = "hubs-integrations-manage"
	HubsIntegrationsView              Capability = "hubs-integrations-view"
	HubsInvitesManage                 Capability = "hubs-invites-manage"
	HubsInvitesSend                   Capability = "hubs-invites-send"
	HubsMembersManage                 Capability = "hubs-members-manage"
	HubsMembersView                   Capability = "hubs-members-view"
	HubsRolesManage                   Capability = "hubs-roles-manage"
	HubsRolesView                     Capability = "hubs-roles-view"
	HubsUpdate                        Capability = "hubs-update"
	HubsUsageView                     Capability = "hubs-usage-view"
	ImagesManage                      Capability = "images-manage"
	ImagesSourcesManage               Capability = "images-sources-manage"
	ImagesSourcesView                 Capability = "images-sources-view"
	ImagesView                        Capability = "images-view"
	IpsManage                         Capability = "ips-manage"
	MonitorManage                     Capability = "monitor-manage"
	MonitorView                       Capability = "monitor-view"
	PipelinesManage                   Capability = "pipelines-manage"
	PipelinesTrigger                  Capability = "pipelines-trigger"
	PipelinesView                     Capability = "pipelines-view"
	SanManage                         Capability = "san-manage"
	SanView                           Capability = "san-view"
	SdnNetworksManage                 Capability = "sdn-networks-manage"
	SdnNetworksView                   Capability = "sdn-networks-view"
	SecurityManage                    Capability = "security-manage"
	SecurityView                      Capability = "security-view"
	ServersConsole                    Capability = "servers-console"
	ServersDecommission               Capability = "servers-decommission"
	ServersLogin                      Capability = "servers-login"
	ServersManage                     Capability = "servers-manage"
	ServersProvision                  Capability = "servers-provision"
	ServersView                       Capability = "servers-view"
	StacksBuildsDeploy                Capability = "stacks-builds-deploy"
	StacksBuildsManage                Capability = "stacks-builds-manage"
	StacksManage                      Capability = "stacks-manage"
	StacksView                        Capability = "stacks-view"
	VirtualMachinesConsole            Capability = "virtual-machines-console"
	VirtualMachinesDeploy             Capability = "virtual-machines-deploy"
	VirtualMachinesLock               Capability = "virtual-machines-lock"
	VirtualMachinesManage             Capability = "virtual-machines-manage"
	VirtualMachinesRootPwView         Capability = "virtual-machines-root-pw-view"
	VirtualMachinesRootPwViewTemp     Capability = "virtual-machines-root-pw-view-temp"
	VirtualMachinesSshKeysManage      Capability = "virtual-machines-ssh-keys-manage"
	VirtualMachinesView               Capability = "virtual-machines-view"
)

// Defines values for ChangelogEntryChangesType.
const (
	ChangelogEntryChangesTypeAdded       ChangelogEntryChangesType = "added"
	ChangelogEntryChangesTypeChanged     ChangelogEntryChangesType = "changed"
	ChangelogEntryChangesTypeDeprecated  ChangelogEntryChangesType = "deprecated"
	ChangelogEntryChangesTypeFixed       ChangelogEntryChangesType = "fixed"
	ChangelogEntryChangesTypeImprovement ChangelogEntryChangesType = "improvement"
	ChangelogEntryChangesTypeRemoved     ChangelogEntryChangesType = "removed"
	ChangelogEntryChangesTypeSecurity    ChangelogEntryChangesType = "security"
)

// Defines values for ChangelogEntryEmailEventsType.
const (
	External ChangelogEntryEmailEventsType = "external"
	Internal ChangelogEntryEmailEventsType = "internal"
	Single   ChangelogEntryEmailEventsType = "single"
)

// Defines values for ChangelogEntryStateCurrent.
const (
	ChangelogEntryStateCurrentApproved  ChangelogEntryStateCurrent = "approved"
	ChangelogEntryStateCurrentDeleted   ChangelogEntryStateCurrent = "deleted"
	ChangelogEntryStateCurrentNew       ChangelogEntryStateCurrent = "new"
	ChangelogEntryStateCurrentPublished ChangelogEntryStateCurrent = "published"
)

// Defines values for ClusterReconfigureMonitoringTierActionAction.
const (
	FeaturesMonitoringTierReconfigure ClusterReconfigureMonitoringTierActionAction = "features.monitoring.tier.reconfigure"
)

// Defines values for ClusterStateCurrent.
const (
	ClusterStateCurrentDeleted  ClusterStateCurrent = "deleted"
	ClusterStateCurrentDeleting ClusterStateCurrent = "deleting"
	ClusterStateCurrentLive     ClusterStateCurrent = "live"
)

// Defines values for ContainerRole.
const (
	Orchestrator ContainerRole = "orchestrator"
)

// Defines values for ContainerBackupLogsType.
const (
	ContainerBackupLogsTypeBackup  ContainerBackupLogsType = "backup"
	ContainerBackupLogsTypeRestore ContainerBackupLogsType = "restore"
)

// Defines values for ContainerBackupStateCurrent.
const (
	ContainerBackupStateCurrentDeleted  ContainerBackupStateCurrent = "deleted"
	ContainerBackupStateCurrentDeleting ContainerBackupStateCurrent = "deleting"
	ContainerBackupStateCurrentLive     ContainerBackupStateCurrent = "live"
	ContainerBackupStateCurrentSaving   ContainerBackupStateCurrent = "saving"
)

// Defines values for ContainerCreateStepAction.
const (
	ContainerCreateStepActionContainerCreate ContainerCreateStepAction = "container.create"
)

// Defines values for ContainerDeleteStepAction.
const (
	ContainerDeleteStepActionContainerDelete ContainerDeleteStepAction = "container.delete"
)

// Defines values for ContainerDeployRestartCondition.
const (
	Always  ContainerDeployRestartCondition = "always"
	Failure ContainerDeployRestartCondition = "failure"
	Never   ContainerDeployRestartCondition = "never"
)

// Defines values for ContainerExtensionIdentifier.
const (
	VirtualMachineV1 ContainerExtensionIdentifier = "virtual-machine-v1"
)

// Defines values for ContainerFunctionTriggerStepAction.
const (
	ContainerFunctionTrigger ContainerFunctionTriggerStepAction = "container.function.trigger"
)

// Defines values for ContainerImageSummaryService.
const (
	ContainerImageSummaryServiceDiscovery    ContainerImageSummaryService = "discovery"
	ContainerImageSummaryServiceLoadbalancer ContainerImageSummaryService = "loadbalancer"
	ContainerImageSummaryServiceVpn          ContainerImageSummaryService = "vpn"
)

// Defines values for ContainerNetworkPublic.
const (
	ContainerNetworkPublicDisable    ContainerNetworkPublic = "disable"
	ContainerNetworkPublicEgressOnly ContainerNetworkPublic = "egress-only"
	ContainerNetworkPublicEnable     ContainerNetworkPublic = "enable"
)

// Defines values for ContainerReconfigureActionAction.
const (
	ContainerReconfigureActionActionReconfigure ContainerReconfigureActionAction = "reconfigure"
)

// Defines values for ContainerReconfigureVolumesActionAction.
const (
	ContainerReconfigureVolumesActionActionVolumesReconfigure ContainerReconfigureVolumesActionAction = "volumes.reconfigure"
)

// Defines values for ContainerReimageActionAction.
const (
	Reimage ContainerReimageActionAction = "reimage"
)

// Defines values for ContainerReimageStepAction.
const (
	ContainerReimage ContainerReimageStepAction = "container.reimage"
)

// Defines values for ContainerRestartActionAction.
const (
	ContainerRestartActionActionRestart ContainerRestartActionAction = "restart"
)

// Defines values for ContainerRestartStepAction.
const (
	ContainerRestart ContainerRestartStepAction = "container.restart"
)

// Defines values for ContainerRuntimeCapabilities.
const (
	CAPAUDITCONTROL   ContainerRuntimeCapabilities = "CAP_AUDIT_CONTROL"
	CAPAUDITREAD      ContainerRuntimeCapabilities = "CAP_AUDIT_READ"
	CAPAUDITWRITE     ContainerRuntimeCapabilities = "CAP_AUDIT_WRITE"
	CAPBLOCKSUSPEND   ContainerRuntimeCapabilities = "CAP_BLOCK_SUSPEND"
	CAPCHOWN          ContainerRuntimeCapabilities = "CAP_CHOWN"
	CAPDACOVERRIDE    ContainerRuntimeCapabilities = "CAP_DAC_OVERRIDE"
	CAPDACREADSEARCH  ContainerRuntimeCapabilities = "CAP_DAC_READ_SEARCH"
	CAPFOWNER         ContainerRuntimeCapabilities = "CAP_FOWNER"
	CAPFSETID         ContainerRuntimeCapabilities = "CAP_FSETID"
	CAPIPCLOCK        ContainerRuntimeCapabilities = "CAP_IPC_LOCK"
	CAPIPCOWNER       ContainerRuntimeCapabilities = "CAP_IPC_OWNER"
	CAPKILL           ContainerRuntimeCapabilities = "CAP_KILL"
	CAPLEASE          ContainerRuntimeCapabilities = "CAP_LEASE"
	CAPLINUXIMMUTABLE ContainerRuntimeCapabilities = "CAP_LINUX_IMMUTABLE"
	CAPMACADMIN       ContainerRuntimeCapabilities = "CAP_MAC_ADMIN"
	CAPMACOVERRIDE    ContainerRuntimeCapabilities = "CAP_MAC_OVERRIDE"
	CAPMKNOD          ContainerRuntimeCapabilities = "CAP_MKNOD"
	CAPNETADMIN       ContainerRuntimeCapabilities = "CAP_NET_ADMIN"
	CAPNETBINDSERVICE ContainerRuntimeCapabilities = "CAP_NET_BIND_SERVICE"
	CAPNETBROADCAST   ContainerRuntimeCapabilities = "CAP_NET_BROADCAST"
	CAPNETRAW         ContainerRuntimeCapabilities = "CAP_NET_RAW"
	CAPSETFCAP        ContainerRuntimeCapabilities = "CAP_SETFCAP"
	CAPSETGID         ContainerRuntimeCapabilities = "CAP_SETGID"
	CAPSETPCAP        ContainerRuntimeCapabilities = "CAP_SETPCAP"
	CAPSETUID         ContainerRuntimeCapabilities = "CAP_SETUID"
	CAPSYSADMIN       ContainerRuntimeCapabilities = "CAP_SYS_ADMIN"
	CAPSYSBOOT        ContainerRuntimeCapabilities = "CAP_SYS_BOOT"
	CAPSYSCHROOT      ContainerRuntimeCapabilities = "CAP_SYS_CHROOT"
	CAPSYSLOG         ContainerRuntimeCapabilities = "CAP_SYSLOG"
	CAPSYSMODULE      ContainerRuntimeCapabilities = "CAP_SYS_MODULE"
	CAPSYSNICE        ContainerRuntimeCapabilities = "CAP_SYS_NICE"
	CAPSYSPACCT       ContainerRuntimeCapabilities = "CAP_SYS_PACCT"
	CAPSYSPTRACE      ContainerRuntimeCapabilities = "CAP_SYS_PTRACE"
	CAPSYSRAWIO       ContainerRuntimeCapabilities = "CAP_SYS_RAWIO"
	CAPSYSRESOURCE    ContainerRuntimeCapabilities = "CAP_SYS_RESOURCE"
	CAPSYSTIME        ContainerRuntimeCapabilities = "CAP_SYS_TIME"
	CAPSYSTTYCONFIG   ContainerRuntimeCapabilities = "CAP_SYS_TTY_CONFIG"
	CAPWAKEALARM      ContainerRuntimeCapabilities = "CAP_WAKE_ALARM"
)

// Defines values for ContainerRuntimeNamespaces.
const (
	ContainerRuntimeNamespacesCgroup  ContainerRuntimeNamespaces = "cgroup"
	ContainerRuntimeNamespacesIpc     ContainerRuntimeNamespaces = "ipc"
	ContainerRuntimeNamespacesMount   ContainerRuntimeNamespaces = "mount"
	ContainerRuntimeNamespacesNetwork ContainerRuntimeNamespaces = "network"
	ContainerRuntimeNamespacesPid     ContainerRuntimeNamespaces = "pid"
	ContainerRuntimeNamespacesUser    ContainerRuntimeNamespaces = "user"
	ContainerRuntimeNamespacesUts     ContainerRuntimeNamespaces = "uts"
)

// Defines values for ContainerScaleActionAction.
const (
	ContainerScaleActionActionScale ContainerScaleActionAction = "scale"
)

// Defines values for ContainerStartActionAction.
const (
	ContainerStartActionActionStart ContainerStartActionAction = "start"
)

// Defines values for ContainerStartStepAction.
const (
	ContainerStart ContainerStartStepAction = "container.start"
)

// Defines values for ContainerStateCurrent.
const (
	ContainerStateCurrentDeleted  ContainerStateCurrent = "deleted"
	ContainerStateCurrentDeleting ContainerStateCurrent = "deleting"
	ContainerStateCurrentFunction ContainerStateCurrent = "function"
	ContainerStateCurrentNew      ContainerStateCurrent = "new"
	ContainerStateCurrentRunning  ContainerStateCurrent = "running"
	ContainerStateCurrentStarting ContainerStateCurrent = "starting"
	ContainerStateCurrentStopped  ContainerStateCurrent = "stopped"
	ContainerStateCurrentStopping ContainerStateCurrent = "stopping"
)

// Defines values for ContainerStateDesired.
const (
	ContainerStateDesiredDeleted  ContainerStateDesired = "deleted"
	ContainerStateDesiredDeleting ContainerStateDesired = "deleting"
	ContainerStateDesiredFunction ContainerStateDesired = "function"
	ContainerStateDesiredNew      ContainerStateDesired = "new"
	ContainerStateDesiredRunning  ContainerStateDesired = "running"
	ContainerStateDesiredStarting ContainerStateDesired = "starting"
	ContainerStateDesiredStopped  ContainerStateDesired = "stopped"
	ContainerStateDesiredStopping ContainerStateDesired = "stopping"
)

// Defines values for ContainerStopActionAction.
const (
	ContainerStopActionActionStop ContainerStopActionAction = "stop"
)

// Defines values for ContainerStopStepAction.
const (
	ContainerStop ContainerStopStepAction = "container.stop"
)

// Defines values for ContainerVolumeRemoteAccessPasswordAlgorithm.
const (
	ContainerVolumeRemoteAccessPasswordAlgorithmMd5    ContainerVolumeRemoteAccessPasswordAlgorithm = "md5"
	ContainerVolumeRemoteAccessPasswordAlgorithmRaw    ContainerVolumeRemoteAccessPasswordAlgorithm = "raw"
	ContainerVolumeRemoteAccessPasswordAlgorithmSha512 ContainerVolumeRemoteAccessPasswordAlgorithm = "sha512"
)

// Defines values for CreatorScopeType.
const (
	CreatorScopeTypeAccount          CreatorScopeType = "account"
	CreatorScopeTypeApiKey           CreatorScopeType = "api-key"
	CreatorScopeTypeEmployee         CreatorScopeType = "employee"
	CreatorScopeTypeEnvironment      CreatorScopeType = "environment"
	CreatorScopeTypePlatform         CreatorScopeType = "platform"
	CreatorScopeTypePlatformPipeline CreatorScopeType = "platform-pipeline"
	CreatorScopeTypeVisitor          CreatorScopeType = "visitor"
)

// Defines values for CredentialsHTTPType.
const (
	CredentialsHTTPTypeHttp CredentialsHTTPType = "http"
)

// Defines values for CredentialsSSHType.
const (
	Ssh CredentialsSSHType = "ssh"
)

// Defines values for CreditStateCurrent.
const (
	CreditStateCurrentExpired CreditStateCurrent = "expired"
	CreditStateCurrentLive    CreditStateCurrent = "live"
	CreditStateCurrentNew     CreditStateCurrent = "new"
)

// Defines values for CycleSourceOriginType.
const (
	CycleSource CycleSourceOriginType = "cycle-source"
)

// Defines values for CycleUploadOriginType.
const (
	CycleUpload CycleUploadOriginType = "cycle-upload"
)

// Defines values for DefaultLbTypeType.
const (
	Default DefaultLbTypeType = "default"
)

// Defines values for DeploymentStrategyName.
const (
	DeploymentStrategyNameDistributed      DeploymentStrategyName = "distributed"
	DeploymentStrategyNameEdge             DeploymentStrategyName = "edge"
	DeploymentStrategyNameFirstAvailable   DeploymentStrategyName = "first-available"
	DeploymentStrategyNameFunction         DeploymentStrategyName = "function"
	DeploymentStrategyNameHighAvailability DeploymentStrategyName = "high-availability"
	DeploymentStrategyNameManual           DeploymentStrategyName = "manual"
	DeploymentStrategyNameNode             DeploymentStrategyName = "node"
	DeploymentStrategyNameResourceDensity  DeploymentStrategyName = "resource-density"
)

// Defines values for DirectImageSourceTypeType.
const (
	Direct DirectImageSourceTypeType = "direct"
)

// Defines values for DirectPaymentDetailsPreference.
const (
	DirectPaymentDetailsPreferenceAch   DirectPaymentDetailsPreference = "ach"
	DirectPaymentDetailsPreferenceCheck DirectPaymentDetailsPreference = "check"
	DirectPaymentDetailsPreferenceWire  DirectPaymentDetailsPreference = "wire"
)

// Defines values for DirectPaymentType.
const (
	DirectPaymentTypeDirectPayment DirectPaymentType = "direct-payment"
)

// Defines values for DnsRecordStateCurrent.
const (
	DnsRecordStateCurrentDeleted  DnsRecordStateCurrent = "deleted"
	DnsRecordStateCurrentDeleting DnsRecordStateCurrent = "deleting"
	DnsRecordStateCurrentLive     DnsRecordStateCurrent = "live"
	DnsRecordStateCurrentPending  DnsRecordStateCurrent = "pending"
)

// Defines values for DnsZoneStateCurrent.
const (
	DnsZoneStateCurrentDeleted   DnsZoneStateCurrent = "deleted"
	DnsZoneStateCurrentDeleting  DnsZoneStateCurrent = "deleting"
	DnsZoneStateCurrentDisabled  DnsZoneStateCurrent = "disabled"
	DnsZoneStateCurrentLive      DnsZoneStateCurrent = "live"
	DnsZoneStateCurrentNew       DnsZoneStateCurrent = "new"
	DnsZoneStateCurrentPending   DnsZoneStateCurrent = "pending"
	DnsZoneStateCurrentVerifying DnsZoneStateCurrent = "verifying"
)

// Defines values for DockerFileOriginType.
const (
	DockerFile DockerFileOriginType = "docker-file"
)

// Defines values for DockerHubOriginType.
const (
	DockerHub DockerHubOriginType = "docker-hub"
)

// Defines values for DockerRegistryOriginType.
const (
	DockerRegistry DockerRegistryOriginType = "docker-registry"
)

// Defines values for EnvironmentCreateStepAction.
const (
	EnvironmentCreate EnvironmentCreateStepAction = "environment.create"
)

// Defines values for EnvironmentDeleteStepAction.
const (
	EnvironmentDelete EnvironmentDeleteStepAction = "environment.delete"
)

// Defines values for EnvironmentDeploymentHealthyWatchStepAction.
const (
	EnvironmentDeploymentHealthyWatch EnvironmentDeploymentHealthyWatchStepAction = "environment.deployment.healthy.watch"
)

// Defines values for EnvironmentDeploymentStartStepAction.
const (
	EnvironmentDeploymentStart EnvironmentDeploymentStartStepAction = "environment.deployment.start"
)

// Defines values for EnvironmentDeploymentStopStepAction.
const (
	EnvironmentDeploymentStop EnvironmentDeploymentStopStepAction = "environment.deployment.stop"
)

// Defines values for EnvironmentDeploymentsPruneStepAction.
const (
	EnvironmentDeploymentsPrune EnvironmentDeploymentsPruneStepAction = "environment.deployments.prune"
)

// Defines values for EnvironmentDeploymentsTagStepAction.
const (
	EnvironmentDeploymentsTag EnvironmentDeploymentsTagStepAction = "environment.deployments.tag"
)

// Defines values for EnvironmentInitializeActionAction.
const (
	EnvironmentInitializeActionActionInitialize EnvironmentInitializeActionAction = "initialize"
)

// Defines values for EnvironmentReconfigureDeploymentsActionAction.
const (
	DeploymentsReconfigure EnvironmentReconfigureDeploymentsActionAction = "deployments.reconfigure"
)

// Defines values for EnvironmentReconfigureMonitoringActionAction.
const (
	MonitoringReconfigure EnvironmentReconfigureMonitoringActionAction = "monitoring.reconfigure"
)

// Defines values for EnvironmentStartActionAction.
const (
	EnvironmentStartActionActionStart EnvironmentStartActionAction = "start"
)

// Defines values for EnvironmentStartStepAction.
const (
	EnvironmentStart EnvironmentStartStepAction = "environment.start"
)

// Defines values for EnvironmentStateCurrent.
const (
	EnvironmentStateCurrentCloning  EnvironmentStateCurrent = "cloning"
	EnvironmentStateCurrentDeleted  EnvironmentStateCurrent = "deleted"
	EnvironmentStateCurrentDeleting EnvironmentStateCurrent = "deleting"
	EnvironmentStateCurrentLive     EnvironmentStateCurrent = "live"
	EnvironmentStateCurrentNew      EnvironmentStateCurrent = "new"
)

// Defines values for EnvironmentStopActionAction.
const (
	EnvironmentStopActionActionStop EnvironmentStopActionAction = "stop"
)

// Defines values for EnvironmentStopStepAction.
const (
	EnvironmentStop EnvironmentStopStepAction = "environment.stop"
)

// Defines values for ErrorCode.
const (
	N400InvalidSyntax                ErrorCode = "400.invalid-syntax"
	N401AuthExpired                  ErrorCode = "401.auth-expired"
	N401AuthInvalid                  ErrorCode = "401.auth-invalid"
	N401NoCookie                     ErrorCode = "401.no-cookie"
	N401UnauthorizedApplication      ErrorCode = "401.unauthorized-application"
	N4032faFailed                    ErrorCode = "403.2fa-failed"
	N4032faRequired                  ErrorCode = "403.2fa-required"
	N403Expired                      ErrorCode = "403.expired"
	N403InvalidIp                    ErrorCode = "403.invalid-ip"
	N403InvalidState                 ErrorCode = "403.invalid-state"
	N403Mismatch                     ErrorCode = "403.mismatch"
	N403NewApplicationCapabilities   ErrorCode = "403.new-application-capabilities"
	N403NotAllowed                   ErrorCode = "403.not-allowed"
	N403NotApproved                  ErrorCode = "403.not-approved"
	N403NotReady                     ErrorCode = "403.not-ready"
	N403Permissions                  ErrorCode = "403.permissions"
	N403PlatformDisabled             ErrorCode = "403.platform-disabled"
	N403RestrictedPortal             ErrorCode = "403.restricted-portal"
	N403TierRestricted               ErrorCode = "403.tier-restricted"
	N403WrongHub                     ErrorCode = "403.wrong-hub"
	N404Account                      ErrorCode = "404.account"
	N404Announcement                 ErrorCode = "404.announcement"
	N404BillingCredit                ErrorCode = "404.billing.credit"
	N404BillingInvoice               ErrorCode = "404.billing.invoice"
	N404BillingOrder                 ErrorCode = "404.billing.order"
	N404BillingPaymentMethod         ErrorCode = "404.billing.payment-method"
	N404BillingPromoCode             ErrorCode = "404.billing.promo-code"
	N404BillingService               ErrorCode = "404.billing.service"
	N404BillingSupport               ErrorCode = "404.billing.support"
	N404BillingTier                  ErrorCode = "404.billing.tier"
	N404Cluster                      ErrorCode = "404.cluster"
	N404CommunityThread              ErrorCode = "404.community.thread"
	N404CommunityThreadReply         ErrorCode = "404.community.thread.reply"
	N404Container                    ErrorCode = "404.container"
	N404ContainerBackup              ErrorCode = "404.container.backup"
	N404CycleosBuild                 ErrorCode = "404.cycleos-build"
	N404DnsRecord                    ErrorCode = "404.dns.record"
	N404DnsZone                      ErrorCode = "404.dns.zone"
	N404EmailVerification            ErrorCode = "404.email-verification"
	N404Environment                  ErrorCode = "404.environment"
	N404EnvironmentScopedVariable    ErrorCode = "404.environment.scoped-variable"
	N404HaServiceSession             ErrorCode = "404.ha-service.session"
	N404Hub                          ErrorCode = "404.hub"
	N404HubApiKey                    ErrorCode = "404.hub.api-key"
	N404HubIntegration               ErrorCode = "404.hub.integration"
	N404HubInvitation                ErrorCode = "404.hub.invitation"
	N404HubMembership                ErrorCode = "404.hub.membership"
	N404HubRole                      ErrorCode = "404.hub.role"
	N404Image                        ErrorCode = "404.image"
	N404ImageBuildLog                ErrorCode = "404.image.build-log"
	N404ImageSource                  ErrorCode = "404.image.source"
	N404InfrastructureAutoscaleGroup ErrorCode = "404.infrastructure.autoscale.group"
	N404InfrastructureCluster        ErrorCode = "404.infrastructure.cluster"
	N404InfrastructureExternalVolume ErrorCode = "404.infrastructure.external-volume"
	N404InfrastructureIpsPool        ErrorCode = "404.infrastructure.ips.pool"
	N404InfrastructureLocation       ErrorCode = "404.infrastructure.location"
	N404InfrastructureModel          ErrorCode = "404.infrastructure.model"
	N404InfrastructureProvider       ErrorCode = "404.infrastructure.provider"
	N404InfrastructureServer         ErrorCode = "404.infrastructure.server"
	N404Instance                     ErrorCode = "404.instance"
	N404Job                          ErrorCode = "404.job"
	N404MonitoringLogsAnalyticsRule  ErrorCode = "404.monitoring.logs.analytics.rule"
	N404Node                         ErrorCode = "404.node"
	N404Notification                 ErrorCode = "404.notification"
	N404Pipeline                     ErrorCode = "404.pipeline"
	N404PipelineKey                  ErrorCode = "404.pipeline.key"
	N404PipelineRun                  ErrorCode = "404.pipeline.run"
	N404PlatformBuild                ErrorCode = "404.platform-build"
	N404Provider                     ErrorCode = "404.provider"
	N404SalesLead                    ErrorCode = "404.sales.lead"
	N404SdnNetwork                   ErrorCode = "404.sdn.network"
	N404Stack                        ErrorCode = "404.stack"
	N404StackBuild                   ErrorCode = "404.stack-build"
	N404StackBuildLog                ErrorCode = "404.stack.build-log"
	N404Survey                       ErrorCode = "404.survey"
	N404SurveyResponse               ErrorCode = "404.survey-response"
	N404Uri                          ErrorCode = "404.uri"
	N404VirtualMachine               ErrorCode = "404.virtual-machine"
	N404VirtualMachineSshKey         ErrorCode = "404.virtual-machine.ssh-key"
	N404VpnAccount                   ErrorCode = "404.vpn.account"
	N409DuplicateFound               ErrorCode = "409.duplicate-found"
	N415InvalidContentType           ErrorCode = "415.invalid-content-type"
	N422AlreadyExists                ErrorCode = "422.already-exists"
	N422InvalidArgument              ErrorCode = "422.invalid-argument"
	N422InvalidInput                 ErrorCode = "422.invalid-input"
	N422MaxExceeded                  ErrorCode = "422.max-exceeded"
	N422MissingArgument              ErrorCode = "422.missing-argument"
	N422NotCompatible                ErrorCode = "422.not-compatible"
	N429RateLimiting                 ErrorCode = "429.rate-limiting"
	N500Database                     ErrorCode = "500.database"
	N500DatabaseInsert               ErrorCode = "500.database-insert"
	N500DatabaseRemove               ErrorCode = "500.database-remove"
	N500DatabaseUpdate               ErrorCode = "500.database-update"
	N500Dev                          ErrorCode = "500.dev"
	N500Email                        ErrorCode = "500.email"
	N500Jobd                         ErrorCode = "500.jobd"
	N500Unknown                      ErrorCode = "500.unknown"
	N503DependencyNotEnabled         ErrorCode = "503.dependency-not-enabled"
	N503NotEnabled                   ErrorCode = "503.not-enabled"
	N503NotReady                     ErrorCode = "503.not-ready"
	N504NotAvailable                 ErrorCode = "504.not-available"
)

// Defines values for ErrorStatus.
const (
	N400 ErrorStatus = 400
	N401 ErrorStatus = 401
	N403 ErrorStatus = 403
	N404 ErrorStatus = 404
	N409 ErrorStatus = 409
	N415 ErrorStatus = 415
	N422 ErrorStatus = 422
	N500 ErrorStatus = 500
	N501 ErrorStatus = 501
	N502 ErrorStatus = 502
	N503 ErrorStatus = 503
	N504 ErrorStatus = 504
)

// Defines values for EventMetadataPriority.
const (
	EventMetadataPriorityCritical EventMetadataPriority = "critical"
	EventMetadataPriorityHigh     EventMetadataPriority = "high"
	EventMetadataPriorityLow      EventMetadataPriority = "low"
	EventMetadataPriorityMedium   EventMetadataPriority = "medium"
	EventMetadataPriorityNormal   EventMetadataPriority = "normal"
)

// Defines values for EventMetadataType.
const (
	EventMetadataTypeAlert   EventMetadataType = "alert"
	EventMetadataTypeAudit   EventMetadataType = "audit"
	EventMetadataTypeError   EventMetadataType = "error"
	EventMetadataTypeInfo    EventMetadataType = "info"
	EventMetadataTypeNotice  EventMetadataType = "notice"
	EventMetadataTypeSuccess EventMetadataType = "success"
	EventMetadataTypeWarning EventMetadataType = "warning"
)

// Defines values for EventType.
const (
	ApiSecurityViolation                                 EventType = "api.security_violation"
	ConsoleSosLogin                                      EventType = "console.sos.login"
	ConsoleSosLoginFailed                                EventType = "console.sos.login.failed"
	ConsoleSshLogin                                      EventType = "console.ssh.login"
	ConsoleSshLoginFailed                                EventType = "console.ssh.login.failed"
	ContainerInstanceBackupCompleted                     EventType = "container.instance.backup.completed"
	ContainerInstanceBackupFailed                        EventType = "container.instance.backup.failed"
	ContainerInstanceDeleteFailed                        EventType = "container.instance.delete.failed"
	ContainerInstanceError                               EventType = "container.instance.error"
	ContainerInstanceFunctionMaxRuntime                  EventType = "container.instance.function.max_runtime"
	ContainerInstanceHealthcheckFailed                   EventType = "container.instance.healthcheck.failed"
	ContainerInstanceHealthcheckRecovered                EventType = "container.instance.healthcheck.recovered"
	ContainerInstanceHealthcheckRestarted                EventType = "container.instance.healthcheck.restarted"
	ContainerInstanceMigrationCompleted                  EventType = "container.instance.migration.completed"
	ContainerInstanceMigrationFailed                     EventType = "container.instance.migration.failed"
	ContainerInstanceNetworkInterfacesCreateFailed       EventType = "container.instance.network.interfaces.create.failed"
	ContainerInstanceRestartFailed                       EventType = "container.instance.restart.failed"
	ContainerInstanceRestartMaxRestarts                  EventType = "container.instance.restart.max_restarts"
	ContainerInstanceStartFailed                         EventType = "container.instance.start.failed"
	ContainerInstanceStartPrivileged                     EventType = "container.instance.start.privileged"
	ContainerInstanceStopFailed                          EventType = "container.instance.stop.failed"
	ContainerInstanceVolumeExtendFailed                  EventType = "container.instance.volume.extend.failed"
	ContainerInstancesAutoscaleDown                      EventType = "container.instances.autoscale.down"
	ContainerInstancesAutoscaleUp                        EventType = "container.instances.autoscale.up"
	ContainerReconfiguredPrivileged                      EventType = "container.reconfigured.privileged"
	ContainerVolumesBaseCreateFailed                     EventType = "container.volumes.base.create.failed"
	ContainerVolumesCreateFailed                         EventType = "container.volumes.create.failed"
	EnvironmentServiceAutoUpdate                         EventType = "environment.service.auto_update"
	EnvironmentServiceDiscoveryClientThrottleHit         EventType = "environment.service.discovery.client.throttle.hit"
	EnvironmentServiceGatewayIpsSyncFailed               EventType = "environment.service.gateway.ips.sync.failed"
	EnvironmentServiceLbIpsSyncFailed                    EventType = "environment.service.lb.ips.sync.failed"
	EnvironmentServiceVpnLoginFailed                     EventType = "environment.service.vpn.login.failed"
	InfrastructureClusterResourcesRamFull                EventType = "infrastructure.cluster.resources.ram.full"
	InfrastructureServerAutoscaleUp                      EventType = "infrastructure.server.autoscale.up"
	InfrastructureServerCheckinMissed                    EventType = "infrastructure.server.checkin.missed"
	InfrastructureServerCheckinResumed                   EventType = "infrastructure.server.checkin.resumed"
	InfrastructureServerComputeFullRestart               EventType = "infrastructure.server.compute.full_restart"
	InfrastructureServerComputeSharedfsMountsMount       EventType = "infrastructure.server.compute.sharedfs.mounts.mount"
	InfrastructureServerComputeSharedfsMountsMountFailed EventType = "infrastructure.server.compute.sharedfs.mounts.mount.failed"
	InfrastructureServerComputeSoftRestart               EventType = "infrastructure.server.compute.soft_restart"
	InfrastructureServerComputeVolumesBaseReconfigured   EventType = "infrastructure.server.compute.volumes.base.reconfigured"
	InfrastructureServerEvacuationCompleted              EventType = "infrastructure.server.evacuation.completed"
	InfrastructureServerEvacuationFailed                 EventType = "infrastructure.server.evacuation.failed"
	InfrastructureServerImageDownloadFailed              EventType = "infrastructure.server.image.download.failed"
	InfrastructureServerInternalApiThrottled             EventType = "infrastructure.server.internal_api.throttled"
	InfrastructureServerManifestSyncFailed               EventType = "infrastructure.server.manifest.sync.failed"
	InfrastructureServerMeshConnectFailed                EventType = "infrastructure.server.mesh.connect.failed"
	InfrastructureServerMonitoringThrottled              EventType = "infrastructure.server.monitoring.throttled"
	InfrastructureServerNeighborIncompatible             EventType = "infrastructure.server.neighbor.incompatible"
	InfrastructureServerNeighborReachable                EventType = "infrastructure.server.neighbor.reachable"
	InfrastructureServerNeighborRebuild                  EventType = "infrastructure.server.neighbor.rebuild"
	InfrastructureServerNeighborUnreachable              EventType = "infrastructure.server.neighbor.unreachable"
	InfrastructureServerNeighborUpgraded                 EventType = "infrastructure.server.neighbor.upgraded"
	InfrastructureServerNeighborsRebuild                 EventType = "infrastructure.server.neighbors.rebuild"
	InfrastructureServerPowerPowerOff                    EventType = "infrastructure.server.power.power-off"
	InfrastructureServerPowerReboot                      EventType = "infrastructure.server.power.reboot"
	InfrastructureServerResourcesLoadHigh                EventType = "infrastructure.server.resources.load.high"
	InfrastructureServerResourcesRamFull                 EventType = "infrastructure.server.resources.ram.full"
	InfrastructureServerResourcesStorageCyclePoolFull    EventType = "infrastructure.server.resources.storage.cycle_pool.full"
	InfrastructureServerResourcesStorageVolumesBaseFull  EventType = "infrastructure.server.resources.storage.volumes.base.full"
	InfrastructureServerSftpLockdown                     EventType = "infrastructure.server.sftp.lockdown"
	InfrastructureServerSftpLogin                        EventType = "infrastructure.server.sftp.login"
	InfrastructureServerSftpLoginFailed                  EventType = "infrastructure.server.sftp.login.failed"
)

// Defines values for ExternalVolumeAttachmentBlockMode.
const (
	ExternalVolumeAttachmentBlockModeMultiNodeReadOnly      ExternalVolumeAttachmentBlockMode = "multi-node-read-only"
	ExternalVolumeAttachmentBlockModeMultiNodeWriter        ExternalVolumeAttachmentBlockMode = "multi-node-writer"
	ExternalVolumeAttachmentBlockModeSingleInstanceReadOnly ExternalVolumeAttachmentBlockMode = "single-instance-read-only"
	ExternalVolumeAttachmentBlockModeSingleInstanceWriter   ExternalVolumeAttachmentBlockMode = "single-instance-writer"
	ExternalVolumeAttachmentBlockModeSingleNodeReadOnly     ExternalVolumeAttachmentBlockMode = "single-node-read-only"
	ExternalVolumeAttachmentBlockModeSingleNodeWriter       ExternalVolumeAttachmentBlockMode = "single-node-writer"
)

// Defines values for ExternalVolumeAttachmentBlockType.
const (
	Block ExternalVolumeAttachmentBlockType = "block"
)

// Defines values for ExternalVolumeAttachmentFileSystemMode.
const (
	ExternalVolumeAttachmentFileSystemModeMultiNodeReadOnly      ExternalVolumeAttachmentFileSystemMode = "multi-node-read-only"
	ExternalVolumeAttachmentFileSystemModeMultiNodeWriter        ExternalVolumeAttachmentFileSystemMode = "multi-node-writer"
	ExternalVolumeAttachmentFileSystemModeSingleInstanceReadOnly ExternalVolumeAttachmentFileSystemMode = "single-instance-read-only"
	ExternalVolumeAttachmentFileSystemModeSingleInstanceWriter   ExternalVolumeAttachmentFileSystemMode = "single-instance-writer"
	ExternalVolumeAttachmentFileSystemModeSingleNodeReadOnly     ExternalVolumeAttachmentFileSystemMode = "single-node-read-only"
	ExternalVolumeAttachmentFileSystemModeSingleNodeWriter       ExternalVolumeAttachmentFileSystemMode = "single-node-writer"
)

// Defines values for ExternalVolumeAttachmentFileSystemType.
const (
	Filesystem ExternalVolumeAttachmentFileSystemType = "filesystem"
)

// Defines values for ExternalVolumeServersReconfigureActionAction.
const (
	ServersReconfigure ExternalVolumeServersReconfigureActionAction = "servers.reconfigure"
)

// Defines values for ExternalVolumeStateCurrent.
const (
	ExternalVolumeStateCurrentConfiguring ExternalVolumeStateCurrent = "configuring"
	ExternalVolumeStateCurrentDeleted     ExternalVolumeStateCurrent = "deleted"
	ExternalVolumeStateCurrentDeleting    ExternalVolumeStateCurrent = "deleting"
	ExternalVolumeStateCurrentLive        ExternalVolumeStateCurrent = "live"
	ExternalVolumeStateCurrentNew         ExternalVolumeStateCurrent = "new"
)

// Defines values for FunctionTriggerActionAction.
const (
	FunctionTriggerActionActionTrigger FunctionTriggerActionAction = "trigger"
)

// Defines values for HaProxyConfigSetBackendBalance.
const (
	First      HaProxyConfigSetBackendBalance = "first"
	Leastconn  HaProxyConfigSetBackendBalance = "leastconn"
	Roundrobin HaProxyConfigSetBackendBalance = "roundrobin"
	Source     HaProxyConfigSetBackendBalance = "source"
	StaticRr   HaProxyConfigSetBackendBalance = "static-rr"
)

// Defines values for HaProxyConfigSetFrontendMode.
const (
	HaProxyConfigSetFrontendModeHttp HaProxyConfigSetFrontendMode = "http"
	HaProxyConfigSetFrontendModeTcp  HaProxyConfigSetFrontendMode = "tcp"
)

// Defines values for HaProxyLbTypeType.
const (
	Haproxy HaProxyLbTypeType = "haproxy"
)

// Defines values for HttpRouterConfigType.
const (
	HttpRouterConfigTypeHttp HttpRouterConfigType = "http"
)

// Defines values for HttpTransportConfigType.
const (
	HttpTransportConfigTypeHttp HttpTransportConfigType = "http"
)

// Defines values for HubStateCurrent.
const (
	HubStateCurrentConfiguring HubStateCurrent = "configuring"
	HubStateCurrentDeleted     HubStateCurrent = "deleted"
	HubStateCurrentDeleting    HubStateCurrent = "deleting"
	HubStateCurrentInactive    HubStateCurrent = "inactive"
	HubStateCurrentLive        HubStateCurrent = "live"
	HubStateCurrentNew         HubStateCurrent = "new"
)

// Defines values for ImageConfigVolumesMode.
const (
	Ro ImageConfigVolumesMode = "ro"
	Rw ImageConfigVolumesMode = "rw"
)

// Defines values for ImageCreateImportStepAction.
const (
	ImageCreateImport ImageCreateImportStepAction = "image.create-import"
)

// Defines values for ImageCreateStepAction.
const (
	ImageCreate ImageCreateStepAction = "image.create"
)

// Defines values for ImageImportStepAction.
const (
	ImageImport ImageImportStepAction = "image.import"
)

// Defines values for ImageSourceStateCurrent.
const (
	ImageSourceStateCurrentDeleted  ImageSourceStateCurrent = "deleted"
	ImageSourceStateCurrentDeleting ImageSourceStateCurrent = "deleting"
	ImageSourceStateCurrentLive     ImageSourceStateCurrent = "live"
)

// Defines values for ImageSourceType.
const (
	ImageSourceTypeBucket     ImageSourceType = "bucket"
	ImageSourceTypeDirect     ImageSourceType = "direct"
	ImageSourceTypeStackBuild ImageSourceType = "stack-build"
)

// Defines values for ImageStateCurrent.
const (
	ImageStateCurrentBuilding    ImageStateCurrent = "building"
	ImageStateCurrentDeleted     ImageStateCurrent = "deleted"
	ImageStateCurrentDeleting    ImageStateCurrent = "deleting"
	ImageStateCurrentDownloading ImageStateCurrent = "downloading"
	ImageStateCurrentLive        ImageStateCurrent = "live"
	ImageStateCurrentNew         ImageStateCurrent = "new"
	ImageStateCurrentSaving      ImageStateCurrent = "saving"
	ImageStateCurrentUploading   ImageStateCurrent = "uploading"
	ImageStateCurrentVerifying   ImageStateCurrent = "verifying"
)

// Defines values for ImagesPruneStepAction.
const (
	ImagesPrune ImagesPruneStepAction = "images.prune"
)

// Defines values for InstanceReadyState.
const (
	InstanceReadyStateActive      InstanceReadyState = "active"
	InstanceReadyStateConfiguring InstanceReadyState = "configuring"
	InstanceReadyStateHibernate   InstanceReadyState = "hibernate"
	InstanceReadyStatePurge       InstanceReadyState = "purge"
)

// Defines values for InstanceExtendVolumeActionAction.
const (
	VolumeExtend InstanceExtendVolumeActionAction = "volume.extend"
)

// Defines values for InstanceMigrateActionAction.
const (
	MigrationStart InstanceMigrateActionAction = "migration.start"
)

// Defines values for InstanceRevertMigrationActionAction.
const (
	MigrationRevert InstanceRevertMigrationActionAction = "migration.revert"
)

// Defines values for InstanceStateCurrent.
const (
	InstanceStateCurrentDeleted   InstanceStateCurrent = "deleted"
	InstanceStateCurrentDeleting  InstanceStateCurrent = "deleting"
	InstanceStateCurrentFailed    InstanceStateCurrent = "failed"
	InstanceStateCurrentMigrating InstanceStateCurrent = "migrating"
	InstanceStateCurrentNew       InstanceStateCurrent = "new"
	InstanceStateCurrentRunning   InstanceStateCurrent = "running"
	InstanceStateCurrentStarting  InstanceStateCurrent = "starting"
	InstanceStateCurrentStopped   InstanceStateCurrent = "stopped"
	InstanceStateCurrentStopping  InstanceStateCurrent = "stopping"
)

// Defines values for InstanceTrafficDrainReconfigureAction.
const (
	TrafficDrainReconfigure InstanceTrafficDrainReconfigureAction = "traffic-drain.reconfigure"
)

// Defines values for IntegrationAdvancedOptionBooleanType.
const (
	Bool IntegrationAdvancedOptionBooleanType = "bool"
)

// Defines values for IntegrationAdvancedOptionIntType.
const (
	IntegrationAdvancedOptionIntTypeInt IntegrationAdvancedOptionIntType = "int"
)

// Defines values for IntegrationAdvancedOptionStringType.
const (
	String IntegrationAdvancedOptionStringType = "string"
)

// Defines values for IntegrationDefinitionFieldType.
const (
	IntegrationDefinitionFieldTypeBlob   IntegrationDefinitionFieldType = "blob"
	IntegrationDefinitionFieldTypeInt    IntegrationDefinitionFieldType = "int"
	IntegrationDefinitionFieldTypeSelect IntegrationDefinitionFieldType = "select"
	IntegrationDefinitionFieldTypeString IntegrationDefinitionFieldType = "string"
)

// Defines values for IntegrationStateCurrent.
const (
	IntegrationStateCurrentDeleted   IntegrationStateCurrent = "deleted"
	IntegrationStateCurrentDeleting  IntegrationStateCurrent = "deleting"
	IntegrationStateCurrentLive      IntegrationStateCurrent = "live"
	IntegrationStateCurrentNew       IntegrationStateCurrent = "new"
	IntegrationStateCurrentVerifying IntegrationStateCurrent = "verifying"
)

// Defines values for InvoiceStateCurrent.
const (
	InvoiceStateCurrentAwaitingFunds InvoiceStateCurrent = "awaiting-funds"
	InvoiceStateCurrentBilled        InvoiceStateCurrent = "billed"
	InvoiceStateCurrentBilling       InvoiceStateCurrent = "billing"
	InvoiceStateCurrentCredited      InvoiceStateCurrent = "credited"
	InvoiceStateCurrentCrediting     InvoiceStateCurrent = "crediting"
	InvoiceStateCurrentNew           InvoiceStateCurrent = "new"
	InvoiceStateCurrentPaid          InvoiceStateCurrent = "paid"
	InvoiceStateCurrentPartiallyPaid InvoiceStateCurrent = "partially-paid"
	InvoiceStateCurrentProcessing    InvoiceStateCurrent = "processing"
	InvoiceStateCurrentRefunded      InvoiceStateCurrent = "refunded"
	InvoiceStateCurrentRefunding     InvoiceStateCurrent = "refunding"
	InvoiceStateCurrentUncollectible InvoiceStateCurrent = "uncollectible"
	InvoiceStateCurrentVoided        InvoiceStateCurrent = "voided"
	InvoiceStateCurrentVoiding       InvoiceStateCurrent = "voiding"
)

// Defines values for IpKind.
const (
	IpKindIpv4 IpKind = "ipv4"
	IpKindIpv6 IpKind = "ipv6"
)

// Defines values for IpPoolKind.
const (
	IpPoolKindIpv4 IpPoolKind = "ipv4"
	IpPoolKindIpv6 IpPoolKind = "ipv6"
)

// Defines values for IpPoolInitializeActionAction.
const (
	IpPoolInitializeActionActionInitialize IpPoolInitializeActionAction = "initialize"
)

// Defines values for IpPoolReconfigureOptionsActionAction.
const (
	OptionsReconfigure IpPoolReconfigureOptionsActionAction = "options.reconfigure"
)

// Defines values for IpPoolStateCurrent.
const (
	IpPoolStateCurrentLive      IpPoolStateCurrent = "live"
	IpPoolStateCurrentReleased  IpPoolStateCurrent = "released"
	IpPoolStateCurrentReleasing IpPoolStateCurrent = "releasing"
)

// Defines values for IpStateCurrent.
const (
	IpStateCurrentAssigned  IpStateCurrent = "assigned"
	IpStateCurrentAssigning IpStateCurrent = "assigning"
	IpStateCurrentAvailable IpStateCurrent = "available"
	IpStateCurrentReleasing IpStateCurrent = "releasing"
)

// Defines values for JobStateCurrent.
const (
	JobStateCurrentCompleted JobStateCurrent = "completed"
	JobStateCurrentError     JobStateCurrent = "error"
	JobStateCurrentExpired   JobStateCurrent = "expired"
	JobStateCurrentNew       JobStateCurrent = "new"
	JobStateCurrentQueued    JobStateCurrent = "queued"
	JobStateCurrentRunning   JobStateCurrent = "running"
	JobStateCurrentScheduled JobStateCurrent = "scheduled"
)

// Defines values for L2Domain.
const (
	L2DomainPrivate L2Domain = "private"
	L2DomainPublic  L2Domain = "public"
	L2DomainShared  L2Domain = "shared"
)

// Defines values for LogFormat.
const (
	NdjsonHeaders LogFormat = "ndjson-headers"
	NdjsonRaw     LogFormat = "ndjson-raw"
)

// Defines values for MembershipStateCurrent.
const (
	MembershipStateCurrentAccepted MembershipStateCurrent = "accepted"
	MembershipStateCurrentDeclined MembershipStateCurrent = "declined"
	MembershipStateCurrentDeleted  MembershipStateCurrent = "deleted"
	MembershipStateCurrentPending  MembershipStateCurrent = "pending"
	MembershipStateCurrentRevoked  MembershipStateCurrent = "revoked"
)

// Defines values for MethodStateCurrent.
const (
	MethodStateCurrentDeleted             MethodStateCurrent = "deleted"
	MethodStateCurrentDeleting            MethodStateCurrent = "deleting"
	MethodStateCurrentLive                MethodStateCurrent = "live"
	MethodStateCurrentPendingVerification MethodStateCurrent = "pending-verification"
)

// Defines values for MetricMetadataType.
const (
	MetricMetadataTypeCount        MetricMetadataType = "count"
	MetricMetadataTypeCounter      MetricMetadataType = "counter"
	MetricMetadataTypeDistribution MetricMetadataType = "distribution"
	MetricMetadataTypeGauge        MetricMetadataType = "gauge"
	MetricMetadataTypeHistogram    MetricMetadataType = "histogram"
	MetricMetadataTypeRate         MetricMetadataType = "rate"
	MetricMetadataTypeSet          MetricMetadataType = "set"
)

// Defines values for MonitoringTier.
const (
	MonitoringTierPlus     MonitoringTier = "plus"
	MonitoringTierPremium  MonitoringTier = "premium"
	MonitoringTierScale    MonitoringTier = "scale"
	MonitoringTierStandard MonitoringTier = "standard"
)

// Defines values for NetworkL2DhcpDetailsMethod.
const (
	Dhcp NetworkL2DhcpDetailsMethod = "dhcp"
)

// Defines values for NetworkL2StaticDetailsMethod.
const (
	NetworkL2StaticDetailsMethodStatic NetworkL2StaticDetailsMethod = "static"
)

// Defines values for NetworkSpecScope.
const (
	NetworkSpecScopePrivate NetworkSpecScope = "private"
	NetworkSpecScopePublic  NetworkSpecScope = "public"
	NetworkSpecScopeShared  NetworkSpecScope = "shared"
)

// Defines values for NetworkStateCurrent.
const (
	NetworkStateCurrentDeleted  NetworkStateCurrent = "deleted"
	NetworkStateCurrentDeleting NetworkStateCurrent = "deleting"
	NetworkStateCurrentLive     NetworkStateCurrent = "live"
)

// Defines values for NodeStateCurrent.
const (
	NodeStateCurrentAuthorizing    NodeStateCurrent = "authorizing"
	NodeStateCurrentDecommissioned NodeStateCurrent = "decommissioned"
	NodeStateCurrentNew            NodeStateCurrent = "new"
	NodeStateCurrentOffline        NodeStateCurrent = "offline"
	NodeStateCurrentOnline         NodeStateCurrent = "online"
)

// Defines values for NodeStateDesired.
const (
	NodeStateDesiredAuthorizing    NodeStateDesired = "authorizing"
	NodeStateDesiredDecommissioned NodeStateDesired = "decommissioned"
	NodeStateDesiredNew            NodeStateDesired = "new"
	NodeStateDesiredOffline        NodeStateDesired = "offline"
	NodeStateDesiredOnline         NodeStateDesired = "online"
)

// Defines values for NoneOriginType.
const (
	NoneOriginTypeNone NoneOriginType = "none"
)

// Defines values for OciRegistryOriginType.
const (
	OciRegistry OciRegistryOriginType = "oci-registry"
)

// Defines values for OrderStateCurrent.
const (
	OrderStateCurrentDeleted   OrderStateCurrent = "deleted"
	OrderStateCurrentDeleting  OrderStateCurrent = "deleting"
	OrderStateCurrentNew       OrderStateCurrent = "new"
	OrderStateCurrentProcessed OrderStateCurrent = "processed"
)

// Defines values for PaymentGateway.
const (
	Stripe PaymentGateway = "stripe"
)

// Defines values for PaymentResultStatus.
const (
	PaymentResultStatusAwaitingDirectPayment PaymentResultStatus = "awaiting-direct-payment"
	PaymentResultStatusCancelled             PaymentResultStatus = "cancelled"
	PaymentResultStatusError                 PaymentResultStatus = "error"
	PaymentResultStatusProcessing            PaymentResultStatus = "processing"
	PaymentResultStatusSuccess               PaymentResultStatus = "success"
)

// Defines values for PipelineRerunActionAction.
const (
	Rerun PipelineRerunActionAction = "rerun"
)

// Defines values for PipelineRunStepAction.
const (
	PipelineRunStepActionContainerCreate                   PipelineRunStepAction = "container.create"
	PipelineRunStepActionContainerDelete                   PipelineRunStepAction = "container.delete"
	PipelineRunStepActionContainerDeprecate                PipelineRunStepAction = "container.deprecate"
	PipelineRunStepActionContainerFunctionTrigger          PipelineRunStepAction = "container.function.trigger"
	PipelineRunStepActionContainerReimage                  PipelineRunStepAction = "container.reimage"
	PipelineRunStepActionContainerRestart                  PipelineRunStepAction = "container.restart"
	PipelineRunStepActionContainerStart                    PipelineRunStepAction = "container.start"
	PipelineRunStepActionContainerStop                     PipelineRunStepAction = "container.stop"
	PipelineRunStepActionEnvironmentCreate                 PipelineRunStepAction = "environment.create"
	PipelineRunStepActionEnvironmentDelete                 PipelineRunStepAction = "environment.delete"
	PipelineRunStepActionEnvironmentDeploymentHealthyWatch PipelineRunStepAction = "environment.deployment.healthy.watch"
	PipelineRunStepActionEnvironmentDeploymentStart        PipelineRunStepAction = "environment.deployment.start"
	PipelineRunStepActionEnvironmentDeploymentStop         PipelineRunStepAction = "environment.deployment.stop"
	PipelineRunStepActionEnvironmentDeploymentsPrune       PipelineRunStepAction = "environment.deployments.prune"
	PipelineRunStepActionEnvironmentDeploymentsTag         PipelineRunStepAction = "environment.deployments.tag"
	PipelineRunStepActionEnvironmentStart                  PipelineRunStepAction = "environment.start"
	PipelineRunStepActionEnvironmentStop                   PipelineRunStepAction = "environment.stop"
	PipelineRunStepActionImageCreate                       PipelineRunStepAction = "image.create"
	PipelineRunStepActionImageCreateImport                 PipelineRunStepAction = "image.create-import"
	PipelineRunStepActionImageImport                       PipelineRunStepAction = "image.import"
	PipelineRunStepActionImagesPrune                       PipelineRunStepAction = "images.prune"
	PipelineRunStepActionSleep                             PipelineRunStepAction = "sleep"
	PipelineRunStepActionStackBuildCreate                  PipelineRunStepAction = "stack.build.create"
	PipelineRunStepActionStackBuildDeploy                  PipelineRunStepAction = "stack.build.deploy"
	PipelineRunStepActionStackBuildGenerate                PipelineRunStepAction = "stack.build.generate"
	PipelineRunStepActionStackPrune                        PipelineRunStepAction = "stack.prune"
	PipelineRunStepActionWebhookGet                        PipelineRunStepAction = "webhook.get"
	PipelineRunStepActionWebhookPost                       PipelineRunStepAction = "webhook.post"
)

// Defines values for PipelineStateCurrent.
const (
	PipelineStateCurrentAcquiring PipelineStateCurrent = "acquiring"
	PipelineStateCurrentDeleted   PipelineStateCurrent = "deleted"
	PipelineStateCurrentDeleting  PipelineStateCurrent = "deleting"
	PipelineStateCurrentLive      PipelineStateCurrent = "live"
)

// Defines values for PipelineTriggerActionAction.
const (
	PipelineTriggerActionActionTrigger PipelineTriggerActionAction = "trigger"
)

// Defines values for PromoCodeStateCurrent.
const (
	PromoCodeStateCurrentDeleted PromoCodeStateCurrent = "deleted"
	PromoCodeStateCurrentLive    PromoCodeStateCurrent = "live"
)

// Defines values for RawSourceType.
const (
	RawSourceTypeRaw RawSourceType = "raw"
)

// Defines values for ReconfigureSdnNetworkActionAction.
const (
	ReconfigureSdnNetworkActionActionReconfigure ReconfigureSdnNetworkActionAction = "reconfigure"
)

// Defines values for RegistryAuthProviderDetailsFlavor.
const (
	Ecr RegistryAuthProviderDetailsFlavor = "ecr"
)

// Defines values for RegistryAuthProviderType.
const (
	Provider RegistryAuthProviderType = "provider"
)

// Defines values for RegistryAuthUserType.
const (
	User RegistryAuthUserType = "user"
)

// Defines values for RegistryAuthWebhookType.
const (
	Webhook RegistryAuthWebhookType = "webhook"
)

// Defines values for ResourceAllowanceAdditionalTerm.
const (
	ResourceAllowanceAdditionalTermMonthly ResourceAllowanceAdditionalTerm = "monthly"
	ResourceAllowanceAdditionalTermOnce    ResourceAllowanceAdditionalTerm = "once"
	ResourceAllowanceAdditionalTermYearly  ResourceAllowanceAdditionalTerm = "yearly"
)

// Defines values for ResourceType.
const (
	ResourceTypeAccount                      ResourceType = "account"
	ResourceTypeBillingInvoice               ResourceType = "billing.invoice"
	ResourceTypeBillingMethod                ResourceType = "billing.method"
	ResourceTypeContainer                    ResourceType = "container"
	ResourceTypeContainerInstance            ResourceType = "container.instance"
	ResourceTypeDnsCertificate               ResourceType = "dns.certificate"
	ResourceTypeDnsZone                      ResourceType = "dns.zone"
	ResourceTypeDnsZoneRecord                ResourceType = "dns.zone.record"
	ResourceTypeEnvironment                  ResourceType = "environment"
	ResourceTypeEnvironmentScopedVariable    ResourceType = "environment.scoped-variable"
	ResourceTypeHub                          ResourceType = "hub"
	ResourceTypeHubApiKey                    ResourceType = "hub.api_key"
	ResourceTypeHubMembership                ResourceType = "hub.membership"
	ResourceTypeHubRole                      ResourceType = "hub.role"
	ResourceTypeImage                        ResourceType = "image"
	ResourceTypeImageSource                  ResourceType = "image.source"
	ResourceTypeInfrastructureAutoscaleGroup ResourceType = "infrastructure.autoscale.group"
	ResourceTypeInfrastructureCluster        ResourceType = "infrastructure.cluster"
	ResourceTypeInfrastructureExternalVolume ResourceType = "infrastructure.external-volume"
	ResourceTypeInfrastructureIpsPool        ResourceType = "infrastructure.ips.pool"
	ResourceTypeInfrastructureProvider       ResourceType = "infrastructure.provider"
	ResourceTypeInfrastructureServer         ResourceType = "infrastructure.server"
	ResourceTypePipeline                     ResourceType = "pipeline"
	ResourceTypePipelineRun                  ResourceType = "pipeline.run"
	ResourceTypeSdnNetwork                   ResourceType = "sdn.network"
	ResourceTypeStack                        ResourceType = "stack"
	ResourceTypeStackBuild                   ResourceType = "stack.build"
	ResourceTypeVirtualMachine               ResourceType = "virtual-machine"
	ResourceTypeVirtualMachineSshKey         ResourceType = "virtual-machine.ssh-key"
)

// Defines values for RoleStateCurrent.
const (
	RoleStateCurrentLive RoleStateCurrent = "live"
)

// Defines values for RunStateCurrent.
const (
	RunStateCurrentAcquiring RunStateCurrent = "acquiring"
	RunStateCurrentCancelled RunStateCurrent = "cancelled"
	RunStateCurrentComplete  RunStateCurrent = "complete"
	RunStateCurrentDeleted   RunStateCurrent = "deleted"
	RunStateCurrentQueued    RunStateCurrent = "queued"
	RunStateCurrentRunning   RunStateCurrent = "running"
)

// Defines values for RuntimeDevicePermissionType.
const (
	B RuntimeDevicePermissionType = "b"
	C RuntimeDevicePermissionType = "c"
)

// Defines values for SFTPPasswordAlgorithm.
const (
	SFTPPasswordAlgorithmMd5    SFTPPasswordAlgorithm = "md5"
	SFTPPasswordAlgorithmRaw    SFTPPasswordAlgorithm = "raw"
	SFTPPasswordAlgorithmSha512 SFTPPasswordAlgorithm = "sha512"
)

// Defines values for ScaleThresholdMetricCpuType.
const (
	Cpu ScaleThresholdMetricCpuType = "cpu"
)

// Defines values for ScaleThresholdMetricCustomType.
const (
	ScaleThresholdMetricCustomTypeCustom ScaleThresholdMetricCustomType = "custom"
)

// Defines values for ScaleThresholdMetricNetworkConnectionsType.
const (
	NetworkConnections ScaleThresholdMetricNetworkConnectionsType = "network-connections"
)

// Defines values for ScaleThresholdMetricNetworkRequestsType.
const (
	NetworkRequests ScaleThresholdMetricNetworkRequestsType = "network-requests"
)

// Defines values for ScaleThresholdMetricNetworkThroughputType.
const (
	NetworkThroughput ScaleThresholdMetricNetworkThroughputType = "network-throughput"
)

// Defines values for ScaleThresholdMetricRamType.
const (
	Ram ScaleThresholdMetricRamType = "ram"
)

// Defines values for ScopedVariableStateCurrent.
const (
	ScopedVariableStateCurrentDeleted  ScopedVariableStateCurrent = "deleted"
	ScopedVariableStateCurrentDeleting ScopedVariableStateCurrent = "deleting"
	ScopedVariableStateCurrentLive     ScopedVariableStateCurrent = "live"
)

// Defines values for ServerAuthResetActionAction.
const (
	AuthReset ServerAuthResetActionAction = "auth.reset"
)

// Defines values for ServerEvacuateActionAction.
const (
	EvacuationStart ServerEvacuateActionAction = "evacuation.start"
)

// Defines values for ServerEvacuateResetActionAction.
const (
	EvacuationReset ServerEvacuateResetActionAction = "evacuation.reset"
)

// Defines values for ServerFeaturesGatewayType.
const (
	ServerFeaturesGatewayTypeBgp    ServerFeaturesGatewayType = "bgp"
	ServerFeaturesGatewayTypeStatic ServerFeaturesGatewayType = "static"
)

// Defines values for ServerPowerOffActionAction.
const (
	PowerOff ServerPowerOffActionAction = "power-off"
)

// Defines values for ServerReconfigureFeaturesActionAction.
const (
	FeaturesReconfigure ServerReconfigureFeaturesActionAction = "features.reconfigure"
)

// Defines values for ServerReconfigureFeaturesActionContentsGatewayType.
const (
	Bgp    ServerReconfigureFeaturesActionContentsGatewayType = "bgp"
	Static ServerReconfigureFeaturesActionContentsGatewayType = "static"
)

// Defines values for ServerReconfigureSharedFsActionAction.
const (
	SharedfsReconfigure ServerReconfigureSharedFsActionAction = "sharedfs.reconfigure"
)

// Defines values for ServerRestartActionAction.
const (
	ServerRestartActionActionRestart ServerRestartActionAction = "restart"
)

// Defines values for ServerRestartComputeActionAction.
const (
	ComputeRestart ServerRestartComputeActionAction = "compute.restart"
)

// Defines values for ServerRestartComputeSpawnerActionAction.
const (
	ComputeSpawnerRestart ServerRestartComputeSpawnerActionAction = "compute.spawner.restart"
)

// Defines values for ServerStateCurrent.
const (
	ServerStateCurrentConfiguring  ServerStateCurrent = "configuring"
	ServerStateCurrentDeleted      ServerStateCurrent = "deleted"
	ServerStateCurrentDeleting     ServerStateCurrent = "deleting"
	ServerStateCurrentLive         ServerStateCurrent = "live"
	ServerStateCurrentNew          ServerStateCurrent = "new"
	ServerStateCurrentProvisioning ServerStateCurrent = "provisioning"
	ServerStateCurrentQuarantined  ServerStateCurrent = "quarantined"
)

// Defines values for ServerUnquarantineActionAction.
const (
	Unquarantine ServerUnquarantineActionAction = "unquarantine"
)

// Defines values for ServiceContainerIdentifier.
const (
	ServiceContainerIdentifierDiscovery    ServiceContainerIdentifier = "discovery"
	ServiceContainerIdentifierGateway      ServiceContainerIdentifier = "gateway"
	ServiceContainerIdentifierLoadbalancer ServiceContainerIdentifier = "loadbalancer"
	ServiceContainerIdentifierScheduler    ServiceContainerIdentifier = "scheduler"
	ServiceContainerIdentifierVpn          ServiceContainerIdentifier = "vpn"
)

// Defines values for ShutdownSignal.
const (
	SIGHUP  ShutdownSignal = "SIGHUP"
	SIGINT  ShutdownSignal = "SIGINT"
	SIGQUIT ShutdownSignal = "SIGQUIT"
	SIGTERM ShutdownSignal = "SIGTERM"
	SIGUSR1 ShutdownSignal = "SIGUSR1"
	SIGUSR2 ShutdownSignal = "SIGUSR2"
)

// Defines values for SleepStepAction.
const (
	Sleep SleepStepAction = "sleep"
)

// Defines values for SourceAwsEbsType.
const (
	AwsEbs SourceAwsEbsType = "aws-ebs"
)

// Defines values for SourceCephRbdType.
const (
	CephRbd SourceCephRbdType = "ceph-rbd"
)

// Defines values for SourceSanIscsiType.
const (
	SanIscsi SourceSanIscsiType = "san-iscsi"
)

// Defines values for StackBuildCreateStepAction.
const (
	StackBuildCreate StackBuildCreateStepAction = "stack.build.create"
)

// Defines values for StackBuildCreateStepDetailsInstructionsGitType.
const (
	StackBuildCreateStepDetailsInstructionsGitTypeBranch StackBuildCreateStepDetailsInstructionsGitType = "branch"
	StackBuildCreateStepDetailsInstructionsGitTypeHash   StackBuildCreateStepDetailsInstructionsGitType = "hash"
	StackBuildCreateStepDetailsInstructionsGitTypeTag    StackBuildCreateStepDetailsInstructionsGitType = "tag"
)

// Defines values for StackBuildDeployActionAction.
const (
	Deploy StackBuildDeployActionAction = "deploy"
)

// Defines values for StackBuildDeployStepAction.
const (
	StackBuildDeploy StackBuildDeployStepAction = "stack.build.deploy"
)

// Defines values for StackBuildGenerateActionAction.
const (
	StackBuildGenerateActionActionGenerate StackBuildGenerateActionAction = "generate"
)

// Defines values for StackBuildGenerateStepAction.
const (
	StackBuildGenerate StackBuildGenerateStepAction = "stack.build.generate"
)

// Defines values for StackBuildInstructionsGitType.
const (
	StackBuildInstructionsGitTypeBranch StackBuildInstructionsGitType = "branch"
	StackBuildInstructionsGitTypeHash   StackBuildInstructionsGitType = "hash"
	StackBuildInstructionsGitTypeTag    StackBuildInstructionsGitType = "tag"
)

// Defines values for StackBuildStateCurrent.
const (
	StackBuildStateCurrentBuilding  StackBuildStateCurrent = "building"
	StackBuildStateCurrentDeleted   StackBuildStateCurrent = "deleted"
	StackBuildStateCurrentDeleting  StackBuildStateCurrent = "deleting"
	StackBuildStateCurrentDeploying StackBuildStateCurrent = "deploying"
	StackBuildStateCurrentImporting StackBuildStateCurrent = "importing"
	StackBuildStateCurrentLive      StackBuildStateCurrent = "live"
	StackBuildStateCurrentNew       StackBuildStateCurrent = "new"
	StackBuildStateCurrentSaving    StackBuildStateCurrent = "saving"
	StackBuildStateCurrentVerifying StackBuildStateCurrent = "verifying"
)

// Defines values for StackImageSourceTypeType.
const (
	StackImageSourceTypeTypeStackBuild StackImageSourceTypeType = "stack-build"
)

// Defines values for StackPruneStepAction.
const (
	StackPrune StackPruneStepAction = "stack.prune"
)

// Defines values for StackRawSourceType.
const (
	StackRawSourceTypeRaw StackRawSourceType = "raw"
)

// Defines values for StackRepoSourceType.
const (
	GitRepo StackRepoSourceType = "git-repo"
)

// Defines values for StackSpecVersion.
const (
	N10 StackSpecVersion = "1.0"
)

// Defines values for StackSpecContainerRole.
const (
	Conductor StackSpecContainerRole = "conductor"
)

// Defines values for StackStateCurrent.
const (
	StackStateCurrentDeleted  StackStateCurrent = "deleted"
	StackStateCurrentDeleting StackStateCurrent = "deleting"
	StackStateCurrentLive     StackStateCurrent = "live"
)

// Defines values for StripeCreditCardType.
const (
	StripeCreditCardTypeStripeCreditCard StripeCreditCardType = "stripe-credit-card"
)

// Defines values for StripeUsBankAcctType.
const (
	StripeUsBankAcctTypeStripeUsBankAcct StripeUsBankAcctType = "stripe-us-bank-acct"
)

// Defines values for TaskStateCurrent.
const (
	TaskStateCurrentCompleted TaskStateCurrent = "completed"
	TaskStateCurrentError     TaskStateCurrent = "error"
	TaskStateCurrentPending   TaskStateCurrent = "pending"
	TaskStateCurrentRunning   TaskStateCurrent = "running"
)

// Defines values for TcpRouterConfigType.
const (
	TcpRouterConfigTypeTcp TcpRouterConfigType = "tcp"
)

// Defines values for TcpTransportConfigType.
const (
	TcpTransportConfigTypeTcp TcpTransportConfigType = "tcp"
)

// Defines values for TermRenew.
const (
	TermRenewMonthly TermRenew = "monthly"
	TermRenewOnce    TermRenew = "once"
	TermRenewYearly  TermRenew = "yearly"
)

// Defines values for TlsCertificateStateCurrent.
const (
	TlsCertificateStateCurrentDeprecated TlsCertificateStateCurrent = "deprecated"
	TlsCertificateStateCurrentLive       TlsCertificateStateCurrent = "live"
	TlsCertificateStateCurrentNew        TlsCertificateStateCurrent = "new"
	TlsCertificateStateCurrentProcessing TlsCertificateStateCurrent = "processing"
)

// Defines values for TriggerKeyStateCurrent.
const (
	TriggerKeyStateCurrentDeleted  TriggerKeyStateCurrent = "deleted"
	TriggerKeyStateCurrentDeleting TriggerKeyStateCurrent = "deleting"
	TriggerKeyStateCurrentLive     TriggerKeyStateCurrent = "live"
)

// Defines values for URLSourceType.
const (
	URLSourceTypeUrl URLSourceType = "url"
)

// Defines values for UdpRouterConfigType.
const (
	UdpRouterConfigTypeUdp UdpRouterConfigType = "udp"
)

// Defines values for UdpTransportConfigType.
const (
	UdpTransportConfigTypeUdp UdpTransportConfigType = "udp"
)

// Defines values for UserScopeType.
const (
	UserScopeTypeAccount          UserScopeType = "account"
	UserScopeTypeApiKey           UserScopeType = "api-key"
	UserScopeTypeEmployee         UserScopeType = "employee"
	UserScopeTypeEnvironment      UserScopeType = "environment"
	UserScopeTypePlatform         UserScopeType = "platform"
	UserScopeTypePlatformPipeline UserScopeType = "platform-pipeline"
	UserScopeTypeVisitor          UserScopeType = "visitor"
)

// Defines values for V1LbConfigRouterConfigDestinationPrioritization.
const (
	V1LbConfigRouterConfigDestinationPrioritizationFixed   V1LbConfigRouterConfigDestinationPrioritization = "fixed"
	V1LbConfigRouterConfigDestinationPrioritizationLatency V1LbConfigRouterConfigDestinationPrioritization = "latency"
	V1LbConfigRouterConfigDestinationPrioritizationRandom  V1LbConfigRouterConfigDestinationPrioritization = "random"
)

// Defines values for V1LbConfigRouterConfigTlsClientAuth.
const (
	V1LbConfigRouterConfigTlsClientAuthNone          V1LbConfigRouterConfigTlsClientAuth = "none"
	V1LbConfigRouterConfigTlsClientAuthRequest       V1LbConfigRouterConfigTlsClientAuth = "request"
	V1LbConfigRouterConfigTlsClientAuthRequire       V1LbConfigRouterConfigTlsClientAuth = "require"
	V1LbConfigRouterConfigTlsClientAuthRequireVerify V1LbConfigRouterConfigTlsClientAuth = "require-verify"
)

// Defines values for V1LbConfigRouterMode.
const (
	V1LbConfigRouterModeRandom     V1LbConfigRouterMode = "random"
	V1LbConfigRouterModeRoundRobin V1LbConfigRouterMode = "round-robin"
	V1LbConfigRouterModeSourceIp   V1LbConfigRouterMode = "source-ip"
)

// Defines values for V1LbControllerTransportConfigVerbosity.
const (
	V1LbControllerTransportConfigVerbosityDebug  V1LbControllerTransportConfigVerbosity = "debug"
	V1LbControllerTransportConfigVerbosityHigh   V1LbControllerTransportConfigVerbosity = "high"
	V1LbControllerTransportConfigVerbosityLow    V1LbControllerTransportConfigVerbosity = "low"
	V1LbControllerTransportConfigVerbosityNormal V1LbControllerTransportConfigVerbosity = "normal"
)

// Defines values for V1LbControllerTransportMode.
const (
	Http V1LbControllerTransportMode = "http"
	Tcp  V1LbControllerTransportMode = "tcp"
	Udp  V1LbControllerTransportMode = "udp"
)

// Defines values for V1LbTypeType.
const (
	V1 V1LbTypeType = "v1"
)

// Defines values for VirtualMachineAttachmentTypeIsoType.
const (
	Iso VirtualMachineAttachmentTypeIsoType = "iso"
)

// Defines values for VirtualMachineCpuConfigCustomType.
const (
	VirtualMachineCpuConfigCustomTypeCustom VirtualMachineCpuConfigCustomType = "custom"
)

// Defines values for VirtualMachineCpuConfigDefaultType.
const (
	Host   VirtualMachineCpuConfigDefaultType = "host"
	Kvm64  VirtualMachineCpuConfigDefaultType = "kvm64"
	Qemu32 VirtualMachineCpuConfigDefaultType = "qemu32"
	Qemu64 VirtualMachineCpuConfigDefaultType = "qemu64"
)

// Defines values for VirtualMachineImageSourceBaseType.
const (
	Base VirtualMachineImageSourceBaseType = "base"
)

// Defines values for VirtualMachineImageSourceExternalVolumeType.
const (
	VirtualMachineImageSourceExternalVolumeTypeExternalVolume VirtualMachineImageSourceExternalVolumeType = "external-volume"
)

// Defines values for VirtualMachineImageSourceIpxeType.
const (
	Ipxe VirtualMachineImageSourceIpxeType = "ipxe"
)

// Defines values for VirtualMachineImageSourceUrlType.
const (
	VirtualMachineImageSourceUrlTypeUrl VirtualMachineImageSourceUrlType = "url"
)

// Defines values for VirtualMachineIpAllocateActionAction.
const (
	IpAllocate VirtualMachineIpAllocateActionAction = "ip.allocate"
)

// Defines values for VirtualMachineIpUnallocateActionAction.
const (
	IpUnallocate VirtualMachineIpUnallocateActionAction = "ip.unallocate"
)

// Defines values for VirtualMachineNetworkConfigPublic.
const (
	VirtualMachineNetworkConfigPublicDisable    VirtualMachineNetworkConfigPublic = "disable"
	VirtualMachineNetworkConfigPublicEgressOnly VirtualMachineNetworkConfigPublic = "egress-only"
	VirtualMachineNetworkConfigPublicEnable     VirtualMachineNetworkConfigPublic = "enable"
)

// Defines values for VirtualMachineReconfigureActionAction.
const (
	VirtualMachineReconfigureActionActionReconfigure VirtualMachineReconfigureActionAction = "reconfigure"
)

// Defines values for VirtualMachineReconfigureVolumesActionAction.
const (
	VirtualMachineReconfigureVolumesActionActionVolumesReconfigure VirtualMachineReconfigureVolumesActionAction = "volumes.reconfigure"
)

// Defines values for VirtualMachineRestartActionAction.
const (
	Restart VirtualMachineRestartActionAction = "restart"
)

// Defines values for VirtualMachineRootPwChangeActionAction.
const (
	RootpwChange VirtualMachineRootPwChangeActionAction = "rootpw.change"
)

// Defines values for VirtualMachineRuntimeConfigHardwareMachineType.
const (
	Microvm VirtualMachineRuntimeConfigHardwareMachineType = "microvm"
	Pc      VirtualMachineRuntimeConfigHardwareMachineType = "pc"
	Q35     VirtualMachineRuntimeConfigHardwareMachineType = "q35"
)

// Defines values for VirtualMachineSshKeyStateCurrent.
const (
	VirtualMachineSshKeyStateCurrentDeleted  VirtualMachineSshKeyStateCurrent = "deleted"
	VirtualMachineSshKeyStateCurrentDeleting VirtualMachineSshKeyStateCurrent = "deleting"
	VirtualMachineSshKeyStateCurrentLive     VirtualMachineSshKeyStateCurrent = "live"
)

// Defines values for VirtualMachineStartActionAction.
const (
	Start VirtualMachineStartActionAction = "start"
)

// Defines values for VirtualMachineStateCurrent.
const (
	VirtualMachineStateCurrentConfiguring VirtualMachineStateCurrent = "configuring"
	VirtualMachineStateCurrentDeleted     VirtualMachineStateCurrent = "deleted"
	VirtualMachineStateCurrentDeleting    VirtualMachineStateCurrent = "deleting"
	VirtualMachineStateCurrentNew         VirtualMachineStateCurrent = "new"
	VirtualMachineStateCurrentRunning     VirtualMachineStateCurrent = "running"
	VirtualMachineStateCurrentStarting    VirtualMachineStateCurrent = "starting"
	VirtualMachineStateCurrentStopped     VirtualMachineStateCurrent = "stopped"
	VirtualMachineStateCurrentStopping    VirtualMachineStateCurrent = "stopping"
)

// Defines values for VirtualMachineStopActionAction.
const (
	Stop VirtualMachineStopActionAction = "stop"
)

// Defines values for VirtualProviderGenerateIsoActionAction.
const (
	VirtualProviderGenerateIsoActionActionGenerate VirtualProviderGenerateIsoActionAction = "generate"
)

// Defines values for VirtualProviderIsoBackendProvider.
const (
	AWS   VirtualProviderIsoBackendProvider = "AWS"
	Azure VirtualProviderIsoBackendProvider = "Azure"
	GCP   VirtualProviderIsoBackendProvider = "GCP"
	Local VirtualProviderIsoBackendProvider = "Local"
)

// Defines values for VirtualProviderIsoConfigServerSdnNeighborPreference.
const (
	VirtualProviderIsoConfigServerSdnNeighborPreferenceIpv4 VirtualProviderIsoConfigServerSdnNeighborPreference = "ipv4"
	VirtualProviderIsoConfigServerSdnNeighborPreferenceIpv6 VirtualProviderIsoConfigServerSdnNeighborPreference = "ipv6"
)

// Defines values for VirtualProviderIsoStateCurrent.
const (
	VirtualProviderIsoStateCurrentBuilding VirtualProviderIsoStateCurrent = "building"
	VirtualProviderIsoStateCurrentDeleted  VirtualProviderIsoStateCurrent = "deleted"
	VirtualProviderIsoStateCurrentDeleting VirtualProviderIsoStateCurrent = "deleting"
	VirtualProviderIsoStateCurrentLive     VirtualProviderIsoStateCurrent = "live"
	VirtualProviderIsoStateCurrentNew      VirtualProviderIsoStateCurrent = "new"
)

// Defines values for VirtualProviderIsoBondMode.
const (
	ActiveBackup VirtualProviderIsoBondMode = "active-backup"
	BalanceAlb   VirtualProviderIsoBondMode = "balance-alb"
	BalanceRr    VirtualProviderIsoBondMode = "balance-rr"
	BalanceTlb   VirtualProviderIsoBondMode = "balance-tlb"
	BalanceXor   VirtualProviderIsoBondMode = "balance-xor"
	Lacp         VirtualProviderIsoBondMode = "lacp"
)

// Defines values for VirtualProviderIsoNicDhcpMode.
const (
	VirtualProviderIsoNicDhcpModeAll  VirtualProviderIsoNicDhcpMode = "all"
	VirtualProviderIsoNicDhcpModeIpv4 VirtualProviderIsoNicDhcpMode = "ipv4"
	VirtualProviderIsoNicDhcpModeIpv6 VirtualProviderIsoNicDhcpMode = "ipv6"
	VirtualProviderIsoNicDhcpModeNone VirtualProviderIsoNicDhcpMode = "none"
)

// Defines values for VpnReconfigureActionAction.
const (
	VpnReconfigureActionActionReconfigure VpnReconfigureActionAction = "reconfigure"
)

// Defines values for VpnResetActionAction.
const (
	Reset VpnResetActionAction = "reset"
)

// Defines values for WafConfigRulesConditionsOperator.
const (
	WafConfigRulesConditionsOperatorEmpty            WafConfigRulesConditionsOperator = "!="
	WafConfigRulesConditionsOperatorEqualEqual       WafConfigRulesConditionsOperator = "=="
	WafConfigRulesConditionsOperatorGreaterThan      WafConfigRulesConditionsOperator = ">"
	WafConfigRulesConditionsOperatorGreaterThanEqual WafConfigRulesConditionsOperator = ">="
	WafConfigRulesConditionsOperatorLessThan         WafConfigRulesConditionsOperator = "<"
	WafConfigRulesConditionsOperatorLessThanEqual    WafConfigRulesConditionsOperator = "<="
)

// Defines values for WafConfigRulesConditionsType.
const (
	GeoMatch    WafConfigRulesConditionsType = "geo-match"
	HeaderMatch WafConfigRulesConditionsType = "header-match"
	IpMatch     WafConfigRulesConditionsType = "ip-match"
	MethodMatch WafConfigRulesConditionsType = "method-match"
	UrlMatch    WafConfigRulesConditionsType = "url-match"
)

// Defines values for WafConfigRulesMatch.
const (
	WafConfigRulesMatchAll   WafConfigRulesMatch = "all"
	WafConfigRulesMatchAny   WafConfigRulesMatch = "any"
	WafConfigRulesMatchEmpty WafConfigRulesMatch = ""
)

// Defines values for WafConfigRulesType.
const (
	Allow WafConfigRulesType = "allow"
	Deny  WafConfigRulesType = "deny"
)

// Defines values for WebhookGetStepAction.
const (
	WebhookGet WebhookGetStepAction = "webhook.get"
)

// Defines values for WebhookPostStepAction.
const (
	WebhookPost WebhookPostStepAction = "webhook.post"
)

// Defines values for GetAccountInvitesParamsMeta.
const (
	GetAccountInvitesParamsMetaCapabilities GetAccountInvitesParamsMeta = "capabilities"
)

// Defines values for GetAccountInvitesParamsInclude.
const (
	GetAccountInvitesParamsIncludeHubs    GetAccountInvitesParamsInclude = "hubs"
	GetAccountInvitesParamsIncludeRoles   GetAccountInvitesParamsInclude = "roles"
	GetAccountInvitesParamsIncludeSenders GetAccountInvitesParamsInclude = "senders"
)

// Defines values for UpdateAccountInviteParamsInclude.
const (
	UpdateAccountInviteParamsIncludeHubs    UpdateAccountInviteParamsInclude = "hubs"
	UpdateAccountInviteParamsIncludeRoles   UpdateAccountInviteParamsInclude = "roles"
	UpdateAccountInviteParamsIncludeSenders UpdateAccountInviteParamsInclude = "senders"
)

// Defines values for GetAccountMembershipsParamsInclude.
const (
	GetAccountMembershipsParamsIncludeHubs    GetAccountMembershipsParamsInclude = "hubs"
	GetAccountMembershipsParamsIncludeRoles   GetAccountMembershipsParamsInclude = "roles"
	GetAccountMembershipsParamsIncludeSenders GetAccountMembershipsParamsInclude = "senders"
)

// Defines values for GetAnnouncementsParamsFilterRange.
const (
	Day   GetAnnouncementsParamsFilterRange = "day"
	Hour  GetAnnouncementsParamsFilterRange = "hour"
	Month GetAnnouncementsParamsFilterRange = "month"
	Week  GetAnnouncementsParamsFilterRange = "week"
	Year  GetAnnouncementsParamsFilterRange = "year"
)

// Defines values for GetAnnouncementsParamsFilterResolved.
const (
	False GetAnnouncementsParamsFilterResolved = "false"
	True  GetAnnouncementsParamsFilterResolved = "true"
)

// Defines values for GetInvoicesParamsMeta.
const (
	GetInvoicesParamsMetaDue GetInvoicesParamsMeta = "due"
)

// Defines values for GetInvoiceParamsMeta.
const (
	GetInvoiceParamsMetaDue GetInvoiceParamsMeta = "due"
	GetInvoiceParamsMetaHub GetInvoiceParamsMeta = "hub"
)

// Defines values for CreateInvoiceJobJSONBodyAction.
const (
	Pay CreateInvoiceJobJSONBodyAction = "pay"
)

// Defines values for CreateBillingMethodJSONBodyDirectPaymentPreference.
const (
	CreateBillingMethodJSONBodyDirectPaymentPreferenceAch   CreateBillingMethodJSONBodyDirectPaymentPreference = "ach"
	CreateBillingMethodJSONBodyDirectPaymentPreferenceCheck CreateBillingMethodJSONBodyDirectPaymentPreference = "check"
	CreateBillingMethodJSONBodyDirectPaymentPreferenceWire  CreateBillingMethodJSONBodyDirectPaymentPreference = "wire"
)

// Defines values for CreateBillingMethodJSONBodyUsBankAcctAccountHolderType.
const (
	Company    CreateBillingMethodJSONBodyUsBankAcctAccountHolderType = "company"
	Individual CreateBillingMethodJSONBodyUsBankAcctAccountHolderType = "individual"
)

// Defines values for CreateBillingMethodJobJSONBodyAction.
const (
	CreateBillingMethodJobJSONBodyActionVerify CreateBillingMethodJobJSONBodyAction = "verify"
)

// Defines values for GetOrdersParamsMeta.
const (
	GetOrdersParamsMetaDue GetOrdersParamsMeta = "due"
)

// Defines values for GetOrdersParamsInclude.
const (
	GetOrdersParamsIncludePromoCodes GetOrdersParamsInclude = "promo_codes"
)

// Defines values for CreateOrderParamsMeta.
const (
	CreateOrderParamsMetaDue CreateOrderParamsMeta = "due"
)

// Defines values for CreateOrderParamsInclude.
const (
	CreateOrderParamsIncludePromoCodes CreateOrderParamsInclude = "promo_codes"
)

// Defines values for CreateOrderJSONBodyTermLength.
const (
	CreateOrderJSONBodyTermLengthMonthly CreateOrderJSONBodyTermLength = "monthly"
	CreateOrderJSONBodyTermLengthOnce    CreateOrderJSONBodyTermLength = "once"
	CreateOrderJSONBodyTermLengthYearly  CreateOrderJSONBodyTermLength = "yearly"
)

// Defines values for GetBillingOrderParamsMeta.
const (
	GetBillingOrderParamsMetaDue GetBillingOrderParamsMeta = "due"
)

// Defines values for GetBillingOrderParamsInclude.
const (
	GetBillingOrderParamsIncludePromoCodes GetBillingOrderParamsInclude = "promo_codes"
)

// Defines values for UpdateBillingOrderParamsMeta.
const (
	UpdateBillingOrderParamsMetaDue UpdateBillingOrderParamsMeta = "due"
)

// Defines values for UpdateBillingOrderParamsInclude.
const (
	UpdateBillingOrderParamsIncludePromoCodes UpdateBillingOrderParamsInclude = "promo_codes"
)

// Defines values for UpdateBillingOrderJSONBodyTermLength.
const (
	Monthly UpdateBillingOrderJSONBodyTermLength = "monthly"
	Once    UpdateBillingOrderJSONBodyTermLength = "once"
	Yearly  UpdateBillingOrderJSONBodyTermLength = "yearly"
)

// Defines values for CreateOrderJobJSONBodyAction.
const (
	Confirm CreateOrderJobJSONBodyAction = "confirm"
)

// Defines values for GetContainersParamsMeta.
const (
	GetContainersParamsMetaDomains        GetContainersParamsMeta = "domains"
	GetContainersParamsMetaInstancesCount GetContainersParamsMeta = "instances_count"
	GetContainersParamsMetaIps            GetContainersParamsMeta = "ips"
)

// Defines values for GetContainersParamsInclude.
const (
	GetContainersParamsIncludeCreators     GetContainersParamsInclude = "creators"
	GetContainersParamsIncludeEnvironments GetContainersParamsInclude = "environments"
	GetContainersParamsIncludeImages       GetContainersParamsInclude = "images"
	GetContainersParamsIncludeStackBuilds  GetContainersParamsInclude = "stack_builds"
	GetContainersParamsIncludeStacks       GetContainersParamsInclude = "stacks"
)

// Defines values for GetContainerParamsMeta.
const (
	GetContainerParamsMetaDomains        GetContainerParamsMeta = "domains"
	GetContainerParamsMetaInstancesCount GetContainerParamsMeta = "instances_count"
	GetContainerParamsMetaIps            GetContainerParamsMeta = "ips"
)

// Defines values for GetContainerParamsInclude.
const (
	GetContainerParamsIncludeCreators     GetContainerParamsInclude = "creators"
	GetContainerParamsIncludeEnvironments GetContainerParamsInclude = "environments"
	GetContainerParamsIncludeImages       GetContainerParamsInclude = "images"
	GetContainerParamsIncludeStackBuilds  GetContainerParamsInclude = "stack_builds"
	GetContainerParamsIncludeStacks       GetContainerParamsInclude = "stacks"
)

// Defines values for GetContainerBackupsParamsInclude.
const (
	GetContainerBackupsParamsIncludeIntegrations GetContainerBackupsParamsInclude = "integrations"
)

// Defines values for GetContainerBackupParamsInclude.
const (
	GetContainerBackupParamsIncludeIntegrations GetContainerBackupParamsInclude = "integrations"
)

// Defines values for CreateContainerBackupJobJSONBodyAction.
const (
	CreateContainerBackupJobJSONBodyActionRestore CreateContainerBackupJobJSONBodyAction = "restore"
)

// Defines values for GetInstancesParamsInclude.
const (
	GetInstancesParamsIncludeContainers   GetInstancesParamsInclude = "containers"
	GetInstancesParamsIncludeCreators     GetInstancesParamsInclude = "creators"
	GetInstancesParamsIncludeEnvironments GetInstancesParamsInclude = "environments"
	GetInstancesParamsIncludeIntegrations GetInstancesParamsInclude = "integrations"
	GetInstancesParamsIncludeLocations    GetInstancesParamsInclude = "locations"
	GetInstancesParamsIncludeServers      GetInstancesParamsInclude = "servers"
)

// Defines values for GetInstancesParamsMeta.
const (
	GetInstancesParamsMetaNode       GetInstancesParamsMeta = "node"
	GetInstancesParamsMetaSdnPoolIps GetInstancesParamsMeta = "sdn_pool_ips"
)

// Defines values for GetInstanceParamsMeta.
const (
	GetInstanceParamsMetaNode       GetInstanceParamsMeta = "node"
	GetInstanceParamsMetaSdnPoolIps GetInstanceParamsMeta = "sdn_pool_ips"
)

// Defines values for GetInstanceParamsInclude.
const (
	GetInstanceParamsIncludeContainers   GetInstanceParamsInclude = "containers"
	GetInstanceParamsIncludeCreators     GetInstanceParamsInclude = "creators"
	GetInstanceParamsIncludeEnvironments GetInstanceParamsInclude = "environments"
	GetInstanceParamsIncludeIntegrations GetInstanceParamsInclude = "integrations"
	GetInstanceParamsIncludeLocations    GetInstanceParamsInclude = "locations"
	GetInstanceParamsIncludeServers      GetInstanceParamsInclude = "servers"
)

// Defines values for GetContainerServersParamsMeta.
const (
	PrimaryIp GetContainerServersParamsMeta = "primary_ip"
)

// Defines values for GetCompatibleServersParamsMeta.
const (
	GetCompatibleServersParamsMetaInstancesCount GetCompatibleServersParamsMeta = "instances_count"
	GetCompatibleServersParamsMetaNode           GetCompatibleServersParamsMeta = "node"
)

// Defines values for GetCompatibleServersParamsInclude.
const (
	GetCompatibleServersParamsIncludeIntegrations GetCompatibleServersParamsInclude = "integrations"
	GetCompatibleServersParamsIncludeLocation     GetCompatibleServersParamsInclude = "location"
	GetCompatibleServersParamsIncludeModels       GetCompatibleServersParamsInclude = "models"
)

// Defines values for CreateUserSuppliedCertificateJobJSONBodyAction.
const (
	Deprecate CreateUserSuppliedCertificateJobJSONBodyAction = "deprecate"
)

// Defines values for GetDNSZonesParamsInclude.
const (
	GetDNSZonesParamsIncludeCreators GetDNSZonesParamsInclude = "creators"
)

// Defines values for UpdateDNSZoneParamsInclude.
const (
	UpdateDNSZoneParamsIncludeCreators UpdateDNSZoneParamsInclude = "creators"
)

// Defines values for UpdateDNSZoneAccessParamsInclude.
const (
	UpdateDNSZoneAccessParamsIncludeCreators UpdateDNSZoneAccessParamsInclude = "creators"
)

// Defines values for GetDNSZoneRecordsParamsInclude.
const (
	GetDNSZoneRecordsParamsIncludeContainers                 GetDNSZoneRecordsParamsInclude = "containers"
	GetDNSZoneRecordsParamsIncludeContainersIdentifiers      GetDNSZoneRecordsParamsInclude = "containers:identifiers"
	GetDNSZoneRecordsParamsIncludeCreators                   GetDNSZoneRecordsParamsInclude = "creators"
	GetDNSZoneRecordsParamsIncludeVirtualMachines            GetDNSZoneRecordsParamsInclude = "virtual-machines"
	GetDNSZoneRecordsParamsIncludeVirtualMachinesIdentifiers GetDNSZoneRecordsParamsInclude = "virtual-machines:identifiers"
)

// Defines values for CreateDNSZoneRecordParamsInclude.
const (
	CreateDNSZoneRecordParamsIncludeContainers                 CreateDNSZoneRecordParamsInclude = "containers"
	CreateDNSZoneRecordParamsIncludeContainersIdentifiers      CreateDNSZoneRecordParamsInclude = "containers:identifiers"
	CreateDNSZoneRecordParamsIncludeCreators                   CreateDNSZoneRecordParamsInclude = "creators"
	CreateDNSZoneRecordParamsIncludeVirtualMachines            CreateDNSZoneRecordParamsInclude = "virtual-machines"
	CreateDNSZoneRecordParamsIncludeVirtualMachinesIdentifiers CreateDNSZoneRecordParamsInclude = "virtual-machines:identifiers"
)

// Defines values for UpdateDNSZoneRecordParamsInclude.
const (
	UpdateDNSZoneRecordParamsIncludeContainers                 UpdateDNSZoneRecordParamsInclude = "containers"
	UpdateDNSZoneRecordParamsIncludeContainersIdentifiers      UpdateDNSZoneRecordParamsInclude = "containers:identifiers"
	UpdateDNSZoneRecordParamsIncludeCreators                   UpdateDNSZoneRecordParamsInclude = "creators"
	UpdateDNSZoneRecordParamsIncludeVirtualMachines            UpdateDNSZoneRecordParamsInclude = "virtual-machines"
	UpdateDNSZoneRecordParamsIncludeVirtualMachinesIdentifiers UpdateDNSZoneRecordParamsInclude = "virtual-machines:identifiers"
)

// Defines values for CreateDNSZoneRecordJobJSONBodyAction.
const (
	GenerateCert CreateDNSZoneRecordJobJSONBodyAction = "generateCert"
)

// Defines values for CreateDNSZoneJobJSONBodyAction.
const (
	CreateDNSZoneJobJSONBodyActionVerify CreateDNSZoneJobJSONBodyAction = "verify"
)

// Defines values for GetEnvironmentsParamsMeta.
const (
	GetEnvironmentsParamsMetaContainers      GetEnvironmentsParamsMeta = "containers"
	GetEnvironmentsParamsMetaContainersCount GetEnvironmentsParamsMeta = "containers_count"
	GetEnvironmentsParamsMetaInstancesCount  GetEnvironmentsParamsMeta = "instances_count"
)

// Defines values for GetEnvironmentsParamsInclude.
const (
	GetEnvironmentsParamsIncludeCreators GetEnvironmentsParamsInclude = "creators"
	GetEnvironmentsParamsIncludeStacks   GetEnvironmentsParamsInclude = "stacks"
)

// Defines values for GetEnvironmentParamsMeta.
const (
	GetEnvironmentParamsMetaContainers      GetEnvironmentParamsMeta = "containers"
	GetEnvironmentParamsMetaContainersCount GetEnvironmentParamsMeta = "containers_count"
	GetEnvironmentParamsMetaInstancesCount  GetEnvironmentParamsMeta = "instances_count"
)

// Defines values for GetEnvironmentParamsInclude.
const (
	GetEnvironmentParamsIncludeClusters GetEnvironmentParamsInclude = "clusters"
	GetEnvironmentParamsIncludeCreators GetEnvironmentParamsInclude = "creators"
	GetEnvironmentParamsIncludeStacks   GetEnvironmentParamsInclude = "stacks"
)

// Defines values for CreateDiscoveryServiceJobJSONBodyAction.
const (
	CreateDiscoveryServiceJobJSONBodyActionReconfigure CreateDiscoveryServiceJobJSONBodyAction = "reconfigure"
)

// Defines values for CreateGatewayServiceJobJSONBodyAction.
const (
	CreateGatewayServiceJobJSONBodyActionReconfigure CreateGatewayServiceJobJSONBodyAction = "reconfigure"
)

// Defines values for CreateLoadBalancerServiceJobJSONBodyAction.
const (
	CreateLoadBalancerServiceJobJSONBodyActionReconfigure CreateLoadBalancerServiceJobJSONBodyAction = "reconfigure"
)

// Defines values for GetLoadBalancerTelemetryLatestControllersParamsInclude.
const (
	GetLoadBalancerTelemetryLatestControllersParamsIncludeContainers GetLoadBalancerTelemetryLatestControllersParamsInclude = "containers"
	GetLoadBalancerTelemetryLatestControllersParamsIncludeInstances  GetLoadBalancerTelemetryLatestControllersParamsInclude = "instances"
	GetLoadBalancerTelemetryLatestControllersParamsIncludeServers    GetLoadBalancerTelemetryLatestControllersParamsInclude = "servers"
)

// Defines values for CreateSchedulerServiceJobJSONBodyAction.
const (
	CreateSchedulerServiceJobJSONBodyActionReconfigure CreateSchedulerServiceJobJSONBodyAction = "reconfigure"
)

// Defines values for GetHubParamsMeta.
const (
	Memberships GetHubParamsMeta = "memberships"
)

// Defines values for GetHubActivityParamsInclude.
const (
	GetHubActivityParamsIncludeComponents   GetHubActivityParamsInclude = "components"
	GetHubActivityParamsIncludeCreators     GetHubActivityParamsInclude = "creators"
	GetHubActivityParamsIncludeEnvironments GetHubActivityParamsInclude = "environments"
	GetHubActivityParamsIncludeImages       GetHubActivityParamsInclude = "images"
	GetHubActivityParamsIncludeStackBuilds  GetHubActivityParamsInclude = "stack_builds"
	GetHubActivityParamsIncludeStacks       GetHubActivityParamsInclude = "stacks"
	GetHubActivityParamsIncludeUsers        GetHubActivityParamsInclude = "users"
)

// Defines values for GetAPIKeyParamsInclude.
const (
	GetAPIKeyParamsIncludeRoles GetAPIKeyParamsInclude = "roles"
)

// Defines values for GetIntegrationsParamsMeta.
const (
	GetIntegrationsParamsMetaDefinition GetIntegrationsParamsMeta = "definition"
)

// Defines values for CreateIntegrationParamsMeta.
const (
	CreateIntegrationParamsMetaDefinition CreateIntegrationParamsMeta = "definition"
)

// Defines values for GetIntegrationParamsMeta.
const (
	GetIntegrationParamsMetaDefinition GetIntegrationParamsMeta = "definition"
)

// Defines values for UpdateIntegrationParamsMeta.
const (
	UpdateIntegrationParamsMetaDefinition UpdateIntegrationParamsMeta = "definition"
)

// Defines values for CreateIntegrationJobJSONBodyAction.
const (
	Verify CreateIntegrationJobJSONBodyAction = "verify"
)

// Defines values for GetHubInvitesParamsMeta.
const (
	GetHubInvitesParamsMetaCapabilities GetHubInvitesParamsMeta = "capabilities"
)

// Defines values for GetHubInvitesParamsInclude.
const (
	GetHubInvitesParamsIncludeRoles   GetHubInvitesParamsInclude = "roles"
	GetHubInvitesParamsIncludeSenders GetHubInvitesParamsInclude = "senders"
)

// Defines values for GetHubMembersParamsInclude.
const (
	GetHubMembersParamsIncludeAccounts GetHubMembersParamsInclude = "accounts"
	GetHubMembersParamsIncludeRoles    GetHubMembersParamsInclude = "roles"
)

// Defines values for GetHubMemberAccountParamsMeta.
const (
	Capabilities GetHubMemberAccountParamsMeta = "capabilities"
)

// Defines values for GetHubMemberAccountParamsInclude.
const (
	GetHubMemberAccountParamsIncludeAccounts GetHubMemberAccountParamsInclude = "accounts"
	GetHubMemberAccountParamsIncludeRoles    GetHubMemberAccountParamsInclude = "roles"
)

// Defines values for GetHubMemberParamsInclude.
const (
	GetHubMemberParamsIncludeAccounts GetHubMemberParamsInclude = "accounts"
	GetHubMemberParamsIncludeRoles    GetHubMemberParamsInclude = "roles"
)

// Defines values for GetHubMembershipParamsInclude.
const (
	Accounts GetHubMembershipParamsInclude = "accounts"
	Roles    GetHubMembershipParamsInclude = "roles"
)

// Defines values for GetRolesParamsMeta.
const (
	GetRolesParamsMetaCounts GetRolesParamsMeta = "counts"
)

// Defines values for GetRoleParamsMeta.
const (
	GetRoleParamsMetaCounts GetRoleParamsMeta = "counts"
)

// Defines values for GetImagesParamsMeta.
const (
	GetImagesParamsMetaContainersCount GetImagesParamsMeta = "containers_count"
)

// Defines values for GetImagesParamsInclude.
const (
	GetImagesParamsIncludeCreators     GetImagesParamsInclude = "creators"
	GetImagesParamsIncludeIntegrations GetImagesParamsInclude = "integrations"
	GetImagesParamsIncludeSources      GetImagesParamsInclude = "sources"
	GetImagesParamsIncludeStackBuilds  GetImagesParamsInclude = "stack_builds"
	GetImagesParamsIncludeStacks       GetImagesParamsInclude = "stacks"
)

// Defines values for GetImageSourcesParamsMeta.
const (
	GetImageSourcesParamsMetaImagesCount GetImageSourcesParamsMeta = "images_count"
)

// Defines values for GetImageSourcesParamsInclude.
const (
	GetImageSourcesParamsIncludeCreators     GetImageSourcesParamsInclude = "creators"
	GetImageSourcesParamsIncludeIntegrations GetImageSourcesParamsInclude = "integrations"
)

// Defines values for GetImageSourceParamsMeta.
const (
	GetImageSourceParamsMetaImagesCount GetImageSourceParamsMeta = "images_count"
)

// Defines values for GetImageSourceParamsInclude.
const (
	GetImageSourceParamsIncludeCreators     GetImageSourceParamsInclude = "creators"
	GetImageSourceParamsIncludeIntegrations GetImageSourceParamsInclude = "integrations"
)

// Defines values for CreateImagesJobJSONBodyAction.
const (
	CreateImagesJobJSONBodyActionPrune CreateImagesJobJSONBodyAction = "prune"
)

// Defines values for GetImageParamsMeta.
const (
	GetImageParamsMetaContainersCount GetImageParamsMeta = "containers_count"
)

// Defines values for GetImageParamsInclude.
const (
	GetImageParamsIncludeCreators     GetImageParamsInclude = "creators"
	GetImageParamsIncludeIntegrations GetImageParamsInclude = "integrations"
	GetImageParamsIncludeSources      GetImageParamsInclude = "sources"
	GetImageParamsIncludeStackBuilds  GetImageParamsInclude = "stack_builds"
	GetImageParamsIncludeStacks       GetImageParamsInclude = "stacks"
)

// Defines values for CreateImageJobJSONBodyAction.
const (
	Import CreateImageJobJSONBodyAction = "import"
)

// Defines values for GetAutoScaleGroupsParamsInclude.
const (
	GetAutoScaleGroupsParamsIncludeIntegrations GetAutoScaleGroupsParamsInclude = "integrations"
	GetAutoScaleGroupsParamsIncludeLocations    GetAutoScaleGroupsParamsInclude = "locations"
	GetAutoScaleGroupsParamsIncludeModels       GetAutoScaleGroupsParamsInclude = "models"
)

// Defines values for GetAutoScaleGroupParamsInclude.
const (
	GetAutoScaleGroupParamsIncludeIntegrations GetAutoScaleGroupParamsInclude = "integrations"
	GetAutoScaleGroupParamsIncludeLocations    GetAutoScaleGroupParamsInclude = "locations"
	GetAutoScaleGroupParamsIncludeModels       GetAutoScaleGroupParamsInclude = "models"
)

// Defines values for GetExternalVolumesParamsMeta.
const (
	GetExternalVolumesParamsMetaContainers GetExternalVolumesParamsMeta = "containers"
)

// Defines values for GetExternalVolumesParamsInclude.
const (
	GetExternalVolumesParamsIncludeLocations GetExternalVolumesParamsInclude = "locations"
	GetExternalVolumesParamsIncludeServers   GetExternalVolumesParamsInclude = "servers"
)

// Defines values for CreateExternalVolumeParamsMeta.
const (
	CreateExternalVolumeParamsMetaContainers CreateExternalVolumeParamsMeta = "containers"
)

// Defines values for CreateExternalVolumeParamsInclude.
const (
	CreateExternalVolumeParamsIncludeLocations CreateExternalVolumeParamsInclude = "locations"
	CreateExternalVolumeParamsIncludeServers   CreateExternalVolumeParamsInclude = "servers"
)

// Defines values for GetExternalVolumeParamsMeta.
const (
	GetExternalVolumeParamsMetaContainers GetExternalVolumeParamsMeta = "containers"
)

// Defines values for GetExternalVolumeParamsInclude.
const (
	GetExternalVolumeParamsIncludeLocations GetExternalVolumeParamsInclude = "locations"
	GetExternalVolumeParamsIncludeServers   GetExternalVolumeParamsInclude = "servers"
)

// Defines values for UpdateExternalVolumeParamsMeta.
const (
	UpdateExternalVolumeParamsMetaContainers UpdateExternalVolumeParamsMeta = "containers"
)

// Defines values for UpdateExternalVolumeParamsInclude.
const (
	UpdateExternalVolumeParamsIncludeLocations UpdateExternalVolumeParamsInclude = "locations"
	UpdateExternalVolumeParamsIncludeServers   UpdateExternalVolumeParamsInclude = "servers"
)

// Defines values for GetIpPoolsParamsInclude.
const (
	GetIpPoolsParamsIncludeIntegrations GetIpPoolsParamsInclude = "integrations"
	GetIpPoolsParamsIncludeLocations    GetIpPoolsParamsInclude = "locations"
	GetIpPoolsParamsIncludeServers      GetIpPoolsParamsInclude = "servers"
)

// Defines values for GetIPPoolParamsInclude.
const (
	GetIPPoolParamsIncludeIntegrations GetIPPoolParamsInclude = "integrations"
	GetIPPoolParamsIncludeLocations    GetIPPoolParamsInclude = "locations"
	GetIPPoolParamsIncludeServers      GetIPPoolParamsInclude = "servers"
)

// Defines values for GetServersParamsMeta.
const (
	GetServersParamsMetaInstancesCount GetServersParamsMeta = "instances_count"
	GetServersParamsMetaNode           GetServersParamsMeta = "node"
)

// Defines values for GetServersParamsInclude.
const (
	GetServersParamsIncludeClusters     GetServersParamsInclude = "clusters"
	GetServersParamsIncludeIntegrations GetServersParamsInclude = "integrations"
	GetServersParamsIncludeLocations    GetServersParamsInclude = "locations"
	GetServersParamsIncludeModels       GetServersParamsInclude = "models"
)

// Defines values for GetServerParamsInclude.
const (
	GetServerParamsIncludeClusters     GetServerParamsInclude = "clusters"
	GetServerParamsIncludeIntegrations GetServerParamsInclude = "integrations"
	GetServerParamsIncludeLocations    GetServerParamsInclude = "locations"
	GetServerParamsIncludeModels       GetServerParamsInclude = "models"
)

// Defines values for GetServerParamsMeta.
const (
	GetServerParamsMetaAllocations    GetServerParamsMeta = "allocations"
	GetServerParamsMetaInstancesCount GetServerParamsMeta = "instances_count"
	GetServerParamsMetaNode           GetServerParamsMeta = "node"
)

// Defines values for GetServerInstancesParamsInclude.
const (
	GetServerInstancesParamsIncludeContainers   GetServerInstancesParamsInclude = "containers"
	GetServerInstancesParamsIncludeCreator      GetServerInstancesParamsInclude = "creator"
	GetServerInstancesParamsIncludeEnvironments GetServerInstancesParamsInclude = "environments"
	GetServerInstancesParamsIncludeIntegrations GetServerInstancesParamsInclude = "integrations"
	GetServerInstancesParamsIncludeLocations    GetServerInstancesParamsInclude = "locations"
	GetServerInstancesParamsIncludeServers      GetServerInstancesParamsInclude = "servers"
)

// Defines values for GetVirtualProviderIsosParamsInclude.
const (
	GetVirtualProviderIsosParamsIncludeIntegrations GetVirtualProviderIsosParamsInclude = "integrations"
)

// Defines values for CreateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreference.
const (
	CreateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreferenceIpv4 CreateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreference = "ipv4"
	CreateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreferenceIpv6 CreateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreference = "ipv6"
)

// Defines values for GetVirtualProviderIsoParamsInclude.
const (
	GetVirtualProviderIsoParamsIncludeIntegrations GetVirtualProviderIsoParamsInclude = "integrations"
)

// Defines values for UpdateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreference.
const (
	UpdateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreferenceIpv4 UpdateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreference = "ipv4"
	UpdateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreferenceIpv6 UpdateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreference = "ipv6"
)

// Defines values for GetJobsParamsInclude.
const (
	GetJobsParamsIncludeCreators GetJobsParamsInclude = "creators"
)

// Defines values for GetEventsParamsFilterType.
const (
	GetEventsParamsFilterTypeAlert   GetEventsParamsFilterType = "alert"
	GetEventsParamsFilterTypeAudit   GetEventsParamsFilterType = "audit"
	GetEventsParamsFilterTypeError   GetEventsParamsFilterType = "error"
	GetEventsParamsFilterTypeInfo    GetEventsParamsFilterType = "info"
	GetEventsParamsFilterTypeNotice  GetEventsParamsFilterType = "notice"
	GetEventsParamsFilterTypeSuccess GetEventsParamsFilterType = "success"
	GetEventsParamsFilterTypeWarning GetEventsParamsFilterType = "warning"
)

// Defines values for AggregateLogsJSONBodyScopeType.
const (
	AggregateLogsJSONBodyScopeTypeContainer   AggregateLogsJSONBodyScopeType = "container"
	AggregateLogsJSONBodyScopeTypeEnvironment AggregateLogsJSONBodyScopeType = "environment"
	AggregateLogsJSONBodyScopeTypeInstance    AggregateLogsJSONBodyScopeType = "instance"
)

// Defines values for AggregateLogsJSONBodySearchType.
const (
	Raw    AggregateLogsJSONBodySearchType = "raw"
	Regexp AggregateLogsJSONBodySearchType = "regexp"
)

// Defines values for GetMetricsParamsFilterType.
const (
	GetMetricsParamsFilterTypeCount        GetMetricsParamsFilterType = "count"
	GetMetricsParamsFilterTypeCounter      GetMetricsParamsFilterType = "counter"
	GetMetricsParamsFilterTypeDistribution GetMetricsParamsFilterType = "distribution"
	GetMetricsParamsFilterTypeGauge        GetMetricsParamsFilterType = "gauge"
	GetMetricsParamsFilterTypeHistogram    GetMetricsParamsFilterType = "histogram"
	GetMetricsParamsFilterTypeRate         GetMetricsParamsFilterType = "rate"
	GetMetricsParamsFilterTypeSet          GetMetricsParamsFilterType = "set"
)

// Defines values for GetPipelinesParamsInclude.
const (
	GetPipelinesParamsIncludeComponents GetPipelinesParamsInclude = "components"
	GetPipelinesParamsIncludeCreators   GetPipelinesParamsInclude = "creators"
	GetPipelinesParamsIncludeName       GetPipelinesParamsInclude = "name"
)

// Defines values for GetPipelineParamsInclude.
const (
	GetPipelineParamsIncludeComponents GetPipelineParamsInclude = "components"
	GetPipelineParamsIncludeCreators   GetPipelineParamsInclude = "creators"
	GetPipelineParamsIncludeName       GetPipelineParamsInclude = "name"
)

// Defines values for GetPipelineRunsParamsInclude.
const (
	GetPipelineRunsParamsIncludeCreators GetPipelineRunsParamsInclude = "creators"
)

// Defines values for GetPipelineRunParamsInclude.
const (
	GetPipelineRunParamsIncludeCreators GetPipelineRunParamsInclude = "creators"
)

// Defines values for GetNetworksParamsInclude.
const (
	GetNetworksParamsIncludeCreators     GetNetworksParamsInclude = "creators"
	GetNetworksParamsIncludeEnvironments GetNetworksParamsInclude = "environments"
)

// Defines values for CreateNetworkParamsInclude.
const (
	CreateNetworkParamsIncludeCreators     CreateNetworkParamsInclude = "creators"
	CreateNetworkParamsIncludeEnvironments CreateNetworkParamsInclude = "environments"
)

// Defines values for GetNetworkParamsInclude.
const (
	GetNetworkParamsIncludeCreators     GetNetworkParamsInclude = "creators"
	GetNetworkParamsIncludeEnvironments GetNetworkParamsInclude = "environments"
)

// Defines values for UpdateNetworkParamsInclude.
const (
	UpdateNetworkParamsIncludeCreators     UpdateNetworkParamsInclude = "creators"
	UpdateNetworkParamsIncludeEnvironments UpdateNetworkParamsInclude = "environments"
)

// Defines values for UpdateNetworkAccessParamsInclude.
const (
	UpdateNetworkAccessParamsIncludeCreators     UpdateNetworkAccessParamsInclude = "creators"
	UpdateNetworkAccessParamsIncludeEnvironments UpdateNetworkAccessParamsInclude = "environments"
)

// Defines values for GetStacksParamsMeta.
const (
	GetStacksParamsMetaBuildsCount     GetStacksParamsMeta = "builds_count"
	GetStacksParamsMetaContainersCount GetStacksParamsMeta = "containers_count"
)

// Defines values for GetStacksParamsInclude.
const (
	GetStacksParamsIncludeCreators GetStacksParamsInclude = "creators"
)

// Defines values for GetStackBuildsParamsMeta.
const (
	GetStackBuildsParamsMetaContainersCount GetStackBuildsParamsMeta = "containers_count"
)

// Defines values for CreateStackJobJSONBodyAction.
const (
	CreateStackJobJSONBodyActionPrune CreateStackJobJSONBodyAction = "prune"
)

// Defines values for LookupIdentifierParamsDesiredComponent.
const (
	LookupIdentifierParamsDesiredComponentCluster     LookupIdentifierParamsDesiredComponent = "cluster"
	LookupIdentifierParamsDesiredComponentContainer   LookupIdentifierParamsDesiredComponent = "container"
	LookupIdentifierParamsDesiredComponentEnvironment LookupIdentifierParamsDesiredComponent = "environment"
	LookupIdentifierParamsDesiredComponentImageSource LookupIdentifierParamsDesiredComponent = "image-source"
	LookupIdentifierParamsDesiredComponentServer      LookupIdentifierParamsDesiredComponent = "server"
	LookupIdentifierParamsDesiredComponentStack       LookupIdentifierParamsDesiredComponent = "stack"
)

// Defines values for GetVirtualMachinesParamsMeta.
const (
	GetVirtualMachinesParamsMetaDomains       GetVirtualMachinesParamsMeta = "domains"
	GetVirtualMachinesParamsMetaHypervisorIps GetVirtualMachinesParamsMeta = "hypervisor_ips"
	GetVirtualMachinesParamsMetaIps           GetVirtualMachinesParamsMeta = "ips"
	GetVirtualMachinesParamsMetaServer        GetVirtualMachinesParamsMeta = "server"
)

// Defines values for GetVirtualMachinesParamsInclude.
const (
	GetVirtualMachinesParamsIncludeClusters     GetVirtualMachinesParamsInclude = "clusters"
	GetVirtualMachinesParamsIncludeContainers   GetVirtualMachinesParamsInclude = "containers"
	GetVirtualMachinesParamsIncludeCreators     GetVirtualMachinesParamsInclude = "creators"
	GetVirtualMachinesParamsIncludeEnvironments GetVirtualMachinesParamsInclude = "environments"
)

// Defines values for GetVirtualMachinesParamsFilterPublicNetwork.
const (
	Disabled GetVirtualMachinesParamsFilterPublicNetwork = "disabled"
	Enabled  GetVirtualMachinesParamsFilterPublicNetwork = "enabled"
)

// Defines values for GetVirtualMachinesParamsFilterState.
const (
	GetVirtualMachinesParamsFilterStateDeleted  GetVirtualMachinesParamsFilterState = "deleted"
	GetVirtualMachinesParamsFilterStateDeleting GetVirtualMachinesParamsFilterState = "deleting"
	GetVirtualMachinesParamsFilterStateNew      GetVirtualMachinesParamsFilterState = "new"
	GetVirtualMachinesParamsFilterStateRunning  GetVirtualMachinesParamsFilterState = "running"
	GetVirtualMachinesParamsFilterStateStarting GetVirtualMachinesParamsFilterState = "starting"
	GetVirtualMachinesParamsFilterStateStopped  GetVirtualMachinesParamsFilterState = "stopped"
	GetVirtualMachinesParamsFilterStateStopping GetVirtualMachinesParamsFilterState = "stopping"
)

// Defines values for CreateVirtualMachineParamsMeta.
const (
	CreateVirtualMachineParamsMetaDomains CreateVirtualMachineParamsMeta = "domains"
	CreateVirtualMachineParamsMetaIps     CreateVirtualMachineParamsMeta = "ips"
	CreateVirtualMachineParamsMetaServer  CreateVirtualMachineParamsMeta = "server"
)

// Defines values for CreateVirtualMachineParamsInclude.
const (
	CreateVirtualMachineParamsIncludeClusters     CreateVirtualMachineParamsInclude = "clusters"
	CreateVirtualMachineParamsIncludeCreators     CreateVirtualMachineParamsInclude = "creators"
	CreateVirtualMachineParamsIncludeEnvironments CreateVirtualMachineParamsInclude = "environments"
)

// Defines values for GetVirtualMachineSshKeysParamsFilterState.
const (
	GetVirtualMachineSshKeysParamsFilterStateDeleted  GetVirtualMachineSshKeysParamsFilterState = "deleted"
	GetVirtualMachineSshKeysParamsFilterStateDeleting GetVirtualMachineSshKeysParamsFilterState = "deleting"
	GetVirtualMachineSshKeysParamsFilterStateLive     GetVirtualMachineSshKeysParamsFilterState = "live"
)

// Defines values for GetVirtualMachineSshKeysParamsInclude.
const (
	GetVirtualMachineSshKeysParamsIncludeCreators     GetVirtualMachineSshKeysParamsInclude = "creators"
	GetVirtualMachineSshKeysParamsIncludeEnvironments GetVirtualMachineSshKeysParamsInclude = "environments"
)

// Defines values for CreateVirtualMachineSshKeyParamsInclude.
const (
	CreateVirtualMachineSshKeyParamsIncludeCreators     CreateVirtualMachineSshKeyParamsInclude = "creators"
	CreateVirtualMachineSshKeyParamsIncludeEnvironments CreateVirtualMachineSshKeyParamsInclude = "environments"
)

// Defines values for GetVirtualMachineSshKeyParamsInclude.
const (
	GetVirtualMachineSshKeyParamsIncludeCreators     GetVirtualMachineSshKeyParamsInclude = "creators"
	GetVirtualMachineSshKeyParamsIncludeEnvironments GetVirtualMachineSshKeyParamsInclude = "environments"
)

// Defines values for UpdateVirtualMachineSshKeyParamsInclude.
const (
	UpdateVirtualMachineSshKeyParamsIncludeCreators     UpdateVirtualMachineSshKeyParamsInclude = "creators"
	UpdateVirtualMachineSshKeyParamsIncludeEnvironments UpdateVirtualMachineSshKeyParamsInclude = "environments"
)

// Defines values for GetVirtualMachineParamsMeta.
const (
	GetVirtualMachineParamsMetaDomains       GetVirtualMachineParamsMeta = "domains"
	GetVirtualMachineParamsMetaHypervisorIps GetVirtualMachineParamsMeta = "hypervisor_ips"
	GetVirtualMachineParamsMetaIps           GetVirtualMachineParamsMeta = "ips"
	GetVirtualMachineParamsMetaServer        GetVirtualMachineParamsMeta = "server"
)

// Defines values for GetVirtualMachineParamsInclude.
const (
	GetVirtualMachineParamsIncludeClusters     GetVirtualMachineParamsInclude = "clusters"
	GetVirtualMachineParamsIncludeContainers   GetVirtualMachineParamsInclude = "containers"
	GetVirtualMachineParamsIncludeCreators     GetVirtualMachineParamsInclude = "creators"
	GetVirtualMachineParamsIncludeEnvironments GetVirtualMachineParamsInclude = "environments"
)

// ACL An access control list. Defines which roles have which permissions on specific resources.
type ACL struct {
	Roles *map[string]struct {
		// Manage Can the user delete / update ACLs for this resource?
		Manage bool `json:"manage"`

		// Modify Can the user edit the state / name / identifier of this resource?
		Modify bool `json:"modify"`

		// View Can the user see / use this resource?
		View bool `json:"view"`
	} `json:"roles,omitempty"`
}

// Account An object representing information about the currently logged-in user.
type Account struct {
	// AllowSupportLogin Indicates whether or not Cycle employees have authorization to log in to this Account in a support capacity.
	AllowSupportLogin *bool `json:"allow_support_login,omitempty"`

	// Email Information about the email address associated with the Account.
	Email struct {
		Added DateTime `json:"added"`

		// Address The email address.
		Address string `json:"address"`

		// Verified If true, the email has been verified and the Account is active.
		Verified bool `json:"verified"`
	} `json:"email"`

	// Events A collection of timestamps for each event in the Account's lifetime.
	Events struct {
		Created   DateTime `json:"created"`
		Deleted   DateTime `json:"deleted"`
		LastLogin DateTime `json:"last_login"`
		Updated   DateTime `json:"updated"`
	} `json:"events"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Name The first and last name associated with the Account.
	Name struct {
		// First The first name of the Account owner.
		First string `json:"first"`

		// Last The last name of the Account owner.
		Last string `json:"last"`
	} `json:"name"`
	State AccountState `json:"state"`

	// TwoFactorAuth Two factor auth verification information.
	TwoFactorAuth *struct {
		// Verified A boolean representing if the account has verified with two-factor authentication.
		Verified bool `json:"verified"`
	} `json:"two_factor_auth"`
}

// AccountMembershipIncludes A resource that is associated with an account's membership.
type AccountMembershipIncludes struct {
	// Hubs A record with an ID mapped to a hub resource.
	Hubs *map[string]Hub `json:"hubs,omitempty"`

	// Roles A map of Roles relevant to this Hub Membership, keyed by the Role ID.
	Roles *map[string]Role `json:"roles,omitempty"`

	// RolesIdentifiers A map of Roles relevant to this Hub Membership, keyed by the Role ID.
	RolesIdentifiers *map[string]ID `json:"roles:identifiers,omitempty"`

	// Senders A record with an ID mapped to a public account for the account that sent this memberships initial invite.
	Senders *struct {
		// Accounts A record with an ID mapped to a public account.
		Accounts *map[string]PublicAccount `json:"accounts,omitempty"`
	} `json:"senders,omitempty"`
}

// AccountState defines model for AccountState.
type AccountState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the account.
	Current AccountStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// AccountStateCurrent The current state of the account.
type AccountStateCurrent string

// Activity A resource representing information about activity taking place on a given hub.
type Activity struct {
	// Annotations A record of additional annotations for the activity.
	Annotations map[string]interface{} `json:"annotations"`

	// Changes An array of changes.
	Changes []Change `json:"changes"`

	// Component An object holding information about a component.
	Component *struct {
		// Id A 24 character hex string used to identify a unique resource.
		Id ID `json:"id"`

		// Type The type of component.
		Type string `json:"type"`
	} `json:"component"`

	// Context ID context for resources associated with an activity.
	Context Context `json:"context"`

	// Error An object describing a given activity error.
	Error *struct {
		// Message The error message.
		Message string `json:"message"`
	} `json:"error"`

	// Event The activity event.
	Event ActivityEvent `json:"event"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Monitor Details related to the monitor that raised this activity event.
	Monitor *ActivityMonitor `json:"monitor,omitempty"`

	// Security Security information pertaining to this activity.
	Security *ActivitySecurity `json:"security,omitempty"`
	Session  *Session          `json:"session"`

	// Status A status for the given activity.
	Status ActivityStatus `json:"status"`

	// Tags An array of tags that denote things such as a type of security event, or can be user-provided.
	Tags *[]string `json:"tags,omitempty"`
	Time DateTime  `json:"time"`

	// User Userscope
	User struct {
		// Id The given user's ID.
		Id string `json:"id"`

		// Type The type of user.
		Type ActivityUserType `json:"type"`
	} `json:"user"`

	// Verbosity A number representing the detail level (verbosity) of this activity.
	//
	// - 0: activity that other users would find useful
	// - 1: activity that can be useful in tracking down how a user did something
	// - 2: full activity, can be useful in debugging problems
	Verbosity int `json:"verbosity"`
}

// ActivityEvent The activity event.
type ActivityEvent string

// ActivityStatus A status for the given activity.
type ActivityStatus string

// ActivityUserType The type of user.
type ActivityUserType string

// ActivityIncludes All includable resources linkable to the given records.
type ActivityIncludes struct {
	// Components A resource that is associated with activity.
	Components *ComponentsIncludes `json:"components,omitempty"`

	// Users An identity that created a resource.
	Users *CreatorInclude `json:"users,omitempty"`
}

// ActivityMonitor Details related to the monitor that raised this activity event.
type ActivityMonitor struct {
	// Event How the platform has handled this monitor event.
	Event ActivityMonitorEvent `json:"event"`

	// Level The severity of the event.
	Level ActivityMonitorLevel `json:"level"`

	// State The current state of the monitored resource
	State ActivityMonitorState `json:"state"`
}

// ActivityMonitorEvent How the platform has handled this monitor event.
type ActivityMonitorEvent string

// ActivityMonitorLevel The severity of the event.
type ActivityMonitorLevel string

// ActivityMonitorState The current state of the monitored resource
type ActivityMonitorState string

// ActivitySecurity Security information pertaining to this activity.
type ActivitySecurity struct {
	// Attack The type of attack the platform has determined has occurred.
	Attack ActivitySecurityAttack `json:"attack"`

	// Event How the platform has handled this security event.
	Event ActivitySecurityEvent `json:"event"`

	// Risk A risk level assessed by the platform. Depending on the nature of the incident, this may change even if the event type is the same.
	Risk ActivitySecurityRisk `json:"risk"`

	// Surface From where the platform has determined this security event originated from.
	Surface ActivitySecuritySurface `json:"surface"`
}

// ActivitySecurityAttack The type of attack the platform has determined has occurred.
type ActivitySecurityAttack string

// ActivitySecurityEvent How the platform has handled this security event.
type ActivitySecurityEvent string

// ActivitySecurityRisk A risk level assessed by the platform. Depending on the nature of the incident, this may change even if the event type is the same.
type ActivitySecurityRisk string

// ActivitySecuritySurface From where the platform has determined this security event originated from.
type ActivitySecuritySurface string

// Address Address information for a given billing method.
type Address struct {
	// Country The country this billing method is associated with.
	Country string `json:"country"`

	// Zip The zip code this billing method is associated with.
	Zip string `json:"zip"`
}

// Announcement An announcement from the Cycle team.
type Announcement struct {
	AffectedIntegrations *[]string `json:"affected_integrations,omitempty"`
	AffectedServices     *[]string `json:"affected_services,omitempty"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Description A description of the announcement
	Description string `json:"description"`

	// Events A collection of timestamps for each event in the announcement's lifetime.
	Events struct {
		Created  DateTime `json:"created"`
		Deleted  DateTime `json:"deleted"`
		Resolved DateTime `json:"resolved"`
		Updated  DateTime `json:"updated"`
	} `json:"events"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Priority The priority or severity of the announcement.
	Priority AnnouncementPriority `json:"priority"`
	State    struct {
		Changed DateTime `json:"changed"`

		// Current The current state of the method.
		Current AnnouncementStateCurrent `json:"current"`

		// Error An error, if any, that has occurred for this resource.
		Error *struct {
			// Message Details about the error that has occurred.
			Message *string   `json:"message,omitempty"`
			Time    *DateTime `json:"time,omitempty"`
		} `json:"error,omitempty"`
	} `json:"state"`

	// Title A description of the event being announced.
	Title   string               `json:"title"`
	Updates []AnnouncementUpdate `json:"updates"`
}

// AnnouncementPriority The priority or severity of the announcement.
type AnnouncementPriority string

// AnnouncementStateCurrent The current state of the method.
type AnnouncementStateCurrent string

// AnnouncementUpdate An update to an Announcement.
type AnnouncementUpdate struct {
	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Message The text describing the update to the announcement.
	Message string   `json:"message"`
	Time    DateTime `json:"time"`
}

// ApiKey An API key resource
type ApiKey struct {
	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the API key's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Ips An array of IP's this API key can make calls from.
	Ips *[]string `json:"ips"`

	// Name A name for the API key.
	Name string `json:"name"`

	// RoleId A 24 character hex string used to identify a unique resource.
	RoleId ID `json:"role_id"`

	// Secret The API key secret.
	Secret string      `json:"secret"`
	State  ApiKeyState `json:"state"`
}

// ApiKeyCreator An extended resource that has information on a Cycle hub API key
type ApiKeyCreator struct {
	// Capabilities The API key capabilities list
	Capabilities struct {
		All      bool     `json:"all"`
		Specific []string `json:"specific"`
	} `json:"capabilities"`

	// Events Describes the date and time at which certain events occurred in the lifetime of this resource.
	Events Events `json:"events"`

	// HubId A 24 character hex string used to identify a unique resource.
	HubId ID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id  ID        `json:"id"`
	Ips *[]string `json:"ips"`

	// Name The name of the API key
	Name string `json:"name"`

	// Permissions Permissions information for an API Key
	Permissions Permissions `json:"permissions"`

	// Secret The API key secret
	Secret *string `json:"secret,omitempty"`
	State  struct {
		Changed DateTime                  `json:"changed"`
		Current ApiKeyCreatorStateCurrent `json:"current"`

		// Error An error, if any, that has occurred for this resource.
		Error *struct {
			// Message Details about the error that has occurred.
			Message *string   `json:"message,omitempty"`
			Time    *DateTime `json:"time,omitempty"`
		} `json:"error,omitempty"`
	} `json:"state"`
}

// ApiKeyCreatorStateCurrent defines model for ApiKeyCreator.State.Current.
type ApiKeyCreatorStateCurrent string

// ApiKeyIncludes A resource that is associated with an API key.
type ApiKeyIncludes struct {
	// Roles A map of roles relevant to this API key, keyed by the role ID.
	Roles *map[string]Role `json:"roles,omitempty"`

	// RolesIdentifiers A map of roles relevant to this API key, keyed by the role ID.
	RolesIdentifiers *map[string]ID `json:"roles:identifiers,omitempty"`
}

// ApiKeyState defines model for ApiKeyState.
type ApiKeyState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the API key.
	Current ApiKeyStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// ApiKeyStateCurrent The current state of the API key.
type ApiKeyStateCurrent string

// AssociatedDiscount Information about a billing discount.
type AssociatedDiscount struct {
	// Amount An object holding information about term and amount that relates to a specific billing component.
	Amount  BillingAmount `json:"amount"`
	Expires DateTime      `json:"expires"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`
}

// Attempt A DNS TLS certificate generation attempt resource.
type Attempt struct {
	// Domains A list of domains associated with the attempt.
	Domains []string `json:"domains"`

	// Error If success is false this property will be populated with an error.
	Error *string `json:"error,omitempty"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Success A boolean where true means the attept was successful at creating the TLS certificate.
	Success bool     `json:"success"`
	Time    DateTime `json:"time"`
}

// AutoScaleGroup defines model for AutoScaleGroup.
type AutoScaleGroup struct {
	Acl     *ACL   `json:"acl"`
	Cluster string `json:"cluster"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the auto-scale group's lifetime.
	Events struct {
		Created  DateTime `json:"created"`
		Deleted  DateTime `json:"deleted"`
		LastSync DateTime `json:"last_sync"`
		Updated  DateTime `json:"updated"`
	} `json:"events"`
	HubId          string                       `json:"hub_id"`
	Id             string                       `json:"id"`
	Identifier     string                       `json:"identifier"`
	Infrastructure AutoScaleGroupInfrastructure `json:"infrastructure"`
	Name           string                       `json:"name"`
	Scale          *AutoScaleGroupScale         `json:"scale,omitempty"`
	State          struct {
		Changed DateTime `json:"changed"`

		// Current The current state of the auto-scale group.
		Current AutoScaleGroupStateCurrent `json:"current"`

		// Error An error, if any, that has occurred for this resource.
		Error *struct {
			// Message Details about the error that has occurred.
			Message *string   `json:"message,omitempty"`
			Time    *DateTime `json:"time,omitempty"`
		} `json:"error,omitempty"`
	} `json:"state"`
}

// AutoScaleGroupStateCurrent The current state of the auto-scale group.
type AutoScaleGroupStateCurrent string

// AutoScaleGroupIncludes All includable resource linkable to the given auto-scale group.
type AutoScaleGroupIncludes struct {
	// Integrations A resource that is associated with an integration.
	Integrations *IntegrationsIncludes `json:"integrations,omitempty"`

	// Locations A resource that is associated with a provider location.
	Locations *LocationsIncludes `json:"locations,omitempty"`

	// Models A resource associated with a server models.
	Models *ServerModelsIncludes `json:"models,omitempty"`
}

// AutoScaleGroupInfrastructure defines model for AutoScaleGroupInfrastructure.
type AutoScaleGroupInfrastructure struct {
	Models []struct {
		// IntegrationId A 24 character hex string used to identify a unique resource.
		IntegrationId *ID `json:"integration_id,omitempty"`
		Locations     []struct {
			AvailabilityZones []string `json:"availability_zones"`
			Id                string   `json:"id"`
		} `json:"locations"`
		ModelId  string `json:"model_id"`
		Priority int    `json:"priority"`

		// Provider The integration identifier for infrastructure provider used.
		Provider string `json:"provider"`
	} `json:"models"`
}

// AutoScaleGroupScale defines model for AutoScaleGroupScale.
type AutoScaleGroupScale struct {
	Down *struct {
		// InactivityPeriod A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		InactivityPeriod *Duration                      `json:"inactivity_period,omitempty"`
		Method           *AutoScaleGroupScaleDownMethod `json:"method,omitempty"`

		// MinTtl A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		MinTtl *Duration `json:"min_ttl,omitempty"`
	} `json:"down,omitempty"`
	Up *struct {
		Maximum *int `json:"maximum,omitempty"`
	} `json:"up,omitempty"`
}

// AutoScaleGroupScaleDownMethod defines model for AutoScaleGroupScale.Down.Method.
type AutoScaleGroupScaleDownMethod string

// BillingAmount An object holding information about term and amount that relates to a specific billing component.
type BillingAmount struct {
	// Mills 1/10th of a cent.
	Mills int `json:"mills"`

	// Term The length of the term.
	Term BillingAmountTerm `json:"term"`
}

// BillingAmountTerm The length of the term.
type BillingAmountTerm string

// BillingBuilds An object holding information about servers included in Billing tier
type BillingBuilds struct {
	// CpuCores The number of CPU Cores availiable for builds
	CpuCores float32 `json:"cpu_cores"`

	// MaxDailyBuilds The maximum number of builds processed per day
	MaxDailyBuilds *int    `json:"max_daily_builds"`
	Parallel       float32 `json:"parallel"`

	// RamGb The amount of RAM availiable for builds
	RamGb float32 `json:"ram_gb"`
}

// BillingImageStorage An object holding information about servers included in Billing tier
type BillingImageStorage struct {
	// AdditionalGb Additional cost for image storage exceeding included_gb
	AdditionalGb struct {
		Mills float32                             `json:"mills"`
		Term  BillingImageStorageAdditionalGbTerm `json:"term"`
	} `json:"additional_gb"`

	// HardCap A boolean indicating if there is a hard limit on the image storage
	HardCap bool `json:"hard_cap"`

	// IncludedGb The GB of image storage included in tier
	IncludedGb float32 `json:"included_gb"`
}

// BillingImageStorageAdditionalGbTerm defines model for BillingImageStorage.AdditionalGb.Term.
type BillingImageStorageAdditionalGbTerm string

// BillingOrder Information about an order.
type BillingOrder struct {
	// Approved A boolean where true represents the order is approved to be paid by the user.
	Approved bool `json:"approved"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the billing order's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Expires DateTime `json:"expires"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id    ID          `json:"id"`
	Items []OrderItem `json:"items"`

	// PromoCodeId An ID associated with a promo code used with the order.
	PromoCodeId *string `json:"promo_code_id"`
	State       struct {
		Changed DateTime `json:"changed"`

		// Current The current state of the order.
		Current BillingOrderStateCurrent `json:"current"`

		// Error An error, if any, that has occurred for this resource.
		Error *struct {
			// Message Details about the error that has occurred.
			Message *string   `json:"message,omitempty"`
			Time    *DateTime `json:"time,omitempty"`
		} `json:"error,omitempty"`
	} `json:"state"`

	// Term Information about a billing term.
	Term Term `json:"term"`

	// TotalPrice 1/10th of a cent.
	TotalPrice int `json:"total_price"`
}

// BillingOrderStateCurrent The current state of the order.
type BillingOrderStateCurrent string

// BillingOrderIncludes defines model for BillingOrderIncludes.
type BillingOrderIncludes struct {
	// PromoCodes A resource that is associated with a promo code.
	PromoCodes *PromoCodeInclude `json:"promo_codes,omitempty"`
}

// BillingRam An object holding information about servers included in Billing tier
type BillingRam struct {
	// AdditionalGb Additional cost for image storage exceeding included_gb
	AdditionalGb struct {
		Mills float32                    `json:"mills"`
		Term  BillingRamAdditionalGbTerm `json:"term"`
	} `json:"additional_gb"`

	// HardCap A boolean indicating if there is a hard limit on the image storage
	HardCap bool `json:"hard_cap"`

	// IncludedGb The GB of image storage included in tier
	IncludedGb float32 `json:"included_gb"`
}

// BillingRamAdditionalGbTerm defines model for BillingRam.AdditionalGb.Term.
type BillingRamAdditionalGbTerm string

// BillingService Information about billing service.
type BillingService struct {
	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Discount Information about a billing discount.
	Discount AssociatedDiscount `json:"discount"`

	// Events A collection of timestamps for each event in the billing service's lifetime.
	Events struct {
		Created    DateTime `json:"created"`
		Deleted    DateTime `json:"deleted"`
		LastBilled DateTime `json:"last_billed"`
		Updated    DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Item Information for an item's plan.
	Item ServiceItem `json:"item"`

	// Order An order is a resource that describes a billing order
	Order Order `json:"order"`

	// Price An object holding information about term and amount that relates to a specific billing component.
	Price BillingAmount       `json:"price"`
	State BillingServiceState `json:"state"`

	// Term Information about a billing term.
	Term Term `json:"term"`

	// Title Billing service title.
	Title string `json:"title"`
}

// BillingServiceState defines model for BillingServiceState.
type BillingServiceState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the billing service.
	Current BillingServiceStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// BillingServiceStateCurrent The current state of the billing service.
type BillingServiceStateCurrent string

// BillingSummary A billing summary.
type BillingSummary struct {
	// Discount 1/10th of a cent (mills).
	Discount float32 `json:"discount"`

	// Price 1/10th of a cent (mills).
	Price float32 `json:"price"`

	// ServiceId The ID of the billing service, the summary pertains to.
	ServiceId string `json:"service_id"`

	// Term Information about a billing term.
	Term Term `json:"term"`

	// Title The billing summary title.
	Title string `json:"title"`

	// Type The plan type.
	Type BillingSummaryType `json:"type"`
}

// BillingSummaryType The plan type.
type BillingSummaryType string

// BucketImageSourceType defines model for BucketImageSourceType.
type BucketImageSourceType struct {
	Details struct {
		Id string `json:"id"`

		// Origin The origin of the image.
		Origin ImageOrigin `json:"origin"`
	} `json:"details"`
	Override *struct {
		Target   *string `json:"target,omitempty"`
		TargzUrl *string `json:"targz_url,omitempty"`
	} `json:"override,omitempty"`
	Type BucketImageSourceTypeType `json:"type"`
}

// BucketImageSourceTypeType defines model for BucketImageSourceType.Type.
type BucketImageSourceTypeType string

// BuildLog A build log for a given image.
type BuildLog struct {
	// Events A collection of timestamps for each event in the build log's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// ImageId The ID of the image the build log pertains to.
	ImageId string `json:"image_id"`

	// Log The log itself.
	Log string `json:"log"`
}

// CPUSnapshot A telemetry snapshot pertaining to CPU usage.
type CPUSnapshot struct {
	// NumCores The total number of cores on the originating node the instance is running on.
	NumCores int `json:"num_cores"`

	// Throttling Throttling statistics.
	Throttling struct {
		// Periods The amount of periods that have passed since the last restart.
		Periods *int `json:"periods,omitempty"`

		// ThrottledPeriods How many times the instance has been throttled for using all its alloted CPU during a period.
		ThrottledPeriods *int `json:"throttled_periods,omitempty"`

		// ThrottledTime The amount of time in nanoseconds this instnace has spent with throttled CPU resources.
		ThrottledTime *int `json:"throttled_time,omitempty"`
	} `json:"throttling"`

	// Usage Usage statistics.
	Usage struct {
		// Kernel The amount of time in nanoseconds used by the kernel since last restart.
		Kernel int `json:"kernel"`

		// Total Total amount of VPU time since last restart.
		Total int `json:"total"`

		// User The amount of time in nanoseconds taken up for user processes.
		User float32 `json:"user"`
	} `json:"usage"`
}

// CPUSpec Information about the CPU for a given server.
type CPUSpec struct {
	// Cores The number of cores.
	Cores *int `json:"cores,omitempty"`

	// Count The number of CPUs.
	Count int `json:"count"`

	// Extra Extra information about the CPU if there is any.
	Extra *map[string]string `json:"extra,omitempty"`

	// Shared A boolean where true represents the CPU is shared.
	Shared *bool `json:"shared,omitempty"`

	// Threads The number of threads.
	Threads *int `json:"threads,omitempty"`

	// Type The type of the CPU.
	Type string `json:"type"`
}

// Capability A capability that a user or API key that represents what an API key or a user can do.
type Capability string

// Change An object with information of details for before and after a resource changed.
type Change struct {
	// After Details about a given event that is part of an activity.
	After *Detail `json:"after,omitempty"`

	// Before Details about a given event that is part of an activity.
	Before *Detail `json:"before,omitempty"`

	// Component A description of the resource that was changed.
	Component string `json:"component"`
}

// ChangelogEntry A changelog entry released by the Cycle team.
type ChangelogEntry struct {
	Approved *struct {
		Date DateTime `json:"date"`

		// SignedBy A type of creator and a matching identifier.
		SignedBy UserScope `json:"signed_by"`
	} `json:"approved"`
	Changes []struct {
		Codebase    *string                   `json:"codebase"`
		Description string                    `json:"description"`
		ExternalUrl *string                   `json:"external_url"`
		Notes       *[]string                 `json:"notes"`
		Showcase    bool                      `json:"showcase"`
		Title       string                    `json:"title"`
		Type        ChangelogEntryChangesType `json:"type"`
	} `json:"changes"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator     CreatorScope `json:"creator"`
	EmailEvents *[]struct {
		Address string `json:"address"`

		// Sender A type of creator and a matching identifier.
		Sender UserScope                     `json:"sender"`
		Sent   DateTime                      `json:"sent"`
		Type   ChangelogEntryEmailEventsType `json:"type"`
	} `json:"email_events,omitempty"`

	// Events A collection of timestamps for each event in the changelog entry's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// Hero An object describing the hero image for the changelog entry.
	Hero *struct {
		ImageAlt *string `json:"image_alt"`
		ImageUrl *string `json:"image_url"`
		Intro    string  `json:"intro"`
	} `json:"hero"`

	// Id A 24 character hex string used to identify a unique resource.
	Id        ID `json:"id"`
	Published *struct {
		Date DateTime `json:"date"`

		// SignedBy A type of creator and a matching identifier.
		SignedBy UserScope `json:"signed_by"`
	} `json:"published"`
	State ChangelogEntryState `json:"state"`

	// Title The title of the changelog entry.
	Title string `json:"title"`

	// Version The version of the release described in the changelog entry.
	Version string `json:"version"`
}

// ChangelogEntryChangesType defines model for ChangelogEntry.Changes.Type.
type ChangelogEntryChangesType string

// ChangelogEntryEmailEventsType defines model for ChangelogEntry.EmailEvents.Type.
type ChangelogEntryEmailEventsType string

// ChangelogEntryState defines model for ChangelogEntryState.
type ChangelogEntryState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the changelog entry.
	Current ChangelogEntryStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// ChangelogEntryStateCurrent The current state of the changelog entry.
type ChangelogEntryStateCurrent string

// Cidr A CIDR (Classless Inter-Domain Routing) string is a notation used to represent an IP address and its associated network prefix.
// It combines an IP address with a suffix that indicates how many bits are fixed for routing.
type Cidr = string

// Cluster Clusters are groups of servers that allow physical separation of resources.
type Cluster struct {
	Acl *ACL `json:"acl"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the cluster's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`
	Features struct {
		// Monitoring The level of monitoring to enable for this cluster. There is a cost associated with higher levels of monitoring.
		Monitoring *struct {
			// Tier The tier of monitoring, that determines the frequency that metrics are aggregated by the platform, on a per-environment basis.
			Tier MonitoringTier `json:"tier"`
		} `json:"monitoring"`
	} `json:"features"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID  `json:"hub_id"`
	Id    string `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier   `json:"identifier"`
	State      ClusterState `json:"state"`
}

// ClusterIncludes A resource associated with a cluster.
type ClusterIncludes map[string]Cluster

// ClusterReconfigureMonitoringTierAction A job that reconfigures the monitoring tier for the cluster.
type ClusterReconfigureMonitoringTierAction struct {
	// Action The action to take.
	Action   ClusterReconfigureMonitoringTierActionAction `json:"action"`
	Contents *struct {
		// Tier The tier of monitoring, that determines the frequency that metrics are aggregated by the platform, on a per-environment basis.
		Tier *MonitoringTier `json:"tier,omitempty"`
	} `json:"contents,omitempty"`
}

// ClusterReconfigureMonitoringTierActionAction The action to take.
type ClusterReconfigureMonitoringTierActionAction string

// ClusterState defines model for ClusterState.
type ClusterState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the cluster.
	Current ClusterStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// ClusterStateCurrent The current state of the cluster.
type ClusterStateCurrent string

// ClusterTask defines model for ClusterTask.
type ClusterTask struct {
	union json.RawMessage
}

// ClusterVersionServerCount A count of servers in a cluster with the given version of Cycle software
type ClusterVersionServerCount struct {
	Agent          map[string]float32 `json:"agent"`
	AgentSpawner   map[string]float32 `json:"agent-spawner"`
	Compute        map[string]float32 `json:"compute"`
	ComputeSpawner map[string]float32 `json:"compute-spawner"`
}

// Component Generic component format for describing resources for the search index
type Component struct {
	// Associations Component associations
	Associations struct {
		// Container Associated container Id
		Container *string `json:"container,omitempty"`

		// Environment Associated environment Id
		Environment *string `json:"environment,omitempty"`

		// Image Associated image Id
		Image *string `json:"image,omitempty"`

		// ImageSource Associated image source Id
		ImageSource *string `json:"image-source,omitempty"`

		// Pipeline Associated pipeline source Id
		Pipeline *string `json:"pipeline,omitempty"`

		// ProviderLocation Associated provider location Id
		ProviderLocation *string `json:"provider-location,omitempty"`

		// Server Associated server Id
		Server *string `json:"server,omitempty"`

		// Stack Associated stack Id
		Stack *string `json:"stack,omitempty"`

		// VirtualMachine Associated virtual machine source Id
		VirtualMachine *string `json:"virtual-machine,omitempty"`
	} `json:"associations"`

	// ContextBlobs related strings for fuzzy search
	ContextBlobs []string `json:"context_blobs"`

	// Events Describes the date and time at which certain events occurred in the lifetime of this resource.
	Events Events `json:"events"`

	// Id ID of the component
	Id string `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Name Name of the component
	Name string `json:"name"`

	// State State of the component
	State string `json:"state"`
}

// ComponentsIncludes A resource that is associated with activity.
type ComponentsIncludes map[string]map[string]interface{}

// Config A container configuration.
type Config struct {
	// Deploy Deployment configuration for the given container.
	Deploy ContainerDeploy `json:"deploy"`

	// Integrations Configuration settings for integrations with a given container.
	Integrations *ContainerIntegrations `json:"integrations,omitempty"`

	// Network Network configuration for a container.
	Network ContainerNetwork `json:"network"`

	// Resources Configuration settings for the resource allocations and limits of a given container.
	Resources *ContainerResources `json:"resources,omitempty"`

	// Runtime Runtime configurations for a given container.
	Runtime *ContainerRuntime `json:"runtime,omitempty"`

	// Scale Network configuration for a container.
	Scale *ContainerScale `json:"scale,omitempty"`
}

// Container Containers are a way to package together your application along with it's dependencies, and run in a resource isolated process. They provide consistency across different hosts, efficiency over traditional hosting methods, and facilitate a micro-service based approach, where each logical piece of your application is split into multiple, easily testable parts (such as API, Backend, Frontend, etc).
type Container struct {
	// Annotations Custom meta data for a given container
	Annotations *map[string]interface{} `json:"annotations"`

	// Config A container configuration.
	Config Config `json:"config"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator    CreatorScope `json:"creator"`
	Deployment *Deployment  `json:"deployment"`

	// Deprecate A boolean where true signifies the container is marked as deprecated.
	Deprecate bool `json:"deprecate"`

	// Environment A summary of supplemental environment and network information specific to a container.
	Environment ContainerEnvironmentSummary `json:"environment"`

	// Events A collection of timestamps for each event in the container's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Started DateTime `json:"started"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`

	// Image A summary of the image this container was created from.
	Image ImageSummary `json:"image"`

	// Instances The number of instances for a given container.
	Instances int `json:"instances"`

	// Lock When set to true, prevents this container from being deleted.
	Lock bool `json:"lock"`

	// Meta A list of meta fields that can be applied to a container.
	Meta *ContainersMeta `json:"meta,omitempty"`

	// Name A user defined name for the container resource.
	Name string `json:"name"`

	// Role The role of a given container if it has one.
	Role  *ContainerRole `json:"role"`
	Stack *StackSummary  `json:"stack"`
	State ContainerState `json:"state"`

	// Stateful A boolean where true signifies the container is stateful.
	Stateful bool             `json:"stateful"`
	Volumes  *[]VolumeSummary `json:"volumes,omitempty"`
}

// ContainerRole The role of a given container if it has one.
type ContainerRole string

// ContainerBackup A Container Backup.
type ContainerBackup struct {
	// ContainerId The ID of the given container.
	ContainerId string `json:"container_id"`

	// Events A collection of timestamps for each event in the backup's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// InstanceId The ID of the instance the backup belongs to.
	InstanceId string               `json:"instance_id"`
	State      ContainerBackupState `json:"state"`

	// Target A target for the given Container Backup.
	Target ContainerBackupTarget `json:"target"`
}

// ContainerBackupIncludes All includable resources linkable to the given Zone.
type ContainerBackupIncludes struct {
	// Integrations A resource that is associated with an integration.
	Integrations *IntegrationsIncludes `json:"integrations,omitempty"`
}

// ContainerBackupLogs Backup logs for a given container.
type ContainerBackupLogs struct {
	// BackupId An identifier for the backup.
	BackupId string `json:"backup_id"`

	// ContainerId An identifier for the container.
	ContainerId string `json:"container_id"`
	Error       *struct {
		Message         string  `json:"message"`
		MessageInternal *string `json:"message_internal,omitempty"`
		Stack           *[]struct {
			File     string `json:"file"`
			Function string `json:"function"`
			Line     int    `json:"line"`
		} `json:"stack,omitempty"`
	} `json:"error"`

	// Events A collection of timestamps for each event in the backup log's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// InstanceId An identifier for the instance.
	InstanceId string `json:"instance_id"`

	// Log The log.
	Log string `json:"log"`

	// Type The type of the backup log.
	Type ContainerBackupLogsType `json:"type"`
}

// ContainerBackupLogsType The type of the backup log.
type ContainerBackupLogsType string

// ContainerBackupState defines model for ContainerBackupState.
type ContainerBackupState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the Container Backup.
	Current ContainerBackupStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// ContainerBackupStateCurrent The current state of the Container Backup.
type ContainerBackupStateCurrent string

// ContainerBackupTarget A target for the given Container Backup.
type ContainerBackupTarget struct {
	FileId string `json:"file_id"`

	// IntegrationId Either a resource ID (objectid - i.e. 651586fca6078e98982dbd90) or a resource Identifier (human-readable)
	IntegrationId HybridIdentifier `json:"integration_id"`

	// Path The target for where to store the Container Backup on the destination service.
	Path string `json:"path"`

	// Size The total size of the backup.
	Size int `json:"size"`
}

// ContainerCreateStep Settings for the create container step for a pipeline.
type ContainerCreateStep struct {
	// Action The action that the step takes.
	Action  ContainerCreateStepAction `json:"action"`
	Details struct {
		// Annotations Additional information about a container
		Annotations *map[string]interface{} `json:"annotations"`

		// Config A container configuration.
		Config     Config      `json:"config"`
		Deployment *Deployment `json:"deployment"`

		// Environment An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Environment FluidIdentifier `json:"environment"`
		Identifier  *string         `json:"identifier"`

		// Image An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Image    FluidIdentifier   `json:"image"`
		Name     string            `json:"name"`
		Stateful bool              `json:"stateful"`
		Volumes  []ContainerVolume `json:"volumes"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// ContainerCreateStepAction The action that the step takes.
type ContainerCreateStepAction string

// ContainerDeleteStep Settings for deleting a container in a pipeline
type ContainerDeleteStep struct {
	// Action The action that the step takes.
	Action  ContainerDeleteStepAction `json:"action"`
	Details struct {
		// Container An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Container FluidIdentifier `json:"container"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// ContainerDeleteStepAction The action that the step takes.
type ContainerDeleteStepAction string

// ContainerDeploy Deployment configuration for the given container.
type ContainerDeploy struct {
	// Constraints Settings that give more granular control over deployment targets and conditions.
	Constraints *struct {
		// Node Constraint settings related to which nodes an instance can be deployed to.
		Node *struct {
			// Tags Lists of server tags that formally declair servers that match the criteria for deployment.
			Tags struct {
				// All A list of tags where a server matching all tags from the list is the only scenario where the server is qualified as a deployment target.
				All *[]string `json:"all,omitempty"`

				// Any A list of tags where a server matching any tags from the list is qualified as a deployment target.
				Any *[]string `json:"any,omitempty"`
			} `json:"tags"`
		} `json:"node,omitempty"`
		Secrets *[]string `json:"secrets,omitempty"`
	} `json:"constraints,omitempty"`

	// Function Configuration options for containers using the 'function' deployment strategy.
	Function *struct {
		// MaxPoolSize The maximum number of instances that Cycle can pre-allocate (includes auto-scaled instances).
		MaxPoolSize *int `json:"max_pool_size"`

		// MaxQueueTime The maximum amount of time Cycle will wait for an instance to be available.
		MaxQueueTime *Duration `json:"max_queue_time"`

		// MaxRuntime The maximum amount of time a function instance can run before timing out.
		MaxRuntime *Duration `json:"max_runtime"`

		// MaxShardConcurrency For each shard (scheduler), the maximum number of tasks it can run in parallel.
		MaxShardConcurrency *int `json:"max_shard_concurrency"`
	} `json:"function"`

	// HealthCheck Configuration for determining the health of a container.
	HealthCheck *struct {
		// Command The command that will be run to verify the health of the container.
		Command string `json:"command"`

		// Delay How long to wait before performing an initial health check when the instance starts. The `state.health.healthy` field of the instance will be `null`` until the first check is performed.
		Delay *Duration `json:"delay"`

		// Interval A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		Interval Duration `json:"interval"`

		// Restart A boolean where `true` represents the desire for a container to restart if unhealthy.
		Restart bool `json:"restart"`

		// Retries The number of times the platform will retry the command before marking the container unhealthy.
		Retries int `json:"retries"`

		// Timeout A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		Timeout Duration `json:"timeout"`
	} `json:"health_check,omitempty"`

	// Instances The number of initial desired instances for a given container.
	Instances int `json:"instances"`

	// Restart Configurations for container restart events.
	Restart *struct {
		// Condition Policy for what should happen in the event of a container dying.
		Condition ContainerDeployRestartCondition `json:"condition"`

		// Delay A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		Delay Duration `json:"delay"`

		// MaxAttempts The amount of times the platform will attempt the restart policies.
		MaxAttempts int `json:"max_attempts"`
	} `json:"restart,omitempty"`

	// Shutdown Configuration for what to do during container shutdown.
	Shutdown *struct {
		// GracefulTimeout How long the platform will wait for a container to stop gracefully.
		GracefulTimeout *Duration `json:"graceful_timeout"`

		// Signals Process signal sent to the container process.
		Signals *[]ShutdownSignal `json:"signals"`
	} `json:"shutdown,omitempty"`

	// Startup Configurations for container startup.
	Startup *struct {
		// Delay A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		Delay *Duration `json:"delay,omitempty"`
	} `json:"startup,omitempty"`
	Stateful *struct {
		Options *struct {
			UseBaseHostname *bool `json:"use_base_hostname"`
		} `json:"options"`
	} `json:"stateful,omitempty"`
	Strategy *DeploymentStrategyName `json:"strategy,omitempty"`

	// Telemetry Configuration settings for container telemetery reporting.
	Telemetry *struct {
		// Disable A boolean where true disables all telemetry reporting for this container.
		Disable bool `json:"disable"`

		// Interval A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		Interval Duration `json:"interval"`

		// Retention A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		Retention Duration `json:"retention"`
	} `json:"telemetry,omitempty"`

	// Update Configurations for container updates.
	Update *struct {
		// Stagger A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		Stagger *Duration `json:"stagger,omitempty"`
	} `json:"update,omitempty"`
}

// ContainerDeployRestartCondition Policy for what should happen in the event of a container dying.
type ContainerDeployRestartCondition string

// ContainerEnvironmentSummary A summary of supplemental environment and network information specific to a container.
type ContainerEnvironmentSummary struct {
	// Cluster The cluster this environment is associated with.
	Cluster string `json:"cluster"`

	// ContainerSubnet The private network subnet ID for this container and its instances.
	ContainerSubnet *string `json:"container_subnet"`

	// Id A 24 character hex string used to identify a unique resource.
	Id     ID             `json:"id"`
	Ipv6   *IPNet         `json:"ipv6"`
	Legacy *LegacyNetwork `json:"legacy"`
}

// ContainerExtension Reference to container functionality that is added by the Cycle platform.
type ContainerExtension struct {
	// Id A 24 character hex string used to identify a unique resource.
	Id         *ID                          `json:"id,omitempty"`
	Identifier ContainerExtensionIdentifier `json:"identifier"`
}

// ContainerExtensionIdentifier defines model for ContainerExtension.Identifier.
type ContainerExtensionIdentifier string

// ContainerFunctionTriggerStep Settings for triggering a function in a pipeline.
type ContainerFunctionTriggerStep struct {
	// Action The action that the step takes.
	Action  ContainerFunctionTriggerStepAction `json:"action"`
	Details struct {
		// Container An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Container FluidIdentifier `json:"container"`

		// RuntimeVariables Variables that affect the runtime of a function container.
		RuntimeVariables FunctionRuntimeVariables `json:"runtime_variables"`

		// Token A custom token used for identifying and managing a claim. Can be any valid string.
		Token *VariableString `json:"token"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// ContainerFunctionTriggerStepAction The action that the step takes.
type ContainerFunctionTriggerStepAction string

// ContainerImageSummary The Id of the image and information on if it is a service.
type ContainerImageSummary struct {
	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Service If this image is a service container this will say either `discovery` | `loadbalancer` | `vpn`.
	Service ContainerImageSummaryService `json:"service"`
}

// ContainerImageSummaryService If this image is a service container this will say either `discovery` | `loadbalancer` | `vpn`.
type ContainerImageSummaryService string

// ContainerIncludes All includable resources linkable to the given container.
type ContainerIncludes struct {
	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`

	// Environments An identity that is associated with an environment.
	Environments *EnvironmentIncludes `json:"environments,omitempty"`

	// EnvironmentsIdentifiers A map of identifiers to an array of resource IDs that are associated with it. All IDs point to the same type of resource.
	EnvironmentsIdentifiers *IdentifierIncludes `json:"environments:identifiers,omitempty"`

	// Images A resource associated with an image.
	Images *ImagesIncludes `json:"images,omitempty"`

	// StackBuilds A resource that is associated with a stack build.
	StackBuilds *StackBuildIncludes `json:"stack_builds,omitempty"`

	// Stacks A resource associated with a stack.
	Stacks *StackIncludes `json:"stacks,omitempty"`

	// StacksIdentifiers A map of identifiers to an array of resource IDs that are associated with it. All IDs point to the same type of resource.
	StacksIdentifiers *IdentifierIncludes `json:"stacks:identifiers,omitempty"`
}

// ContainerIntegrations Configuration settings for integrations with a given container.
type ContainerIntegrations struct {
	// Backups Automated backups configuration for the given container.
	Backups *struct {
		// Backup Configuration settings for each backup.
		Backup struct {
			// Command The command to run for the backup.
			Command string `json:"command"`

			// CronString A cron string that configures how often the backup will run.
			CronString *string `json:"cron_string,omitempty"`

			// Timeout How long the backup will attempt to run before timing out.
			Timeout *Duration `json:"timeout"`
		} `json:"backup"`

		// IntegrationId Either a resource ID (objectid - i.e. 651586fca6078e98982dbd90) or a resource Identifier (human-readable)
		IntegrationId *HybridIdentifier `json:"integration_id,omitempty"`

		// Restore Configuration settings for restoring from a backup.
		Restore *struct {
			// Command The command to run for restoring from a backup.
			Command string `json:"command"`

			// Timeout The time in seconds for the restore to attempt to complete before timing out.
			Timeout *Duration `json:"timeout,omitempty"`
		} `json:"restore"`

		// Retention How long the platform will keep backups. Default is 1 year.
		Retention *Duration `json:"retention"`
	} `json:"backups,omitempty"`

	// Files Inject remotely hosted files into container instances at runtime.
	Files *[]struct {
		// Destination The path in the container for these files to be injected.
		Destination string `json:"destination"`

		// Source The http endpoint that is hosting the files to be used.
		Source string `json:"source"`
	} `json:"files,omitempty"`

	// LetsEncrypt Configuration settings to embed a TLS certificate in the container.
	LetsEncrypt *struct {
		// AdditionalCertsPath File path where any remaining certificate files will be stored.
		AdditionalCertsPath *string `json:"additional_certs_path,omitempty"`

		// BundlePath Path where the `certificate.bundle` will be saved.
		BundlePath *string `json:"bundle_path,omitempty"`

		// CertificatePath Path where the `certificate.cert` will be saved.
		CertificatePath *string `json:"certificate_path,omitempty"`

		// ChainPath Path where the `certificate.chain` will be saved.
		ChainPath *string `json:"chain_path,omitempty"`

		// KeyPath Path where the `certificate.key` will be saved.
		KeyPath *string `json:"key_path,omitempty"`
	} `json:"lets_encrypt"`
	SharedFileSystems *map[string]struct {
		MountPoint string `json:"mount_point"`
		Writable   bool   `json:"writable"`
	} `json:"shared_file_systems"`

	// Webhooks Webhooks that can be set for specific event reporting and advanced container configurations.
	Webhooks *struct {
		// Config An endpoint that the platform will react out to with a get request.  This endpoint serves a partial container config which can modify `runtime`, `resources`, and `integrations` configurations.
		Config *string `json:"config,omitempty"`

		// Events Container events that can be configured to report to a webhook.
		Events *struct {
			// Deploy A webhook to hit when a container deploy event happens.
			Deploy *string `json:"deploy,omitempty"`

			// Start A webhook to hit when a container start event happens.
			Start *string `json:"start,omitempty"`

			// Stop A webhook to hit when a container stop event happens.
			Stop *string `json:"stop,omitempty"`
		} `json:"events,omitempty"`
	} `json:"webhooks,omitempty"`
}

// ContainerNetwork Network configuration for a container.
type ContainerNetwork struct {
	// Hostname The hostname for the given container.
	Hostname string `json:"hostname"`

	// L2 Layer 2 network configuration options for containers running on virtual provider servers.
	L2 *map[string]interface{} `json:"l2,omitempty"`

	// Ports An array of port mappings for the container.
	Ports *[]string `json:"ports,omitempty"`

	// Public The public network settings for the given container
	Public ContainerNetworkPublic `json:"public"`
}

// ContainerNetworkPublic The public network settings for the given container
type ContainerNetworkPublic string

// ContainerReconfigureAction defines model for ContainerReconfigureAction.
type ContainerReconfigureAction struct {
	// Action The action to take.
	Action ContainerReconfigureActionAction `json:"action"`

	// Contents A container configuration.
	Contents Config `json:"contents"`
}

// ContainerReconfigureActionAction The action to take.
type ContainerReconfigureActionAction string

// ContainerReconfigureVolumesAction defines model for ContainerReconfigureVolumesAction.
type ContainerReconfigureVolumesAction struct {
	// Action The action to take.
	Action ContainerReconfigureVolumesActionAction `json:"action"`

	// Contents A map of volume objects where the key is the id and the value is the volume's config.
	Contents map[string]ContainerVolume `json:"contents"`
}

// ContainerReconfigureVolumesActionAction The action to take.
type ContainerReconfigureVolumesActionAction string

// ContainerReimageAction defines model for ContainerReimageAction.
type ContainerReimageAction struct {
	// Action The action to take.
	Action ContainerReimageActionAction `json:"action"`

	// Contents Additional information needed to complete the job.
	Contents struct {
		// AllowIncompatible A boolean where true signifies the image being used to reimage does not have to have compatibility with the image being replaced.
		AllowIncompatible *bool `json:"allow_incompatible,omitempty"`

		// ImageId The ID of the image to use when reimaging.
		ImageId string `json:"image_id"`

		// OverwriteRuntimeConfig A boolean where true signifies the user wishes to overwrite the current runtime configuration for the given container during the reimage process.
		OverwriteRuntimeConfig *bool `json:"overwrite_runtime_config,omitempty"`
	} `json:"contents"`
}

// ContainerReimageActionAction The action to take.
type ContainerReimageActionAction string

// ContainerReimageStep Settings for reimaging a container in a pipeline
type ContainerReimageStep struct {
	// Action The action that the step takes.
	Action  ContainerReimageStepAction `json:"action"`
	Details struct {
		// Container An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Container FluidIdentifier `json:"container"`

		// Image An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Image   FluidIdentifier `json:"image"`
		Options *struct {
			// AllowIncompatible A boolean where true signifies the image being used to reimage does not have to have compatibility with the image being replaced.
			AllowIncompatible bool `json:"allow_incompatible"`

			// OverwriteRuntimeConfig A boolean where true signifies the user wishes to overwrite the current runtime configuration for the given container during the reimage process.
			OverwriteRuntimeConfig bool `json:"overwrite_runtime_config"`
		} `json:"options,omitempty"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// ContainerReimageStepAction The action that the step takes.
type ContainerReimageStepAction string

// ContainerResources Configuration settings for the resource allocations and limits of a given container.
type ContainerResources struct {
	// Cpu Configurations settings related to CPU usage.
	Cpu struct {
		Cpus *string `json:"cpus,omitempty"`

		// Shares A share represents 1/10th of the available compute time on a single thread.
		Shares *struct {
			// Limit The limit (maximum) amount of shares each instance of a container can use.
			Limit int `json:"limit"`

			// Reserve The reserve (allocation) number of shares for each instance of a given container.
			Reserve int `json:"reserve"`
		} `json:"shares,omitempty"`
	} `json:"cpu"`

	// Ram Configuration settings for limits and reserves of RAM resources for the given container.
	Ram struct {
		// Limit The limit (maximum) amount of RAM each instance of the given container can use.
		Limit *string `json:"limit,omitempty"`

		// Reserve The reserve (allocation) of RAM given to each instance of the container.
		Reserve *string `json:"reserve,omitempty"`
	} `json:"ram"`
}

// ContainerRestartAction defines model for ContainerRestartAction.
type ContainerRestartAction struct {
	// Action The name of the action to perform.
	Action ContainerRestartActionAction `json:"action"`
}

// ContainerRestartActionAction The name of the action to perform.
type ContainerRestartActionAction string

// ContainerRestartStep Settings for restarting a container in a pipeline
type ContainerRestartStep struct {
	// Action The action that the step takes.
	Action  ContainerRestartStepAction `json:"action"`
	Details struct {
		// Container An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Container FluidIdentifier `json:"container"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// ContainerRestartStepAction The action that the step takes.
type ContainerRestartStepAction string

// ContainerRuntime Runtime configurations for a given container.
type ContainerRuntime struct {
	// Capabilities A list of linux kernel capabilites for the given container.
	Capabilities *[]ContainerRuntimeCapabilities `json:"capabilities,omitempty"`

	// Command A command that will be run in place of the images defined startup command.
	Command *struct {
		// Args Arguments to pass to the command.
		Args *string `json:"args"`

		// Path System path for the command.
		Path *string `json:"path"`
	} `json:"command"`
	Devices *struct {
		// Expose An array of devices to expose to the container.
		Expose *[]RuntimeExposedDevice `json:"expose,omitempty"`

		// Permissions Rules for granting or denying access to a device node.
		Permissions *[]RuntimeDevicePermission `json:"permissions,omitempty"`

		// ShmSize The size of the shared host memory device (/dev/shm).
		ShmSize *string `json:"shm_size"`
	} `json:"devices"`

	// EnvironmentVars A record of environment variables for the given container.
	EnvironmentVars *map[string]string `json:"environment_vars,omitempty"`
	Host            *struct {
		// ExposeCgroups If true, Cycle will mount the host's `/sys/fs/cgroups` directory into the container at `/var/run/cycle/host/cgroups`.
		ExposeCgroups *bool `json:"expose_cgroups"`

		// ExposeProc If true, Cycle will mount the `/proc` directory into the container, giving it access to the host metrics. This is useful if you're running i.e. a monitoring agent.
		ExposeProc *bool `json:"expose_proc"`

		// PowerManagement If true, Cycle will give the container instances access via internal api to power off or reboot the host server.
		PowerManagement *bool `json:"power_management"`
	} `json:"host"`

	// Namespaces Namespaces the given container will have access to.
	Namespaces *[]ContainerRuntimeNamespaces `json:"namespaces,omitempty"`

	// Privileged Selecting this option will give this container full permissions on the server. This is not recommended and increases the likelihood of your server being compromised.
	Privileged bool `json:"privileged"`

	// Rlimits A record of rlimits and their values.
	Rlimits *map[string]struct {
		// Hard The hard limit for the rlimit.
		Hard *int `json:"hard,omitempty"`

		// Soft The soft limit for the rlimit.
		Soft *int `json:"soft,omitempty"`
	} `json:"rlimits,omitempty"`
	Rootfs *struct {
		// Readonly Enabling this option will set the containers filesystem to readonly. Volumes associated with the container will not be affected by this.
		Readonly *bool `json:"readonly,omitempty"`
	} `json:"rootfs,omitempty"`
	Seccomp *struct {
		Disable *bool          `json:"disable,omitempty"`
		Rules   *[]SeccompRule `json:"rules,omitempty"`
	} `json:"seccomp"`

	// Sysctl A record of sysctl fields and values for a given container.
	Sysctl *map[string]string `json:"sysctl,omitempty"`

	// Workdir Configure the working directory for the given container.
	Workdir *string `json:"workdir,omitempty"`
}

// ContainerRuntimeCapabilities defines model for ContainerRuntime.Capabilities.
type ContainerRuntimeCapabilities string

// ContainerRuntimeNamespaces defines model for ContainerRuntime.Namespaces.
type ContainerRuntimeNamespaces string

// ContainerScale Network configuration for a container.
type ContainerScale struct {
	// AutoscaleGroup The autoscaling group describes which servers should be deployed
	AutoscaleGroup *string `json:"autoscale_group"`

	// Instances Describes how many instances should be running
	Instances struct {
		// Max Maximum additional instances the auto-scaler will run at any time
		Max int `json:"max"`

		// MaxServer Minimum number of instances per server
		MaxServer int `json:"max_server"`

		// MinTtl A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		MinTtl Duration `json:"min_ttl"`
	} `json:"instances"`

	// Thresholds An array of rules that dictate when a scaling event will be triggered
	Thresholds []ScaleThresholdMetric `json:"thresholds"`

	// Window A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
	Window Duration `json:"window"`
}

// ContainerScaleAction defines model for ContainerScaleAction.
type ContainerScaleAction struct {
	// Action The action to take.
	Action ContainerScaleActionAction `json:"action"`

	// Contents Additional information needed to complete the job.
	Contents struct {
		// Instances The number of desired instances to scale to.
		Instances int `json:"instances"`
	} `json:"contents"`
}

// ContainerScaleActionAction The action to take.
type ContainerScaleActionAction string

// ContainerStartAction defines model for ContainerStartAction.
type ContainerStartAction struct {
	// Action The name of the action to perform.
	Action ContainerStartActionAction `json:"action"`
}

// ContainerStartActionAction The name of the action to perform.
type ContainerStartActionAction string

// ContainerStartStep Settings for starting a container in a pipeline
type ContainerStartStep struct {
	// Action The action that the step takes.
	Action  ContainerStartStepAction `json:"action"`
	Details struct {
		// Container An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Container FluidIdentifier `json:"container"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// ContainerStartStepAction The action that the step takes.
type ContainerStartStepAction string

// ContainerState defines model for ContainerState.
type ContainerState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the container.
	Current ContainerStateCurrent `json:"current"`

	// Desired The desired state of the container.
	Desired *ContainerStateDesired `json:"desired,omitempty"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// ContainerStateCurrent The current state of the container.
type ContainerStateCurrent string

// ContainerStateDesired The desired state of the container.
type ContainerStateDesired string

// ContainerStopAction defines model for ContainerStopAction.
type ContainerStopAction struct {
	// Action The name of the action to perform.
	Action ContainerStopActionAction `json:"action"`
}

// ContainerStopActionAction The name of the action to perform.
type ContainerStopActionAction string

// ContainerStopStep Settings for stopping a container in a pipeline
type ContainerStopStep struct {
	// Action The action that the step takes.
	Action  ContainerStopStepAction `json:"action"`
	Details struct {
		// Container An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Container FluidIdentifier `json:"container"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// ContainerStopStepAction The action that the step takes.
type ContainerStopStepAction string

// ContainerSummary Lightweight summary of a container for environment pages and lists.
type ContainerSummary struct {
	// Environment A summary of supplemental environment and network information specific to a container.
	Environment ContainerEnvironmentSummary `json:"environment"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Image A summary of the image this container was created from.
	Image ImageSummary `json:"image"`

	// Name A user defined name for the container.
	Name    string          `json:"name"`
	State   ContainerState  `json:"state"`
	Volumes []VolumeSummary `json:"volumes"`
}

// ContainerTask defines model for ContainerTask.
type ContainerTask struct {
	union json.RawMessage
}

// ContainerVolume Configuration settings for container volumes.
type ContainerVolume struct {
	// BlockDevice Indicates that the volume will be used as unformatted block storage.
	BlockDevice bool `json:"block_device"`

	// Destination The mountpoint path for the container.
	Destination string `json:"destination"`
	External    *struct {
		// Id A 24 character hex string used to identify a unique resource.
		Id *ID `json:"id,omitempty"`
	} `json:"external,omitempty"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Local Configuration for settings local to the container filesystem.
	Local *struct {
		// MaxSize A human-readable data size string. Values are expressed as an integer followed by a unit suffix, without spaces. Supported units:
		//   - b, k, m, g, t, p (bytes, kilobytes, megabytes, gigabytes, terabytes, petabytes)
		//   - An optional "b" suffix may be added (e.g., "mb", "gb").
		// Units are case-insensitive. Example: "512M", "10GB", "1t".
		MaxSize DataSize `json:"max_size"`

		// StoragePool A boolean where true signifies using the largest drive over 2TB for the target server.
		StoragePool *bool `json:"storage_pool"`
	} `json:"local"`

	// ReadOnly A boolean where true marks the volume as read only.
	ReadOnly bool `json:"read_only"`

	// RemoteAccess Configuration settings for remotely accessing the container volume.
	RemoteAccess *struct {
		// Enable A boolean where true represents this container volume being open to remote access connections over SFTP.
		Enable bool      `json:"enable"`
		Ips    *[]string `json:"ips,omitempty"`

		// Password Password configuration settings for the remote access of the container volume.
		Password *struct {
			// Algorithm The hashing algorithm used to has the password.
			Algorithm ContainerVolumeRemoteAccessPasswordAlgorithm `json:"algorithm"`

			// Data The raw or hashed password.
			Data string `json:"data"`
		} `json:"password"`

		// Webhook Call out to a webhook to authenticate usernames/passwords if an organization manages their own accounts
		Webhook *string `json:"webhook,omitempty"`
	} `json:"remote_access,omitempty"`
}

// ContainerVolumeRemoteAccessPasswordAlgorithm The hashing algorithm used to has the password.
type ContainerVolumeRemoteAccessPasswordAlgorithm string

// ContainersIncludes A resource that is associated with a container.
type ContainersIncludes map[string]Container

// ContainersMeta A list of meta fields that can be applied to a container.
type ContainersMeta struct {
	Domains *[]struct {
		// Fqdn The fully qualified domain name.
		Fqdn string `json:"fqdn"`

		// Record A DNS record.
		Record *DnsRecord `json:"record,omitempty"`
	} `json:"domains"`

	// InstancesCount A summary of resources by state
	InstancesCount *StateCountSummary `json:"instances_count,omitempty"`

	// Ips An array of IP resources.
	Ips *[]Ip `json:"ips,omitempty"`
}

// Context ID context for resources associated with an activity.
type Context struct {
	// Cluster The identifier of a specific cluster.
	Cluster *string `json:"cluster,omitempty"`

	// ContainerId An ID for the given resource.
	ContainerId *string `json:"container_id,omitempty"`

	// DnsZoneId An ID for the given resource.
	DnsZoneId *string `json:"dns_zone_id,omitempty"`

	// EnvironmentId An ID for the given resource.
	EnvironmentId *string `json:"environment_id,omitempty"`

	// InstanceId An ID for the given resource.
	InstanceId *string `json:"instance_id,omitempty"`

	// ServerId An ID for the given resource.
	ServerId *string `json:"server_id,omitempty"`

	// StackId An ID for the given resource.
	StackId *string `json:"stack_id,omitempty"`

	// VirtualMachineId A virtual machine ID.
	VirtualMachineId *string `json:"virtual_machine_id,omitempty"`
}

// CreatorInclude An identity that created a resource.
type CreatorInclude struct {
	// Accounts Included creators that are public accounts, keyed by ID.
	Accounts *map[string]PublicAccount `json:"accounts,omitempty"`

	// ApiKeys Included creators that are Cycle API Keys, keyed by ID.
	ApiKeys *map[string]ApiKeyCreator `json:"api_keys,omitempty"`

	// Employees Included creators that are employees of Cycle, keyed by ID.
	Employees *map[string]PublicAccount `json:"employees,omitempty"`

	// Environments Included creators that are Cycle environments (usually automatically created resources), keyed by ID.
	Environments *map[string]Environment `json:"environments,omitempty"`

	// Visitors Included creators that are not Cycle accounts, keyed by ID.
	Visitors *map[string]PublicAccount `json:"visitors,omitempty"`
}

// CreatorScope The creator scope is embedded in resource objects to describe who created them
type CreatorScope struct {
	// Id A 24 character hex string used to identify a unique resource.
	Id   ID               `json:"id"`
	Type CreatorScopeType `json:"type"`
}

// CreatorScopeType defines model for CreatorScope.Type.
type CreatorScopeType string

// CredentialsHTTP defines model for CredentialsHTTP.
type CredentialsHTTP struct {
	// Credentials Authentication credentails for the Dockerfile image source type when authenticating over HTTP.
	Credentials struct {
		// Password For authentication, the password.
		Password string `json:"password"`

		// Username For authentication, the username.
		Username string `json:"username"`
	} `json:"credentials"`
	Type CredentialsHTTPType `json:"type"`
}

// CredentialsHTTPType defines model for CredentialsHTTP.Type.
type CredentialsHTTPType string

// CredentialsSSH defines model for CredentialsSSH.
type CredentialsSSH struct {
	// Credentials Authentication credentials for the Dockerfile image source type when authenticating with SSH.
	Credentials struct {
		// Passphrase The passphrase used for the key.
		Passphrase string `json:"passphrase"`

		// PrivateKey A pem encoded private key.
		PrivateKey string `json:"private_key"`

		// Username The username for the repo service, that is used to authenticate an ssh key.
		Username string `json:"username"`
	} `json:"credentials"`
	Type CredentialsSSHType `json:"type"`
}

// CredentialsSSHType defines model for CredentialsSSH.Type.
type CredentialsSSHType string

// Credit Information about a billing credit.
type Credit struct {
	// AccountId The account the credit was issued to.
	AccountId string `json:"account_id"`

	// Amount The amount of credit.
	Amount int `json:"amount"`

	// AmountRemaining The amount of the credit that remains after being applied to invoices.
	AmountRemaining int `json:"amount_remaining"`

	// Description Some extra information about the billing credit.
	Description string `json:"description"`

	// Events A collection of timestamps for each event in the billing order's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// Expires Information on when the billing credit expires.
	Expires *struct {
		Date *DateTime `json:"date,omitempty"`
	} `json:"expires"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id    ID `json:"id"`
	State struct {
		Changed DateTime `json:"changed"`

		// Current The current state of the credit.
		Current CreditStateCurrent `json:"current"`

		// Error An error, if any, that has occurred for this resource.
		Error *struct {
			// Message Details about the error that has occurred.
			Message *string   `json:"message,omitempty"`
			Time    *DateTime `json:"time,omitempty"`
		} `json:"error,omitempty"`
	} `json:"state"`
}

// CreditStateCurrent The current state of the credit.
type CreditStateCurrent string

// CycleSourceOrigin An image origin that references an image source on Cycle.
//
// This origin will never be embedded in an image source. It is for use in stacks, describing an image which is already a part of an image source on Cycle.
type CycleSourceOrigin struct {
	Details struct {
		// SourceId A 24 character hex string used to identify a unique resource.
		SourceId ID `json:"source_id"`
	} `json:"details"`
	Type CycleSourceOriginType `json:"type"`
}

// CycleSourceOriginType defines model for CycleSourceOrigin.Type.
type CycleSourceOriginType string

// CycleUploadOrigin An image origin where the image is pushed directly to the factory, bypassing the need for a registry or external source.
//
// In order to utilize this image origin type, a tar file of an OCI compliant image will need to be generated and pushed directly to the factory. The authentication token is generated when this image is created, and expires at the provided time.
// Once you have a token, it can be uploaded as multipart form data under the key `file.tar`, directly to the factory at `https://factory.cycle.io:9414/v1/images/<IMAGE ID>/upload?hub-id=<HUB ID>&token=<TOKEN>`.
type CycleUploadOrigin struct {
	Details struct {
		Expires DateTime `json:"expires"`

		// Token The token that is required by the factory to accept an upload for this image.
		Token string `json:"token"`
	} `json:"details"`
	Type CycleUploadOriginType `json:"type"`
}

// CycleUploadOriginType defines model for CycleUploadOrigin.Type.
type CycleUploadOriginType string

// DataSize A human-readable data size string. Values are expressed as an integer followed by a unit suffix, without spaces. Supported units:
//   - b, k, m, g, t, p (bytes, kilobytes, megabytes, gigabytes, terabytes, petabytes)
//   - An optional "b" suffix may be added (e.g., "mb", "gb").
//
// Units are case-insensitive. Example: "512M", "10GB", "1t".
type DataSize = string

// DateTime defines model for DateTime.
type DateTime = time.Time

// DefaultLbType defines model for DefaultLbType.
type DefaultLbType struct {
	Details V1LbConfig `json:"details"`

	// Ipv4 Allow / disallow traffic to be routed via IPv4.
	Ipv4 bool `json:"ipv4"`

	// Ipv6 Allow / disallow traffic to be routed via IPv6.
	Ipv6 bool              `json:"ipv6"`
	Type DefaultLbTypeType `json:"type"`
}

// DefaultLbTypeType defines model for DefaultLbType.Type.
type DefaultLbTypeType string

// DeployedVolume A deployed volume resource.
type DeployedVolume struct {
	// ContainerId The ID of the container the instance was created from.
	ContainerId string `json:"container_id"`

	// ContainerVolumeId The ID for the volume withing the context of the container.
	ContainerVolumeId string `json:"container_volume_id"`

	// Hash A hash used as part of the identification mechanisms for the platform and API.
	Hash string `json:"hash"`

	// Id The ID of the deployed volume.
	Id string `json:"id"`

	// InstanceId The ID for the container instance this volume is attached to.
	InstanceId string `json:"instance_id"`

	// Path The path where the volume is mounted on the instnace filesystem.
	Path string `json:"path"`

	// ServerId The ID of the server the instance is deployed to.
	ServerId string `json:"server_id"`

	// Storage Storage information for the volume.
	Storage struct {
		// Total The total amount of volume storage available, in MB's.
		Total int `json:"total"`

		// Used The amount of volume storage used, in MB's
		Used int `json:"used"`
	} `json:"storage"`
}

// Deployment A logical grouping of containers inside of an Environment. Facilitates zero-downtime deployments by separating multiple versions of the same application within an environment.
//
// If a container is a member of a deployment, it can only resolve containers in that same deployment, or containers NOT in a deployment. If a container is NOT a member of a deployment, it can resolve all containers in the environment.
type Deployment struct {
	// Version Version can be any string, but if it begins with a "v", semantic version will be enforced. A [Semantic Version](https://semver.org/) string. Follows the format vMAJOR.MINOR.PATCH-build.
	Version Version `json:"version"`
}

// DeploymentStrategy Information about supported container deployment strategies.
type DeploymentStrategy struct {
	// Description A description for the deployment strategy.
	Description string `json:"description"`

	// Disabled A boolean where true signifies a strategy is either not yet or no longer available.
	Disabled bool `json:"disabled"`

	// Name The human-friendly name of the deployment strategy.
	Name string `json:"name"`
}

// DeploymentStrategyName defines model for DeploymentStrategyName.
type DeploymentStrategyName string

// Detail Details about a given event that is part of an activity.
type Detail struct {
	// Boolean A boolean describing if a resource exists or not.
	Boolean *string `json:"boolean,omitempty"`

	// Id A 24 character hex string used to identify a unique resource.
	Id *ID `json:"id,omitempty"`

	// Number A number describing the amount of the resource that exists.
	Number *int `json:"number,omitempty"`

	// String Additional information.
	String *string `json:"string,omitempty"`
}

// DirectImageSourceType defines model for DirectImageSourceType.
type DirectImageSourceType struct {
	Details struct {
		Id string `json:"id"`

		// Origin The origin of the image.
		Origin ImageOrigin `json:"origin"`
	} `json:"details"`
	Override *struct {
		Target   *string `json:"target,omitempty"`
		TargzUrl *string `json:"targz_url,omitempty"`
	} `json:"override,omitempty"`
	Type DirectImageSourceTypeType `json:"type"`
}

// DirectImageSourceTypeType defines model for DirectImageSourceType.Type.
type DirectImageSourceTypeType string

// DirectPayment A payment method that must be enabled by Cycle staff, solely for telling us they're going to send us checks, wires, ach, outside of Cycle.
type DirectPayment struct {
	Details struct {
		// Instructions Any additional instructions for an organization's billing dept., etc. that should be known about this payment method.
		Instructions string `json:"instructions"`

		// Preference The preference for how the payment will be sent.
		Preference DirectPaymentDetailsPreference `json:"preference"`
	} `json:"details"`
	Type DirectPaymentType `json:"type"`
}

// DirectPaymentDetailsPreference The preference for how the payment will be sent.
type DirectPaymentDetailsPreference string

// DirectPaymentType defines model for DirectPayment.Type.
type DirectPaymentType string

// DiscoveryConfig The config object for the discovery service.
type DiscoveryConfig struct {
	// CustomResolvers A list of custom DNS resolver strings.  Can specifify domains or ips.
	CustomResolvers *[]string `json:"custom_resolvers"`

	// DualStackLegacy When enabled, discovery will return both IPv6 and IPv4 when in legacy mode.  Otherwise, only IPv4 will be returned.
	DualStackLegacy *bool     `json:"dual_stack_legacy,omitempty"`
	EmptySetDelay   *Duration `json:"empty_set_delay"`

	// Hosts A mapping of hostnames to IP addresses for custom internal resolutions. Acts as a custom /etc/resolv.conf file that works environment wide.
	Hosts *map[string]struct {
		// Ipv4 The IPv4 address the discovery server should return to any container instance requesting this hostname.
		Ipv4 *[]string `json:"ipv4"`

		// Ipv6 The IPv6 address the discovery server should return to any container instance requesting this hostname.
		Ipv6 *[]string `json:"ipv6"`
	} `json:"hosts"`
}

// DiscoveryEnvironmentService Information about the environments discovery service(s).
type DiscoveryEnvironmentService struct {
	// AutoUpdate A boolean where `true` represents the desire to automatically update the environment discovery service.
	AutoUpdate *bool `json:"auto_update,omitempty"`

	// Config The config object for the discovery service.
	Config *DiscoveryConfig `json:"config"`

	// ContainerId The ID of the discovery service container
	ContainerId string `json:"container_id"`

	// Enable Whether or not the discovery service is enabled.
	Enable bool `json:"enable"`

	// HighAvailability A boolean representing if this service container is set to high availability mode or not.
	HighAvailability bool `json:"high_availability"`
}

// DnsRecord A DNS record.
type DnsRecord struct {
	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events Describes the date and time at which certain events occurred in the lifetime of this resource.
	Events Events `json:"events"`

	// Features TLS features for the record.
	Features *struct {
		Certificate *DnsRecordTlsCertificate `json:"certificate"`
	} `json:"features"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Name A name used for the record, where `@` signifies the use of the root domain.
	Name string `json:"name"`

	// ResolvedDomain The name of the record and the origin as a domain name.
	ResolvedDomain string         `json:"resolved_domain"`
	State          DnsRecordState `json:"state"`

	// Type DNS record types the platform supports.
	Type DnsRecordTypes `json:"type"`

	// ZoneId A unique identifier for the zone
	ZoneId string `json:"zone_id"`
}

// DnsRecordState defines model for DnsRecordState.
type DnsRecordState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the record.
	Current DnsRecordStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// DnsRecordStateCurrent The current state of the record.
type DnsRecordStateCurrent string

// DnsRecordTlsCertificate A TLS certificate assigned to a DNS record.
type DnsRecordTlsCertificate struct {
	Expires   *DateTime `json:"expires,omitempty"`
	Generated DateTime  `json:"generated"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// UserSupplied If true, this certificate was manually supplied, and was not auto-generated by the platform.
	UserSupplied bool `json:"user_supplied"`

	// WildcardChild A value where true represents that the certificate is using a shared wildcard cert.
	WildcardChild bool `json:"wildcard_child"`
}

// DnsRecordTypes DNS record types the platform supports.
type DnsRecordTypes struct {
	// A A DNS A record
	A *struct {
		// Ip The IPv4 address that the A record should map to.
		Ip string `json:"ip"`
	} `json:"a,omitempty"`

	// Aaaa A DNS AAAA record
	Aaaa *struct {
		// Ip The IPv6 address that the AAAA record should map to.
		Ip string `json:"ip"`
	} `json:"aaaa,omitempty"`

	// Alias A DNS ALIAS record.
	Alias *struct {
		// Domain The domain string returned from the DNS server when this alias record is requested.
		Domain string `json:"domain"`
	} `json:"alias,omitempty"`

	// Caa A DNS CAA record.
	Caa *struct {
		// Tag The ASCII string that represents the identifier of the property represented by the record.
		Tag string `json:"tag"`

		// Value The value associated with the tag.
		Value string `json:"value"`
	} `json:"caa,omitempty"`

	// Cname A DNS CNAME record
	Cname *struct {
		// Domain The domain string the record resolves to.
		Domain string `json:"domain"`
	} `json:"cname,omitempty"`

	// Linked A LINKED record is a record special to Cycle.  It represents a URL that points to a specific container or deployment of a container, however the IP address mapping in handled automatically by the platform.
	Linked *struct {
		// Features Features associated with this record.
		Features struct {
			// Geodns Options for the GeoDNS LINKED record feature.
			Geodns struct {
				// Enable If enabled, Cycle will attempt to match inbound requests to the closest load balancer geographically.
				Enable bool `json:"enable"`
			} `json:"geodns"`

			// Tls TLS properties of the record.
			Tls struct {
				// Enable A boolean, where true represents this record will be paired with a TLS certificate automatically maintained by the platform.
				Enable bool `json:"enable"`
			} `json:"tls"`
			Wildcard *struct {
				// ResolveSubDomains If enabled, subdomains will resolve for wildcard records. If disabled, only the primary domain will resolve.
				ResolveSubDomains bool `json:"resolve_sub_domains"`
			} `json:"wildcard"`
		} `json:"features"`
	} `json:"linked,omitempty"`

	// Mx A DNS MX record
	Mx *struct {
		// Domain The domain this mx record points to.
		Domain string `json:"domain"`

		// Priority The priority setting for this mx record.
		Priority int `json:"priority"`
	} `json:"mx,omitempty"`

	// Ns A DNS NS record
	Ns *struct {
		// Domain The domain of the nameserver for this record.
		Domain string `json:"domain"`
	} `json:"ns,omitempty"`

	// Srv A DNS SRV record.
	Srv *struct {
		// Domain The domain for the record.
		Domain string `json:"domain"`

		// Port The port number for the service.
		Port int `json:"port"`

		// Priority The priority for the record.
		Priority int `json:"priority"`

		// Weight Teh weight configured for this record - breaks ties for priority.
		Weight int `json:"weight"`
	} `json:"srv,omitempty"`

	// Txt A DNS TXT record.
	Txt *struct {
		// Value The value for this TXT record.
		Value string `json:"value"`
	} `json:"txt,omitempty"`
}

// DnsZone DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
type DnsZone struct {
	Acl *ACL `json:"acl"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the DNS zone's lifetime.
	Events struct {
		Created          DateTime `json:"created"`
		Deleted          DateTime `json:"deleted"`
		LastVerification DateTime `json:"last_verification"`
		Updated          DateTime `json:"updated"`
		Verified         DateTime `json:"verified"`
	} `json:"events"`

	// Hosted A boolean where true represents this zone is a hosted zone.
	Hosted bool `json:"hosted"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Origin The origin for the given DNS zone.
	Origin string       `json:"origin"`
	State  DnsZoneState `json:"state"`
}

// DnsZoneIncludes All includable resources linkable to the given Zone.
type DnsZoneIncludes struct {
	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`
}

// DnsZoneState defines model for DnsZoneState.
type DnsZoneState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the zone.
	Current DnsZoneStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// DnsZoneStateCurrent The current state of the zone.
type DnsZoneStateCurrent string

// DockerFileOrigin An image origin where the image is built from a Dockerfile located in a git repository.
type DockerFileOrigin struct {
	Details struct {
		// BuildFile The path to the Dockerfile to be used for buiding the image.
		BuildFile *string `json:"build_file"`

		// ContextDir The path to the directory to use as the context when building the image.
		ContextDir  *string                `json:"context_dir"`
		Credentials *DockerfileCredentials `json:"credentials"`
		Existing    *ExistingSource        `json:"existing"`
		Repo        *RepoType              `json:"repo"`

		// TargzUrl An endpoint that serves the tar file.
		TargzUrl *string `json:"targz_url"`
	} `json:"details"`
	Type DockerFileOriginType `json:"type"`
}

// DockerFileOriginType defines model for DockerFileOrigin.Type.
type DockerFileOriginType string

// DockerHubOrigin An image origin where the image is pulled from DockerHub.
type DockerHubOrigin struct {
	Details struct {
		Existing *ExistingSource `json:"existing"`

		// Target The DockerHub target string. ex - `mysql:5.7`
		Target string `json:"target"`

		// Token For authentication, a token.
		Token *string `json:"token,omitempty"`

		// Username For authentication, a username.
		Username *string `json:"username,omitempty"`
	} `json:"details"`
	Type DockerHubOriginType `json:"type"`
}

// DockerHubOriginType defines model for DockerHubOrigin.Type.
type DockerHubOriginType string

// DockerRegistryOrigin An image origin where the image is pulled from a private Docker registry.
type DockerRegistryOrigin struct {
	Details struct {
		// Existing In a stack, specifies an image source ID from which Cycle will derive any values not specified in the stack file. This is useful for avoiding direct placement of credentials in a stack file, for example.
		Existing *ExistingSource `json:"existing,omitempty"`

		// Password For authentication, a password.
		Password *string `json:"password,omitempty"`

		// Target The image name on the registry.
		Target string `json:"target"`

		// Token For authentication, a token.
		Token *string `json:"token,omitempty"`

		// Url The url of the remote registry.
		Url string `json:"url"`

		// Username For authentication, a username.
		Username *string `json:"username,omitempty"`
	} `json:"details"`
	Type DockerRegistryOriginType `json:"type"`
}

// DockerRegistryOriginType defines model for DockerRegistryOrigin.Type.
type DockerRegistryOriginType string

// DockerfileCredentials An array of credentials objects to be used when authenticating against private images used by the Dockerfile.
type DockerfileCredentials = []struct {
	// Token A token for authentication.
	Token *string `json:"token,omitempty"`

	// Url The url the resource is located at.
	Url *string `json:"url,omitempty"`

	// Username A username for authentication.
	Username *string `json:"username,omitempty"`
}

// Duration A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
type Duration = string

// Environment Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://cycle.io/docs/platform/introduction-to-environments).
type Environment struct {
	// About Contains details regarding the environment.
	About EnvironmentAbout `json:"about"`
	Acl   *ACL             `json:"acl"`

	// Cluster The cluster this environment is associated with.
	Cluster string `json:"cluster"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Deployments A map of custom tags to deployment versions.
	Deployments *struct {
		// Tags A map of custom tags to deployment versions. Allows for defining a custom, persistent tag with a changing version number.
		// For example, `dev -> v1.2.3-dev`. This is useful when dealing with DNS LINKED records, where you always want dev.example.com to point to the
		// `dev` version of your app within an environment, where you can continuously deploy and update it without needing to change the record. It is
		// even more useful when you have multiple LINKED records, and you update i.e. `prod`` tag to point to a new version, all records using the `prod` tag
		// are switched at once.
		Tags EnvironmentDeploymentTags `json:"tags"`
	} `json:"deployments"`

	// Events A collection of timestamps for each event in the environment's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// Features An object representing specialized features configured for this environment.
	Features EnvironmentFeatures `json:"features"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`

	// Meta A list of meta fields that can be applied to this environment.
	Meta *EnvironmentMeta `json:"meta,omitempty"`

	// Name A user defined name for the environment resource.
	Name           string          `json:"name"`
	PrivateNetwork *PrivateNetwork `json:"private_network"`

	// Services Service containers run by this environment and their configurations.
	Services EnvironmentServices `json:"services"`
	State    EnvironmentState    `json:"state"`
}

// EnvironmentAbout Contains details regarding the environment.
type EnvironmentAbout struct {
	// Description A custom description for this environment.
	Description string `json:"description"`

	// Favorite If true, this environment has been marked as a favorite.
	Favorite bool `json:"favorite"`
}

// EnvironmentCreateStep Settings for creating an environment in a pipeline.
type EnvironmentCreateStep struct {
	// Action The action that the step takes.
	Action  EnvironmentCreateStepAction `json:"action"`
	Details struct {
		About   *EnvironmentAbout `json:"about"`
		Cluster string            `json:"cluster"`

		// Features An object representing specialized features configured for this environment.
		Features EnvironmentFeatures `json:"features"`
		Name     string              `json:"name"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// EnvironmentCreateStepAction The action that the step takes.
type EnvironmentCreateStepAction string

// EnvironmentDeleteStep Settings for deleting an environment in a pipeline.
type EnvironmentDeleteStep struct {
	// Action The action that the step takes.
	Action  EnvironmentDeleteStepAction `json:"action"`
	Details struct {
		// Environment An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Environment FluidIdentifier `json:"environment"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// EnvironmentDeleteStepAction The action that the step takes.
type EnvironmentDeleteStepAction string

// EnvironmentDeploymentHealthyWatchStep Waits for a deployment to be considered 'healthy' before allowing the pipeline to continue.
// A deployement is considered 'healthy' when all instances of all containers that have had a state change in the last 15 minutes
// that have health checks defined, become healthy.
type EnvironmentDeploymentHealthyWatchStep struct {
	// Action The action that the step takes.
	Action  EnvironmentDeploymentHealthyWatchStepAction `json:"action"`
	Details struct {
		// Environment An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Environment FluidIdentifier `json:"environment"`

		// MaxWait The maximum amount of time to wait for the deployment to become healthy before failing this step.
		MaxWait *Duration `json:"max_wait"`
		Tag     *string   `json:"tag"`
		Version *string   `json:"version"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// EnvironmentDeploymentHealthyWatchStepAction The action that the step takes.
type EnvironmentDeploymentHealthyWatchStepAction string

// EnvironmentDeploymentStartStep Start all containers with a specific deployment version/tag within an environment.
type EnvironmentDeploymentStartStep struct {
	// Action The action that the step takes.
	Action  EnvironmentDeploymentStartStepAction `json:"action"`
	Details struct {
		// Environment An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Environment FluidIdentifier `json:"environment"`
		Tag         *string         `json:"tag"`
		Version     *string         `json:"version"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// EnvironmentDeploymentStartStepAction The action that the step takes.
type EnvironmentDeploymentStartStepAction string

// EnvironmentDeploymentStopStep Stop all containers with a specific deployment version/tag within an environment.
type EnvironmentDeploymentStopStep struct {
	// Action The action that the step takes.
	Action  EnvironmentDeploymentStopStepAction `json:"action"`
	Details struct {
		// Environment An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Environment FluidIdentifier `json:"environment"`
		Tag         *string         `json:"tag"`
		Version     *string         `json:"version"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// EnvironmentDeploymentStopStepAction The action that the step takes.
type EnvironmentDeploymentStopStepAction string

// EnvironmentDeploymentTags A map of custom tags to deployment versions. Allows for defining a custom, persistent tag with a changing version number.
// For example, `dev -> v1.2.3-dev`. This is useful when dealing with DNS LINKED records, where you always want dev.example.com to point to the
// `dev` version of your app within an environment, where you can continuously deploy and update it without needing to change the record. It is
// even more useful when you have multiple LINKED records, and you update i.e. `prod tag to point to a new version, all records using the `prod` tag
// are switched at once.
type EnvironmentDeploymentTags map[string]Version

// EnvironmentDeploymentsPruneStep Remove any containers that are part of a deployment that does NOT have a tag associated with it.
type EnvironmentDeploymentsPruneStep struct {
	// Action The action that the step takes.
	Action  EnvironmentDeploymentsPruneStepAction `json:"action"`
	Details struct {
		// Environment An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Environment FluidIdentifier `json:"environment"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// EnvironmentDeploymentsPruneStepAction The action that the step takes.
type EnvironmentDeploymentsPruneStepAction string

// EnvironmentDeploymentsTagStep Settings for updating a deployment tag to another deployment version.
type EnvironmentDeploymentsTagStep struct {
	// Action The action that the step takes.
	Action  EnvironmentDeploymentsTagStepAction `json:"action"`
	Details struct {
		// Deployment The selector for which deployment to apply the new tag to.
		Deployment map[string]interface{} `json:"deployment"`

		// Environment An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Environment FluidIdentifier `json:"environment"`

		// Tag A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
		// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
		// have the identifier of `my-container` and is automatically created by the platform.
		//
		// The identifier does not have to be unique.
		Tag Identifier `json:"tag"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// EnvironmentDeploymentsTagStepAction The action that the step takes.
type EnvironmentDeploymentsTagStepAction string

// EnvironmentFeatures An object representing specialized features configured for this environment.
type EnvironmentFeatures struct {
	// LegacyNetworking Whether or not legacy networking mode is enabled on this environment.
	LegacyNetworking bool `json:"legacy_networking"`

	// Monitoring The level of monitoring to enable for this environment. There is a cost associated with higher levels of monitoring.
	Monitoring *struct {
		// Config The configuration for environment monitoring.
		Config *EnvironmentMonitoringConfig `json:"config,omitempty"`

		// Tier The tier of monitoring, that determines the frequency that metrics are aggregated by the platform, on a per-environment basis.
		Tier MonitoringTier `json:"tier"`
	} `json:"monitoring"`
}

// EnvironmentIncludes An identity that is associated with an environment.
type EnvironmentIncludes map[string]Environment

// EnvironmentInitializeAction A task to initialize an environment.
type EnvironmentInitializeAction struct {
	// Action The name of the action to perform.
	Action EnvironmentInitializeActionAction `json:"action"`
}

// EnvironmentInitializeActionAction The name of the action to perform.
type EnvironmentInitializeActionAction string

// EnvironmentMeta A list of meta fields that can be applied to this environment.
type EnvironmentMeta struct {
	Containers *[]struct {
		// Environment A summary of supplemental environment and network information specific to a container.
		Environment ContainerEnvironmentSummary `json:"environment"`

		// Id A 24 character hex string used to identify a unique resource.
		Id ID `json:"id"`

		// Image The Id of the image and information on if it is a service.
		Image ContainerImageSummary `json:"image"`

		// Name A user defined name for the container resource.
		Name  string         `json:"name"`
		State ContainerState `json:"state"`
	} `json:"containers,omitempty"`

	// ContainersCount A summary of resources by state
	ContainersCount *StateCountSummary `json:"containers_count,omitempty"`

	// InstancesCount A summary of resources by state
	InstancesCount *StateCountSummary `json:"instances_count,omitempty"`
}

// EnvironmentMonitoringConfig The configuration for environment monitoring.
type EnvironmentMonitoringConfig struct {
	// Logs An object describing the log configuration for the environment.
	Logs *struct {
		// Drain An object describing log drain configuration for the environment.
		Drain *struct {
			// ExcludeServices If enabled, service logs will not be included in log drain.
			ExcludeServices bool       `json:"exclude_services"`
			Format          *LogFormat `json:"format,omitempty"`

			// Url The destination URL for the log drain.
			Url string `json:"url"`
		} `json:"drain"`
	} `json:"logs"`
}

// EnvironmentNetworkSummary Details about the environment network this instance is a member of.
type EnvironmentNetworkSummary struct {
	// Id A 24 character hex string used to identify a unique resource.
	Id     ID     `json:"id"`
	Ipv6   *IPNet `json:"ipv6"`
	Legacy *struct {
		Host   int    `json:"host"`
		Ipv4   *IPNet `json:"ipv4"`
		Subnet int    `json:"subnet"`
	} `json:"legacy"`
	MacAddr       string `json:"mac_addr"`
	NetworkSubnet string `json:"network_subnet"`
	Subnet        string `json:"subnet"`
	VxlanTag      int    `json:"vxlan_tag"`
}

// EnvironmentReconfigureDeploymentsAction A task to reconfigure deployment mappings on an environment.
type EnvironmentReconfigureDeploymentsAction struct {
	// Action The action to take.
	Action   EnvironmentReconfigureDeploymentsActionAction `json:"action"`
	Contents struct {
		// Tags A map of custom tags to deployment versions. Allows for defining a custom, persistent tag with a changing version number.
		// For example, `dev -> v1.2.3-dev`. This is useful when dealing with DNS LINKED records, where you always want dev.example.com to point to the
		// `dev` version of your app within an environment, where you can continuously deploy and update it without needing to change the record. It is
		// even more useful when you have multiple LINKED records, and you update i.e. `prod`` tag to point to a new version, all records using the `prod` tag
		// are switched at once.
		Tags EnvironmentDeploymentTags `json:"tags"`
	} `json:"contents"`
}

// EnvironmentReconfigureDeploymentsActionAction The action to take.
type EnvironmentReconfigureDeploymentsActionAction string

// EnvironmentReconfigureMonitoringAction A task to reconfigure monitoring on an environment.
type EnvironmentReconfigureMonitoringAction struct {
	// Action The action to take.
	Action   EnvironmentReconfigureMonitoringActionAction `json:"action"`
	Contents struct {
		// Config The configuration for environment monitoring.
		Config EnvironmentMonitoringConfig `json:"config"`
	} `json:"contents"`
}

// EnvironmentReconfigureMonitoringActionAction The action to take.
type EnvironmentReconfigureMonitoringActionAction string

// EnvironmentServiceContainerSummary An object containing information about a service container associated with this environment.
type EnvironmentServiceContainerSummary struct {
	// AutoUpdate Whether or not the service will be automatically updated as new versions are released. Otherwise, the service will need to be restarted manually.
	AutoUpdate  *bool `json:"auto_update,omitempty"`
	ContainerId *ID   `json:"container_id"`

	// Enable Whether or not the service is enabled.
	Enable bool `json:"enable"`

	// HighAvailability Whether or not the service is deployed in high availability
	HighAvailability bool           `json:"high_availability"`
	State            ContainerState `json:"state"`
}

// EnvironmentServices Service containers run by this environment and their configurations.
type EnvironmentServices struct {
	Discovery    *DiscoveryEnvironmentService    `json:"discovery"`
	Gateway      *GatewayEnvironmentService      `json:"gateway"`
	Loadbalancer *LoadBalancerEnvironmentService `json:"loadbalancer"`
	Scheduler    *SchedulerEnvironmentService    `json:"scheduler"`
	Vpn          *VpnEnvironmentService          `json:"vpn"`
}

// EnvironmentStartAction A task to start an environment.
type EnvironmentStartAction struct {
	// Action The name of the action to perform.
	Action EnvironmentStartActionAction `json:"action"`
}

// EnvironmentStartActionAction The name of the action to perform.
type EnvironmentStartActionAction string

// EnvironmentStartStep Settings for starting an environment in a pipeline.
type EnvironmentStartStep struct {
	// Action The action that the step takes.
	Action  EnvironmentStartStepAction `json:"action"`
	Details struct {
		// Environment An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Environment FluidIdentifier `json:"environment"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// EnvironmentStartStepAction The action that the step takes.
type EnvironmentStartStepAction string

// EnvironmentState defines model for EnvironmentState.
type EnvironmentState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the environment.
	Current EnvironmentStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// EnvironmentStateCurrent The current state of the environment.
type EnvironmentStateCurrent string

// EnvironmentStopAction A task to stop an environment.
type EnvironmentStopAction struct {
	// Action The name of the action to perform.
	Action EnvironmentStopActionAction `json:"action"`
}

// EnvironmentStopActionAction The name of the action to perform.
type EnvironmentStopActionAction string

// EnvironmentStopStep Settings for stopping an environment in a pipeline.
type EnvironmentStopStep struct {
	// Action The action that the step takes.
	Action  EnvironmentStopStepAction `json:"action"`
	Details struct {
		// Environment An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Environment FluidIdentifier `json:"environment"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// EnvironmentStopStepAction The action that the step takes.
type EnvironmentStopStepAction string

// EnvironmentSummary Contains useful and relevant data/statistics for an environment that would otherwise be several separate API calls.
type EnvironmentSummary struct {
	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Services An object containing information about the service containers associated with this container. Each key is the name of a service, one of `discovery`, `vpn`, or `loadbalancer`.
	Services struct {
		Discovery    *EnvironmentServiceContainerSummary `json:"discovery"`
		Gateway      *EnvironmentServiceContainerSummary `json:"gateway"`
		Loadbalancer *EnvironmentServiceContainerSummary `json:"loadbalancer"`
		Scheduler    *EnvironmentServiceContainerSummary `json:"scheduler"`
		Vpn          *EnvironmentServiceContainerSummary `json:"vpn"`
	} `json:"services"`
	State EnvironmentState `json:"state"`

	// Stats Statistics about the containers and instances associated with this environment.
	Stats struct {
		// Containers A summary of resources by state
		Containers StateCountSummary `json:"containers"`

		// Instances A summary of resources by state
		Instances StateCountSummary `json:"instances"`

		// Servers A summary of instance counts, keyed by the host server ID.
		Servers *map[string]StateCountSummary `json:"servers,omitempty"`
	} `json:"stats"`
}

// EnvironmentTask defines model for EnvironmentTask.
type EnvironmentTask struct {
	union json.RawMessage
}

// Error The Cycle API uses standard HTTP response codes to indicate the success or failure of an API request. Codes in the `2xx` range indicate success. Codes in the `4xx` range indicate a request that failed due to input, and codes in the `5xx` range indicate an error on Cycle's part (rare).
// There are two types of error response objects. Errors with authentication are formatted to follow the OAuth spec, while all other errors follow the same convention. If you're using one of our API Libraries, they will standardize OAuth errors to fit the general convention.
type Error struct {
	// Code A Cycle standard error code.
	Code *ErrorCode `json:"code,omitempty"`

	// Detail A more detailed description of the error.
	Detail *string `json:"detail,omitempty"`

	// Extra Additional entries on the error object to provide extra details.
	Extra *struct {
		// Capability A capability that a user or API key that represents what an API key or a user can do.
		Capability *Capability `json:"capability,omitempty"`
	} `json:"extra,omitempty"`

	// Source A [JSON pointer](https://tools.ietf.org/html/rfc6901/) describing the source of an error.
	Source *string `json:"source,omitempty"`

	// Status The HTTP response code.
	Status *ErrorStatus `json:"status,omitempty"`

	// Title The main text describing the error.
	Title *string `json:"title,omitempty"`
}

// ErrorCode A Cycle standard error code.
type ErrorCode string

// ErrorStatus The HTTP response code.
type ErrorStatus int

// ErrorEnvelope An error response.
type ErrorEnvelope struct {
	Data *map[string]interface{} `json:"data"`

	// Error The Cycle API uses standard HTTP response codes to indicate the success or failure of an API request. Codes in the `2xx` range indicate success. Codes in the `4xx` range indicate a request that failed due to input, and codes in the `5xx` range indicate an error on Cycle's part (rare).
	// There are two types of error response objects. Errors with authentication are formatted to follow the OAuth spec, while all other errors follow the same convention. If you're using one of our API Libraries, they will standardize OAuth errors to fit the general convention.
	Error Error `json:"error"`
}

// Event A platform-generated event. Describes something happening on the platform at a specific time. Can be informational, security related, or a notice of something important.
type Event struct {
	// Labels Additional key-values that can be used for querying in an aggregation pipeline. Often useful for filtering.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Information about this event, such as the type of event, the data it represents, and critical common information such as hub ID and associated cluster.
	Metadata struct {
		// Cluster The cluster associated with this event
		Cluster *string `json:"cluster"`

		// Component The specific resource ID and type associated with this event.
		Component *struct {
			// Id A 24 character hex string used to identify a unique resource.
			Id   ID     `json:"id"`
			Type string `json:"type"`
		} `json:"component"`
		Event EventType `json:"event"`

		// HubId A 24 character hex string used to identify a unique resource.
		HubId *ID `json:"hub_id,omitempty"`

		// Origin The originator of this event.
		Origin string `json:"origin"`

		// Priority Describes how important this event is.
		Priority EventMetadataPriority `json:"priority"`

		// Type The type of event.
		//   - **info**: represents an informational message.
		//   - **warning**: represents a warning message indicating a potential issue.
		//   - **error**: represents an error message indicating a failure or critical issue.
		//   - **success**: represents a success message indicating a successful operation.
		//   - **alert**: represents a critical message indicating a severe issue.
		//   - **notice**: represents a notice message indicating a noteworthy event.
		//   - **audit**: represents a notice message indicating a message that would be needed for audits
		Type EventMetadataType `json:"type"`
	} `json:"metadata"`

	// Tags Additional tags associated with the event.
	Tags *[]string `json:"tags,omitempty"`

	// Text A message describing what happened.
	Text *string  `json:"text,omitempty"`
	Time DateTime `json:"time"`
}

// EventMetadataPriority Describes how important this event is.
type EventMetadataPriority string

// EventMetadataType The type of event.
//   - **info**: represents an informational message.
//   - **warning**: represents a warning message indicating a potential issue.
//   - **error**: represents an error message indicating a failure or critical issue.
//   - **success**: represents a success message indicating a successful operation.
//   - **alert**: represents a critical message indicating a severe issue.
//   - **notice**: represents a notice message indicating a noteworthy event.
//   - **audit**: represents a notice message indicating a message that would be needed for audits
type EventMetadataType string

// EventType defines model for EventType.
type EventType string

// Events Describes the date and time at which certain events occurred in the lifetime of this resource.
type Events map[string]DateTime

// ExistingSource In a stack, specifies an image source ID from which Cycle will derive any values not specified in the stack file. This is useful for avoiding direct placement of credentials in a stack file, for example.
type ExistingSource struct {
	// SourceId A 24 character hex string used to identify a unique resource.
	SourceId *ID `json:"source_id,omitempty"`
}

// ExternalVolume A persistent storage volume within a cluster. Volumes may be attached to containers or VMs and can originate from different storage sources.
type ExternalVolume struct {
	// About Additional details about the external volume.
	About ExternalVolumeAbout `json:"about"`

	// Attachment Attachment configuration for an external volume.
	Attachment *ExternalVolumeAttachment `json:"attachment,omitempty"`

	// Cluster A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Cluster Identifier `json:"cluster"`

	// Events Timestamps for events that happen over the lifetime of the attached volume.
	Events ExternalVolumeEvents `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// LocationId A 24 character hex string used to identify a unique resource.
	LocationId ID `json:"location_id"`

	// Meta A list of meta fields that can be applied to an attached volume.
	Meta *ExternalVolumeMeta `json:"meta,omitempty"`

	// Name The name of the external volume.
	Name string `json:"name"`

	// Options Configuration options controlling the behavior of the volume.
	Options   ExternalVolumeOptions `json:"options"`
	ServerIds []ID                  `json:"server_ids"`

	// Size A human-readable data size string. Values are expressed as an integer followed by a unit suffix, without spaces. Supported units:
	//   - b, k, m, g, t, p (bytes, kilobytes, megabytes, gigabytes, terabytes, petabytes)
	//   - An optional "b" suffix may be added (e.g., "mb", "gb").
	// Units are case-insensitive. Example: "512M", "10GB", "1t".
	Size *DataSize `json:"size,omitempty"`

	// Source The source information for this volume.
	Source ExternalVolumeSource `json:"source"`
	State  ExternalVolumeState  `json:"state"`
}

// ExternalVolumeAbout Additional details about the external volume.
type ExternalVolumeAbout struct {
	// Description Custom details about this external volume.
	Description string `json:"description"`
}

// ExternalVolumeAttachment Attachment configuration for an external volume.
type ExternalVolumeAttachment struct {
	union json.RawMessage
}

// ExternalVolumeAttachmentBlock Configuration for a block volume attachment.
type ExternalVolumeAttachmentBlock struct {
	// Details Details for a block attachment. Present when `type` is `block`.
	Details map[string]interface{} `json:"details"`

	// Mode The access mode for the attachment.
	Mode ExternalVolumeAttachmentBlockMode `json:"mode"`
	Type ExternalVolumeAttachmentBlockType `json:"type"`
}

// ExternalVolumeAttachmentBlockMode The access mode for the attachment.
type ExternalVolumeAttachmentBlockMode string

// ExternalVolumeAttachmentBlockType defines model for ExternalVolumeAttachmentBlock.Type.
type ExternalVolumeAttachmentBlockType string

// ExternalVolumeAttachmentFileSystem Configuration for a filesystem volume attachment.
type ExternalVolumeAttachmentFileSystem struct {
	// Details Details for a filesystem attachment. Present when `type` is `filesystem`.
	Details map[string]interface{} `json:"details"`

	// Mode The access mode for the attachment.
	Mode ExternalVolumeAttachmentFileSystemMode `json:"mode"`
	Type ExternalVolumeAttachmentFileSystemType `json:"type"`
}

// ExternalVolumeAttachmentFileSystemMode The access mode for the attachment.
type ExternalVolumeAttachmentFileSystemMode string

// ExternalVolumeAttachmentFileSystemType defines model for ExternalVolumeAttachmentFileSystem.Type.
type ExternalVolumeAttachmentFileSystemType string

// ExternalVolumeEvents Timestamps for events that happen over the lifetime of the attached volume.
type ExternalVolumeEvents struct {
	Created      DateTime  `json:"created"`
	Deleted      DateTime  `json:"deleted"`
	LastSync     *DateTime `json:"last_sync,omitempty"`
	LastVerified *DateTime `json:"last_verified,omitempty"`
	Updated      DateTime  `json:"updated"`
}

// ExternalVolumeIncludes All includable resources linked to the given external volume.
type ExternalVolumeIncludes struct {
	Locations *map[string]ProviderLocation `json:"locations,omitempty"`
	Servers   *map[string]Server           `json:"servers,omitempty"`
}

// ExternalVolumeMeta A list of meta fields that can be applied to an attached volume.
type ExternalVolumeMeta struct {
	Containers *[]ContainerSummary `json:"containers,omitempty"`
}

// ExternalVolumeOptions Configuration options controlling the behavior of the volume.
type ExternalVolumeOptions struct {
	// Create If the volume doesn't exist, attempt to create it on container start if create struct defined.
	Create *struct {
		// Size A human-readable data size string. Values are expressed as an integer followed by a unit suffix, without spaces. Supported units:
		//   - b, k, m, g, t, p (bytes, kilobytes, megabytes, gigabytes, terabytes, petabytes)
		//   - An optional "b" suffix may be added (e.g., "mb", "gb").
		// Units are case-insensitive. Example: "512M", "10GB", "1t".
		Size DataSize `json:"size"`
	} `json:"create"`
}

// ExternalVolumeServersReconfigureAction A task to reconfigure mountable destination servers for external volume.
type ExternalVolumeServersReconfigureAction struct {
	// Action The name of the action to perform (servers.reconfigure).
	Action ExternalVolumeServersReconfigureActionAction `json:"action"`

	// Contents Contents contains an array of server ids to set as mountable destinations for the external volume.
	Contents *[]ID `json:"contents,omitempty"`
}

// ExternalVolumeServersReconfigureActionAction The name of the action to perform (servers.reconfigure).
type ExternalVolumeServersReconfigureActionAction string

// ExternalVolumeSource The source information for this volume.
type ExternalVolumeSource struct {
	union json.RawMessage
}

// ExternalVolumeState defines model for ExternalVolumeState.
type ExternalVolumeState struct {
	Changed DateTime `json:"changed"`

	// Current The current lifecycle state of the volume.
	Current ExternalVolumeStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// ExternalVolumeStateCurrent The current lifecycle state of the volume.
type ExternalVolumeStateCurrent string

// ExternalVolumeTask defines model for ExternalVolumeTask.
type ExternalVolumeTask struct {
	union json.RawMessage
}

// FeaturesSpec The spec for server features.
type FeaturesSpec struct {
	// Extra Provider specific features, allowing for additional, unspecified properties. This is an open map for any key-value pairs, accommodating various types of values.
	Extra *map[string]interface{} `json:"extra"`

	// Hypervisor Indicates if the model supports virtual machines.
	Hypervisor *bool `json:"hypervisor"`

	// Raid The type of RAID supported, if any.
	Raid *string `json:"raid"`
}

// FluidIdentifier An identifier used in pipelines to refer to different kinds of resources across Cycle.
//
// - `id:<mongo id>`: A raw resource ID
// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
// - `from:<stage/step>`: For referencing a previous pipeline step.
type FluidIdentifier = string

// FunctionRuntimeVariables Variables that affect the runtime of a function container.
type FunctionRuntimeVariables struct {
	// EnvironmentVariables Environment variables to inject into the container.
	EnvironmentVariables *map[string]string `json:"environment_variables"`
}

// FunctionTask defines model for FunctionTask.
type FunctionTask struct {
	union json.RawMessage
}

// FunctionTriggerAction defines model for FunctionTriggerAction.
type FunctionTriggerAction struct {
	// Action The name of the action to perform.
	Action   FunctionTriggerActionAction `json:"action"`
	Contents struct {
		// RuntimeVariables Variables that affect the runtime of a function container.
		RuntimeVariables FunctionRuntimeVariables `json:"runtime_variables"`

		// Token A custom token used for identifying and managing a claim. Can be any valid string 5 characters or more.
		Token string `json:"token"`
	} `json:"contents"`
}

// FunctionTriggerActionAction The name of the action to perform.
type FunctionTriggerActionAction string

// GPUSpec Information about a given servers GPU resources.
type GPUSpec struct {
	// Cores The number of cores.
	Cores *int `json:"cores,omitempty"`

	// Count The number of GPUs.
	Count int `json:"count"`

	// Extra Extra information about the GPU if there is any.
	Extra *map[string]string `json:"extra,omitempty"`

	// Shared A boolean where true represents the GPU is shared.
	Shared *bool `json:"shared,omitempty"`

	// Type The type of the GPU.
	Type string `json:"type"`

	// VramGb The amount of virtaul RAM for the GPU.
	VramGb *int `json:"vram_gb,omitempty"`
}

// GatewayEnvironmentService Information about the environments gateway service(s).
type GatewayEnvironmentService struct {
	// AutoUpdate A boolean where `true` represents the desire to automatically update the environment gateway service.
	AutoUpdate *bool `json:"auto_update,omitempty"`

	// ContainerId The ID of the gateway service container
	ContainerId string `json:"container_id"`

	// Enable Whether or not the gateway service is enabled.
	Enable bool `json:"enable"`

	// HighAvailability A boolean representing if this service container is set to high availability mode or not.
	HighAvailability bool `json:"high_availability"`
}

// HaProxyConfig Describes settings that are passed to HAProxy within the load balancer.
type HaProxyConfig struct {
	Default HaProxyConfigSet `json:"default"`

	// Ports An object that defines how HAProxy will act on a specific port. The key is a custom port, and the value is the same settings object found under `default` above.
	Ports map[string]HaProxyConfigSet `json:"ports"`
}

// HaProxyConfigSet defines model for HaProxyConfigSet.
type HaProxyConfigSet struct {
	// Backend Settings related to how the load balancer routes connections to container instances.
	Backend struct {
		// Balance How connections are balanced across your container instances. Can be one of the following:
		//  - `roundrobin`: Each container instance is used in turns.
		//  - `static-rr`: Each container instance is used in turns, but is faster than Round Robin at the expense of being less dynamic.
		//  - `leastconn`: Routes traffic to the instance with the least number of active connections.
		//  - `first`: Routes traffic to the first available instance.
		//  - `source`: The same client IP always reaches the same container instance as long as no instance goes down or up.
		Balance HaProxyConfigSetBackendBalance `json:"balance"`

		// Timeouts Various options for handling timeouts when communicating with a container instance behind the load balancer.
		Timeouts *struct {
			// ConnectMs The number of milliseconds the load balancer will wait for a successful connection to a container instance. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4-timeout%20connect) for more information.
			ConnectMs *int `json:"connect_ms"`

			// QueueMs The number of milliseconds the load balancer will hold connections in a queue when the maximum number of connections has been reached. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4-timeout%20queue) for more information.
			QueueMs *int `json:"queue_ms"`

			// ServerFinMs The number of milliseconds the load balancer will wait for the server to send data when one direction is already closed. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4-timeout%20server-fin) for more information.
			ServerFinMs *int `json:"server_fin_ms"`

			// ServerSecs The number of seconds the load balancer will wait for a response from the container instance. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4.2-timeout%20server) for more information.
			ServerSecs *int `json:"server_secs"`

			// TunnelSecs The number of milliseconds the load balancer will allow for inactivity on a bidirectional tunnel. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4-timeout%20tunnel) for more information.
			TunnelSecs *int `json:"tunnel_secs"`
		} `json:"timeouts"`
	} `json:"backend"`

	// Frontend Settings that describe how incoming traffic to the load balancer is handled.
	Frontend struct {
		// MaxConnections The number of simultaneous connections that can be processed at a time.
		MaxConnections *int `json:"max_connections"`

		// Mode The type of traffic expected by the load balancer for this port. Can be either:
		//  - tcp: Traffic is forwarded without any parsing or additional manipulation.
		//  - http: Traffic is treated as web traffic. If a LINKED record is configured for a container exposing this port, the domain will be parsed and it will be forwarded to the proper container. This allows multiple services to run on port 80 in the same environment.
		Mode HaProxyConfigSetFrontendMode `json:"mode"`

		// Timeouts Various options for handling timeouts when communicating with the client.
		Timeouts *struct {
			// ClientFinMs The number of milliseconds the load balancer will wait for a client to send it data when one direction is already closed. This is particularly useful to avoid keeping connections in a waiting state for too long when clients do not disconnect cleanly.
			ClientFinMs *int `json:"client_fin_ms"`

			// ClientSecs The number of seconds the load balancer will wait for a response from a client before disconnecting.
			ClientSecs *int `json:"client_secs"`

			// HttpKeepAliveMs The number of milliseconds the load balancer will wait for a new HTTP request to start coming after a response was set. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4.2-timeout%20http-request) for more information. (`http` mode only)
			HttpKeepAliveMs *int `json:"http_keep_alive_ms"`

			// HttpRequestMs The number of milliseconds the load balancer will wait for a complete HTTP request. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4.2-timeout%20http-request) for more information. (`http` mode only)
			HttpRequestMs *int `json:"http_request_ms"`
		} `json:"timeouts"`
	} `json:"frontend"`
}

// HaProxyConfigSetBackendBalance How connections are balanced across your container instances. Can be one of the following:
//   - `roundrobin`: Each container instance is used in turns.
//   - `static-rr`: Each container instance is used in turns, but is faster than Round Robin at the expense of being less dynamic.
//   - `leastconn`: Routes traffic to the instance with the least number of active connections.
//   - `first`: Routes traffic to the first available instance.
//   - `source`: The same client IP always reaches the same container instance as long as no instance goes down or up.
type HaProxyConfigSetBackendBalance string

// HaProxyConfigSetFrontendMode The type of traffic expected by the load balancer for this port. Can be either:
//   - tcp: Traffic is forwarded without any parsing or additional manipulation.
//   - http: Traffic is treated as web traffic. If a LINKED record is configured for a container exposing this port, the domain will be parsed and it will be forwarded to the proper container. This allows multiple services to run on port 80 in the same environment.
type HaProxyConfigSetFrontendMode string

// HaProxyLbType defines model for HaProxyLbType.
type HaProxyLbType struct {
	Details *HaProxyConfig `json:"details"`

	// Ipv4 Allow / disallow traffic to be routed via IPv4.
	Ipv4 bool `json:"ipv4"`

	// Ipv6 Allow / disallow traffic to be routed via IPv6.
	Ipv6 bool              `json:"ipv6"`
	Type HaProxyLbTypeType `json:"type"`
}

// HaProxyLbTypeType defines model for HaProxyLbType.Type.
type HaProxyLbTypeType string

// HttpRouterConfig Additional configuration options for HTTP mode routers.
type HttpRouterConfig struct {
	Details struct {
		Caching *struct {
			Files *[]struct {
				// Match Regex string that describes the files to cache.
				Match string `json:"match"`

				// Ttl A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
				Ttl Duration `json:"ttl"`
			} `json:"files"`
		} `json:"caching"`
		Forward *struct {
			// ContentMod Allows the load balancer to modify content before it reaches the user.
			ContentMod *struct {
				// Replace An array that describes a list of replacement match/value pairs.
				Replace *[]struct {
					// Match String that will be replaced.
					Match string `json:"match"`

					// Value Replacement value.
					Value string `json:"value"`
				} `json:"replace"`
			} `json:"content_mod"`
			Scheme *string `json:"scheme"`

			// Url The URL to forward the request to.
			//
			// Given a path match of `^/example/(.*)$`, a route such as `/example/wow.jpg` would be forwarded as /wow.jpg.
			Url *string `json:"url"`
		} `json:"forward"`
		Proxy *struct {
			// ContentMod Allows the load balancer to modify content before it reaches the user.
			ContentMod *struct {
				// Replace An array that describes a list of replacement match/value pairs.
				Replace *[]struct {
					// Match String that will be replaced.
					Match string `json:"match"`

					// Value Replacement value.
					Value string `json:"value"`
				} `json:"replace"`
			} `json:"content_mod"`

			// Domain The domain that this router will proxy.
			Domain *string `json:"domain"`

			// Url The full URL that this router will proxy.
			Url *string `json:"url"`
		} `json:"proxy"`

		// Redirect Defines a built-in redirect for HTTP mode routers
		Redirect *struct {
			// AutoHttpsRedirect If enabled and a sibling controller exists for port 443, requests will be auto redirected to it. Essentially sets up automatic TLS redirection for this router.
			AutoHttpsRedirect bool `json:"auto_https_redirect"`

			// Port The port to redirect traffic to.
			Port *int `json:"port"`

			// RemoveWww If true, any request comes in with "www" prefix will be permanently redirected to the same path without www.
			RemoveWww bool `json:"remove_www"`

			// Scheme The scheme to redirect to. (i.e. `https`)
			Scheme *string `json:"scheme"`

			// Url A specific URL to redirect to.
			Url *string `json:"url"`
		} `json:"redirect"`
	} `json:"details"`
	Type HttpRouterConfigType `json:"type"`
}

// HttpRouterConfigType defines model for HttpRouterConfig.Type.
type HttpRouterConfigType string

// HttpTransportConfig Additional configuration options for the HTTP transport mode.
type HttpTransportConfig struct {
	Details struct {
		// Connections Defines extra configuration options connections to the load balancer
		Connections struct {
			// MaxIdleConnsPerConnection Maximum number of simultaneous connections (via http/2) per connection.
			MaxIdleConnsPerConnection *int `json:"max_idle_conns_per_connection"`
		} `json:"connections"`

		// Telemetry Configuration options for how telemetry is handled.
		Telemetry struct {
			// IgnorePaths An array of paths to exclude from tracking.
			IgnorePaths *[]string `json:"ignore_paths"`

			// MaxTrackableUrls Determines how many URLs the load balancer will track at one time. Defaults to 150.
			MaxTrackableUrls *int `json:"max_trackable_urls"`

			// TrackInvalidRequests Whether or not to track invalid requests. An invalid request is a request that came in that no router existed for. Usually this means bot requests. Defaults to false.
			TrackInvalidRequests *bool `json:"track_invalid_requests"`
		} `json:"telemetry"`
	} `json:"details"`
	Type HttpTransportConfigType `json:"type"`
}

// HttpTransportConfigType defines model for HttpTransportConfig.Type.
type HttpTransportConfigType string

// Hub A hub resource.
type Hub struct {
	Billing *HubBillingProfile `json:"billing"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the hub's lifetime.
	Events HubEvents `json:"events"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`

	// Meta A list of meta fields that can be applied to a hub.
	Meta *HubMeta `json:"meta,omitempty"`

	// Name A name for the hub.
	Name string `json:"name"`

	// Security Security options for a hub.
	Security HubSecurity `json:"security"`
	State    HubState    `json:"state"`

	// Webhooks Hub related webhooks. When supplied, the given webhook will be called with a payload any time one of these events occurs.
	Webhooks HubWebhooks `json:"webhooks"`
}

// HubBillingContact The contact to whom invoices are billed.
type HubBillingContact struct {
	// LegalBusinessName The legal business name of the billing contact.
	LegalBusinessName string `json:"legal_business_name"`

	// Name The name of the billing contact.
	Name string `json:"name"`

	// TaxId The legal tax ID of the billing contact, if applicable.
	TaxId string `json:"tax_id"`
}

// HubBillingProfile A billing profile for a given hub.
type HubBillingProfile struct {
	// AllowDirectPayments When true, this hub is allowed to create 'direct' payment methods.
	AllowDirectPayments *bool `json:"allow_direct_payments,omitempty"`

	// AllowPrepaid A boolean where true represents this account being approved to use a prepaid card for billing transactions.
	AllowPrepaid *bool `json:"allow_prepaid,omitempty"`

	// Contact The contact to whom invoices are billed.
	Contact *HubBillingContact `json:"contact,omitempty"`

	// Disable A boolean where true means this billing is disabled on this hub.
	Disable *bool `json:"disable,omitempty"`

	// Emails An array of email addresses to whom the billing invoices will be sent to. If left empty, they will be sent to the owner of this hub.
	Emails *[]string `json:"emails"`

	// PauseInvoices A boolean where true represents invoices have been paused on this hub for one reason or another.
	PauseInvoices bool `json:"pause_invoices"`

	// Plans Information about the plan associated with this hub.
	Plans struct {
		// SupportId An ID referencing the support plan applied to this hub.
		SupportId *string `json:"support_id"`

		// TierId An ID referencing the pricing tier applied to this hub.
		TierId *string `json:"tier_id"`
	} `json:"plans"`

	// Term Information about a billing term.
	Term Term `json:"term"`
}

// HubEvents A collection of timestamps for each event in the hub's lifetime.
type HubEvents struct {
	Converted        *DateTime `json:"converted,omitempty"`
	Created          DateTime  `json:"created"`
	Deleted          DateTime  `json:"deleted"`
	FirstContainer   *DateTime `json:"first_container,omitempty"`
	FirstEnvironment *DateTime `json:"first_environment,omitempty"`
	FirstImage       *DateTime `json:"first_image,omitempty"`
	FirstOrder       *DateTime `json:"first_order,omitempty"`
	FirstProvider    *DateTime `json:"first_provider,omitempty"`
	FirstServer      *DateTime `json:"first_server,omitempty"`
	Updated          DateTime  `json:"updated"`
}

// HubID The unique ID of the Hub this resource was created in.
type HubID = string

// HubInviteIncludes All includable resources for invites.
type HubInviteIncludes struct {
	// Roles A map of roles relevant to this hub membership, keyed by the Role ID.
	Roles *map[string]Role `json:"roles,omitempty"`

	// RolesIdentifiers A map of roles relevant to this hub membership, keyed by the role ID.
	RolesIdentifiers *map[string]ID `json:"roles:identifiers,omitempty"`

	// Senders A record with an ID mapped to a public account for the account that sent this memberships initial invite.
	Senders *struct {
		// Accounts A record with an ID mapped to a public account.
		Accounts *map[string]PublicAccount `json:"accounts,omitempty"`
	} `json:"senders,omitempty"`
}

// HubMembership A membership resource that is scoped to an individual hub.
type HubMembership struct {
	// AccountId An ID for the account associated with the given membership.
	AccountId *string `json:"account_id,omitempty"`

	// Cycle If this member is a Cycle employee, their employee ID will be listed here. Cycle employee accounts do not consume a "membership" for a given hub.
	Cycle *struct {
		// EmployeeId The ID of the employee this membership is associated with.
		EmployeeId string `json:"employee_id"`
	} `json:"cycle,omitempty"`

	// Events A collection of timestamps for each event in the membership's lifetime.
	Events struct {
		Created *DateTime `json:"created,omitempty"`
		Deleted *DateTime `json:"deleted,omitempty"`
		Joined  DateTime  `json:"joined"`
		Updated *DateTime `json:"updated,omitempty"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Invitation Information about a hub membership invitation.
	Invitation Invitation `json:"invitation"`

	// Preferences Preference information set by the user for the membership.
	Preferences *struct {
		Email struct {
			Notificaitons *struct {
				Server struct {
					New     *bool `json:"new"`
					Offline *bool `json:"offline"`
				} `json:"server"`
			} `json:"notificaitons,omitempty"`
		} `json:"email"`
		Portal struct {
			Notifications struct {
				Jobs struct {
					ApikeyAlerts bool `json:"apikey_alerts"`
				} `json:"jobs"`
			} `json:"notifications"`
		} `json:"portal"`
	} `json:"preferences,omitempty"`

	// RoleId A 24 character hex string used to identify a unique resource.
	RoleId ID              `json:"role_id"`
	State  MembershipState `json:"state"`
}

// HubMembershipIncludes A resource that is associated with a hub membership.
type HubMembershipIncludes struct {
	// Accounts A record with an ID mapped to a public account.
	Accounts *map[string]PublicAccount `json:"accounts,omitempty"`

	// Hubs A record with an ID mapped to a hub resource.
	Hubs *map[string]Hub `json:"hubs,omitempty"`

	// Roles A map of Roles relevant to this Hub Membership, keyed by the Role ID.
	Roles *map[string]Role `json:"roles,omitempty"`

	// RolesIdentifiers A map of Roles relevant to this Hub Membership, keyed by the Role ID.
	RolesIdentifiers *map[string]ID `json:"roles:identifiers,omitempty"`

	// Senders A record with an ID mapped to a public account for the account that sent this memberships initial invite.
	Senders *struct {
		// Accounts A record with an ID mapped to a public account.
		Accounts *map[string]PublicAccount `json:"accounts,omitempty"`
	} `json:"senders,omitempty"`
}

// HubMembershipIncludes2 All includable resources for hub memberships.
type HubMembershipIncludes2 struct {
	// Accounts A record with an ID mapped to a public account.
	Accounts *map[string]PublicAccount `json:"accounts,omitempty"`

	// Roles A map of roles relevant to this hub membership, keyed by the Role ID.
	Roles *map[string]Role `json:"roles,omitempty"`

	// RolesIdentifiers A map of roles relevant to this hub membership, keyed by the role ID.
	RolesIdentifiers *map[string]ID `json:"roles:identifiers,omitempty"`
}

// HubMeta A list of meta fields that can be applied to a hub.
type HubMeta struct {
	// Membership A membership resource that is scoped to an individual hub.
	Membership *HubMembership `json:"membership,omitempty"`
}

// HubSecurity Security options for a hub.
type HubSecurity struct {
	// Force2fa When true, any API call for this hub from an account that does not have two-factor auth enabled will fail with a 403 error.
	Force2fa bool `json:"force_2fa"`
}

// HubState defines model for HubState.
type HubState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the hub.
	Current HubStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// HubStateCurrent The current state of the hub.
type HubStateCurrent string

// HubUsageDatum A hub usage data point
type HubUsageDatum struct {
	Containers   float32 `json:"containers"`
	Environments float32 `json:"environments"`
	Members      float32 `json:"members"`
	Servers      float32 `json:"servers"`
	Time         string  `json:"time"`
}

// HubWebhooks Hub related webhooks. When supplied, the given webhook will be called with a payload any time one of these events occurs.
type HubWebhooks struct {
	// ServerDeleted A webhook that is called any time a server in this hub is deleted. The payload will be a `Server` object.
	ServerDeleted *string `json:"server_deleted"`

	// ServerDeployed A webhook that is called any time a server is deployed to this hub. The payload will be a `Server` object.
	ServerDeployed *string `json:"server_deployed"`
}

// HugeTLB HugeTLB data.
type HugeTLB struct {
	// FailCount The number of times the hugeTLB memory limit has been exceeded by this instance.
	FailCount *int `json:"fail_count,omitempty"`

	// Max The maximum number of bytes allowed to be used for huge pages for this instance.
	Max *int `json:"max,omitempty"`

	// Usage The number of bytes being consumed by huge pages of all sizes.
	Usage *int `json:"usage,omitempty"`
}

// HybridIdentifier Either a resource ID (objectid - i.e. 651586fca6078e98982dbd90) or a resource Identifier (human-readable)
type HybridIdentifier = string

// ID A 24 character hex string used to identify a unique resource.
type ID = string

// IPNet defines model for IPNet.
type IPNet struct {
	// Cidr The CIDR notation, describing the range of IP addresses.
	Cidr string `json:"cidr"`

	// Ip The IP address.
	Ip string `json:"ip"`
}

// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
// have the identifier of `my-container` and is automatically created by the platform.
//
// The identifier does not have to be unique.
type Identifier = string

// IdentifierIncludes A map of identifiers to an array of resource IDs that are associated with it. All IDs point to the same type of resource.
type IdentifierIncludes map[string][]ID

// Image An image is a point in time build on a given image source, and what is distributed by Cycle to run containers.
type Image struct {
	// About An object that holds information about the image.
	About *struct {
		// Description A description of the image.
		Description *string `json:"description"`
	} `json:"about,omitempty"`

	// Backend Describes where the image is hosted.
	Backend struct {
		// FileId A file id for the image, used by the platform.
		FileId string `json:"file_id"`

		// FileName A file name for the image, used by the platform.
		FileName string `json:"file_name"`

		// Provider The provider where this image is hosted.
		Provider string `json:"provider"`

		// Size The size of the image in bytes.
		Size int `json:"size"`
	} `json:"backend"`

	// Build Any additional build details for this image
	Build *struct {
		// Args Arguments to pass to the builder during a build of this image.
		Args *map[string]string `json:"args,omitempty"`

		// UseDisk If true, will skip using /dev/shm when building an image on factory. Allows for building much larger images.
		UseDisk *bool `json:"use_disk,omitempty"`
	} `json:"build"`

	// Builder Configuration options regarding the builder used to create/import this Image.
	Builder *struct {
		// IntegrationId A 24 character hex string used to identify a unique resource.
		IntegrationId ID `json:"integration_id"`
	} `json:"builder"`

	// Config Configuration settings for the image.
	Config struct {
		// Command The CMD array used to start the container.
		Command []string `json:"command"`

		// Entrypoint An entrypoint command.
		Entrypoint []string `json:"entrypoint"`

		// Env Image defined environment variables for the image.
		Env map[string]string `json:"env"`

		// Labels Image labels.
		Labels map[string]string `json:"labels"`

		// Ports The port settings for the image.
		Ports []struct {
			Container float32 `json:"container"`

			// Host Host Port
			Host float32 `json:"host"`
			Type string  `json:"type"`
		} `json:"ports"`

		// SignalStop A set command to be run if a signal is called.
		SignalStop string `json:"signal_stop"`

		// User The linux user this image runs its processes as.
		User string `json:"user"`

		// Volumes Volumes information for the given image.
		Volumes []struct {
			// Mode Permission settings for the volume.
			Mode *ImageConfigVolumesMode `json:"mode,omitempty"`

			// Path The path where the volume is mounted.
			Path *string `json:"path,omitempty"`
		} `json:"volumes"`

		// Workdir The working directory for the image.
		Workdir string `json:"workdir"`
	} `json:"config"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator *CreatorScope `json:"creator,omitempty"`

	// Events A collection of timestamps for each event in the image's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// Factory Information about the Factory service that built/imported the Image into Cycle.
	Factory *struct {
		Acknowledged DateTime `json:"acknowledged"`
		Cached       DateTime `json:"cached"`

		// NodeId The node holding the factory service that was responsible for building the image.
		NodeId string `json:"node_id"`
	} `json:"factory"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Meta A list of meta fields that can be applied to the image.
	Meta *ImageMeta `json:"meta,omitempty"`

	// Name A user defined name for the image.
	Name string `json:"name"`

	// Requires Any restrictions or requirements needed to run this image as a container.
	Requires struct {
		NvidiaGpu *bool `json:"nvidia_gpu,omitempty"`
	} `json:"requires"`

	// Size The image size in bytes.
	Size   int           `json:"size"`
	Source *Image_Source `json:"source,omitempty"`
	State  ImageState    `json:"state"`
}

// ImageConfigVolumesMode Permission settings for the volume.
type ImageConfigVolumesMode string

// Image_Source defines model for Image.Source.
type Image_Source struct {
	union json.RawMessage
}

// ImageCreateImportStep A pipeline step for creating and importing an image in one go.
type ImageCreateImportStep struct {
	// Action The action that the step takes.
	Action  ImageCreateImportStepAction `json:"action"`
	Details struct {
		// Build Optional build-time options for when this image is built on pipeline run.
		Build *struct {
			// Args Build args passed into the container image build process during pipeline run.
			Args *map[string]string `json:"args"`
		} `json:"build,omitempty"`
		Name *string `json:"name"`

		// Override An override object to be used for a single image create request.
		Override *struct {
			// Target For image sources with `docker-hub` or `docker-registry` origin types. A target to be used for overridding the default target - should include an image and a tag.
			Target *string `json:"target"`

			// TargzUrl For image sources with `docker-file` origin types. A URL pointing to a .tar.gz file of a repo with a Dockerfile in it - can be used instead of linking Cycle directly to a repository.
			TargzUrl *string `json:"targz_url"`
		} `json:"override"`

		// Source An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Source FluidIdentifier `json:"source"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// ImageCreateImportStepAction The action that the step takes.
type ImageCreateImportStepAction string

// ImageCreateStep Settings for the image create step for a pipeline.
type ImageCreateStep struct {
	// Action The action that the step takes.
	Action  ImageCreateStepAction `json:"action"`
	Details struct {
		// Build Optional build-time options for when this image is built on pipeline run.
		Build *struct {
			// Args Build args passed into the container image build process during pipeline run.
			Args *map[string]string `json:"args"`
		} `json:"build,omitempty"`
		Name *string `json:"name"`

		// Override An override object to be used for a single image create request.
		Override *struct {
			// Target For image sources with `docker-hub` or `docker-registry` origin types. A target to be used for overridding the default target - should include an image and a tag.
			Target *string `json:"target"`

			// TargzUrl For image sources with `docker-file` origin types. A URL pointing to a .tar.gz file of a repo with a Dockerfile in it - can be used instead of linking Cycle directly to a repository.
			TargzUrl *string `json:"targz_url"`
		} `json:"override"`

		// Source An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Source FluidIdentifier `json:"source"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// ImageCreateStepAction The action that the step takes.
type ImageCreateStepAction string

// ImageImportStep Settings for the image import step for a pipeline.
type ImageImportStep struct {
	// Action The action that the step takes.
	Action  ImageImportStepAction `json:"action"`
	Details struct {
		// Image An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Image FluidIdentifier `json:"image"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// ImageImportStepAction The action that the step takes.
type ImageImportStepAction string

// ImageIncludes All includable resources linkable to the given image.
type ImageIncludes struct {
	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`

	// Integrations A resource that is associated with an integration.
	Integrations *IntegrationsIncludes `json:"integrations,omitempty"`

	// IntegrationsIdentifiers A map of identifiers to an array of resource IDs that are associated with it. All IDs point to the same type of resource.
	IntegrationsIdentifiers *IdentifierIncludes `json:"integrations:identifiers,omitempty"`

	// Sources A resource associated with an image source.
	Sources *ImageSourceIncludes `json:"sources,omitempty"`

	// SourcesIdentifiers A map of identifiers to an array of resource IDs that are associated with it. All IDs point to the same type of resource.
	SourcesIdentifiers *IdentifierIncludes `json:"sources:identifiers,omitempty"`

	// StackBuilds A resource that is associated with a stack build.
	StackBuilds *StackBuildIncludes `json:"stack_builds,omitempty"`

	// Stacks A resource associated with a stack.
	Stacks *StackIncludes `json:"stacks,omitempty"`

	// StacksIdentifiers A map of identifiers to an array of resource IDs that are associated with it. All IDs point to the same type of resource.
	StacksIdentifiers *IdentifierIncludes `json:"stacks:identifiers,omitempty"`
}

// ImageMeta A list of meta fields that can be applied to the image.
type ImageMeta struct {
	// ContainersCount A summary of resources by state
	ContainersCount *StateCountSummary `json:"containers_count,omitempty"`
}

// ImageOrigin The origin of the image.
type ImageOrigin struct {
	union json.RawMessage
}

// ImageSource An image source is a set of resources that direct the platform on where it can find the resources needed to build an image resource.
type ImageSource struct {
	// About Information about the image source resource.
	About *ImageSourceAbout `json:"about,omitempty"`
	Acl   *ACL              `json:"acl"`

	// Builder Configuration options regarding the builder used to create/import Images using this Image Source.
	Builder *struct {
		// IntegrationId The ID or Identifier of the Integration used to do the build.
		IntegrationId *HybridIdentifier `json:"integration_id"`
	} `json:"builder"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the image source's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`

	// Meta A list of meta fields that can be applied to this environment.
	Meta *ImageSourceMeta `json:"meta,omitempty"`

	// Name A name for the image source resource.
	Name string `json:"name"`

	// Origin The origin of the image.
	Origin ImageOrigin      `json:"origin"`
	State  ImageSourceState `json:"state"`

	// Type The type of images in this source.
	Type ImageSourceType `json:"type"`
}

// ImageSourceAbout Information about the image source resource.
type ImageSourceAbout struct {
	// Description Some information about the image source resource.
	Description *string `json:"description"`
}

// ImageSourceIncludes A resource associated with an image source.
type ImageSourceIncludes map[string]ImageSource

// ImageSourceMeta A list of meta fields that can be applied to this environment.
type ImageSourceMeta struct {
	ImagesCount *struct {
		State struct {
			// Building Number of images in this source with state building
			Building float32 `json:"building"`

			// Deleting Number of images in this source with state deleting
			Deleting float32 `json:"deleting"`

			// Downloading Number of images in this source with state downloading
			Downloading float32 `json:"downloading"`

			// Live Number of images in this source with state live
			Live float32 `json:"live"`

			// New Number of images in this source with state new
			New float32 `json:"new"`

			// Saving Number of images in this source with state saving
			Saving float32 `json:"saving"`

			// Verifying Number of images in this source with state verifying
			Verifying float32 `json:"verifying"`
		} `json:"state"`

		// Total Number of image sources
		Total float32 `json:"total"`
	} `json:"images_count,omitempty"`
}

// ImageSourceState defines model for ImageSourceState.
type ImageSourceState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the image source.
	Current ImageSourceStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// ImageSourceStateCurrent The current state of the image source.
type ImageSourceStateCurrent string

// ImageSourceType The type of images in this source.
type ImageSourceType string

// ImageState defines model for ImageState.
type ImageState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the image.
	Current ImageStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// ImageStateCurrent The current state of the image.
type ImageStateCurrent string

// ImageSummary A summary of the image this container was created from.
type ImageSummary struct {
	Extension *ContainerExtension `json:"extension"`
	Id        *ID                 `json:"id"`

	// Service If a service container, the identifier specifying which service it is.
	Service *ServiceContainerIdentifier `json:"service"`
}

// ImagesIncludes A resource associated with an image.
type ImagesIncludes map[string]Image

// ImagesPruneStep Settings for the images prune step for a pipeline.
type ImagesPruneStep struct {
	// Action The action that the step takes.
	Action  ImagesPruneStepAction `json:"action"`
	Details struct {
		SourceIds []ID `json:"source_ids"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// ImagesPruneStepAction The action that the step takes.
type ImagesPruneStepAction string

// Index An index that enables search in the portal
type Index struct {
	Containers   map[string]Component `json:"containers"`
	DnsZones     map[string]Component `json:"dns_zones"`
	Environments map[string]Component `json:"environments"`
	Generated    DateTime             `json:"generated"`

	// HubId Id describing the Hub
	HubId           string               `json:"hub_id"`
	ImageSources    map[string]Component `json:"image_sources"`
	Instances       map[string]Component `json:"instances"`
	Pipelines       map[string]Component `json:"pipelines"`
	Servers         map[string]Component `json:"servers"`
	Stacks          map[string]Component `json:"stacks"`
	VirtualMachines map[string]Component `json:"virtual_machines"`
}

// InfrastructureResourceSummary A summary of resource utilization/availability.
type InfrastructureResourceSummary struct {
	// Cpu Information about CPU resources.
	Cpu struct {
		// Cores The number of CPU cores.
		Cores int `json:"cores"`

		// ShareRatio The ratio of shares allocated to total shares.
		ShareRatio *int `json:"share_ratio,omitempty"`

		// Shares Information about CPU shares.
		Shares struct {
			// Allocated The number of shares allocated.
			Allocated int `json:"allocated"`

			// Total The total number of shares available.
			Total int `json:"total"`
		} `json:"shares"`
	} `json:"cpu"`

	// Ram Information about RAM Resources.
	Ram struct {
		// AllocatedMb The total amount of allocated RAM in MBs.
		AllocatedMb int `json:"allocated_mb"`

		// ProvisionedMb The total amount of provisioned RAM in MBs.
		ProvisionedMb *int `json:"provisioned_mb,omitempty"`

		// TotalMb The total amount of RAM in MBsr.
		TotalMb int `json:"total_mb"`

		// UsedMb The total amount of used RAM in MBs.
		UsedMb int `json:"used_mb"`
	} `json:"ram"`
}

// InfrastructureSummary An infrastructure summary resource.
type InfrastructureSummary struct {
	// Clusters Records pointing to information about clusters that make up this hubs infrastructure.
	Clusters map[string]struct {
		// Healthy Whether Cycle has determined this cluster to be healthy or not.
		Healthy bool `json:"healthy"`

		// Instances A summary of resources by state
		Instances StateCountSummary `json:"instances"`

		// Name The name of the cluster
		Name string `json:"name"`

		// Resources A summary of resource utilization/availability.
		Resources InfrastructureResourceSummary `json:"resources"`
		Servers   struct {
			Count     float32 `json:"count"`
			Providers map[string]struct {
				Count     float32         `json:"count"`
				Locations *map[string]int `json:"locations"`
				Models    *map[string]int `json:"models"`

				// Resources A summary of resource utilization/availability.
				Resources *InfrastructureResourceSummary `json:"resources,omitempty"`
			} `json:"providers"`

			// ServerIds IDs of all servers in this cluster.
			ServerIds *[]ID `json:"server_ids,omitempty"`
		} `json:"servers"`

		// Versions A count of servers in a cluster with the given version of Cycle software
		Versions ClusterVersionServerCount `json:"versions"`
	} `json:"clusters"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Images Statistics about image usage.
	Images struct {
		// Tier Image tier information.
		Tier struct {
			// AllocatedMb A value in MB representing the amount of allocated space for images.
			AllocatedMb int `json:"allocated_mb"`

			// TotalMb A value in MB representing the total MB of space on the infrastructure available for images.
			TotalMb int `json:"total_mb"`

			// UsedMb A value in MB representing the total MB of space images are taking up out of the total megabytes available.
			UsedMb int `json:"used_mb"`
		} `json:"tier"`
	} `json:"images"`

	// Servers The number of servers on the cluster
	Servers float32  `json:"servers"`
	Updated DateTime `json:"updated"`
}

// Instance An instance of a Container.
type Instance struct {
	Autoscale *InstanceAutoScale `json:"autoscale"`

	// ContainerId A container identifier for the container that is associated with this instance.
	ContainerId string `json:"container_id"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator    CreatorScope `json:"creator"`
	Deployment *Deployment  `json:"deployment"`

	// Environment Details about the environment network this instance is a member of.
	Environment EnvironmentNetworkSummary `json:"environment"`

	// Events A collection of timestamps for each event in the instance's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`
	Extension *ContainerExtension `json:"extension"`

	// Function If the instance is a function, additional details relating to its function properties
	Function *struct {
		// Seed The seed used for this function.
		Seed int `json:"seed"`
	} `json:"function,omitempty"`

	// Hostname The hostname of the instance.
	Hostname string `json:"hostname"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// LocationId A location identifier that's associated with the server this instance is deployed to.
	LocationId string             `json:"location_id"`
	Meta       *InstanceMeta      `json:"meta"`
	Migration  *InstanceMigration `json:"migration"`
	Provider   InstanceProvider   `json:"provider"`

	// PurgeTime The timestamp of when the instance was purged.
	PurgeTime *DateTime `json:"purge_time"`

	// ReadyState The state as it relates to the following. * `active` - instance can be started or stopped. * `purge` - instance should be deleted. * `hibernate` - instance is active but not allowed to run. * `configuring` - this instance is not allowed to start yet
	ReadyState InstanceReadyState `json:"ready_state"`

	// ServerId A 24 character hex string used to identify a unique resource.
	ServerId ID `json:"server_id"`

	// Service Identifier of a service Container within an Environment.
	Service *ServiceContainerIdentifier `json:"service,omitempty"`

	// State Information about the state of an instance.
	State InstanceState `json:"state"`

	// Stateful If the instance is stateful, additional details relating to its stateful properties.
	Stateful *struct {
		// BaseHostname The base hostname for the given instance.
		BaseHostname string `json:"base_hostname"`

		// Id A 24 character hex string used to identify a unique resource.
		Id ID `json:"id"`
	} `json:"stateful"`
	TrafficDrain *InstanceTrafficDrain `json:"traffic_drain"`
}

// InstanceReadyState The state as it relates to the following. * `active` - instance can be started or stopped. * `purge` - instance should be deleted. * `hibernate` - instance is active but not allowed to run. * `configuring` - this instance is not allowed to start yet
type InstanceReadyState string

// InstanceAutoScale Auto-scale details for instances created by auto-scale events.
type InstanceAutoScale struct {
	MinTtl DateTime `json:"min_ttl"`
}

// InstanceExtendVolumeAction defines model for InstanceExtendVolumeAction.
type InstanceExtendVolumeAction struct {
	// Action The name of the action to perform.
	Action   InstanceExtendVolumeActionAction `json:"action"`
	Contents struct {
		// ExtendSize A human-readable data size string. Values are expressed as an integer followed by a unit suffix, without spaces. Supported units:
		//   - b, k, m, g, t, p (bytes, kilobytes, megabytes, gigabytes, terabytes, petabytes)
		//   - An optional "b" suffix may be added (e.g., "mb", "gb").
		// Units are case-insensitive. Example: "512M", "10GB", "1t".
		ExtendSize DataSize `json:"extend_size"`

		// VolumeId The ID of the volume that will be extended through this task.
		VolumeId string `json:"volume_id"`
	} `json:"contents"`
}

// InstanceExtendVolumeActionAction The name of the action to perform.
type InstanceExtendVolumeActionAction string

// InstanceIncludes A resource associated with an instance.
type InstanceIncludes struct {
	// Containers A resource that is associated with a container.
	Containers *ContainersIncludes `json:"containers,omitempty"`

	// ContainersIdentifiers A map of identifiers to an array of resource IDs that are associated with it. All IDs point to the same type of resource.
	ContainersIdentifiers *IdentifierIncludes `json:"containers:identifiers,omitempty"`

	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`

	// Environments An identity that is associated with an environment.
	Environments *EnvironmentIncludes `json:"environments,omitempty"`

	// EnvironmentsIdentifiers A map of identifiers to an array of resource IDs that are associated with it. All IDs point to the same type of resource.
	EnvironmentsIdentifiers *IdentifierIncludes `json:"environments:identifiers,omitempty"`

	// Integrations A resource that is associated with an integration.
	Integrations *IntegrationsIncludes `json:"integrations,omitempty"`

	// IntegrationsIdentifiers A map of identifiers to an array of resource IDs that are associated with it. All IDs point to the same type of resource.
	IntegrationsIdentifiers *IdentifierIncludes `json:"integrations:identifiers,omitempty"`

	// Locations A resource that is associated with a provider location.
	Locations *LocationsIncludes `json:"locations,omitempty"`

	// Servers A resource that is associated with a server.
	Servers *ServersIncludes `json:"servers,omitempty"`
}

// InstanceMeta A list of meta fields that can be applied to an instance.
type InstanceMeta struct {
	Node *struct {
		Healthy     *bool      `json:"healthy,omitempty"`
		LastCheckin *DateTime  `json:"last_checkin,omitempty"`
		Online      *bool      `json:"online,omitempty"`
		State       *NodeState `json:"state,omitempty"`
	} `json:"node,omitempty"`
	SdnPoolIps *[]Ip `json:"sdn_pool_ips,omitempty"`
}

// InstanceMigrateAction defines model for InstanceMigrateAction.
type InstanceMigrateAction struct {
	// Action The name of the action to perform.
	Action   InstanceMigrateActionAction `json:"action"`
	Contents struct {
		// DestinationServerId The ID of the server being migrated to.
		DestinationServerId string `json:"destination_server_id"`

		// Stateful Information about additonal configuration settings used when migrating a stateful instance.
		Stateful *struct {
			// CopyVolumes A boolean where true represents the desire to copy the contents of the volume for a given stateful instance with the migration.
			CopyVolumes bool `json:"copy_volumes"`
		} `json:"stateful,omitempty"`
	} `json:"contents"`
}

// InstanceMigrateActionAction The name of the action to perform.
type InstanceMigrateActionAction string

// InstanceMigration Information regarding the migration of an instance, such as the server that the instance came from or the server that the instance was moved to.
type InstanceMigration struct {
	Completed *DateTime `json:"completed,omitempty"`

	// CopyVolumes A boolean where true represents the volumes for the instance should be copied to the new server as well.
	CopyVolumes bool               `json:"copy_volumes"`
	From        *MigrationInstance `json:"from"`

	// Key A key used by the platform to verify the migration.
	Key     string             `json:"key"`
	Started *DateTime          `json:"started,omitempty"`
	To      *MigrationInstance `json:"to"`
}

// InstanceProvider defines model for InstanceProvider.
type InstanceProvider struct {
	// IntegrationId A 24 character hex string used to identify a unique resource.
	IntegrationId ID `json:"integration_id"`

	// Location The identifier of the location related to the server this instance runs on.
	Location string `json:"location"`

	// Vendor The vendor of the hub provider integration related to the server this instance runs on.
	Vendor string `json:"vendor"`
}

// InstanceRevertMigrationAction defines model for InstanceRevertMigrationAction.
type InstanceRevertMigrationAction struct {
	// Action The name of the action to perform.
	Action InstanceRevertMigrationActionAction `json:"action"`
}

// InstanceRevertMigrationActionAction The name of the action to perform.
type InstanceRevertMigrationActionAction string

// InstanceState defines model for InstanceState.
type InstanceState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the instance.
	Current InstanceStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`

	// Health information about the health of the instance.
	Health *struct {
		// Healthy Describes the healthiness of the instance. Health checks can be configured at the container level.
		// - `true`: The instance is considered healthy.
		// - `false`: The instance is considered unhealthy.
		// - `null`: The instance has not yet reported its health, or a health check has not yet been performed.
		Healthy *bool    `json:"healthy"`
		Updated DateTime `json:"updated"`
	} `json:"health"`
}

// InstanceStateCurrent The current state of the instance.
type InstanceStateCurrent string

// InstanceTask defines model for InstanceTask.
type InstanceTask struct {
	union json.RawMessage
}

// InstanceTelemetryReport An Instance telemetry report.
type InstanceTelemetryReport struct {
	// Request A summary of report requests and when they occured.
	Request TelemetryReportRequest `json:"request"`

	// Snapshots An array of telemetry snapshots.
	Snapshots []ResourceSnapshot `json:"snapshots"`
}

// InstanceTrafficDrain Traffic drain details for instance.
type InstanceTrafficDrain struct {
	Started DateTime `json:"started"`
}

// InstanceTrafficDrainReconfigure defines model for InstanceTrafficDrainReconfigure.
type InstanceTrafficDrainReconfigure struct {
	// Action The name of the action to perform.
	Action   InstanceTrafficDrainReconfigureAction `json:"action"`
	Contents struct {
		// Enable Enable or disable traffic drain for the instance.
		Enable bool `json:"enable"`
	} `json:"contents"`
}

// InstanceTrafficDrainReconfigureAction The name of the action to perform.
type InstanceTrafficDrainReconfigureAction string

// InstanceVolume A container instance volume resource.
type InstanceVolume struct {
	// Config Configuration settings for container volumes.
	Config ContainerVolume `json:"config"`

	// Deployed A deployed volume resource.
	Deployed *DeployedVolume `json:"deployed,omitempty"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Sftp Information about connecting to a instance volume over SFTP.
	Sftp *SFTP `json:"sftp,omitempty"`
}

// Integration defines model for Integration.
type Integration struct {
	// Auth Authentication information for the integration, can be null.
	Auth *IntegrationAuth `json:"auth"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the integration's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// Extra Updated key-value pairs associated with the integration.
	Extra *map[string]string `json:"extra"`

	// HubId A 24 character hex string used to identify a unique resource.
	HubId ID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier       `json:"identifier"`
	Meta       *IntegrationMeta `json:"meta"`

	// Name Name of the integration.
	Name  string           `json:"name"`
	State IntegrationState `json:"state"`

	// Vendor Which vendor this integration is associated with.
	Vendor string `json:"vendor"`
}

// IntegrationAdvancedOptionBoolean defines model for IntegrationAdvancedOptionBoolean.
type IntegrationAdvancedOptionBoolean struct {
	Default *bool                                `json:"default"`
	Key     string                               `json:"key"`
	Title   string                               `json:"title"`
	Type    IntegrationAdvancedOptionBooleanType `json:"type"`
}

// IntegrationAdvancedOptionBooleanType defines model for IntegrationAdvancedOptionBoolean.Type.
type IntegrationAdvancedOptionBooleanType string

// IntegrationAdvancedOptionInt defines model for IntegrationAdvancedOptionInt.
type IntegrationAdvancedOptionInt struct {
	Default *int                             `json:"default"`
	Key     string                           `json:"key"`
	Title   string                           `json:"title"`
	Type    IntegrationAdvancedOptionIntType `json:"type"`
}

// IntegrationAdvancedOptionIntType defines model for IntegrationAdvancedOptionInt.Type.
type IntegrationAdvancedOptionIntType string

// IntegrationAdvancedOptionString defines model for IntegrationAdvancedOptionString.
type IntegrationAdvancedOptionString struct {
	Default *string                             `json:"default"`
	Key     string                              `json:"key"`
	Title   string                              `json:"title"`
	Type    IntegrationAdvancedOptionStringType `json:"type"`
}

// IntegrationAdvancedOptionStringType defines model for IntegrationAdvancedOptionString.Type.
type IntegrationAdvancedOptionStringType string

// IntegrationAuth defines model for IntegrationAuth.
type IntegrationAuth struct {
	// ApiKey API key for accessing the Integration.
	ApiKey *string `json:"api_key"`

	// Base64Config Base64 encoded configuration for the Integration.
	Base64Config *string `json:"base64_config"`

	// ClientId Client ID for the Integration.
	ClientId *string `json:"client_id"`

	// KeyId Key ID for accessing the Integration.
	KeyId *string `json:"key_id"`

	// Namespace The namespace associated with the Integration.
	Namespace *string `json:"namespace"`

	// Region The region associated with the Integration.
	Region *string `json:"region"`

	// Secret Secret for accessing the Integration.
	Secret *string `json:"secret"`

	// SubscriptionId Subscription ID for the Integration.
	SubscriptionId *string `json:"subscription_id"`
}

// IntegrationDefinition Describes an integration for a Cycle hub that can be enabled by the hub owner.
type IntegrationDefinition struct {
	// Deprecated If true, this integration is no longer being supported and may be removed in the future. New instances of this integration will not be able to be created.
	Deprecated *bool `json:"deprecated,omitempty"`

	// Editable If true, the integration can be edited. Otherwise, to make a change it will need to be deleted and recreated.
	Editable bool `json:"editable"`

	// ExtendedConfiguration Additional configuration options that are available when using this integration. These describe additional functionality that Cycle may utilize.
	ExtendedConfiguration *struct {
		Options *[]IntegrationDefinition_ExtendedConfiguration_Options_Item `json:"options"`
	} `json:"extended_configuration"`

	// Extends A list of functionality that this integration extends. i.e. ["backups"]
	Extends *[]string `json:"extends"`

	// Features A list of additional features supported by this integration.
	Features *[]string `json:"features"`
	Fields   *struct {
		Auth  *map[string]IntegrationDefinitionField `json:"auth"`
		Extra *map[string]IntegrationDefinitionField `json:"extra"`
	} `json:"fields,omitempty"`
	Name                 string `json:"name"`
	Public               bool   `json:"public"`
	SupportsMultiple     bool   `json:"supports_multiple"`
	SupportsVerification bool   `json:"supports_verification"`
	Url                  string `json:"url"`

	// Usable Whether or not this integration can be used at this time.
	Usable bool   `json:"usable"`
	Vendor string `json:"vendor"`
}

// IntegrationDefinition_ExtendedConfiguration_Options_Item defines model for IntegrationDefinition.ExtendedConfiguration.Options.Item.
type IntegrationDefinition_ExtendedConfiguration_Options_Item struct {
	union json.RawMessage
}

// IntegrationDefinitionField defines model for IntegrationDefinitionField.
type IntegrationDefinitionField struct {
	Description *string                         `json:"description,omitempty"`
	Name        string                          `json:"name"`
	Options     *[]string                       `json:"options"`
	Regex       *string                         `json:"regex"`
	Required    bool                            `json:"required"`
	Type        *IntegrationDefinitionFieldType `json:"type,omitempty"`
}

// IntegrationDefinitionFieldType defines model for IntegrationDefinitionField.Type.
type IntegrationDefinitionFieldType string

// IntegrationMeta Additional fields that can be requested for an Integration on fetch.
type IntegrationMeta struct {
	// Definition Describes an integration for a Cycle hub that can be enabled by the hub owner.
	Definition *IntegrationDefinition `json:"definition,omitempty"`
}

// IntegrationState defines model for IntegrationState.
type IntegrationState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the integration.
	Current IntegrationStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// IntegrationStateCurrent The current state of the integration.
type IntegrationStateCurrent string

// IntegrationsIncludes A resource that is associated with an integration.
type IntegrationsIncludes map[string]Integration

// Invitation Information about a hub membership invitation.
type Invitation struct {
	// Events A collection of timestamps for each event in the invitation's lifetime.
	Events struct {
		Accepted DateTime `json:"accepted"`
		Created  DateTime `json:"created"`
		Declined DateTime `json:"declined"`
		Deleted  DateTime `json:"deleted"`
		Revoked  DateTime `json:"revoked"`
		Updated  DateTime `json:"updated"`
	} `json:"events"`

	// Recipient The email address for the invitations recipient.
	Recipient string `json:"recipient"`

	// Sender Information about the origin account of the invitation.
	Sender struct {
		// Id A 24 character hex string used to identify a unique resource.
		Id ID `json:"id"`

		// Type The account type.
		Type string `json:"type"`
	} `json:"sender"`
}

// Invoice Information about a billing invoice.
type Invoice struct {
	// Approved A boolean where true represents the invoice is approved for collection.
	Approved bool `json:"approved"`

	// BillingContact The contact to whom invoices are billed.
	BillingContact *HubBillingContact `json:"billing_contact,omitempty"`

	// Charges The amount in charges generated through the licesnse agreement + overages for the billing period covered by the invoice.
	Charges int              `json:"charges"`
	Credits *[]InvoiceCredit `json:"credits"`
	Due     *DateTime        `json:"due,omitempty"`

	// Events A collection of timestamps for each event in the billing order's lifetime.
	Events struct {
		Billed         DateTime  `json:"billed"`
		Created        DateTime  `json:"created"`
		Credited       DateTime  `json:"credited"`
		Deleted        DateTime  `json:"deleted"`
		Paid           DateTime  `json:"paid"`
		PaymentAttempt *DateTime `json:"payment_attempt,omitempty"`
		Updated        DateTime  `json:"updated"`
		Voided         DateTime  `json:"voided"`
	} `json:"events"`

	// FailedPaymentAttempts The number of failed payment attempts for the invoice.
	FailedPaymentAttempts int `json:"failed_payment_attempts"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id       ID         `json:"id"`
	LateFees *[]LateFee `json:"late_fees"`

	// Meta A list of meta fields that can be applied to a invoice.
	Meta     *InvoiceMeta      `json:"meta,omitempty"`
	Overdue  *DateTime         `json:"overdue,omitempty"`
	Payments *[]Payment        `json:"payments"`
	Services *[]BillingSummary `json:"services"`
	State    InvoiceState      `json:"state"`
}

// InvoiceCredit A billing credit for a specific invoice.
type InvoiceCredit struct {
	// Amount The amount of credit for the invoice.
	Amount int `json:"amount"`

	// AssociatedCredit Credit associated with an invoice.
	AssociatedCredit struct {
		// Amount The amount of the credit.
		Amount int `json:"amount"`

		// Id A 24 character hex string used to identify a unique resource.
		Id ID `json:"id"`
	} `json:"associated_credit"`

	// Description A description of the invoice credit.
	Description string `json:"description"`

	// Id A 24 character hex string used to identify a unique resource.
	Id   ID       `json:"id"`
	Time DateTime `json:"time"`
}

// InvoiceMeta A list of meta fields that can be applied to a invoice.
type InvoiceMeta struct {
	// Due The amount due for a given invoice.
	Due *int `json:"due,omitempty"`

	// Hub A hub resource.
	Hub *Hub `json:"hub,omitempty"`
}

// InvoiceState defines model for InvoiceState.
type InvoiceState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the invoice.
	Current InvoiceStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// InvoiceStateCurrent The current state of the invoice.
type InvoiceStateCurrent string

// Ip Details about an IP.
type Ip struct {
	// Address The IP address.
	Address string `json:"address"`

	// Assignment Information about the assignment of this IP.
	Assignment *struct {
		// ContainerId A 24 character hex string used to identify a unique resource.
		ContainerId ID `json:"container_id"`

		// EnvironmentId A 24 character hex string used to identify a unique resource.
		EnvironmentId ID `json:"environment_id"`

		// InstanceId A 24 character hex string used to identify a unique resource.
		InstanceId ID `json:"instance_id"`

		// VirtualMachine Details about the virtual machine this IP is assigned to.
		VirtualMachine *struct {
			// Id A 24 character hex string used to identify a unique resource.
			Id ID `json:"id"`
		} `json:"virtual_machine,omitempty"`
	} `json:"assignment"`

	// Cidr The CIDR for the IP.
	Cidr string `json:"cidr"`

	// Gateway The IP gateway.
	Gateway string `json:"gateway"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Ip An IP address is a numerical label that uniquely identifies a device on a network and enables it to send and receive data.
	Ip IpAddress `json:"ip"`

	// Kind The type of IP protocol this IP is.
	Kind IpKind `json:"kind"`

	// Network A CIDR (Classless Inter-Domain Routing) string is a notation used to represent an IP address and its associated network prefix.
	// It combines an IP address with a suffix that indicates how many bits are fixed for routing.
	Network *Cidr `json:"network,omitempty"`

	// NetworkId A 24 character hex string used to identify a unique resource.
	NetworkId ID `json:"network_id"`

	// Options Options for an IP.
	Options *IpOptions `json:"options,omitempty"`

	// PoolId A 24 character hex string used to identify a unique resource.
	PoolId ID      `json:"pool_id"`
	State  IpState `json:"state"`
}

// IpKind The type of IP protocol this IP is.
type IpKind string

// IpAddress An IP address is a numerical label that uniquely identifies a device on a network and enables it to send and receive data.
type IpAddress = string

// IpOptions Options for an IP.
type IpOptions struct {
	// ProxyArp If enabled, allows pool to respond to ARP requests, on behalf of a container / virtual machine, at the host level.
	ProxyArp *bool `json:"proxy_arp"`
}

// IpPool An IP Pool
type IpPool struct {
	// Block Network information about the pool.
	Block struct {
		// Cidr A cidr for the pool.
		Cidr string `json:"cidr"`

		// Gateway A gateway for the pool.
		Gateway string `json:"gateway"`

		// Network A CIDR (Classless Inter-Domain Routing) string is a notation used to represent an IP address and its associated network prefix.
		// It combines an IP address with a suffix that indicates how many bits are fixed for routing.
		Network *Cidr `json:"network,omitempty"`
	} `json:"block"`

	// Floating A boolean where true represents the pool as a floating IP pool.
	Floating bool `json:"floating"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Ips Data about IPs in the pool.
	Ips struct {
		// Available Of the total number of IP's how many are available to be assigned.
		Available int `json:"available"`

		// Total The total number of IPs in the pool.
		Total int `json:"total"`
	} `json:"ips"`

	// Kind The type of IP pool.
	Kind IpPoolKind `json:"kind"`

	// LocationId An ID associated with a location resource.
	LocationId string `json:"location_id"`

	// Options Options for an IP.
	Options *IpOptions `json:"options,omitempty"`

	// Provider A IP Pool provider.
	Provider IpPoolProvider `json:"provider"`

	// ServerId An ID associated with a server resource.
	ServerId string      `json:"server_id"`
	State    IpPoolState `json:"state"`
}

// IpPoolKind The type of IP pool.
type IpPoolKind string

// IpPoolIncludes Resources associated with an IP Pool.
type IpPoolIncludes struct {
	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`

	// Integrations A resource that is associated with an integration.
	Integrations *IntegrationsIncludes `json:"integrations,omitempty"`

	// Locations A resource that is associated with a provider location.
	Locations *LocationsIncludes `json:"locations,omitempty"`

	// Servers A resource that is associated with a server.
	Servers *ServersIncludes `json:"servers,omitempty"`
}

// IpPoolInitializeAction defines model for IpPoolInitializeAction.
type IpPoolInitializeAction struct {
	// Action The action to take.
	Action IpPoolInitializeActionAction `json:"action"`
}

// IpPoolInitializeActionAction The action to take.
type IpPoolInitializeActionAction string

// IpPoolProvider A IP Pool provider.
type IpPoolProvider struct {
	// IntegrationId A 24 character hex string used to identify a unique resource.
	IntegrationId ID `json:"integration_id"`

	// Location Information about the location of the provider this pool is associated with.
	Location string `json:"location"`

	// Reservation A reservation identifier associated with the pool reservation.
	Reservation string `json:"reservation"`

	// Server A server identifier associated with the pool.
	Server string `json:"server"`

	// ServerAssignment An identifier linked to the server assingment of the IP pool.
	ServerAssignment string `json:"server_assignment"`

	// Vendor A vendor for a provider.
	Vendor string `json:"vendor"`
}

// IpPoolReconfigureOptionsAction defines model for IpPoolReconfigureOptionsAction.
type IpPoolReconfigureOptionsAction struct {
	// Action The action to take.
	Action IpPoolReconfigureOptionsActionAction `json:"action"`

	// Contents Options for an IP.
	Contents *IpOptions `json:"contents,omitempty"`
}

// IpPoolReconfigureOptionsActionAction The action to take.
type IpPoolReconfigureOptionsActionAction string

// IpPoolState defines model for IpPoolState.
type IpPoolState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the pool.
	Current IpPoolStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// IpPoolStateCurrent The current state of the pool.
type IpPoolStateCurrent string

// IpPoolTask defines model for IpPoolTask.
type IpPoolTask struct {
	union json.RawMessage
}

// IpState defines model for IpState.
type IpState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the IP.
	Current IpStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// IpStateCurrent The current state of the IP.
type IpStateCurrent string

// Job A job resource.
type Job struct {
	// Caption A short description of the job.
	Caption string `json:"caption"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the job's lifetime.
	Events struct {
		Completed DateTime `json:"completed"`
		Queued    DateTime `json:"queued"`
		Started   DateTime `json:"started"`
	} `json:"events"`
	Expires DateTime `json:"expires"`

	// Hash A combination of the individual task details and job details.
	Hash string `json:"hash"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// LimitDuplicates A boolean where true represents the job is set to prevent duplicates of itself quickly after creation.
	LimitDuplicates bool `json:"limit_duplicates"`

	// Queue A dash separated string showing the environment_id where the job is taking place.
	Queue    string   `json:"queue"`
	Schedule DateTime `json:"schedule"`
	State    JobState `json:"state"`

	// Tasks An array of job tasks.
	Tasks []JobTask `json:"tasks"`
}

// JobDescriptor A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
type JobDescriptor struct {
	// Action The action that was taken.
	Action string `json:"action"`

	// Job Contains some basic information about the job associated with this task.
	Job *struct {
		// Accepted Describes if the job has been accepted
		Accepted bool `json:"accepted"`

		// Id The ID of the job
		Id       string `json:"id"`
		Parallel struct {
			SubQueue *string `json:"sub_queue"`
			Tasks    bool    `json:"tasks"`
		} `json:"parallel"`

		// Queue Describes the queue this job is a part of.
		Queue    string   `json:"queue"`
		Schedule DateTime `json:"schedule"`
		Tasks    *[]struct {
			// Caption A short description of the task.
			Caption string `json:"caption"`

			// Header The API function called.
			Header string `json:"header"`

			// Input Input information used for the job tasks.
			Input map[string]interface{} `json:"input"`

			// Steps An array of job task steps.
			Steps *[]TaskStep `json:"steps"`
		} `json:"tasks"`
	} `json:"job,omitempty"`
}

// JobIncludes defines model for JobIncludes.
type JobIncludes struct {
	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`
}

// JobState defines model for JobState.
type JobState struct {
	Changed *DateTime `json:"changed,omitempty"`

	// Current The current state of the job.
	Current JobStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this job.
	Error *struct {
		// Message Details about the error that has occurred.
		Message string `json:"message"`
	} `json:"error"`
}

// JobStateCurrent The current state of the job.
type JobStateCurrent string

// JobTask Information about a job task.
type JobTask struct {
	// Caption A short description of the task.
	Caption string `json:"caption"`

	// Error An error object describing issues with the job.
	Error *struct {
		// Message An error message
		Message string `json:"message"`
	} `json:"error"`

	// Events A collection of timestamps for each event in the job's lifetime.
	Events struct {
		Completed DateTime `json:"completed"`
		Queued    DateTime `json:"queued"`
		Started   DateTime `json:"started"`
	} `json:"events"`

	// Header The API function called.
	Header string `json:"header"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Input Input information used for the job tasks.
	Input map[string]interface{} `json:"input"`

	// Output Output informaiton used for the job tasks.
	Output *map[string]string `json:"output"`
	State  TaskState          `json:"state"`

	// Steps An array of job task steps.
	Steps *[]TaskStep `json:"steps"`
}

// L2Domain A standardized name for different layer-2 networks that can be configured on virtual provider hosts.
//
//	Containers will utilize this name to determine which network to attach to on the host, if set in the config.
type L2Domain string

// LateFee A late fee, applied to an invoice.
type LateFee struct {
	// Amount 1/10th of a cent.
	Amount int `json:"amount"`

	// Description A description of the late fee.
	Description string `json:"description"`

	// Id A 24 character hex string used to identify a unique resource.
	Id   ID       `json:"id"`
	Time DateTime `json:"time"`
}

// LegacyNetwork Legacy network information for an environment.
type LegacyNetwork struct {
	// Ipv4 IPv4 information available from environments using legacy networking.
	Ipv4 *IPNet `json:"ipv4"`

	// Subnet The IPv4 subnet id.
	Subnet int `json:"subnet"`
}

// LoadBalancerConfig The config object for the loadbalancer service.
type LoadBalancerConfig struct {
	union json.RawMessage
}

// LoadBalancerEnvironmentService Information about the environments loadbalancer service(s).
type LoadBalancerEnvironmentService struct {
	// AutoUpdate A boolean representing if this service container is set to autoupdate or not
	AutoUpdate *bool               `json:"auto_update,omitempty"`
	Config     *LoadBalancerConfig `json:"config"`

	// ContainerId The ID of the loadbalancer service container
	ContainerId *string `json:"container_id"`

	// Enable Whether or not the loadbalancer service is enabled.
	Enable bool `json:"enable"`

	// HighAvailability A boolean representing if this service container is set to high availability mode or not.
	HighAvailability bool `json:"high_availability"`
}

// LoadBalancerLatestControllers Information about the latest controllers that generated traffic.
type LoadBalancerLatestControllers struct {
	Controllers *[]LoadBalancerLatestTelemetryController `json:"controllers"`
	Created     DateTime                                 `json:"created"`
}

// LoadBalancerLatestTelemetry Snapshots of the latest load balancer telemetry
type LoadBalancerLatestTelemetry struct {
	Controllers *[]LoadBalancerLatestTelemetryController `json:"controllers"`
	Created     DateTime                                 `json:"created"`
}

// LoadBalancerLatestTelemetryController defines model for LoadBalancerLatestTelemetryController.
type LoadBalancerLatestTelemetryController struct {
	// Controller A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Controller Identifier                             `json:"controller"`
	Instances  *[]LoadBalancerLatestTelemetryInstance `json:"instances"`
	Time       DateTime                               `json:"time"`
}

// LoadBalancerLatestTelemetryInstance Detailed telemetry for a load balancer instance at a point in time.
type LoadBalancerLatestTelemetryInstance struct {
	// Cluster A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Cluster Identifier `json:"cluster"`

	// ContainerId A 24 character hex string used to identify a unique resource.
	ContainerId ID `json:"container_id"`

	// Controller A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Controller Identifier `json:"controller"`

	// EnvironmentId A 24 character hex string used to identify a unique resource.
	EnvironmentId ID `json:"environment_id"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// InstanceId A 24 character hex string used to identify a unique resource.
	InstanceId ID                             `json:"instance_id"`
	Latest     *LoadBalancerTelemetrySnapshot `json:"latest"`

	// ServerId A 24 character hex string used to identify a unique resource.
	ServerId  ID                               `json:"server_id"`
	Snapshots *[]LoadBalancerTelemetrySnapshot `json:"snapshots"`
	Time      DateTime                         `json:"time"`
}

// LoadBalancerTelemetryControllerMetrics defines model for LoadBalancerTelemetryControllerMetrics.
type LoadBalancerTelemetryControllerMetrics struct {
	BytesReceived    int `json:"bytes_received"`
	BytesTransmitted int `json:"bytes_transmitted"`
	Connections      int `json:"connections"`
	Disconnects      struct {
		DestinationUnavailable int `json:"destination_unavailable"`
		NoError                int `json:"no_error"`
		RequestInvalid         int `json:"request_invalid"`
		RouterNomatch          int `json:"router_nomatch"`
		RouterNone             int `json:"router_none"`
		TimeoutIdle            int `json:"timeout_idle"`
		UnknownError           int `json:"unknown_error"`
	} `json:"disconnects"`
	Requests int `json:"requests"`
}

// LoadBalancerTelemetryReport Aggregated load balancer telemetry across all instances for a given range.
type LoadBalancerTelemetryReport struct {
	Created DateTime `json:"created"`

	// Range A start and end date-time pair indicating a range of time
	Range     Range `json:"range"`
	Snapshots *[]struct {
		// Controller A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
		// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
		// have the identifier of `my-container` and is automatically created by the platform.
		//
		// The identifier does not have to be unique.
		Controller Identifier                             `json:"controller"`
		Metrics    LoadBalancerTelemetryControllerMetrics `json:"metrics"`
		Time       DateTime                               `json:"time"`
	} `json:"snapshots"`
}

// LoadBalancerTelemetryRouterMetrics defines model for LoadBalancerTelemetryRouterMetrics.
type LoadBalancerTelemetryRouterMetrics struct {
	Destinations map[string]struct {
		Connections *struct {
			BytesReceived    *int            `json:"bytes_received,omitempty"`
			BytesTransmitted *int            `json:"bytes_transmitted,omitempty"`
			Errors           *map[string]int `json:"errors,omitempty"`
			Success          int             `json:"success"`
			Unavailable      int             `json:"unavailable"`
		} `json:"connections"`
		ContainerId string `json:"container_id"`
		InstanceId  string `json:"instance_id"`
		LatencyMs   *[]int `json:"latency_ms,omitempty"`
		Requests    *struct {
			Errors    *map[string]int `json:"errors,omitempty"`
			Responses *map[string]int `json:"responses,omitempty"`
			Total     int             `json:"total"`
		} `json:"requests"`
	} `json:"destinations"`
}

// LoadBalancerTelemetrySnapshot defines model for LoadBalancerTelemetrySnapshot.
type LoadBalancerTelemetrySnapshot struct {
	Cumulative struct {
		Metrics LoadBalancerTelemetryControllerMetrics `json:"metrics"`
		Router  *LoadBalancerTelemetryRouterMetrics    `json:"router"`
		Urls    *LoadBalancerTelemetryUrlMetrics       `json:"urls"`
	} `json:"cumulative"`
	Current struct {
		Metrics LoadBalancerTelemetryControllerMetrics `json:"metrics"`
		Router  *LoadBalancerTelemetryRouterMetrics    `json:"router"`
		Urls    *LoadBalancerTelemetryUrlMetrics       `json:"urls"`
	} `json:"current"`
	DatasetId int      `json:"dataset_id"`
	Started   DateTime `json:"started"`
	Time      DateTime `json:"time"`
	Version   *string  `json:"version,omitempty"`
}

// LoadBalancerTelemetryUrlMetrics defines model for LoadBalancerTelemetryUrlMetrics.
type LoadBalancerTelemetryUrlMetrics struct {
	Destinations map[string]struct {
		Requests *struct {
			// Errors An object where the key is the error type and the value is the number of hits with that error.
			Errors *map[string]int `json:"errors,omitempty"`

			// Handlers An object describing the relative breakdown of proxy, cache, forward, and redirect URL responses.
			Handlers struct {
				Cache    LoadBalancerTelemetryUrlRequestHandler `json:"cache"`
				Forward  LoadBalancerTelemetryUrlRequestHandler `json:"forward"`
				Proxy    LoadBalancerTelemetryUrlRequestHandler `json:"proxy"`
				Redirect LoadBalancerTelemetryUrlRequestHandler `json:"redirect"`
			} `json:"handlers"`

			// Host The host name of the URL request.
			Host    string   `json:"host"`
			LastHit DateTime `json:"last_hit"`

			// Method The HTTP method of the URL request.
			Method string `json:"method"`

			// Path The path portion of the inbound URL request.
			Path string `json:"path"`

			// Responses An object where the key is the response type and the value is the number of hits with that response.
			Responses *map[string]int `json:"responses,omitempty"`

			// Total The number of requests to a this URL.
			Total int `json:"total"`
		} `json:"requests"`
	} `json:"destinations"`
}

// LoadBalancerTelemetryUrlRequestHandler defines model for LoadBalancerTelemetryUrlRequestHandler.
type LoadBalancerTelemetryUrlRequestHandler struct {
	// Hits The number of hits to a specific URL handler.
	Hits int `json:"hits"`

	// TimingMs The cumulative ms of response time across all hits.
	TimingMs int `json:"timing_ms"`
}

// LocationsIncludes A resource that is associated with a provider location.
type LocationsIncludes map[string]ProviderLocation

// LogFormat defines model for LogFormat.
type LogFormat string

// LogLine A log line is point in time data output from a container instance.
type LogLine struct {
	// ContextWindow A randomly generated ID that is assigned to all lines in the same context window.
	// The first line with a specific ID is the log line that matches the query, and the following
	// log lines are included due to the the set context window in the aggregate.
	ContextWindow *string `json:"context_window,omitempty"`

	// InstanceId The container instance that the log line originated from.
	InstanceId *string `json:"instance_id"`

	// Message The message associated with the log line.
	Message string `json:"message"`

	// Source The source that generated the log line.
	Source string   `json:"source"`
	Time   DateTime `json:"time"`
}

// Mandate Information about the creator of a payment method for compliance purposes.
type Mandate struct {
	Accepted DateTime `json:"accepted"`

	// Email The email associated with the account that accepted the mandate
	Email string `json:"email"`

	// Ip The IP address at the time the mandate was accepted.
	Ip string `json:"ip"`

	// UserAgent The user agent of the browser when the mandate was accepted.
	UserAgent string `json:"user_agent"`
}

// MembershipState defines model for MembershipState.
type MembershipState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the membership.
	Current MembershipStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// MembershipStateCurrent The current state of the membership.
type MembershipStateCurrent string

// MemoryData defines model for MemoryData.
type MemoryData struct {
	// FailCount The number of times the memory liimit was exceeded for the instance.
	FailCount *float32 `json:"fail_count,omitempty"`

	// Limit The maximum number of bytes of memory this instance has acess to.
	Limit *float32 `json:"limit,omitempty"`

	// MaxUsage The highest amoun tof memory usage since the last restart.
	MaxUsage *float32 `json:"max_usage,omitempty"`

	// Usage The number in bytes of memory being used by the instance at the time of the snapshot.
	Usage *float32 `json:"usage,omitempty"`
}

// MemorySnapshot A snapshot of memory usage statistics.
type MemorySnapshot struct {
	// Cache The number of bytes of page cache memory being used by this instance.
	Cache          *float32    `json:"cache,omitempty"`
	KernelTcpUsage *MemoryData `json:"kernel_tcp_usage,omitempty"`
	KernelUsage    *MemoryData `json:"kernel_usage,omitempty"`
	SwapUsage      *MemoryData `json:"swap_usage,omitempty"`
	Usage          *MemoryData `json:"usage,omitempty"`
}

// MemorySpec Information about the memory resources of a given server.
type MemorySpec struct {
	// Extra Extra inforamtion about the memory resources.
	Extra map[string]string `json:"extra"`

	// SizeGb A number that represents the memory resources in GB.
	SizeGb int `json:"size_gb"`

	// Type The type of the memory resources.
	Type string `json:"type"`
}

// Method Information about a billing method, usable to pay invoices.
type Method struct {
	// Address Address information for a given billing method.
	Address Address `json:"address"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the credit card's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Mandate Information about the creator of a payment method for compliance purposes.
	Mandate *Mandate `json:"mandate,omitempty"`

	// Name A name for the billing method.
	Name string `json:"name"`

	// Primary A boolean where true represents this billing method is set to primary for a given hub.
	Primary bool `json:"primary"`

	// Source The underlying source (credit card, bank account, etc) used by a payment method.
	Source MethodSource `json:"source"`
	State  struct {
		Changed DateTime `json:"changed"`

		// Current The current state of the method.
		Current MethodStateCurrent `json:"current"`

		// Error An error, if any, that has occurred for this resource.
		Error *struct {
			// Message Details about the error that has occurred.
			Message *string   `json:"message,omitempty"`
			Time    *DateTime `json:"time,omitempty"`
		} `json:"error,omitempty"`
	} `json:"state"`
}

// MethodStateCurrent The current state of the method.
type MethodStateCurrent string

// MethodSource The underlying source (credit card, bank account, etc) used by a payment method.
type MethodSource struct {
	union json.RawMessage
}

// Metric A granular point-in-time measurement of a value, and its associated metadata. Metrics may contain multiple data points collected between submission to the platform.
type Metric struct {
	// Labels Additional key-values that can be used for querying in an aggregation pipeline. Often useful for filtering.
	Labels *map[string]string `json:"labels,omitempty"`

	// Metadata Information about this metric, such as the type of metric, the data it represents, and critical common information such as hub ID and associated cluster.
	Metadata struct {
		// Cluster The cluster associated with this metric
		Cluster *string `json:"cluster"`

		// Component The specific resource ID and type associated with this metric.
		Component *struct {
			// Id A 24 character hex string used to identify a unique resource.
			Id   ID     `json:"id"`
			Type string `json:"type"`
		} `json:"component"`

		// HubId A 24 character hex string used to identify a unique resource.
		HubId *ID `json:"hub_id,omitempty"`

		// Metric The data this metric represents. Cycle provides several built-in metrics, and, tier allowing, hubs can submit custom metrics as well.
		//
		// Here is a non-exhaustive list of some of the metrics provided by the platform automatically:
		//   - container.instances.num
		//   - discovery.resolutions.cache_hits
		//   - discovery.resolutions.lookups
		//   - discovery.resolutions.not-founds
		//   - environment.containers.num
		//   - environment.instances.num
		//   - environments.num
		//   - images.num
		//   - images.storage_kb
		//   - infrastructure.resources.cpu.cores
		//   - infrastructure.resources.cpu.usage.idle
		//   - infrastructure.resources.cpu.usage.iowait
		//   - infrastructure.resources.cpu.usage.nice
		//   - infrastructure.resources.cpu.usage.soft_irq
		//   - infrastructure.resources.cpu.usage.steal
		//   - infrastructure.resources.cpu.usage.system
		//   - infrastructure.resources.cpu.usage.user
		//   - infrastructure.resources.ram.available_kb
		//   - infrastructure.resources.ram.free_kb
		//   - infrastructure.resources.ram.total_kb
		//   - infrastructure.servers.num
		//   - lb.controller.connections
		//   - lb.controller.disconnects.destination_unavailable
		//   - lb.controller.disconnects.no_error
		//   - lb.controller.disconnects.timeout_idle
		//   - lb.controller.disconnects.timeout_init
		//   - lb.controller.disconnects.total
		//   - lb.controller.disconnects.unknown_error
		//   - lb.controller.received_kb
		//   - lb.controller.requests
		//   - lb.controller.requests.total
		//   - lb.controller.requests.url.handlers.forward.hits
		//   - lb.controller.requests.url.handlers.forward.timing_ms
		//   - lb.controller.requests.url.handlers.redirect.hits
		//   - lb.controller.requests.url.handlers.redirect.timing_ms
		//   - lb.controller.router.destinations.connections.invalid
		//   - lb.controller.router.destinations.connections.received_kb
		//   - lb.controller.router.destinations.connections.success
		//   - lb.controller.router.destinations.connections.transmitted_kb
		//   - lb.controller.router.destinations.connections.unavailable
		//   - lb.controller.router.destinations.latency
		//   - lb.controller.router.destinations.requests.total
		//   - lb.controller.transmitted_kb
		//   - memberships.num
		//   - pipeline.runs.num
		//   - stack.builds.num
		Metric string `json:"metric"`

		// Origin The originator of this metric.
		Origin string `json:"origin"`

		// Type The type of data represented by the metric.
		//   - **gauge**: represents a single numerical value that can arbitrarily go up and down.
		//   - **count**: represents a counter that resets periodically.
		//   - **counter**: represents a counter that only increases.
		//   - **rate**: represents the rate of change of a counter per second.
		//   - **histogram**: tracks the statistical distribution of a set of values.
		//   - **distribution**: aggregates data across multiple hosts and applications.
		//   - **set**: tracks the number of unique elements in a group.
		Type MetricMetadataType `json:"type"`
	} `json:"metadata"`

	// Points An array of recorded data points for this metric.
	Points [][]Metric_Points_Item `json:"points"`

	// Tags Additional tags associated with the metric.
	Tags *[]string `json:"tags,omitempty"`
	Time DateTime  `json:"time"`
}

// MetricMetadataType The type of data represented by the metric.
//   - **gauge**: represents a single numerical value that can arbitrarily go up and down.
//   - **count**: represents a counter that resets periodically.
//   - **counter**: represents a counter that only increases.
//   - **rate**: represents the rate of change of a counter per second.
//   - **histogram**: tracks the statistical distribution of a set of values.
//   - **distribution**: aggregates data across multiple hosts and applications.
//   - **set**: tracks the number of unique elements in a group.
type MetricMetadataType string

// MetricPoints1 defines model for .
type MetricPoints1 = int

// Metric_Points_Item defines model for Metric.points.Item.
type Metric_Points_Item struct {
	union json.RawMessage
}

// MigrationInstance Information about a migrated instance.
type MigrationInstance struct {
	// InstanceId The ID of the instance.
	InstanceId string `json:"instance_id"`

	// ServerId The ID of the server.
	ServerId string `json:"server_id"`
}

// Monitor A monitor used to determine latency between the public internet and a load balancer on Cycle. These monitors are automatically created and managed by the platform. Information about specific monitors is provided for determining the regional latencies for an environment.
type Monitor struct {
	// City The name of the city where this monitor is located.
	City string `json:"city"`

	// Country The full name of the country where this monitor is located.
	Country string `json:"country"`

	// CountryShort The country code of where this monitor is located.
	CountryShort string `json:"country_short"`

	// Latitude The latitude where this monitor is located.
	Latitude float32 `json:"latitude"`

	// Longitude The longitude where this monitor is located.
	Longitude float32 `json:"longitude"`

	// NodeId The ID of the node this monitor is running on.
	NodeId string `json:"node_id"`

	// Region The name of the region (state, province, prefecture, etc.) where this monitor is located.
	Region string `json:"region"`
}

// MonitoringTier The tier of monitoring, that determines the frequency that metrics are aggregated by the platform, on a per-environment basis.
type MonitoringTier string

// MonitoringTierDetails Detailed information about a monitoring tier's features.
type MonitoringTierDetails struct {
	// Description A hamanized description of the monitoring tier.
	Description string `json:"description"`

	// Enabled Whether or not this tier is a selectable monitoring tier for an environment. A disabled tier may be either one coming in the future, or a legacy tier that is no longer available, but saved for historical reasons.
	Enabled bool `json:"enabled"`

	// Events Details on how events are handled for this tier.
	Events struct {
		// Custom Whether or not custom user-submitted events are supported on this tier.
		Custom bool `json:"custom"`

		// RetentionPeriod A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		RetentionPeriod Duration        `json:"retention_period"`
		Usage           MonitoringUsage `json:"usage"`
	} `json:"events"`
	Features struct {
		PublicPingMonitor bool `json:"public_ping_monitor"`
	} `json:"features"`
	Forwarding struct {
		Bandwidth MonitoringUsage `json:"bandwidth"`

		// Supported Indicates if metric forwarding is supported on this tier.
		Supported bool `json:"supported"`
	} `json:"forwarding"`

	// Logs Details on how logs are handled for this tier.
	Logs struct {
		// Analysis Details on log analysis features for this tier.
		Analysis struct {
			// RetentionPeriod A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
			RetentionPeriod Duration `json:"retention_period"`
			Rules           int      `json:"rules"`

			// Supported Indicates if log analysis is supported on this tier.
			Supported bool            `json:"supported"`
			Usage     MonitoringUsage `json:"usage"`
		} `json:"analysis"`

		// Collection Details on log collection features for this tier.
		Collection struct {
			Cold *MonitoringTierDetailsLogsCollectionTier `json:"cold,omitempty"`
			Hot  *MonitoringTierDetailsLogsCollectionTier `json:"hot,omitempty"`

			// Supported Indicates if log collection is supported on this tier.
			Supported bool `json:"supported"`
		} `json:"collection"`
	} `json:"logs"`

	// Metrics Details on how metrics are handled for this tier.
	Metrics struct {
		// ContainerTelemetryGranularity A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		ContainerTelemetryGranularity Duration `json:"container_telemetry_granularity"`

		// Custom Whether or not custom user-submitted metrics are supported on this tier.
		Custom bool `json:"custom"`

		// DownsamplePeriod A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		DownsamplePeriod Duration `json:"downsample_period"`

		// RetentionPeriod A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		RetentionPeriod Duration `json:"retention_period"`

		// ServiceGranularity A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		ServiceGranularity Duration        `json:"service_granularity"`
		Usage              MonitoringUsage `json:"usage"`
	} `json:"metrics"`

	// Price An object holding information about term and amount that relates to a specific billing component.
	Price BillingAmount `json:"price"`
}

// MonitoringTierDetailsLogsCollectionTier defines model for MonitoringTierDetailsLogsCollectionTier.
type MonitoringTierDetailsLogsCollectionTier struct {
	Bandwidth MonitoringUsage `json:"bandwidth"`

	// RetentionPeriod A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
	RetentionPeriod Duration        `json:"retention_period"`
	Storage         MonitoringUsage `json:"storage"`
}

// MonitoringUsage defines model for MonitoringUsage.
type MonitoringUsage struct {
	// Additional An object describing the additonal cost of monitoring exceeding the included usage.
	Additional *struct {
		// Price An object holding information about term and amount that relates to a specific billing component.
		Price BillingAmount `json:"price"`
		Size  int           `json:"size"`
	} `json:"additional"`

	// HardCap A boolean indicating if there is hard usage limit on the tier.
	HardCap bool `json:"hard_cap"`

	// Included Number that, when used in conjunction with unit, describes the included usage.
	Included int `json:"included"`

	// Unit A string describing the metric unit.
	Unit string `json:"unit"`
}

// Network SDN Network resource.
type Network struct {
	Acl *ACL `json:"acl"`

	// Cluster The infrastructure cluster the environments belonging to this network belong to.
	Cluster string `json:"cluster"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Environments An array of environments and timestamps.
	Environments *[]struct {
		Added DateTime `json:"added"`

		// Id A 24 character hex string used to identify a unique resource.
		Id ID `json:"id"`
	} `json:"environments"`

	// Events A collection of timestamps for each event in the network's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Identifier A network identifier used to construct http calls that specifically use this network over another.
	Identifier string     `json:"identifier"`
	L2         *NetworkL2 `json:"l2"`

	// Name The name of the network.
	Name           string                  `json:"name"`
	PrivateNetwork *NetworkPrivacySettings `json:"private_network"`
	State          NetworkState            `json:"state"`
}

// NetworkIncludes All includable resource linkable to the given network.
type NetworkIncludes struct {
	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`

	// Environments An identity that is associated with an environment.
	Environments *EnvironmentIncludes `json:"environments,omitempty"`
}

// NetworkL2 Layer 2 network information for a Cycle SDN.
type NetworkL2 struct {
	Domain        *L2Domain     `json:"domain"`
	HostInterface *string       `json:"host_interface"`
	Ips           NetworkL2_Ips `json:"ips"`
	LocationIds   []ID          `json:"location_ids"`

	// Routes An array of L2 routes that are added to this SDN
	Routes *[]struct {
		// Gateway An IP address is a numerical label that uniquely identifies a device on a network and enables it to send and receive data.
		Gateway *IpAddress `json:"gateway,omitempty"`

		// Network A CIDR (Classless Inter-Domain Routing) string is a notation used to represent an IP address and its associated network prefix.
		// It combines an IP address with a suffix that indicates how many bits are fixed for routing.
		Network Cidr `json:"network"`
	} `json:"routes,omitempty"`
	Vid *int `json:"vid"`
}

// NetworkL2_Ips defines model for NetworkL2.Ips.
type NetworkL2_Ips struct {
	union json.RawMessage
}

// NetworkL2DhcpDetails defines model for NetworkL2DhcpDetails.
type NetworkL2DhcpDetails struct {
	Details *map[string]interface{}    `json:"details,omitempty"`
	Method  NetworkL2DhcpDetailsMethod `json:"method"`
}

// NetworkL2DhcpDetailsMethod defines model for NetworkL2DhcpDetails.Method.
type NetworkL2DhcpDetailsMethod string

// NetworkL2StaticDetails defines model for NetworkL2StaticDetails.
type NetworkL2StaticDetails struct {
	Details struct {
		Ipv4 *struct {
			// Gateway The IP of the gateway
			Gateway *string `json:"gateway"`

			// Network The CIDR for the network.
			Network string `json:"network"`

			// Usable The usable CIDR.
			Usable string `json:"usable"`
		} `json:"ipv4"`
		Ipv6 *struct {
			// Gateway The IP of the gateway
			Gateway *string `json:"gateway"`

			// Network The CIDR for the network.
			Network string `json:"network"`

			// Usable The usable CIDR.
			Usable string `json:"usable"`
		} `json:"ipv6"`
	} `json:"details"`
	Method NetworkL2StaticDetailsMethod `json:"method"`
}

// NetworkL2StaticDetailsMethod defines model for NetworkL2StaticDetails.Method.
type NetworkL2StaticDetailsMethod string

// NetworkPrivacySettings Private network information for a Cycle SDN.
type NetworkPrivacySettings struct {
	// Ipv6 IPv6 infromation for the network.
	Ipv6 struct {
		// Cidr The private network CIDR.
		Cidr string `json:"cidr"`

		// Ip The networks IPv6 base.
		Ip string `json:"ip"`
	} `json:"ipv6"`

	// MacAddrSuffix A number used to ensure a MAC address exists for each network.
	MacAddrSuffix int `json:"mac_addr_suffix"`

	// Subnet The subnet of the private network.
	Subnet string `json:"subnet"`

	// VxlanTag A tag used to ensure proper routing.
	VxlanTag int `json:"vxlan_tag"`
}

// NetworkSnapshot A snapshot of network usage statistics.
type NetworkSnapshot struct {
	// Interfaces An array of network interfaces attached to this instance.
	Interfaces []struct {
		Name    string `json:"name"`
		RxBytes int    `json:"rx_bytes"`
		TxBytes int    `json:"tx_bytes"`
	} `json:"interfaces"`
}

// NetworkSpec Information about the network resources for a given server.
type NetworkSpec struct {
	// Count The number of network resources for a given server.
	Count int `json:"count"`

	// Scope The scope of the interfaces.
	Scope NetworkSpecScope `json:"scope"`

	// Throughput The network throughput in MB(per second).
	Throughput int `json:"throughput"`

	// Type The type of the NIC.
	Type string `json:"type"`
}

// NetworkSpecScope The scope of the interfaces.
type NetworkSpecScope string

// NetworkState defines model for NetworkState.
type NetworkState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the network.
	Current NetworkStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// NetworkStateCurrent The current state of the network.
type NetworkStateCurrent string

// NodeMetaStats Statistics that pertain to a specific node.
type NodeMetaStats struct {
	// Cpu Statistics about the CPU resources on a server.
	Cpu ServerStatsCpu `json:"cpu"`

	// Load Statistics about the current load on the server.
	Load ServerStatsLoad `json:"load"`

	// Network Statistics about the networks on a given server.
	Network ServerStatsNetwork `json:"network"`

	// Os Statistics about the operating system installed on the server (CycleOS).
	Os ServerStatsOS `json:"os"`

	// Ram Statistics about the RAM on a given server.
	Ram ServerStatsRam `json:"ram"`

	// Storage Statistics about storage for a given server.
	Storage ServerStatsStorage `json:"storage"`

	// Uptime Statistics describing the uptime of a given server.
	Uptime ServerStatsUptime `json:"uptime"`

	// Vendor Details about the vendors for the server.
	Vendor ServerStatsVendor `json:"vendor"`

	// Versions Information about the versions of Cycle services on a given server.
	Versions ServerStatsVersions `json:"versions"`
}

// NodeState defines model for NodeState.
type NodeState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the node.
	Current NodeStateCurrent  `json:"current"`
	Desired *NodeStateDesired `json:"desired"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// NodeStateCurrent The current state of the node.
type NodeStateCurrent string

// NodeStateDesired defines model for NodeState.Desired.
type NodeStateDesired string

// NoneOrigin An empty origin. No details are provided for this image.
type NoneOrigin struct {
	Type NoneOriginType `json:"type"`
}

// NoneOriginType defines model for NoneOrigin.Type.
type NoneOriginType string

// OciRegistryOrigin An image origin that pulls images fro an OCI-compatible registry. Also used for provider-native registries, such as AWS ECR.
type OciRegistryOrigin struct {
	Details struct {
		// Auth Authentication details for a third party image registry/source.
		Auth *RegistryAuth `json:"auth,omitempty"`

		// Existing In a stack, specifies an image source ID from which Cycle will derive any values not specified in the stack file. This is useful for avoiding direct placement of credentials in a stack file, for example.
		Existing *ExistingSource `json:"existing,omitempty"`

		// Target The image name on the registry.
		Target string `json:"target"`

		// Url The url of the remote registry.
		Url string `json:"url"`
	} `json:"details"`
	Type OciRegistryOriginType `json:"type"`
}

// OciRegistryOriginType defines model for OciRegistryOrigin.Type.
type OciRegistryOriginType string

// Order An order is a resource that describes a billing order
type Order struct {
	Approved bool `json:"approved"`

	// Creator A type of creator and a matching identifier.
	Creator UserScope `json:"creator"`

	// Events A collection of timestamps for each event in the orders lifetime.
	Events struct {
		Expires DateTime `json:"expires"`
	} `json:"events"`
	HubId       string      `json:"hub_id"`
	Items       []OrderItem `json:"items"`
	PromoCodeId *string     `json:"promo_code_id"`
	State       OrderState  `json:"state"`

	// Term Information about a billing term.
	Term       Term    `json:"term"`
	TotalPrice float32 `json:"total_price"`
}

// OrderItem Describes a billing item
type OrderItem struct {
	Description string `json:"description"`
	Discount    *struct {
		// Amount An object holding information about term and amount that relates to a specific billing component.
		Amount  BillingAmount `json:"amount"`
		Expires DateTime      `json:"expires"`
		Id      string        `json:"id"`
	} `json:"discount,omitempty"`
	Id       string  `json:"id"`
	NetPrice float32 `json:"net_price"`

	// Price An object holding information about term and amount that relates to a specific billing component.
	Price BillingAmount `json:"price"`

	// Service Information for an item's plan.
	Service ServiceItem `json:"service"`
}

// OrderState defines model for OrderState.
type OrderState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the zone.
	Current OrderStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// OrderStateCurrent The current state of the zone.
type OrderStateCurrent string

// Overage Detailed information about resource overages incurred beyond included billing tier limits.
type Overage struct {
	// DnsLinkedRecords Overage related to DNS linked records usage.
	DnsLinkedRecords *struct {
		// Cost The total cost of the DNS linked record overage in mills.
		Cost int `json:"cost"`

		// Hours The number of DNS linked record hours exceeding the included amount.
		Hours int `json:"hours"`
	} `json:"dns_linked_records,omitempty"`

	// DnsZones Overage related to DNS zone usage.
	DnsZones *struct {
		// Cost The total cost of the DNS zone overage in mills.
		Cost int `json:"cost"`

		// Hours The number of DNS zone hours exceeding the included amount.
		Hours int `json:"hours"`
	} `json:"dns_zones,omitempty"`

	// ImageStorage Overage related to container or image storage usage.
	ImageStorage *struct {
		// Cost The total cost of the image storage overage in mills.
		Cost int `json:"cost"`

		// Gbs The number of gigabytes of image storage overage.
		Gbs int `json:"gbs"`
	} `json:"image_storage,omitempty"`

	// Members Overage related to member usage.
	Members *struct {
		// Cost The total cost of the member overage in mills.
		Cost int `json:"cost"`

		// Hours The number of member hours exceeding the included amount.
		Hours int `json:"hours"`
	} `json:"members,omitempty"`

	// Ram (GEN 1) Overage related to RAM usage.
	Ram *struct {
		// Cost The total cost of the RAM overage in mills.
		Cost int `json:"cost"`

		// GbHours The number of RAM GB-hours exceeding the included amount.
		GbHours int `json:"gb_hours"`
	} `json:"ram,omitempty"`

	// Servers Overage related to server runtime.
	Servers *struct {
		// Cost The total cost of the server overage in mills.
		Cost int `json:"cost"`

		// Hours The number of server hours exceeding the included amount.
		Hours int `json:"hours"`
	} `json:"servers,omitempty"`

	// Term Information about a billing term.
	Term Term `json:"term"`
}

// Payment A billing payment.
type Payment struct {
	// Amount 1/10th of a cent.
	Amount int `json:"amount"`

	// AmountRefunded 1/10th of a cent.
	AmountRefunded int `json:"amount_refunded"`

	// Description Some information about the payment.
	Description string `json:"description"`

	// Gateway The type of payment gateway used.
	Gateway PaymentGateway `json:"gateway"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// MethodId The ID associated with the billing method used.
	MethodId *string  `json:"method_id,omitempty"`
	Refunds  []Refund `json:"refunds"`

	// Result A billing payment result.
	Result PaymentResult `json:"result"`
	Time   DateTime      `json:"time"`
}

// PaymentGateway The type of payment gateway used.
type PaymentGateway string

// PaymentResult A billing payment result.
type PaymentResult struct {
	// Error A description of the error that took place when processing the payment.
	Error string `json:"error"`

	// Status The status of a payment.
	Status PaymentResultStatus `json:"status"`
}

// PaymentResultStatus The status of a payment.
type PaymentResultStatus string

// Permissions Permissions information for an API Key
type Permissions struct {
	// AllEnvironments A boolean, where true represents this API key is authorized to make requests that involve all of a hubs environments
	AllEnvironments bool `json:"all_environments"`

	// Environments An environment ID and a boolean representing management configuration for an API key
	Environments []struct {
		// Id A 24 character hex string used to identify a unique resource.
		Id ID `json:"id"`

		// Manage A boolean, where true represents the API keys ability to make changes to the environment components
		Manage bool `json:"manage"`
	} `json:"environments"`
}

// Pipeline A pipeline resource.
type Pipeline struct {
	Acl *ACL `json:"acl"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Disable A boolean where true signifies the pipeline is disabled.
	Disable bool `json:"disable"`

	// Dynamic Setting to true enables variable and other advanced logic support on this pipeline. This is a one-way toggle. Once set to true, it cannot be set back to false.
	Dynamic bool `json:"dynamic"`

	// Events A collection of timestamps for each event in the pipeline's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		LastRun DateTime `json:"last_run"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Name A name for the pipeline.
	Name string `json:"name"`

	// Stages An array of stages.
	Stages *[]PipelineStage `json:"stages,omitempty"`
	State  PipelineState    `json:"state"`
}

// PipelineIncludes All includable resources linkable to the given pipeline.
type PipelineIncludes struct {
	// Components A record of resources that can be associated with the pipeline.
	Components *map[string]map[string]interface{} `json:"components,omitempty"`

	// ComponentsIdentifiers A map of identifiers to an array of resource IDs that are associated with it. All IDs point to the same type of resource.
	ComponentsIdentifiers *IdentifierIncludes `json:"components:identifiers,omitempty"`

	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`

	// Name A name value.
	Name *string `json:"name,omitempty"`
}

// PipelineRerunAction defines model for PipelineRerunAction.
type PipelineRerunAction struct {
	// Action The requested action to perform.
	Action   PipelineRerunActionAction `json:"action"`
	Contents *struct {
		// RunId A 24 character hex string used to identify a unique resource.
		RunId *ID `json:"run_id,omitempty"`
	} `json:"contents,omitempty"`
}

// PipelineRerunActionAction The requested action to perform.
type PipelineRerunActionAction string

// PipelineRun A pipeline run resource.
type PipelineRun struct {
	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the pipeline run's lifetime.
	Events PipelineRunEvents `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// PipelineId The ID for the pipeline this run belongs to.
	PipelineId string `json:"pipeline_id"`

	// SkipLocks Describes if a skip lock was defined during pipeline trigger.
	SkipLocks *bool `json:"skip_locks,omitempty"`

	// Stages An array of pipeline stages.
	Stages []struct {
		// Events A collection of timestamps for each event in the pipeline run's lifetime.
		Events struct {
			Finished DateTime `json:"finished"`
			Started  DateTime `json:"started"`
		} `json:"events"`

		// Identifier A stage identifier.
		Identifier string            `json:"identifier"`
		Steps      []PipelineRunStep `json:"steps"`
	} `json:"stages"`
	State RunState `json:"state"`

	// SubQueue Describes the sub queue defined during pipeline trigger, if present.
	SubQueue *string `json:"sub_queue"`

	// Variables A map of variable values used during pipeline run.
	Variables *map[string]string `json:"variables,omitempty"`
}

// PipelineRunEvents A collection of timestamps for each event in the pipeline run's lifetime.
type PipelineRunEvents struct {
	Finished DateTime `json:"finished"`
	Queued   DateTime `json:"queued"`
	Started  DateTime `json:"started"`
}

// PipelineRunStep defines model for PipelineRunStep.
type PipelineRunStep struct {
	Action     PipelineRunStepAction `json:"action"`
	Components *[]struct {
		Id   string       `json:"id"`
		Type ResourceType `json:"type"`
	} `json:"components"`

	// Error An error, if any, that has occurred for this step.
	Error *struct {
		// Message Details about the error that has occurred.
		Message string `json:"message"`
	} `json:"error"`

	// Events A collection of timestamps for each event in the pipeline run's lifetime.
	Events struct {
		Finished DateTime `json:"finished"`
		Started  DateTime `json:"started"`
	} `json:"events"`
	Identifier string `json:"identifier"`
	Success    bool   `json:"success"`
}

// PipelineRunStepAction defines model for PipelineRunStep.Action.
type PipelineRunStepAction string

// PipelineStage A stage for a given pipeline.
type PipelineStage struct {
	// Identifier A stage identifier.
	Identifier string `json:"identifier"`

	// Options Additonal options for the stage.
	Options *struct {
		// Skip A boolean where true indicates the given stage should be skipped when the pipeline is run.
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`

	// Steps An array of steps for the stage.
	Steps []PipelineSteps `json:"steps"`
}

// PipelineState defines model for PipelineState.
type PipelineState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the pipeline.
	Current PipelineStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// PipelineStateCurrent The current state of the pipeline.
type PipelineStateCurrent string

// PipelineSteps A step for a pipeline stage.
type PipelineSteps struct {
	union json.RawMessage
}

// PipelineTask defines model for PipelineTask.
type PipelineTask struct {
	union json.RawMessage
}

// PipelineTriggerAction defines model for PipelineTriggerAction.
type PipelineTriggerAction struct {
	// Action The requested action to perform.
	Action   PipelineTriggerActionAction `json:"action"`
	Contents *struct {
		Advanced *struct {
			// SkipLocks To enable skip locks, pass the current UNIX timestamp. Must be accurate within 10 minutes of the current UTC time.
			// This will skip lock checks when running a pipeline - the user takes all risk of ensuring two pipeline runs won't make conflicting changes.
			SkipLocks *int `json:"skip_locks"`

			// SubQueue Sub queue allows multiple concurrent pipeline runs.
			SubQueue *string `json:"sub_queue"`
		} `json:"advanced,omitempty"`

		// Variables A map of variables to pass into the pipeline when it runs.
		Variables *map[string]string `json:"variables,omitempty"`
	} `json:"contents,omitempty"`
}

// PipelineTriggerActionAction The requested action to perform.
type PipelineTriggerActionAction string

// PrivateNetwork defines model for PrivateNetwork.
type PrivateNetwork struct {
	Ipv6 struct {
		// Cidr The CIDR notation, describing the range of IP addresses.
		Cidr string `json:"cidr"`

		// Ip The IP address.
		Ip string `json:"ip"`
	} `json:"ipv6"`
	Legacy *LegacyNetwork `json:"legacy"`

	// Subnet The subnet ID.
	Subnet string `json:"subnet"`

	// VxlanTag The vxlan tag added to each packet to help identify the network.
	VxlanTag int `json:"vxlan_tag"`
}

// ProcessesSnapshot Process information for a given snapshot.
type ProcessesSnapshot struct {
	// Current The current number of running processes in the instance.
	Current *float32 `json:"current,omitempty"`

	// Limit The maximum number of running processes for the instance.
	Limit *float32 `json:"limit,omitempty"`
}

// PromoCode A billing promo code.
type PromoCode struct {
	// Code The promo "code".
	Code string `json:"code"`

	// Credit The amount of credit the promo code offers.
	Credit *struct {
		// Amount An object holding information about term and amount that relates to a specific billing component.
		Amount  *BillingAmount `json:"amount,omitempty"`
		Expires *struct {
			Interval string `json:"interval"`
			Number   int    `json:"number"`
		} `json:"expires,omitempty"`
	} `json:"credit"`
	Expires DateTime `json:"expires"`
	State   struct {
		Changed DateTime `json:"changed"`

		// Current The current state of the promo code.
		Current PromoCodeStateCurrent `json:"current"`

		// Error An error, if any, that has occurred for this resource.
		Error *struct {
			// Message Details about the error that has occurred.
			Message *string   `json:"message,omitempty"`
			Time    *DateTime `json:"time,omitempty"`
		} `json:"error,omitempty"`
	} `json:"state"`
}

// PromoCodeStateCurrent The current state of the promo code.
type PromoCodeStateCurrent string

// PromoCodeInclude A resource that is associated with a promo code.
type PromoCodeInclude map[string]PromoCode

// ProviderLocation Location information for a given provider.
type ProviderLocation struct {
	// Abbreviation An abbreviation for the given provider locaiton.
	Abbreviation string `json:"abbreviation"`

	// Annotations Additional information about the given provider locaiton.
	Annotations map[string]interface{} `json:"annotations"`

	// Compatible A boolean where true means the locaiton is supported by the platform.
	Compatible bool `json:"compatible"`

	// Features Additional information about available and supported features of the provider location.
	Features struct {
		// Available Available features for the provider location.
		Available []string `json:"available"`

		// Supported Supported features for the provider location.
		Supported []string `json:"supported"`
	} `json:"features"`
	Geographic *ProviderLocationGeography `json:"geographic"`
	Id         string                     `json:"id"`

	// Name A name for the location.
	Name string `json:"name"`

	// Provider Information about the locaiton of the provider.
	Provider ProviderLocationDetails `json:"provider"`
}

// ProviderLocationDetails Information about the locaiton of the provider.
type ProviderLocationDetails struct {
	AvailabilityZones *[]string `json:"availability_zones,omitempty"`

	// Code A location code returned from the provider.
	Code string `json:"code"`

	// Identifier An identifier for the given provider
	Identifier string `json:"identifier"`

	// IntegrationId A 24 character hex string used to identify a unique resource.
	IntegrationId *ID `json:"integration_id,omitempty"`

	// Location A location name returned from the provider.
	Location string `json:"location"`
	Vendor   string `json:"vendor"`
}

// ProviderLocationGeography Geographic information about a provider location.
type ProviderLocationGeography struct {
	// City The city the datacenter resides in.
	City string `json:"city"`

	// Country The country the datacenter resides in.
	Country string `json:"country"`

	// Latitude The latitude of the given provider datacenter.
	Latitude int `json:"latitude"`

	// Longitude The longitude of the given provider datacenter.
	Longitude int `json:"longitude"`

	// Region The region the datacenter resides in.
	Region string `json:"region"`

	// State The state the datacenter resides in.
	State string `json:"state"`
}

// ProviderServerModel A server from a provider.
type ProviderServerModel struct {
	// Compatible A boolean where true signifies this server is compatible with the platform.
	Compatible bool `json:"compatible"`

	// Description A description of the server.
	Description string `json:"description"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// LocationIds An array of location IDs where this server type is available.
	LocationIds []string `json:"location_ids"`

	// LowResource A boolean where true signifies the server has a limited amount of resources and should only be used for very lightweight workloads.
	LowResource bool `json:"low_resource"`

	// Name A name for the server.
	Name string `json:"name"`

	// Price An object holding information about term and amount that relates to a specific billing component.
	Price BillingAmount `json:"price"`

	// Provider Higher level information about a providers server.
	Provider ProviderServerSpec `json:"provider"`

	// Specs Specs for a given server
	Specs ServerSpecs `json:"specs"`
}

// ProviderServerSpec Higher level information about a providers server.
type ProviderServerSpec struct {
	AvailabilityZones *map[string][]string `json:"availability_zones,omitempty"`

	// Category A category for the server.
	Category string `json:"category"`

	// Class A class for the server.
	Class *string `json:"class,omitempty"`

	// Identifier A provider identifier
	Identifier    string `json:"identifier"`
	IntegrationId *ID    `json:"integration_id"`

	// Locations A list of location ID's this server is available.
	Locations []string `json:"locations"`

	// Model The model of the server.
	Model string `json:"model"`
}

// PublicAccount Publicly available information about an account
type PublicAccount struct {
	// Email Email information for an account
	Email struct {
		// Address The email address associated with the account.
		Address string `json:"address"`
	} `json:"email"`
	Events *PublicAccount_Events `json:"events,omitempty"`

	// Id Id information for an account
	Id string `json:"id"`

	// Name The first and last name of an account owner
	Name struct {
		// First The first name of the account owner
		First string `json:"first"`

		// Last The last name of the account owner
		Last string `json:"last"`
	} `json:"name"`
	TwoFactorAuth struct {
		// Verified Indicates if the user account has two factor authentication enabled for log in.
		Verified bool `json:"verified"`
	} `json:"two_factor_auth"`
}

// PublicAccount_Events defines model for PublicAccount.Events.
type PublicAccount_Events struct {
	LastLogin            *DateTime           `json:"last_login,omitempty"`
	AdditionalProperties map[string]DateTime `json:"-"`
}

// Range A start and end date-time pair indicating a range of time
type Range struct {
	End   DateTime `json:"end"`
	Start DateTime `json:"start"`
}

// RawSource The `raw` type of scoped variable `value`, referred to as a source.  This means that the value is static, not the result of a call to an external or internal URL.
type RawSource struct {
	Details struct {
		// Blob A boolean where true represents the text the user is entering will be multi line.
		Blob   bool `json:"blob"`
		Secret *struct {
			// Hint A user specified hint that will suggest what the encryption key might be
			Hint *string `json:"hint"`

			// Iv A string describing the IV Hex associated with the encryption of the variable
			Iv *string `json:"iv,omitempty"`
		} `json:"secret"`

		// Value The value of the variable.
		Value string `json:"value"`
	} `json:"details"`

	// Type The type of source value, can be either `raw` or `url`.
	Type RawSourceType `json:"type"`
}

// RawSourceType The type of source value, can be either `raw` or `url`.
type RawSourceType string

// ReconfigureSdnNetworkAction defines model for ReconfigureSdnNetworkAction.
type ReconfigureSdnNetworkAction struct {
	// Action The job to do.
	Action ReconfigureSdnNetworkActionAction `json:"action"`

	// Contents Additional information needed for the job.
	Contents struct {
		// EnvironmentIds An array of environment identifiers for the network.
		EnvironmentIds *[]string `json:"environment_ids"`
		L2             *struct {
			HostInterface *string `json:"host_interface"`
			LocationIds   *[]ID   `json:"location_ids,omitempty"`

			// Routes An array of defined L2 routes
			Routes *[]struct {
				// Gateway An IP address is a numerical label that uniquely identifies a device on a network and enables it to send and receive data.
				Gateway *IpAddress `json:"gateway,omitempty"`

				// Usable A CIDR (Classless Inter-Domain Routing) string is a notation used to represent an IP address and its associated network prefix.
				// It combines an IP address with a suffix that indicates how many bits are fixed for routing.
				Usable *Cidr `json:"usable,omitempty"`
			} `json:"routes,omitempty"`
		} `json:"l2"`
	} `json:"contents"`
}

// ReconfigureSdnNetworkActionAction The job to do.
type ReconfigureSdnNetworkActionAction string

// RecordIncludes All includable resources linkable to the given records.
type RecordIncludes struct {
	Containers            *map[string]Container `json:"containers,omitempty"`
	ContainersIdentifiers *map[string]ID        `json:"containers:identifiers,omitempty"`

	// Creators An identity that created a resource.
	Creators                   *CreatorInclude            `json:"creators,omitempty"`
	VirtualMachines            *map[string]VirtualMachine `json:"virtual-machines,omitempty"`
	VirtualMachinesIdentifiers *map[string]ID             `json:"virtual-machines:identifiers,omitempty"`
}

// Refund A billing refund.
type Refund struct {
	// Amount 1/10th of a cent.
	Amount int `json:"amount"`

	// Description Some information about the payment refund.
	Description string `json:"description"`

	// Gateway The type of payment gateway used.
	Gateway PaymentGateway `json:"gateway"`

	// Id A 24 character hex string used to identify a unique resource.
	Id   ID       `json:"id"`
	Time DateTime `json:"time"`
}

// RegistryAuth Authentication details for a third party image registry/source.
type RegistryAuth struct {
	union json.RawMessage
}

// RegistryAuthProvider Credentials for authentication to a provider-native image registry, such as AWS ECR.
type RegistryAuthProvider struct {
	Details struct {
		Credentials struct {
			ApiKey   *string `json:"api_key,omitempty"`
			ClientId *string `json:"client_id,omitempty"`

			// Config A base64'd string of additional configuration options.
			Config         *string `json:"config,omitempty"`
			Namespace      *string `json:"namespace,omitempty"`
			Region         *string `json:"region,omitempty"`
			Secret         *string `json:"secret,omitempty"`
			SubscriptionId *string `json:"subscription_id,omitempty"`
		} `json:"credentials"`
		Flavor RegistryAuthProviderDetailsFlavor `json:"flavor"`
	} `json:"details"`
	Type RegistryAuthProviderType `json:"type"`
}

// RegistryAuthProviderDetailsFlavor defines model for RegistryAuthProvider.Details.Flavor.
type RegistryAuthProviderDetailsFlavor string

// RegistryAuthProviderType defines model for RegistryAuthProvider.Type.
type RegistryAuthProviderType string

// RegistryAuthUser User/token based credentials for authentication to a third-party image source.
type RegistryAuthUser struct {
	Details struct {
		Token    *string `json:"token,omitempty"`
		Username *string `json:"username,omitempty"`
	} `json:"details"`
	Type RegistryAuthUserType `json:"type"`
}

// RegistryAuthUserType defines model for RegistryAuthUser.Type.
type RegistryAuthUserType string

// RegistryAuthWebhook Webhook-based authentication to the provided URL. This webhook expects to receive a base-64 string that when decoded is in the format `username:password`
type RegistryAuthWebhook struct {
	Details struct {
		Url string `json:"url"`
	} `json:"details"`
	Type RegistryAuthWebhookType `json:"type"`
}

// RegistryAuthWebhookType defines model for RegistryAuthWebhook.Type.
type RegistryAuthWebhookType string

// RepoType Information about the repository.
type RepoType struct {
	// Auth Authentication information for the repository.
	Auth *RepoType_Auth `json:"auth,omitempty"`

	// Branch An optional branch arguement.  Default value is `master`.
	Branch *string `json:"branch,omitempty"`

	// Ref Repository reference information.
	Ref *struct {
		// Type The type of reference being used.
		Type string `json:"type"`

		// Value The value for the given reference type.
		Value string `json:"value"`
	} `json:"ref"`

	// Url The URL of the repository.
	Url string `json:"url"`
}

// RepoType_Auth Authentication information for the repository.
type RepoType_Auth struct {
	union json.RawMessage
}

// ResourceAllowance Generic structure for a resource with an included allotment, optional hard cap, and per-unit overage cost.
type ResourceAllowance struct {
	// Additional Cost for units that exceed the included amount.
	Additional struct {
		// Mills Cost in mills per additional unit.
		Mills int `json:"mills"`

		// Term Billing term that applies to the additional cost.
		Term ResourceAllowanceAdditionalTerm `json:"term"`
	} `json:"additional"`

	// HardCap Whether there is a hard limit on this resource.
	HardCap bool `json:"hard_cap"`

	// Included The number of units included in the tier price.
	Included int `json:"included"`
}

// ResourceAllowanceAdditionalTerm Billing term that applies to the additional cost.
type ResourceAllowanceAdditionalTerm string

// ResourceSnapshot A resource snapshot that shows instance telemetry.
type ResourceSnapshot struct {
	Cluster     *Identifier `json:"cluster"`
	ContainerId *ID         `json:"container_id"`

	// Cpu A telemetry snapshot pertaining to CPU usage.
	Cpu           CPUSnapshot `json:"cpu"`
	EnvironmentId *ID         `json:"environment_id"`
	HubId         *HubID      `json:"hub_id"`

	// Hugetlb HugeTLB data.
	Hugetlb    *HugeTLB `json:"hugetlb,omitempty"`
	InstanceId *ID      `json:"instance_id"`

	// Memory A snapshot of memory usage statistics.
	Memory MemorySnapshot `json:"memory"`

	// Network A snapshot of network usage statistics.
	Network NetworkSnapshot `json:"network"`

	// Processes Process information for a given snapshot.
	Processes ProcessesSnapshot `json:"processes"`
	ServerId  *ID               `json:"server_id"`
	Time      DateTime          `json:"time"`
}

// ResourceType defines model for ResourceType.
type ResourceType string

// Role A Role is a custom combination of platform-level capabilities, allowing for fully customizable role-based access controls across the platform.
type Role struct {
	// Capabilities The list of platform level capabilities assigned to this Role.
	Capabilities struct {
		// All If true, the Role has all capabilities.
		All      bool         `json:"all"`
		Specific []Capability `json:"specific"`
	} `json:"capabilities"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Default A reference to the original identifier of the default Role this Role was built from.  A value of null means it is a fully custom Role.
	Default *Identifier `json:"default"`

	// Events Timestamps for each event in the Role's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// Extra Custom user-defined properties for storing extra information on the Role. Not utilized by Cycle.
	Extra *map[string]string `json:"extra,omitempty"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID  `json:"hub_id"`
	Id    string `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`

	// Meta A list of meta fields that can be applied to a role.
	Meta *RoleMeta `json:"meta,omitempty"`
	Name *string   `json:"name"`

	// Rank An integer between 0 and 10 that indicates the Role hierarchy. An account can only edit a Role that is less than their rank. The 'owner' Role is rank 10.
	Rank int `json:"rank"`

	// Root The Role marked as root has full moderation control over all Roles.
	Root  bool `json:"root"`
	State struct {
		Changed DateTime `json:"changed"`

		// Current The current state of the Role.
		Current RoleStateCurrent `json:"current"`

		// Error An error, if any, that has occurred for this resource.
		Error *struct {
			// Message Details about the error that has occurred.
			Message *string   `json:"message,omitempty"`
			Time    *DateTime `json:"time,omitempty"`
		} `json:"error,omitempty"`
	} `json:"state"`
}

// RoleStateCurrent The current state of the Role.
type RoleStateCurrent string

// RoleMeta A list of meta fields that can be applied to a role.
type RoleMeta struct {
	Counts *struct {
		ApiKeys int `json:"api_keys"`
		Members int `json:"members"`
	} `json:"counts,omitempty"`
}

// RunState defines model for RunState.
type RunState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the pipeline run.
	Current RunStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// RunStateCurrent The current state of the pipeline run.
type RunStateCurrent string

// RuntimeDevicePermission A rule that grants or denies access to a device node (e.g., Linux cgroup device rule). Controls which device type and major/minor numbers are allowed, and with what access.
type RuntimeDevicePermission struct {
	// Access The access mode permitted by this rule. Common conventions use a combination of letters (e.g., r, w, m) to indicate read, write, and mknod capabilities.
	Access RuntimeDevicePermissionAccess `json:"access"`

	// Allow Whether this rule allows (true) or denies (false) access.
	Allow bool `json:"allow"`

	// Major Device major number.
	Major *int64 `json:"major"`

	// Minor Device minor number.
	Minor *int64 `json:"minor"`

	// Type The class of device this rule applies to (for example, block devices or character devices).
	Type RuntimeDevicePermissionType `json:"type"`
}

// RuntimeDevicePermissionAccess The access mode permitted by this rule. Common conventions use a combination of letters (e.g., r, w, m) to indicate read, write, and mknod capabilities.
type RuntimeDevicePermissionAccess = string

// RuntimeDevicePermissionType The class of device this rule applies to (for example, block devices or character devices).
type RuntimeDevicePermissionType string

// RuntimeExposedDevice A host device exposed to the container during runtime.
type RuntimeExposedDevice struct {
	// Destination The path inside the container that the device is mapped to.
	Destination string `json:"destination"`

	// Options Options passed when mounting the device.
	Options *[]string `json:"options,omitempty"`

	// Source The path to the device on the host.
	Source string `json:"source"`
}

// SFTP Information about connecting to a instance volume over SFTP.
type SFTP struct {
	// Host The hostname for connecting to the volume over SFTP.
	Host string `json:"host"`

	// Password Password configuration settings for the remote access of the container volume.
	Password struct {
		// Algorithm The hashing algorithm used to has the password.
		Algorithm SFTPPasswordAlgorithm `json:"algorithm"`

		// Data The raw or hashed password.
		Data string `json:"data"`
	} `json:"password"`

	// Port The port number to use when connecting.
	Port float32 `json:"port"`

	// Username The username to use when connecting.
	Username string `json:"username"`
}

// SFTPPasswordAlgorithm The hashing algorithm used to has the password.
type SFTPPasswordAlgorithm string

// SSHResponse SSH connection information for a given container instance.
type SSHResponse struct {
	// Address The SSH connection response address.
	Address string `json:"address"`

	// Secret The SSH connection response secret.
	Secret string `json:"secret"`

	// Token An Instance SSH token.
	Token SSHToken `json:"token"`
}

// SSHToken An Instance SSH token.
type SSHToken struct {
	// ContainerId The ID of the container from which the instance was created.
	ContainerId string `json:"container_id"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the SSH token's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Expires DateTime `json:"expires"`
		Used    DateTime `json:"used"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// InstanceId The ID of the instance being connected to.
	InstanceId string `json:"instance_id"`

	// Valid A boolean where true represents the token as being a valid token to be used for connection.
	Valid bool `json:"valid"`
}

// ScaleThresholdMetric Discriminated union describing the different types of scaling threshold and their respective details
type ScaleThresholdMetric struct {
	union json.RawMessage
}

// ScaleThresholdMetricCpu Describes the CPU threshold at which scaling will occur
type ScaleThresholdMetricCpu struct {
	Details struct {
		Utilization int `json:"utilization"`
	} `json:"details"`
	Type ScaleThresholdMetricCpuType `json:"type"`
}

// ScaleThresholdMetricCpuType defines model for ScaleThresholdMetricCpu.Type.
type ScaleThresholdMetricCpuType string

// ScaleThresholdMetricCustom A custom threshold for defining a scaling event.
type ScaleThresholdMetricCustom struct {
	Details struct {
		// Webhook A URL describing the destination Cycle should send a POST webhook payload to.
		Webhook WebhookURL `json:"webhook"`
	} `json:"details"`
	Type ScaleThresholdMetricCustomType `json:"type"`
}

// ScaleThresholdMetricCustomType defines model for ScaleThresholdMetricCustom.Type.
type ScaleThresholdMetricCustomType string

// ScaleThresholdMetricNetworkConnections Describes the network connections threshold at which scaling will occur
type ScaleThresholdMetricNetworkConnections struct {
	Details struct {
		Connections int `json:"connections"`
	} `json:"details"`
	Type ScaleThresholdMetricNetworkConnectionsType `json:"type"`
}

// ScaleThresholdMetricNetworkConnectionsType defines model for ScaleThresholdMetricNetworkConnections.Type.
type ScaleThresholdMetricNetworkConnectionsType string

// ScaleThresholdMetricNetworkRequests Describes the network requests threshold at which scaling will occur
type ScaleThresholdMetricNetworkRequests struct {
	Details struct {
		Requests int `json:"requests"`
	} `json:"details"`
	Type ScaleThresholdMetricNetworkRequestsType `json:"type"`
}

// ScaleThresholdMetricNetworkRequestsType defines model for ScaleThresholdMetricNetworkRequests.Type.
type ScaleThresholdMetricNetworkRequestsType string

// ScaleThresholdMetricNetworkThroughput Describes the network throughput threshold at which scaling will occur
type ScaleThresholdMetricNetworkThroughput struct {
	Details struct {
		// Bandwidth The limit (maximum) amount of throughput each instance of the given container can use before triggering a scaling event.
		Bandwidth string `json:"bandwidth"`
		Private   bool   `json:"private"`
	} `json:"details"`
	Type ScaleThresholdMetricNetworkThroughputType `json:"type"`
}

// ScaleThresholdMetricNetworkThroughputType defines model for ScaleThresholdMetricNetworkThroughput.Type.
type ScaleThresholdMetricNetworkThroughputType string

// ScaleThresholdMetricRam Describes the RAM threshold at which scaling will occur.
type ScaleThresholdMetricRam struct {
	Details struct {
		// Usage The target average RAM usage of all instances of this container. Going above this threshold will trigger a scaling event. This threshold must be greater than 25MB.
		Usage string `json:"usage"`
	} `json:"details"`
	Type ScaleThresholdMetricRamType `json:"type"`
}

// ScaleThresholdMetricRamType defines model for ScaleThresholdMetricRam.Type.
type ScaleThresholdMetricRamType string

// SchedulerAccessKey Custom authorization keys for the scheduler service.
type SchedulerAccessKey struct {
	// Ips Whitelisted IPs that are allowed to make requests to the scheduler service.
	Ips *[]string `json:"ips,omitempty"`

	// Name The name given to this access key
	Name string `json:"name"`

	// Secret The access key secret. This should be submitted with requests to a publicly accessible scheduler service.
	Secret string `json:"secret"`
}

// SchedulerConfig Configuration options for the scheduler Environment service.
type SchedulerConfig struct {
	AccessKeys *[]SchedulerAccessKey `json:"access_keys,omitempty"`

	// Public If true, this scheduler will be accessible over the public internet. It will enable a LINKED record to be pointed to the scheduler container, and inbound requests to trigger function containers.
	Public bool `json:"public"`
}

// SchedulerEnvironmentService Information about the environments scheduler service. The scheduler is used by containers with a function deployment strategy to route requests to the correct instances.
type SchedulerEnvironmentService struct {
	// AutoUpdate A boolean where `true` represents the desire to automatically update the environment scheduler service.
	AutoUpdate *bool            `json:"auto_update,omitempty"`
	Config     *SchedulerConfig `json:"config"`

	// ContainerId The ID of the scheduler service container.
	ContainerId *string `json:"container_id"`

	// Enable Whether or not the scheduler service is enabled.
	Enable bool `json:"enable"`

	// HighAvailability A boolean representing if the scheduler service container is set to high availability. mode or not. As of Jan 2024, this will always be false because HA is not availiable for the scheduler service.
	HighAvailability *bool `json:"high_availability,omitempty"`
}

// ScopedVariable Scoped variables are a way for users to dynamically allocate runtime specific environment variables across any number of containers in an environment.
type ScopedVariable struct {
	// Access The way the scoped variable is accessed.
	Access ScopedVariableAccess `json:"access"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator    CreatorScope `json:"creator"`
	Deployment *Deployment  `json:"deployment"`

	// EnvironmentId An identifier used to reference the environment this resource is scoped to.
	EnvironmentId string `json:"environment_id"`

	// Events A collection of timestamps for each event in the Scoped Variable's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`

	// Scope Information about the assignment of the scoped variable and how it is invoked.
	Scope ScopedVariableScope `json:"scope"`

	// Source The source or value of the scoped variable.
	Source ScopedVariable_Source `json:"source"`
	State  ScopedVariableState   `json:"state"`
}

// ScopedVariable_Source The source or value of the scoped variable.
type ScopedVariable_Source struct {
	union json.RawMessage
}

// ScopedVariableAccess The way the scoped variable is accessed.
type ScopedVariableAccess struct {
	// EnvVariable When set to true, this scoped variable is set as an environment variable inside the container.
	EnvVariable *struct {
		// Key The name of the environment variable set on the target container.
		Key string `json:"key"`
	} `json:"env_variable"`

	// File File is an object that describes a path to mount the file to inside the container.
	File *struct {
		// Decode When true, Cycle will interpret this variable as a base-64 encoded string, and decode it before passing it into the container.
		Decode bool `json:"decode"`

		// Gid The linux GID to set on the file.
		Gid *int `json:"gid"`

		// Path The path to mount the file to inside the container.
		Path *string `json:"path"`

		// Permissions A linux file mode that will be set on the injected file.
		Permissions *string `json:"permissions"`

		// Uid The linux UID to set on the file.
		Uid *int `json:"uid"`
	} `json:"file"`

	// InternalApi If set, this scoped variable will be available over the internal API. Contains settings for accessing this variable over the internal API.
	InternalApi *struct {
		// Duration Duration is a time string that the internal API will serve that variable after runtime starts.
		Duration *Duration `json:"duration"`
	} `json:"internal_api"`
}

// ScopedVariableScope Information about the assignment of the scoped variable and how it is invoked.
type ScopedVariableScope struct {
	// Containers Information about the assignment of the scoped variable to different containers in the environment.
	Containers struct {
		// Global A boolean where true represents the scoped variables is globally assigned to all current and future containers in the environment.
		Global bool `json:"global"`

		// Identifiers An array of container identifiers, where each container identfied will have access to the scoped variable.
		Identifiers []string `json:"identifiers"`

		// Ids An array of container IDs, where each container identified will have access to the scoped variable.
		Ids []string `json:"ids"`
	} `json:"containers"`
}

// ScopedVariableState defines model for ScopedVariableState.
type ScopedVariableState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the scoped variable.
	Current ScopedVariableStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// ScopedVariableStateCurrent The current state of the scoped variable.
type ScopedVariableStateCurrent string

// SdnNetworkTask defines model for SdnNetworkTask.
type SdnNetworkTask struct {
	union json.RawMessage
}

// SeccompRule Rules for controlling Linux seccomp inside a container.
type SeccompRule struct {
	Capabilities *struct {
		Excludes *string `json:"excludes,omitempty"`
		Includes *string `json:"includes,omitempty"`
	} `json:"capabilities,omitempty"`

	// Syscall LinuxSyscall is used to match a syscall in Seccomp
	Syscall *struct {
		Action string `json:"action"`
		Args   *[]struct {
			Index    int    `json:"index"`
			Op       string `json:"op"`
			Value    int    `json:"value"`
			ValueTwo *int   `json:"valueTwo,omitempty"`
		} `json:"args,omitempty"`
		ErrnoRet *int     `json:"errnoRet,omitempty"`
		Names    []string `json:"names"`
	} `json:"syscall,omitempty"`
}

// Server The server resource, referring to servers that have been deployed to a Cycle hub.
type Server struct {
	Autoscale *struct {
		// GroupId A 24 character hex string used to identify a unique resource.
		GroupId ID `json:"group_id"`
	} `json:"autoscale"`

	// Cluster The cluster the given server is deployed to.
	Cluster string `json:"cluster"`

	// Constraints Constraints to apply to the server.
	Constraints ServerConstraints `json:"constraints"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Ephemeral Set to true when a server is created as part of an auto-scale event.
	Ephemeral bool `json:"ephemeral"`

	// Evacuate Details about a server's evacuation status. When an evacuation is in progress, no new container instances will be permitted on the server.
	Evacuate *struct {
		Started DateTime `json:"started"`
	} `json:"evacuate"`

	// Events A collection of timestamps for each event in the server's lifetime.
	Events struct {
		Created        DateTime `json:"created"`
		Deleted        DateTime `json:"deleted"`
		LatestInstance DateTime `json:"latest_instance"`

		// Provisioning Information about the provisioning of the server.
		Provisioning struct {
			Completed DateTime `json:"completed"`
			Failed    DateTime `json:"failed"`
			Started   DateTime `json:"started"`
		} `json:"provisioning"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// Features A set of features a given server can have and their information.
	Features ServerFeatures `json:"features"`

	// Hostname The server hostname.
	Hostname string `json:"hostname"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// LocationId An identifier for the location this server is deployed to.
	LocationId string `json:"location_id"`

	// Meta A list of meta fields that can be applied to a server.
	Meta *ServerMeta `json:"meta,omitempty"`

	// ModelId An identifier for the model of server that is deployed.
	ModelId string `json:"model_id"`

	// Nickname A custom name given to the server for identification purposes. Does not affect server hostname.
	Nickname *string `json:"nickname"`

	// NodeId An identifier for the node.
	NodeId string `json:"node_id"`

	// Provider A resource regarding the provider a given server is deployed from.
	Provider          ServerProvider          `json:"provider"`
	SharedFileSystems ServerSharedFileSystems `json:"shared_file_systems"`
	State             ServerState             `json:"state"`
}

// ServerAuthResetAction A job that resets authentication for the server.
// Only for servers deployed from a virtual provider.
type ServerAuthResetAction struct {
	// Action The action to take.
	Action ServerAuthResetActionAction `json:"action"`
}

// ServerAuthResetActionAction The action to take.
type ServerAuthResetActionAction string

// ServerConstraints Constraints to apply to the server.
type ServerConstraints struct {
	// Allow Settings for the server, things that are or are not allowed.
	Allow struct {
		// Overcommit A boolean where true means - allow twice the normal amount of CPU shares to be allocated to containers deployed to this server.
		Overcommit bool `json:"overcommit"`

		// Pool A boolean where true means - allow containers with no tags specified to be deployed to this server.
		Pool bool `json:"pool"`

		// Services A boolean where true means - allow service containers to be deployed to this container.
		Services bool `json:"services"`
	} `json:"allow"`

	// Tags A list of server tags to put on the given server.
	Tags []string `json:"tags"`
}

// ServerEvacuateAction defines model for ServerEvacuateAction.
type ServerEvacuateAction struct {
	// Action The action to take.
	Action   ServerEvacuateActionAction `json:"action"`
	Contents struct {
		Destination struct {
			ServerId *ID `json:"server_id"`
		} `json:"destination"`
	} `json:"contents"`
}

// ServerEvacuateActionAction The action to take.
type ServerEvacuateActionAction string

// ServerEvacuateResetAction defines model for ServerEvacuateResetAction.
type ServerEvacuateResetAction struct {
	// Action The action to take.
	Action ServerEvacuateResetActionAction `json:"action"`
}

// ServerEvacuateResetActionAction The action to take.
type ServerEvacuateResetActionAction string

// ServerFeatures A set of features a given server can have and their information.
type ServerFeatures struct {
	// BaseVolumeGb The size of the base volume (where Cycle stores container images on this server).
	BaseVolumeGb *int `json:"base_volume_gb"`

	// Gateway Configuration options for running gateway services on this server.
	Gateway *struct {
		// Type The type of gateway service that can be run on this server.
		Type ServerFeaturesGatewayType `json:"type"`
	} `json:"gateway"`

	// Sftp A boolean where true means the server accepts incoming SFTP connections through the remote volume integration.
	Sftp bool `json:"sftp"`
}

// ServerFeaturesGatewayType The type of gateway service that can be run on this server.
type ServerFeaturesGatewayType string

// ServerIncludes A resource associated with a server.
type ServerIncludes struct {
	Clusters *map[string]Cluster `json:"clusters,omitempty"`

	// Integrations A resource that is associated with an integration.
	Integrations *IntegrationsIncludes `json:"integrations,omitempty"`

	// Locations A resource that is associated with a provider location.
	Locations *LocationsIncludes `json:"locations,omitempty"`

	// Models A resources that assocaited with a provider server.
	Models *ServerModelIncludes `json:"models,omitempty"`
}

// ServerInstancesSummary A Server ID and number of Instances of a specific Container it hosts.
type ServerInstancesSummary struct {
	Instances int `json:"instances"`

	// ServerId A 24 character hex string used to identify a unique resource.
	ServerId ID `json:"server_id"`
}

// ServerMeta A list of meta fields that can be applied to a server.
type ServerMeta struct {
	Allocations *struct {
		CpuShares struct {
			Allocatable int `json:"allocatable"`
			Allocated   int `json:"allocated"`
			Total       int `json:"total"`
		} `json:"cpu_shares"`
		Ram struct {
			AllocatableMb int `json:"allocatable_mb"`
			AllocatedMb   int `json:"allocated_mb"`
			TotalMb       int `json:"total_mb"`
		} `json:"ram"`
	} `json:"allocations,omitempty"`

	// InstancesCount A summary of resources by state
	InstancesCount *StateCountSummary `json:"instances_count,omitempty"`

	// Node Infrormation about the status of the server.
	Node *struct {
		// Drivers An array a drivers associated with the given server.
		Drivers []string `json:"drivers"`

		// Healthy A boolean where true means the platform is reporting the server as healthy.
		Healthy     bool     `json:"healthy"`
		LastCheckin DateTime `json:"last_checkin"`

		// Online A boolean where true means the server is online and reachable by the platform.
		Online bool      `json:"online"`
		State  NodeState `json:"state"`

		// Stats Statistics that pertain to a specific node.
		Stats NodeMetaStats `json:"stats"`
	} `json:"node,omitempty"`
}

// ServerModelIncludes A resources that assocaited with a provider server.
type ServerModelIncludes map[string]ProviderServerModel

// ServerModelsIncludes A resource associated with a server models.
type ServerModelsIncludes map[string]ProviderServerModel

// ServerPowerOffAction A job that powers the server off.
// Only for servers deployed from a virtual provider.
type ServerPowerOffAction struct {
	// Action The action to take.
	Action ServerPowerOffActionAction `json:"action"`
}

// ServerPowerOffActionAction The action to take.
type ServerPowerOffActionAction string

// ServerProvider A resource regarding the provider a given server is deployed from.
type ServerProvider struct {
	Extra *map[string]interface{} `json:"extra,omitempty"`

	// InitIps The IP's assigned to this server during provisioning.
	InitIps *[]string `json:"init_ips,omitempty"`

	// IntegrationId A 24 character hex string used to identify a unique resource.
	IntegrationId ID `json:"integration_id"`

	// Location A location where the server is deployed.
	Location string `json:"location"`

	// MacAddr The mac address for the server.
	MacAddr *string `json:"mac_addr,omitempty"`

	// Model The model of the server that is deployed.
	Model            string `json:"model"`
	ProvisionOptions *struct {
		EncryptStorage *bool    `json:"encrypt_storage,omitempty"`
		ReservationId  *string  `json:"reservation_id,omitempty"`
		StorageSize    *float32 `json:"storage_size,omitempty"`
	} `json:"provision_options,omitempty"`

	// Server A provider specific identifier for the server.
	Server string `json:"server"`

	// Vendor The vendor for the provider this server is deployed from.
	Vendor string `json:"vendor"`

	// Zone The zone of the server that is deployed, if defined.
	Zone *string `json:"zone"`
}

// ServerReconfigureFeaturesAction defines model for ServerReconfigureFeaturesAction.
type ServerReconfigureFeaturesAction struct {
	// Action The action to take.
	Action ServerReconfigureFeaturesActionAction `json:"action"`

	// Contents Supplemental information needed to perform the action.
	Contents struct {
		// BaseVolumeGb A number in GB for how big the base volume should be.  This cannot be lower than the currently set value for the server.
		BaseVolumeGb *int `json:"base_volume_gb"`

		// Gateway Configuration options for running gateway services on this server.
		Gateway *struct {
			// Type The type of gateway service that can be run on this server.
			Type ServerReconfigureFeaturesActionContentsGatewayType `json:"type"`
		} `json:"gateway"`

		// Sftp A boolean where true represents the desire for the server to accept incoming SFTP requests for container volumes.
		Sftp *bool `json:"sftp,omitempty"`
	} `json:"contents"`
}

// ServerReconfigureFeaturesActionAction The action to take.
type ServerReconfigureFeaturesActionAction string

// ServerReconfigureFeaturesActionContentsGatewayType The type of gateway service that can be run on this server.
type ServerReconfigureFeaturesActionContentsGatewayType string

// ServerReconfigureSharedFsAction defines model for ServerReconfigureSharedFsAction.
type ServerReconfigureSharedFsAction struct {
	// Action The action to take.
	Action   ServerReconfigureSharedFsActionAction `json:"action"`
	Contents struct {
		// Directories An object describing directory identifiers with value {}.
		Directories *map[string]interface{} `json:"directories"`
		Mounts      *map[string]struct {
			// Options Comma separated string describing the server mount options.
			Options string `json:"options"`

			// Source String describing the server mount source.
			Source string `json:"source"`

			// Type String describing the server mount type.
			Type string `json:"type"`
		} `json:"mounts"`
	} `json:"contents"`
}

// ServerReconfigureSharedFsActionAction The action to take.
type ServerReconfigureSharedFsActionAction string

// ServerRestartAction A job that restarts the server.
type ServerRestartAction struct {
	// Action The action to take.
	Action ServerRestartActionAction `json:"action"`
}

// ServerRestartActionAction The action to take.
type ServerRestartActionAction string

// ServerRestartComputeAction A job that restarts compute service on a given server.
type ServerRestartComputeAction struct {
	// Action The action to take.
	Action ServerRestartComputeActionAction `json:"action"`
}

// ServerRestartComputeActionAction The action to take.
type ServerRestartComputeActionAction string

// ServerRestartComputeSpawnerAction A job that restarts compute service on a given server.
type ServerRestartComputeSpawnerAction struct {
	// Action The action to take.
	Action ServerRestartComputeSpawnerActionAction `json:"action"`
}

// ServerRestartComputeSpawnerActionAction The action to take.
type ServerRestartComputeSpawnerActionAction string

// ServerSharedFileSystems defines model for ServerSharedFileSystems.
type ServerSharedFileSystems struct {
	// Directories An object describing directory identifiers with value {}.
	Directories *map[string]interface{} `json:"directories"`
	Mounts      *map[string]struct {
		// Options Comma separated string describing the server mount options.
		Options string `json:"options"`

		// Source String describing the server mount source.
		Source string `json:"source"`

		// Type String describing the server mount type.
		Type string `json:"type"`
	} `json:"mounts"`
}

// ServerSpecs Specs for a given server
type ServerSpecs struct {
	// Cpu Information about the CPU for a given server.
	Cpu CPUSpec `json:"cpu"`

	// Features The spec for server features.
	Features FeaturesSpec `json:"features"`

	// Gpu Information about a given servers GPU resources.
	Gpu GPUSpec `json:"gpu"`

	// Memory Information about the memory resources of a given server.
	Memory  MemorySpec    `json:"memory"`
	Network []NetworkSpec `json:"network"`
	Storage []StorageSpec `json:"storage"`
}

// ServerState defines model for ServerState.
type ServerState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the server.
	Current ServerStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// ServerStateCurrent The current state of the server.
type ServerStateCurrent string

// ServerStatsCpu Statistics about the CPU resources on a server.
type ServerStatsCpu struct {
	// Cores The number of CPU's or vCPU's for a given server.
	Cores *int `json:"cores,omitempty"`

	// Processors An array of processor information objects.
	Processors *[]struct {
		// Model The model of the processor.
		Model *string `json:"model,omitempty"`

		// Speed The speed of the processor.
		Speed *float32 `json:"speed,omitempty"`
	} `json:"processors,omitempty"`
	Usage *ServerStatsCpuUsage `json:"usage,omitempty"`

	// Virtualization A true value indicates the server supports virtualization.
	Virtualization *bool `json:"virtualization,omitempty"`
}

// ServerStatsCpuUsage defines model for ServerStatsCpuUsage.
type ServerStatsCpuUsage struct {
	Guest     *int `json:"guest,omitempty"`
	GuestNice *int `json:"guest_nice,omitempty"`
	Idle      *int `json:"idle,omitempty"`
	Iowait    *int `json:"iowait,omitempty"`
	Irq       *int `json:"irq,omitempty"`
	Nice      *int `json:"nice,omitempty"`
	SoftIrq   *int `json:"soft_irq,omitempty"`
	Steal     *int `json:"steal,omitempty"`
	System    *int `json:"system,omitempty"`
	User      *int `json:"user,omitempty"`
}

// ServerStatsCpuUsageTelemetry defines model for ServerStatsCpuUsageTelemetry.
type ServerStatsCpuUsageTelemetry struct {
	Guest     *float32 `json:"guest,omitempty"`
	GuestNice *float32 `json:"guest_nice,omitempty"`
	Idle      *float32 `json:"idle,omitempty"`
	Iowait    *float32 `json:"iowait,omitempty"`
	Irq       *float32 `json:"irq,omitempty"`
	Nice      *float32 `json:"nice,omitempty"`
	SoftIrq   *float32 `json:"soft_irq,omitempty"`
	Steal     *float32 `json:"steal,omitempty"`
	System    *float32 `json:"system,omitempty"`
	User      *float32 `json:"user,omitempty"`
}

// ServerStatsLoad Statistics about the current load on the server.
type ServerStatsLoad struct {
	// Avg15m the 15 minute load average.
	Avg15m float32 `json:"avg15m"`

	// Avg1m The 1 minute load average.
	Avg1m float32 `json:"avg1m"`

	// Avg5m The 5 minute load average.
	Avg5m float32 `json:"avg5m"`
}

// ServerStatsNetwork Statistics about the networks on a given server.
type ServerStatsNetwork struct {
	// ExternalIpv4 The public IPv4 address used to connect to this server.
	ExternalIpv4 string `json:"external_ipv4"`

	// ExternalIpv6 The public IPv6 address used to connect to this server.
	ExternalIpv6 string `json:"external_ipv6"`

	// Interfaces Network interfaces for a given server.
	Interfaces *map[string]struct {
		// Addrs An array of IP addresses associated with the interface.
		Addrs *[]string `json:"addrs"`

		// Flags Flags for the given interface.
		Flags string `json:"flags"`

		// Interface The interface name.
		Interface string `json:"interface"`

		// MacAddr The mac address for the interface.
		MacAddr string `json:"mac_addr"`

		// Mtu The maximum transmission unit for the interface.
		Mtu int `json:"mtu"`

		// RxBytes The bytes received over the interface.
		RxBytes int `json:"rx_bytes"`

		// Speed The link speed for the interface in megabits.
		Speed int `json:"speed"`

		// TxBytes The bytes transmitted over the interface.
		TxBytes int `json:"tx_bytes"`
	} `json:"interfaces,omitempty"`
}

// ServerStatsOS Statistics about the operating system installed on the server (CycleOS).
type ServerStatsOS struct {
	// Hostname The hostname as set by the given server's OS.
	Hostname *string `json:"hostname,omitempty"`

	// Kernel The currently installed kernel version.
	Kernel *string `json:"kernel,omitempty"`

	// Release The currently installed release version of the OS.
	Release *string `json:"release,omitempty"`
}

// ServerStatsRam Statistics about the RAM on a given server.
type ServerStatsRam struct {
	// Available The available RAM on the server.
	Available int `json:"available"`

	// Free The free RAM on the server.
	Free int `json:"free"`

	// Total The total RAM on the server.
	Total int `json:"total"`
}

// ServerStatsRamTelemetry Statistics about the RAM on a given server.
type ServerStatsRamTelemetry struct {
	// Available The available RAM on the server.
	Available float32 `json:"available"`

	// Free The free RAM on the server.
	Free float32 `json:"free"`

	// Total The total RAM on the server.
	Total float32 `json:"total"`
}

// ServerStatsStorage Statistics about storage for a given server.
type ServerStatsStorage struct {
	// Mounts Records that show information about mounted filesystems where the key is the path to the mount.
	Mounts map[string]struct {
		// Device The device assocaited with the mount.
		Device *string `json:"device,omitempty"`

		// Free The amount of uninitialized storage in KB.
		Free int `json:"free"`

		// Mountpoint The path the mount is associated with.
		Mountpoint *string `json:"mountpoint,omitempty"`

		// Total The total amount of storage in KB available at this mount.
		Total int `json:"total"`

		// Type The type of filesystem in use by the mount.
		Type string `json:"type"`

		// Used The amount of storage being used in KB.
		Used int `json:"used"`
	} `json:"mounts"`

	// VolumeGroups An array of volume group objects.
	VolumeGroups map[string]struct {
		// Name A name for the volume group.
		Name string `json:"name"`

		// Size A number representing the aggregate group volume size in megabytes.
		Size int `json:"size"`

		// Volumes The actual volumes.
		Volumes map[string]struct {
			// DataPercent The percent of the volumes size being used by data.
			DataPercent int `json:"data_percent"`

			// MetaPercent The percent of the volumes size being used by meta data.
			MetaPercent int `json:"meta_percent"`

			// Name The name of the volume.
			Name string `json:"name"`

			// Pool The name of the volume pool this volume is associated with.
			Pool string `json:"pool"`

			// Size The size in megabytes of the volume.
			Size int `json:"size"`
		} `json:"volumes"`
	} `json:"volume_groups"`
}

// ServerStatsTelemetry Statistics about a given servers telemetery data.
type ServerStatsTelemetry struct {
	CpuUsage *ServerStatsCpuUsageTelemetry `json:"cpu_usage,omitempty"`

	// Load Statistics about the current load on the server.
	Load ServerStatsLoad `json:"load"`

	// Ram Statistics about the RAM on a given server.
	Ram ServerStatsRamTelemetry `json:"ram"`

	// StorageBase Telemetry data for the base volume of a given server.
	StorageBase struct {
		// Free The amount of free space on the base volume.
		Free int `json:"free"`

		// Total The total amount of space on the base volume.
		Total int `json:"total"`

		// Used The amount of storage currently used in the base volume.
		Used int `json:"used"`
	} `json:"storage_base"`

	// StoragePool User data storage across all devices.
	StoragePool struct {
		// DataPercent The percentage of storage used by user data.
		DataPercent float32 `json:"data_percent"`

		// MetaPercent The percentage of storage used by the file allocation stables, etc.
		MetaPercent float32 `json:"meta_percent"`

		// Total The total amount of storage available.
		Total float32 `json:"total"`
	} `json:"storage_pool"`
	Time DateTime `json:"time"`
}

// ServerStatsUptime Statistics describing the uptime of a given server.
type ServerStatsUptime struct {
	// CpuIdle CPU idle time.
	CpuIdle *float32 `json:"cpu_idle,omitempty"`

	// Seconds The amount in seconds the server has been up (resets on restart).
	Seconds *float32 `json:"seconds,omitempty"`
}

// ServerStatsVendor Details about the vendors for the server.
type ServerStatsVendor struct {
	// BiosVendor The bios vendor of the server.
	BiosVendor *string `json:"bios_vendor,omitempty"`

	// BoardName The board name of the server.
	BoardName *string `json:"board_name,omitempty"`

	// BoardSerial The board serial number of the server.
	BoardSerial *string `json:"board_serial,omitempty"`

	// BoardVendor The board vendor of the server.
	BoardVendor *string `json:"board_vendor,omitempty"`

	// SystemVendor The system vendor of the server.
	SystemVendor *string `json:"system_vendor,omitempty"`
}

// ServerStatsVersions Information about the versions of Cycle services on a given server.
type ServerStatsVersions struct {
	// Services A list of records about Cycle services.
	Services map[string]string `json:"services"`
}

// ServerTags Tags for a given server.
type ServerTags struct {
	// Data An array of server tags.
	Data []string `json:"data"`
}

// ServerTask defines model for ServerTask.
type ServerTask struct {
	union json.RawMessage
}

// ServerUnquarantineAction defines model for ServerUnquarantineAction.
type ServerUnquarantineAction struct {
	// Action The action to take.
	Action   ServerUnquarantineActionAction `json:"action"`
	Contents struct {
		Cluster string `json:"cluster"`
	} `json:"contents"`
}

// ServerUnquarantineActionAction The action to take.
type ServerUnquarantineActionAction string

// ServersIncludes A resource that is associated with a server.
type ServersIncludes map[string]Server

// ServiceContainerIdentifier Identifier of a service Container within an Environment.
type ServiceContainerIdentifier string

// ServiceItem Information for an item's plan.
type ServiceItem struct {
	// Support Information about the support component of the billing item.
	Support *struct {
		// Id A 24 character hex string used to identify a unique resource.
		Id ID `json:"id"`

		// Name The support contract name.
		Name string `json:"name"`

		// Price The price of the support contract (monthly).
		Price int `json:"price"`
	} `json:"support,omitempty"`

	// Tier Information about the tier component of the billing item.
	Tier *struct {
		// Id A 24 character hex string used to identify a unique resource.
		Id ID `json:"id"`

		// Name The support contract name.
		Name string `json:"name"`

		// Price An object holding information about term and amount that relates to a specific billing component.
		Price BillingAmount `json:"price"`
	} `json:"tier,omitempty"`
}

// Session Session info about the activity entry.
type Session struct {
	// ApiKey The API key ID.
	ApiKey *string `json:"api_key"`

	// Ip The IP of the account associated with the session.
	Ip    string `json:"ip"`
	Token *struct {
		ApplicationCapabilitiesVersion int `json:"application_capabilities_version"`

		// ApplicationId A 24 character hex string used to identify a unique resource.
		ApplicationId ID `json:"application_id"`
	} `json:"token"`

	// Url URL endpoint assocaited with the activity context - does not include domain.
	Url string `json:"url"`
}

// ShutdownSignal Process signals that Cycle can be configured to send to the container on a shutdown event.
type ShutdownSignal string

// SleepStep Settings for the sleep step for a pipeline.
type SleepStep struct {
	// Action The action that the step takes.
	Action  SleepStepAction `json:"action"`
	Details struct {
		// Duration A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
		Duration *Duration `json:"duration,omitempty"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// SleepStepAction The action that the step takes.
type SleepStepAction string

// SourceAwsEbs An AWS EBS volume source. Defines how to authenticate to AWS and which EBS volume to attach.
type SourceAwsEbs struct {
	Details struct {
		// Auth AWS credentials for accessing EBS. Either an instance role may be used or explicit Access Key credentials may be provided.
		Auth SourceAwsEbsAuth `json:"auth"`

		// Volume Reference to the specific EBS volume to attach.
		Volume SourceAwsEbsRef `json:"volume"`
	} `json:"details"`
	Type SourceAwsEbsType `json:"type"`
}

// SourceAwsEbsType defines model for SourceAwsEbs.Type.
type SourceAwsEbsType string

// SourceAwsEbsAuth AWS credentials for accessing EBS. Either an instance role may be used or explicit Access Key credentials may be provided.
type SourceAwsEbsAuth struct {
	// AccessKeyId AWS Access Key ID to use for authentication (optional if using instance role).
	AccessKeyId *string `json:"access_key_id,omitempty"`

	// SecretAccessKey AWS Secret Access Key to use for authentication (optional if using instance role).
	SecretAccessKey *string `json:"secret_access_key,omitempty"`

	// UseInstanceRole When true, use the instance's IAM role for authentication.
	UseInstanceRole *bool `json:"use_instance_role,omitempty"`
}

// SourceAwsEbsRef Reference to the specific EBS volume to attach.
type SourceAwsEbsRef struct {
	// Az Optional AWS Availability Zone where the volume resides (for example, "us-east-1a").
	Az *string `json:"az,omitempty"`

	// VolumeId The EBS volume ID (for example, "vol-0abcd1234ef567890").
	VolumeId string `json:"volume_id"`
}

// SourceCephRbd A Ceph RBD volume source. Defines monitor endpoints, optional cluster FSID, client identity (CephX), and the specific image to attach.
type SourceCephRbd struct {
	Details struct {
		// Image Reference to the specific RBD image to attach.
		Image SourceCephRbdImageRef `json:"image"`

		// IntegrationId A 24 character hex string used to identify a unique resource.
		IntegrationId ID `json:"integration_id"`
	} `json:"details"`
	Type SourceCephRbdType `json:"type"`
}

// SourceCephRbdType defines model for SourceCephRbd.Type.
type SourceCephRbdType string

// SourceCephRbdImageRef Reference to the specific RBD image to attach.
type SourceCephRbdImageRef struct {
	// Name Name of the RBD image.
	Name string `json:"name"`

	// Namespace Optional RBD namespace within the pool.
	Namespace *string `json:"namespace,omitempty"`

	// Pool Name of the Ceph pool containing the RBD image.
	Pool string `json:"pool"`

	// Snapshot Optional snapshot name if attaching a snapshot view of the image.
	Snapshot *string `json:"snapshot,omitempty"`
}

// SourceIncludes A resource associate with an image source.
type SourceIncludes struct {
	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`

	// Integrations A resource that is associated with an integration.
	Integrations *IntegrationsIncludes `json:"integrations,omitempty"`

	// IntegrationsIdentifiers A map of identifiers to an array of resource IDs that are associated with it. All IDs point to the same type of resource.
	IntegrationsIdentifiers *IdentifierIncludes `json:"integrations:identifiers,omitempty"`
}

// SourceSanIscsi A SAN iSCSI volume source. Defines one or more iSCSI targets and the LUN number to attach.
type SourceSanIscsi struct {
	Details struct {
		// IntegrationIds One or more iSCSI integration IDs to use for authentication.
		IntegrationIds []ID `json:"integration_ids"`

		// Lun Logical Unit Number exposed by the target(s) to attach.
		Lun int32 `json:"lun"`
	} `json:"details"`
	Type SourceSanIscsiType `json:"type"`
}

// SourceSanIscsiType defines model for SourceSanIscsi.Type.
type SourceSanIscsiType string

// Stack Stacks are a way to orchestrate multiple containers atomically and automatically.
type Stack struct {
	Acl *ACL `json:"acl"`

	// Creator A type of creator and a matching identifier.
	Creator UserScope `json:"creator"`

	// Events A collection of timestamps for each event in the Stacks lifetime.
	Events struct {
		Created   DateTime `json:"created"`
		Deleted   DateTime `json:"deleted"`
		LastBuild DateTime `json:"last_build"`
		Updated   DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`

	// Meta A list of meta fields that can be applied to this stack.
	Meta *StackMeta `json:"meta,omitempty"`

	// Name A user defined name for the stack resource.
	Name string `json:"name"`

	// Source A source for a stack to be created from.
	Source StackSource `json:"source"`
	State  StackState  `json:"state"`

	// Variables A map of default variable values used when building this stack. A variable can be added anywhere in a stack using the format `{{var}}` where `var` would be a key in this map.
	Variables *map[string]string `json:"variables,omitempty"`
}

// StackBuild A stack build resource.
type StackBuild struct {
	// About Information about the stack build.
	About struct {
		// Description Information describing the stack
		Description string `json:"description"`

		// GitCommit Information about the git commit this stack build was created from.
		GitCommit *StackGitCommit `json:"git_commit,omitempty"`

		// Version Information about the version of the stack.
		Version string `json:"version"`
	} `json:"about"`

	// Events A collection of timestamps for each event in the stack build's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Instructions Additional instructions used when generating this stack build.
	Instructions StackBuildInstructions `json:"instructions"`

	// Meta A list of meta fields that can be applied to a stack build.
	Meta *StackBuildMeta `json:"meta,omitempty"`
	Spec *StackSpec      `json:"spec"`

	// StackId An identifier for the stack related to this build.
	StackId string          `json:"stack_id"`
	State   StackBuildState `json:"state"`
}

// StackBuildAbout Information about the stack build.
type StackBuildAbout struct {
	// Description A user defined description for the build.
	Description string `json:"description"`

	// GitCommit Information about the git commit this stack build was created from.
	GitCommit *StackGitCommit `json:"git_commit,omitempty"`

	// Version A user defined version of the build.
	Version string `json:"version"`
}

// StackBuildCreateStep Settings for creating a stack build in a pipeline.
type StackBuildCreateStep struct {
	// Action The action that the step takes.
	Action  StackBuildCreateStepAction `json:"action"`
	Details struct {
		// About Information about the stack build.
		About *struct {
			// Description A user defined description for the build.
			Description string `json:"description"`

			// Version A user defined version of the build.
			Version string `json:"version"`
		} `json:"about"`

		// Instructions Additional instructions used when generating this stack build.
		Instructions *struct {
			// Git Git information specifics.
			Git *struct {
				// Type The type of information the user is passing.
				Type StackBuildCreateStepDetailsInstructionsGitType `json:"type"`

				// Value The actual value to be passed.
				Value string `json:"value"`
			} `json:"git,omitempty"`

			// Variables Custom variables applied to the stack during build. Any place in the stack where a `{{variable}}` is used is replaced with the value of the variable supplied in this map.
			Variables *map[string]string `json:"variables,omitempty"`
		} `json:"instructions"`

		// Stack An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Stack FluidIdentifier `json:"stack"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// StackBuildCreateStepAction The action that the step takes.
type StackBuildCreateStepAction string

// StackBuildCreateStepDetailsInstructionsGitType The type of information the user is passing.
type StackBuildCreateStepDetailsInstructionsGitType string

// StackBuildDeployAction defines model for StackBuildDeployAction.
type StackBuildDeployAction struct {
	// Action The action the job takes.
	Action StackBuildDeployActionAction `json:"action"`

	// Contents Additional information needed for the job.
	Contents struct {
		Deployment *Deployment `json:"deployment"`

		// EnvironmentId The ID for the environment this stack build will be deployed to.
		EnvironmentId string                       `json:"environment_id"`
		Update        *StackBuildDeploymentUpdates `json:"update"`

		// Variables Custom variables applied to the stack during deploy. Any place in the stack where a `{{variable}}` is used is replaced with the value of the variable supplied in this map.
		Variables *map[string]string `json:"variables,omitempty"`
	} `json:"contents"`
}

// StackBuildDeployActionAction The action the job takes.
type StackBuildDeployActionAction string

// StackBuildDeployStep Settings for deploying a stack build in a pipeline.
type StackBuildDeployStep struct {
	// Action The action that the step takes.
	Action  StackBuildDeployStepAction `json:"action"`
	Details struct {
		// Build An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Build      FluidIdentifier `json:"build"`
		Deployment *Deployment     `json:"deployment"`

		// Environment An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Environment FluidIdentifier              `json:"environment"`
		Update      *StackBuildDeploymentUpdates `json:"update"`

		// Variables Custom variables applied to the stack during deploy. Any place in the stack where a `{{variable}}` is used is replaced with the value of the variable supplied in this map.
		Variables *map[string]string `json:"variables,omitempty"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// StackBuildDeployStepAction The action that the step takes.
type StackBuildDeployStepAction string

// StackBuildDeploymentUpdates Optional update object used to specify specific params to update from the stack build.
type StackBuildDeploymentUpdates struct {
	// Containers A map of the container identifiers to update within the environment.
	Containers map[string]StackDeployContainersObject `json:"containers"`

	// ScopedVariables An object that describes configuration options for scoped variables on stack build. If null, scoped variables will be ignored during deployment events.
	ScopedVariables *struct {
		// AddNew If set to true, any scoped variables that are new to the environment will be created when deployed.
		AddNew bool `json:"add_new"`

		// AssociateDeployment If set to true and `add_new` is enabled, any variables that dont exist FOR THAT DEPLOYMENT will be created.
		// If set to true and `replace_existing` is enabled, any matching variables FOR THAT DEPLOYMENT will be replaced.
		AssociateDeployment bool `json:"associate_deployment"`

		// ReplaceExisting When deploying to the environment, any scoped variables defined in the build that match an existing scoped variable in the environment will cause the existing scoped variable to be updated to the new value.
		ReplaceExisting bool `json:"replace_existing"`
	} `json:"scoped_variables"`
}

// StackBuildGenerateAction defines model for StackBuildGenerateAction.
type StackBuildGenerateAction struct {
	// Action The job to do.
	Action StackBuildGenerateActionAction `json:"action"`
}

// StackBuildGenerateActionAction The job to do.
type StackBuildGenerateActionAction string

// StackBuildGenerateStep Settings for the stack build generate step for a pipeline.
type StackBuildGenerateStep struct {
	// Action The action that the step takes.
	Action  StackBuildGenerateStepAction `json:"action"`
	Details struct {
		// Build An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Build FluidIdentifier `json:"build"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// StackBuildGenerateStepAction The action that the step takes.
type StackBuildGenerateStepAction string

// StackBuildIncludes A resource that is associated with a stack build.
type StackBuildIncludes map[string]StackBuild

// StackBuildInstructions Additional instructions used when generating this stack build.
type StackBuildInstructions struct {
	// Git Git information specifics.
	Git *struct {
		// Type The type of information the user is passing.
		Type StackBuildInstructionsGitType `json:"type"`

		// Value The actual value to be passed.
		Value string `json:"value"`
	} `json:"git,omitempty"`

	// Variables Custom variables applied to the stack during build. Any place in the stack where a `{{variable}}` is used is replaced with the value of the variable supplied in this map.
	Variables *map[string]string `json:"variables,omitempty"`
}

// StackBuildInstructionsGitType The type of information the user is passing.
type StackBuildInstructionsGitType string

// StackBuildLog A build log for a given stack build.
type StackBuildLog struct {
	// BuildId The ID of stack build the build log pertains to.
	BuildId string `json:"build_id"`

	// Events A collection of timestamps for each event in the build log's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Log The log itself.
	Log string `json:"log"`

	// StackId The ID of stack the build log pertains to.
	StackId string `json:"stack_id"`
}

// StackBuildMeta A list of meta fields that can be applied to a stack build.
type StackBuildMeta struct {
	// ContainersCount A summary of resources by state
	ContainersCount *StateCountSummary `json:"containers_count,omitempty"`
}

// StackBuildState defines model for StackBuildState.
type StackBuildState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the stack build.
	Current StackBuildStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// StackBuildStateCurrent The current state of the stack build.
type StackBuildStateCurrent string

// StackBuildTask defines model for StackBuildTask.
type StackBuildTask struct {
	union json.RawMessage
}

// StackDeployContainersObject Options to control how a container behaves when a stack build is deployed.
type StackDeployContainersObject struct {
	// Reconfigure A boolean where true represents the container is to be reconfigured.
	Reconfigure bool `json:"reconfigure"`

	// Reimage A boolean where true represents the container is to be reimaged.
	Reimage bool `json:"reimage"`
}

// StackGitCommit Information about the git commit this stack build was created from.
type StackGitCommit struct {
	// Author Inforamtion about the author of the commit.
	Author struct {
		// Email The commit authors email address.
		Email string `json:"email"`

		// Name The commit authors name.
		Name string `json:"name"`
	} `json:"author"`

	// Hash The commit hash for the given stack build.
	Hash string `json:"hash"`

	// Message The commit message for the given stack build hash.
	Message string   `json:"message"`
	Time    DateTime `json:"time"`
}

// StackImageSourceType defines model for StackImageSourceType.
type StackImageSourceType struct {
	Details struct {
		Containers []Identifier `json:"containers"`
		Id         string       `json:"id"`

		// Origin The origin of the image.
		Origin  ImageOrigin `json:"origin"`
		StackId string      `json:"stack_id"`
	} `json:"details"`
	Override *struct {
		Target   *string `json:"target,omitempty"`
		TargzUrl *string `json:"targz_url,omitempty"`
	} `json:"override,omitempty"`
	Type StackImageSourceTypeType `json:"type"`
}

// StackImageSourceTypeType defines model for StackImageSourceType.Type.
type StackImageSourceTypeType string

// StackInclude All includable resources linkable to the given stack.
type StackInclude struct {
	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`
}

// StackIncludes A resource associated with a stack.
type StackIncludes map[string]Stack

// StackMeta A list of meta fields that can be applied to this stack.
type StackMeta struct {
	// BuildsCount A summary of resources by state
	BuildsCount *StateCountSummary `json:"builds_count,omitempty"`

	// ContainersCount A summary of resources by state
	ContainersCount *StateCountSummary `json:"containers_count,omitempty"`
}

// StackPruneStep Settings for pruning a stack in a pipeline.
type StackPruneStep struct {
	// Action The action that the step takes.
	Action  StackPruneStepAction `json:"action"`
	Details struct {
		Criteria *struct {
			Expire *Duration `json:"expire"`
		} `json:"criteria"`

		// Stack An identifier used in pipelines to refer to different kinds of resources across Cycle.
		//
		// - `id:<mongo id>`: A raw resource ID
		// - `resource:<a resource identifier>`: A compound identifier pointing to a resource.
		// - `from:<stage/step>`: For referencing a previous pipeline step.
		Stack FluidIdentifier `json:"stack"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// StackPruneStepAction The action that the step takes.
type StackPruneStepAction string

// StackRawSource A stack spec resource.
type StackRawSource struct {
	Details *StackSpec         `json:"details"`
	Type    StackRawSourceType `json:"type"`
}

// StackRawSourceType defines model for StackRawSource.Type.
type StackRawSourceType string

// StackRepoSource A repo source type for a stack.
type StackRepoSource struct {
	Details struct {
		// Auth Authentication information for the repository.
		Auth *StackRepoSource_Details_Auth `json:"auth,omitempty"`

		// Branch An optional branch arguement.  Default value is `master`.
		Branch *string `json:"branch,omitempty"`

		// Ref Repository reference information.
		Ref *struct {
			// Type The type of reference being used.
			Type string `json:"type"`

			// Value The value for the given reference type.
			Value string `json:"value"`
		} `json:"ref,omitempty"`

		// StackFile Specify which file in the repo contains the stack spec. By default, it is `cycle.json` in the root of the repo.
		StackFile *string `json:"stack_file"`

		// Url The URL of the repository.
		Url string `json:"url"`
	} `json:"details"`
	Type StackRepoSourceType `json:"type"`
}

// StackRepoSource_Details_Auth Authentication information for the repository.
type StackRepoSource_Details_Auth struct {
	union json.RawMessage
}

// StackRepoSourceType defines model for StackRepoSource.Type.
type StackRepoSourceType string

// StackSource A source for a stack to be created from.
type StackSource struct {
	union json.RawMessage
}

// StackSpec A Cycle stack file is an "environment as code". This allows an environment to be generated consistently based on a fixed specification.
// Stack files can describe multiple containers and their configurations, environment service settings, scoped variables, and important metadata.
type StackSpec struct {
	About *StackSpec_About `json:"about,omitempty"`

	// Annotations Additional meta info about the stack.
	Annotations *StackSpec_Annotations `json:"annotations,omitempty"`
	Containers  StackSpec_Containers   `json:"containers"`

	// Monitoring Monitoring options for containers within this stack.
	Monitoring *StackSpec_Monitoring `json:"monitoring,omitempty"`

	// ScopedVariables Describes variables that are assigned to one or more containers at runtime. Can be assigned as an environment variable, written as a file inside the container(s), or accessed over the internal API.
	ScopedVariables *StackSpec_ScopedVariables `json:"scoped_variables,omitempty"`

	// Services Settings for any auxillary services deployed as part of the environment, such as load balancer and discovery services.
	Services *StackSpec_Services `json:"services,omitempty"`

	// Version The version of the Cycle stack file used.
	Version StackSpecVersion `json:"version"`
}

// StackSpecAbout0 defines model for .
type StackSpecAbout0 struct {
	// Description Custom, user-defined details about this stack.
	Description string `json:"description"`

	// Version A custom, user-defined version of the stack.
	Version string `json:"version"`
}

// StackSpec_About defines model for StackSpec.About.
type StackSpec_About struct {
	union json.RawMessage
}

// StackSpecAnnotations0 defines model for .
type StackSpecAnnotations0 map[string]interface{}

// StackSpec_Annotations Additional meta info about the stack.
type StackSpec_Annotations struct {
	union json.RawMessage
}

// StackSpecContainers0 A mapping of containers that will be deployed as a part of this stack. The key is used as the container's identifier.
type StackSpecContainers0 map[string]StackSpecContainer

// StackSpec_Containers defines model for StackSpec.Containers.
type StackSpec_Containers struct {
	union json.RawMessage
}

// StackSpec_Monitoring Monitoring options for containers within this stack.
type StackSpec_Monitoring struct {
	union json.RawMessage
}

// StackSpecScopedVariables0 defines model for .
type StackSpecScopedVariables0 = []StackSpecScopedVariable

// StackSpec_ScopedVariables Describes variables that are assigned to one or more containers at runtime. Can be assigned as an environment variable, written as a file inside the container(s), or accessed over the internal API.
type StackSpec_ScopedVariables struct {
	union json.RawMessage
}

// StackSpecServices0 defines model for .
type StackSpecServices0 struct {
	Discovery    *StackVariable `json:"discovery"`
	Loadbalancer *StackVariable `json:"loadbalancer"`
	Scheduler    *StackVariable `json:"scheduler"`
	Vpn          *StackVariable `json:"vpn"`
}

// StackSpec_Services Settings for any auxillary services deployed as part of the environment, such as load balancer and discovery services.
type StackSpec_Services struct {
	union json.RawMessage
}

// StackSpecVersion The version of the Cycle stack file used.
type StackSpecVersion string

// StackSpecContainer A container template defined within a stack.
type StackSpecContainer struct {
	Annotations *StackSpecContainer_Annotations `json:"annotations,omitempty"`
	Config      StackSpecContainer_Config       `json:"config"`

	// Deprecate If true, the container is marked as `deprecated`, and cannot be started anymore. Deprecated containers also don't count toward resource utilization.
	Deprecate *StackSpecContainer_Deprecate `json:"deprecate,omitempty"`

	// Image Details about the image used for this container.
	Image StackSpecContainer_Image `json:"image"`

	// Lock If true, the container is marked as `locked` and cannot be deleted in any way until the lock is lifted.
	Lock *StackSpecContainer_Lock `json:"lock,omitempty"`

	// Name The human-readable name of this container.
	Name string `json:"name"`

	// Role The role applied to this container. **Not yet implemented**
	Role *StackSpecContainerRole `json:"role"`

	// Stateful Whether or not to mark the container as stateful when deployed. Stateful containers can utilize volumes (stateful data) and are generally used for running databases or other data management applications.
	Stateful StackSpecContainer_Stateful `json:"stateful"`

	// Volumes A list of configurations for volumes that will be attached to the container. Only applicable if the container is set to `stateful`.
	Volumes *StackSpecContainer_Volumes `json:"volumes,omitempty"`
}

// StackSpecContainerAnnotations0 Additional user-provided meta data about the container.
type StackSpecContainerAnnotations0 map[string]interface{}

// StackSpecContainer_Annotations defines model for StackSpecContainer.Annotations.
type StackSpecContainer_Annotations struct {
	union json.RawMessage
}

// StackSpecContainerConfig0 Configuration options for this container that will be applied when deployed as part of the stack.
type StackSpecContainerConfig0 struct {
	Deploy       StackSpecContainer_Config_0_Deploy  `json:"deploy"`
	Integrations *StackVariable                      `json:"integrations"`
	Network      StackSpecContainer_Config_0_Network `json:"network"`
	Resources    *StackVariable                      `json:"resources"`
	Runtime      *StackVariable                      `json:"runtime"`

	// Scaling Configuration options for auto-scaling.
	Scaling *StackVariable `json:"scaling"`
}

// StackSpecContainer_Config_0_Deploy defines model for StackSpecContainer.Config.0.Deploy.
type StackSpecContainer_Config_0_Deploy struct {
	union json.RawMessage
}

// StackSpecContainer_Config_0_Network defines model for StackSpecContainer.Config.0.Network.
type StackSpecContainer_Config_0_Network struct {
	union json.RawMessage
}

// StackSpecContainer_Config defines model for StackSpecContainer.Config.
type StackSpecContainer_Config struct {
	union json.RawMessage
}

// StackSpecContainerDeprecate0 defines model for .
type StackSpecContainerDeprecate0 = bool

// StackSpecContainer_Deprecate If true, the container is marked as `deprecated`, and cannot be started anymore. Deprecated containers also don't count toward resource utilization.
type StackSpecContainer_Deprecate struct {
	union json.RawMessage
}

// StackSpecContainer_Image Details about the image used for this container.
type StackSpecContainer_Image struct {
	union json.RawMessage
}

// StackSpecContainerLock0 defines model for .
type StackSpecContainerLock0 = bool

// StackSpecContainer_Lock If true, the container is marked as `locked` and cannot be deleted in any way until the lock is lifted.
type StackSpecContainer_Lock struct {
	union json.RawMessage
}

// StackSpecContainerRole The role applied to this container. **Not yet implemented**
type StackSpecContainerRole string

// StackSpecContainerStateful0 defines model for .
type StackSpecContainerStateful0 = bool

// StackSpecContainer_Stateful Whether or not to mark the container as stateful when deployed. Stateful containers can utilize volumes (stateful data) and are generally used for running databases or other data management applications.
type StackSpecContainer_Stateful struct {
	union json.RawMessage
}

// StackSpecContainerVolumes0 defines model for .
type StackSpecContainerVolumes0 = []StackSpecContainerVolume

// StackSpecContainer_Volumes A list of configurations for volumes that will be attached to the container. Only applicable if the container is set to `stateful`.
type StackSpecContainer_Volumes struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeploy Stack configuration options related to how the container behaves over its lifecycle (startup, shutdown, health checks, etc).
type StackSpecContainerConfigDeploy struct {
	// Constraints Configuration options that provide the ability to set restrictions on which nodes instances of this container are able to be deployed to. (i.e. if you have a GPU container, it should only go on nodes with a GPU).
	Constraints *StackSpecContainerConfigDeploy_Constraints `json:"constraints,omitempty"`

	// Function Configuration options for containers using the 'function' deployment strategy.
	Function *StackSpecContainerConfigDeploy_Function `json:"function,omitempty"`

	// HealthCheck Configuration options for automated container health checks.
	HealthCheck *StackSpecContainerConfigDeploy_HealthCheck `json:"health_check,omitempty"`

	// Instances The number of desired instances to deploy.
	Instances StackSpecContainerConfigDeploy_Instances `json:"instances"`

	// Restart Configuration options for how Cycle should handle restarting this container (i.e. in case the process inside the container dies).
	Restart *StackSpecContainerConfigDeploy_Restart `json:"restart,omitempty"`

	// Shutdown Configuration options for how this container behaves during shutdown.
	Shutdown *StackSpecContainerConfigDeploy_Shutdown `json:"shutdown,omitempty"`

	// Startup Configuration options for how this container behaves during startup.
	Startup *StackSpecContainerConfigDeploy_Startup `json:"startup,omitempty"`

	// Stateful Configuration options for stateful containers.
	Stateful *StackSpecContainerConfigDeploy_Stateful `json:"stateful,omitempty"`

	// Strategy The strategy Cycle will apply when deploying instances of this container.
	//
	// - ** resource-density **: Cycle will distribute instances across servers to maintain balanced resource usage.
	// - ** high-availability **: Cycle will deploy instances across servers with an emphasis on geographic and physical separation. Requires multiple locations.
	// - ** distributed **: Cycle will deploy instances across servers with an emphasis on physical separation. Does not require multiple locations.
	// - ** first-available **: Cycle will deploy one instance to every server that matches the specified criteria. (default)
	// - ** node **: Cycle will deploy one instance to every server that matches the specified criteria.
	// - ** edge **: Cycle will prioritize geographic distribution of instances.
	// - ** function **: Every ingress request/connection receives its own instance.
	// - ** manual **: Cycle will not make any decisions on where instances are deployed. Instead, instances must be deployed manually using the portal or API.
	Strategy *string `json:"strategy,omitempty"`

	// Telemetry Configuration options for how the instance telemetry (CPU usage, etc) is handled.
	Telemetry *StackSpecContainerConfigDeploy_Telemetry `json:"telemetry,omitempty"`

	// Update Configurations for how the container behaves during updates.
	Update *StackSpecContainerConfigDeploy_Update `json:"update,omitempty"`
}

// StackSpecContainerConfigDeployConstraints0 defines model for .
type StackSpecContainerConfigDeployConstraints0 struct {
	Node *struct {
		// Tags Tags applied to a node. Cycle generates some automatically, but additional, custom tags can be applied on a per-node basis.
		Tags StackSpecContainerConfigDeploy_Constraints_0_Node_Tags `json:"tags"`
	} `json:"node"`
}

// StackSpecContainerConfigDeployConstraints0NodeTags0 defines model for .
type StackSpecContainerConfigDeployConstraints0NodeTags0 struct {
	// All A node must have **ALL** of these tags to be considered a valid deployment target for this container.
	All *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All `json:"all,omitempty"`

	// Any If a node has at least one of these tags, it is considered a valid deployment target for this container.
	Any *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any `json:"any,omitempty"`
}

// StackSpecContainerConfigDeployConstraints0NodeTags0All0 defines model for .
type StackSpecContainerConfigDeployConstraints0NodeTags0All0 = []string

// StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All A node must have **ALL** of these tags to be considered a valid deployment target for this container.
type StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeployConstraints0NodeTags0Any0 defines model for .
type StackSpecContainerConfigDeployConstraints0NodeTags0Any0 = []string

// StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any If a node has at least one of these tags, it is considered a valid deployment target for this container.
type StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeploy_Constraints_0_Node_Tags Tags applied to a node. Cycle generates some automatically, but additional, custom tags can be applied on a per-node basis.
type StackSpecContainerConfigDeploy_Constraints_0_Node_Tags struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeploy_Constraints Configuration options that provide the ability to set restrictions on which nodes instances of this container are able to be deployed to. (i.e. if you have a GPU container, it should only go on nodes with a GPU).
type StackSpecContainerConfigDeploy_Constraints struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeployFunction0 defines model for .
type StackSpecContainerConfigDeployFunction0 struct {
	// MaxPoolSize The maximum number of instances that Cycle can pre-allocate (includes auto-scaled instances).
	MaxPoolSize *StackSpecContainerConfigDeploy_Function_0_MaxPoolSize `json:"max_pool_size,omitempty"`

	// MaxQueueTime The maximum amount of time Cycle will wait for an instance to be available.
	MaxQueueTime *StackVariable `json:"max_queue_time"`

	// MaxRuntime The maximum amount of time a function instance can run before timing out.
	MaxRuntime *StackVariable `json:"max_runtime"`

	// MaxShardConcurrency For each shard (scheduler), the maximum number of tasks it can run in parallel.
	MaxShardConcurrency *StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency `json:"max_shard_concurrency,omitempty"`
}

// StackSpecContainerConfigDeployFunction0MaxPoolSize0 defines model for .
type StackSpecContainerConfigDeployFunction0MaxPoolSize0 = int

// StackSpecContainerConfigDeploy_Function_0_MaxPoolSize The maximum number of instances that Cycle can pre-allocate (includes auto-scaled instances).
type StackSpecContainerConfigDeploy_Function_0_MaxPoolSize struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeployFunction0MaxShardConcurrency0 defines model for .
type StackSpecContainerConfigDeployFunction0MaxShardConcurrency0 = int

// StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency For each shard (scheduler), the maximum number of tasks it can run in parallel.
type StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeploy_Function Configuration options for containers using the 'function' deployment strategy.
type StackSpecContainerConfigDeploy_Function struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeployHealthCheck0 defines model for .
type StackSpecContainerConfigDeployHealthCheck0 struct {
	// Command The command or script to run to verify the health of the container. This script is run inside the container by Cycle.
	// This command accepts two types of entries:
	// - The first is a reference to a script that already lives in the container filesystem. This can be defined by giving the full path to the script as the value.   - The second format is an inline script.  If you need the code to execute within a shell, wrap the commands in escaped quotes like this `"\"curl -s -o /dev/console -w \"%{http_code}\" http://localhost:3000/_health | grep '200'  && exit 0 || exit 1\""`.  Do not use the `/bin/sh -c <commands>` format, this will not be accepted.
	Command string `json:"command"`

	// Delay How long to wait after a container start event before running health checks.
	Delay *StackVariable `json:"delay"`

	// Interval How long to wait between running health checks.
	Interval string `json:"interval"`

	// Restart A boolean where true represents the desire for the container to restart if any instance is unhealthy.
	Restart StackSpecContainerConfigDeploy_HealthCheck_0_Restart `json:"restart"`

	// Retries The number of times to retry the command before marking an instance unhealthy.
	Retries StackSpecContainerConfigDeploy_HealthCheck_0_Retries `json:"retries"`

	// Timeout How long before a health check attempt times out.
	Timeout string `json:"timeout"`
}

// StackSpecContainerConfigDeployHealthCheck0Restart0 defines model for .
type StackSpecContainerConfigDeployHealthCheck0Restart0 = bool

// StackSpecContainerConfigDeploy_HealthCheck_0_Restart A boolean where true represents the desire for the container to restart if any instance is unhealthy.
type StackSpecContainerConfigDeploy_HealthCheck_0_Restart struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeployHealthCheck0Retries0 defines model for .
type StackSpecContainerConfigDeployHealthCheck0Retries0 = int

// StackSpecContainerConfigDeploy_HealthCheck_0_Retries The number of times to retry the command before marking an instance unhealthy.
type StackSpecContainerConfigDeploy_HealthCheck_0_Retries struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeploy_HealthCheck Configuration options for automated container health checks.
type StackSpecContainerConfigDeploy_HealthCheck struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeployInstances0 defines model for .
type StackSpecContainerConfigDeployInstances0 = int

// StackSpecContainerConfigDeploy_Instances The number of desired instances to deploy.
type StackSpecContainerConfigDeploy_Instances struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeployRestart0 defines model for .
type StackSpecContainerConfigDeployRestart0 struct {
	// Condition Under what circumstances Cycle should try to restart this container.
	Condition string `json:"condition"`

	// Delay How long the platform will wait between restart attempts.
	Delay string `json:"delay"`

	// MaxAttempts The maximum number of restart attempts Cycle will make.
	MaxAttempts StackSpecContainerConfigDeploy_Restart_0_MaxAttempts `json:"max_attempts"`
}

// StackSpecContainerConfigDeployRestart0MaxAttempts0 defines model for .
type StackSpecContainerConfigDeployRestart0MaxAttempts0 = int

// StackSpecContainerConfigDeploy_Restart_0_MaxAttempts The maximum number of restart attempts Cycle will make.
type StackSpecContainerConfigDeploy_Restart_0_MaxAttempts struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeploy_Restart Configuration options for how Cycle should handle restarting this container (i.e. in case the process inside the container dies).
type StackSpecContainerConfigDeploy_Restart struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeployShutdown0 defines model for .
type StackSpecContainerConfigDeployShutdown0 struct {
	// GracefulTimeout How long the platform will wait for a container to stop gracefully.
	GracefulTimeout *StackVariable                                     `json:"graceful_timeout"`
	Signals         *StackSpecContainerConfigDeploy_Shutdown_0_Signals `json:"signals,omitempty"`
}

// StackSpecContainerConfigDeployShutdown0Signals0 Signals that should be sent to the container on shutdown.
type StackSpecContainerConfigDeployShutdown0Signals0 = []ShutdownSignal

// StackSpecContainerConfigDeploy_Shutdown_0_Signals defines model for StackSpecContainerConfigDeploy.Shutdown.0.Signals.
type StackSpecContainerConfigDeploy_Shutdown_0_Signals struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeploy_Shutdown Configuration options for how this container behaves during shutdown.
type StackSpecContainerConfigDeploy_Shutdown struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeployStartup0 defines model for .
type StackSpecContainerConfigDeployStartup0 struct {
	// Delay How long the platform will wait before sending the start signal to the given container.
	Delay *StackVariable `json:"delay"`
}

// StackSpecContainerConfigDeploy_Startup Configuration options for how this container behaves during startup.
type StackSpecContainerConfigDeploy_Startup struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeployStateful0 defines model for .
type StackSpecContainerConfigDeployStateful0 struct {
	// Options Stateful container options.
	Options *struct {
		// UseBaseHostname When enabled, instances will utilize stateless base hostnames instead of being prefixed with a unique ID.
		UseBaseHostname *bool `json:"use_base_hostname"`
	} `json:"options"`
}

// StackSpecContainerConfigDeploy_Stateful Configuration options for stateful containers.
type StackSpecContainerConfigDeploy_Stateful struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeployTelemetry0 defines model for .
type StackSpecContainerConfigDeployTelemetry0 struct {
	// Disable If true, Cycle will not aggregate telemetry for this container's instances.
	Disable StackSpecContainerConfigDeploy_Telemetry_0_Disable `json:"disable"`

	// Interval The duration between samples.
	Interval *StackVariable `json:"interval"`

	// Retention How long telemetry data should be retained.
	Retention *StackVariable `json:"retention"`

	// Webhook A URL where Cycle will send telemetry data to. The payload will be an instance resource snapshot.
	Webhook *string `json:"webhook,omitempty"`
}

// StackSpecContainerConfigDeployTelemetry0Disable0 defines model for .
type StackSpecContainerConfigDeployTelemetry0Disable0 = bool

// StackSpecContainerConfigDeploy_Telemetry_0_Disable If true, Cycle will not aggregate telemetry for this container's instances.
type StackSpecContainerConfigDeploy_Telemetry_0_Disable struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeploy_Telemetry Configuration options for how the instance telemetry (CPU usage, etc) is handled.
type StackSpecContainerConfigDeploy_Telemetry struct {
	union json.RawMessage
}

// StackSpecContainerConfigDeployUpdate0 defines model for .
type StackSpecContainerConfigDeployUpdate0 struct {
	// Stagger When set, Cycle will pick a random time from `0 - this duration`, and stagger the instances so they all start at different times (up to the time specified here).
	Stagger *StackVariable `json:"stagger"`
}

// StackSpecContainerConfigDeploy_Update Configurations for how the container behaves during updates.
type StackSpecContainerConfigDeploy_Update struct {
	union json.RawMessage
}

// StackSpecContainerConfigNetwork Stack configuration options related to the container's network.
type StackSpecContainerConfigNetwork struct {
	// Hostname The hostname of the container. This is how it can be referenced by other containers in the same environment.
	Hostname string `json:"hostname"`

	// Ports A list of port mappings on this container.
	Ports *StackSpecContainerConfigNetwork_Ports `json:"ports,omitempty"`

	// Public The level of public network access this container should have.
	Public string `json:"public"`
}

// StackSpecContainerConfigNetworkPorts0 defines model for .
type StackSpecContainerConfigNetworkPorts0 = []string

// StackSpecContainerConfigNetwork_Ports A list of port mappings on this container.
type StackSpecContainerConfigNetwork_Ports struct {
	union json.RawMessage
}

// StackSpecContainerImage defines model for StackSpecContainerImage.
type StackSpecContainerImage struct {
	// Build Additional details applied when building an image.
	Build *StackSpecContainerImage_Build `json:"build,omitempty"`

	// Builder A specific builder to use. By default, Cycle uses its factory service and a standard build command to build images, but this can be enhanced by using an image builder integration.
	Builder *StackSpecContainerImage_Builder `json:"builder,omitempty"`

	// Name The human-readable name of this image.
	Name *string `json:"name,omitempty"`

	// Origin Instructions on how to fetch or build this image.
	Origin StackSpecContainerImage_Origin `json:"origin"`
}

// StackSpecContainerImageBuild0 defines model for .
type StackSpecContainerImageBuild0 struct {
	// Args A map of build arguments applied to the image at build time.
	Args StackSpecContainerImage_Build_0_Args `json:"args"`
}

// StackSpecContainerImageBuild0Args0 defines model for .
type StackSpecContainerImageBuild0Args0 map[string]string

// StackSpecContainerImage_Build_0_Args A map of build arguments applied to the image at build time.
type StackSpecContainerImage_Build_0_Args struct {
	union json.RawMessage
}

// StackSpecContainerImage_Build Additional details applied when building an image.
type StackSpecContainerImage_Build struct {
	union json.RawMessage
}

// StackSpecContainerImageBuilder0 defines model for .
type StackSpecContainerImageBuilder0 struct {
	// IntegrationId Either a resource ID (objectid - i.e. 651586fca6078e98982dbd90) or a resource Identifier (human-readable)
	IntegrationId HybridIdentifier `json:"integration_id"`
}

// StackSpecContainerImage_Builder A specific builder to use. By default, Cycle uses its factory service and a standard build command to build images, but this can be enhanced by using an image builder integration.
type StackSpecContainerImage_Builder struct {
	union json.RawMessage
}

// StackSpecContainerImage_Origin Instructions on how to fetch or build this image.
type StackSpecContainerImage_Origin struct {
	union json.RawMessage
}

// StackSpecContainerVolume A container volume configuration.
type StackSpecContainerVolume struct {
	// BlockDevice Indicates that the volume will be used as unformatted block storage.
	BlockDevice *StackSpecContainerVolume_BlockDevice `json:"block_device,omitempty"`

	// Destination The path this volume should be mounted at inside the container.
	Destination string         `json:"destination"`
	External    *StackVariable `json:"external"`

	// Local Configuration options for local volumes.
	Local *StackSpecContainerVolume_Local `json:"local,omitempty"`

	// ReadOnly If true, the container will be unable to write data to the volume.
	ReadOnly *StackSpecContainerVolume_ReadOnly `json:"read_only,omitempty"`

	// RemoteAccess Configuration options for setting up remote access to this volume via SFTP.
	RemoteAccess *StackSpecContainerVolume_RemoteAccess `json:"remote_access,omitempty"`
}

// StackSpecContainerVolumeBlockDevice0 defines model for .
type StackSpecContainerVolumeBlockDevice0 = bool

// StackSpecContainerVolume_BlockDevice Indicates that the volume will be used as unformatted block storage.
type StackSpecContainerVolume_BlockDevice struct {
	union json.RawMessage
}

// StackSpecContainerVolumeLocal0 defines model for .
type StackSpecContainerVolumeLocal0 struct {
	// MaxSize The maximum size this volume can grow to. Container volumes on Cycle are thinly provisioned, meaning this isn't an allocation - the volume will only use the space it needs up to this size.
	MaxSize string `json:"max_size"`

	// StoragePool A boolean where true signifies using the largest drive over 2TB for the target server.
	StoragePool *StackSpecContainerVolume_Local_0_StoragePool `json:"storage_pool,omitempty"`
}

// StackSpecContainerVolumeLocal0StoragePool0 defines model for .
type StackSpecContainerVolumeLocal0StoragePool0 = bool

// StackSpecContainerVolume_Local_0_StoragePool A boolean where true signifies using the largest drive over 2TB for the target server.
type StackSpecContainerVolume_Local_0_StoragePool struct {
	union json.RawMessage
}

// StackSpecContainerVolume_Local Configuration options for local volumes.
type StackSpecContainerVolume_Local struct {
	union json.RawMessage
}

// StackSpecContainerVolumeReadOnly0 defines model for .
type StackSpecContainerVolumeReadOnly0 = bool

// StackSpecContainerVolume_ReadOnly If true, the container will be unable to write data to the volume.
type StackSpecContainerVolume_ReadOnly struct {
	union json.RawMessage
}

// StackSpecContainerVolumeRemoteAccess0 defines model for .
type StackSpecContainerVolumeRemoteAccess0 struct {
	// Enable If true, this volume will be accessible over SFTP.
	Enable StackSpecContainerVolume_RemoteAccess_0_Enable `json:"enable"`

	// Ips A list of IPs that SFTP access will be limited to.
	Ips *StackSpecContainerVolume_RemoteAccess_0_Ips `json:"ips,omitempty"`

	// Password The password used for logging in to this volume via SFTP.
	Password StackSpecContainerVolume_RemoteAccess_0_Password `json:"password"`

	// Webhook If set, Cycle will call out to this URL for authentication. Anything other than a 200 response will be considered a validation failure.
	Webhook *string `json:"webhook,omitempty"`
}

// StackSpecContainerVolumeRemoteAccess0Enable0 defines model for .
type StackSpecContainerVolumeRemoteAccess0Enable0 = bool

// StackSpecContainerVolume_RemoteAccess_0_Enable If true, this volume will be accessible over SFTP.
type StackSpecContainerVolume_RemoteAccess_0_Enable struct {
	union json.RawMessage
}

// StackSpecContainerVolumeRemoteAccess0Ips0 defines model for .
type StackSpecContainerVolumeRemoteAccess0Ips0 = []string

// StackSpecContainerVolume_RemoteAccess_0_Ips A list of IPs that SFTP access will be limited to.
type StackSpecContainerVolume_RemoteAccess_0_Ips struct {
	union json.RawMessage
}

// StackSpecContainerVolumeRemoteAccess0Password0 defines model for .
type StackSpecContainerVolumeRemoteAccess0Password0 struct {
	// Algorithm The algorithm the password is encoded with. `raw` means the password is plain-text.
	Algorithm string `json:"algorithm"`

	// Data The password string.
	Data string `json:"data"`
}

// StackSpecContainerVolume_RemoteAccess_0_Password The password used for logging in to this volume via SFTP.
type StackSpecContainerVolume_RemoteAccess_0_Password struct {
	union json.RawMessage
}

// StackSpecContainerVolume_RemoteAccess Configuration options for setting up remote access to this volume via SFTP.
type StackSpecContainerVolume_RemoteAccess struct {
	union json.RawMessage
}

// StackSpecImageOrigin The origin of the image.
type StackSpecImageOrigin struct {
	union json.RawMessage
}

// StackSpecMonitoringConfig Monitoring options for the stack build & containers within this stack.
type StackSpecMonitoringConfig struct {
	// Logs A variable specified in a stack spec.
	Logs *StackVariable `json:"logs,omitempty"`
}

// StackSpecScopedVariable defines model for StackSpecScopedVariable.
type StackSpecScopedVariable struct {
	Access     StackSpecScopedVariable_Access `json:"access"`
	Identifier string                         `json:"identifier"`
	Scope      StackSpecScopedVariable_Scope  `json:"scope"`
	Source     *StackVariable                 `json:"source"`
}

// StackSpecScopedVariableAccess0 defines model for .
type StackSpecScopedVariableAccess0 struct {
	// EnvVariable A variable specified in a stack spec.
	EnvVariable *StackVariable `json:"env_variable,omitempty"`

	// File Grants access to this variable as a file inside the container.
	File *StackSpecScopedVariable_Access_0_File `json:"file,omitempty"`

	// InternalApi Grants access to this variable over the Internal API.
	InternalApi *StackSpecScopedVariable_Access_0_InternalApi `json:"internal_api,omitempty"`
}

// StackSpecScopedVariableAccess0File0 defines model for .
type StackSpecScopedVariableAccess0File0 struct {
	// Decode When true, Cycle will interpret this variable as a base-64 encoded string, and decode it before writing it to the file inside the container.
	Decode StackSpecScopedVariable_Access_0_File_0_Decode `json:"decode"`

	// Gid The linux GID to set on the file.
	Gid *StackSpecScopedVariable_Access_0_File_0_Gid `json:"gid,omitempty"`

	// Path The absolute path to write the variable to (including file name). If `null`, it will be written to `/var/run/cycle/variables/{variable-identifier}`.
	Path string `json:"path"`

	// Permissions A linux file mode that will be set on the injected file.
	Permissions *string `json:"permissions,omitempty"`

	// Uid The linux UID to set on the file.
	Uid *StackSpecScopedVariable_Access_0_File_0_Uid `json:"uid,omitempty"`
}

// StackSpecScopedVariableAccess0File0Decode0 defines model for .
type StackSpecScopedVariableAccess0File0Decode0 = bool

// StackSpecScopedVariable_Access_0_File_0_Decode When true, Cycle will interpret this variable as a base-64 encoded string, and decode it before writing it to the file inside the container.
type StackSpecScopedVariable_Access_0_File_0_Decode struct {
	union json.RawMessage
}

// StackSpecScopedVariableAccess0File0Gid0 defines model for .
type StackSpecScopedVariableAccess0File0Gid0 = int

// StackSpecScopedVariable_Access_0_File_0_Gid The linux GID to set on the file.
type StackSpecScopedVariable_Access_0_File_0_Gid struct {
	union json.RawMessage
}

// StackSpecScopedVariableAccess0File0Uid0 defines model for .
type StackSpecScopedVariableAccess0File0Uid0 = int

// StackSpecScopedVariable_Access_0_File_0_Uid The linux UID to set on the file.
type StackSpecScopedVariable_Access_0_File_0_Uid struct {
	union json.RawMessage
}

// StackSpecScopedVariable_Access_0_File Grants access to this variable as a file inside the container.
type StackSpecScopedVariable_Access_0_File struct {
	union json.RawMessage
}

// StackSpecScopedVariableAccess0InternalApi0 defines model for .
type StackSpecScopedVariableAccess0InternalApi0 struct {
	// Duration Sets the duration that this variable can be accessed over the Internal API, after container start. Provides additional security as sensitive data can only be accessed for a limited time.
	Duration *StackVariable `json:"duration"`
}

// StackSpecScopedVariable_Access_0_InternalApi Grants access to this variable over the Internal API.
type StackSpecScopedVariable_Access_0_InternalApi struct {
	union json.RawMessage
}

// StackSpecScopedVariable_Access defines model for StackSpecScopedVariable.Access.
type StackSpecScopedVariable_Access struct {
	union json.RawMessage
}

// StackSpecScopedVariableScope0 defines model for .
type StackSpecScopedVariableScope0 struct {
	// Containers Describes the containers that have access to this scoped variable.
	Containers StackSpecScopedVariable_Scope_0_Containers `json:"containers"`
}

// StackSpecScopedVariableScope0Containers0 defines model for .
type StackSpecScopedVariableScope0Containers0 struct {
	// Global If true, all containers in the environment will have access to this variable.
	Global StackSpecScopedVariable_Scope_0_Containers_0_Global `json:"global"`

	// Identifiers A list of container identifiers that are granted access to this variable.
	Identifiers *StackSpecScopedVariable_Scope_0_Containers_0_Identifiers `json:"identifiers,omitempty"`

	// Ids A list of container IDs that are granted access to this variable.
	Ids *StackSpecScopedVariable_Scope_0_Containers_0_Ids `json:"ids,omitempty"`
}

// StackSpecScopedVariableScope0Containers0Global0 defines model for .
type StackSpecScopedVariableScope0Containers0Global0 = bool

// StackSpecScopedVariable_Scope_0_Containers_0_Global If true, all containers in the environment will have access to this variable.
type StackSpecScopedVariable_Scope_0_Containers_0_Global struct {
	union json.RawMessage
}

// StackSpecScopedVariableScope0Containers0Identifiers0 defines model for .
type StackSpecScopedVariableScope0Containers0Identifiers0 = []Identifier

// StackSpecScopedVariable_Scope_0_Containers_0_Identifiers A list of container identifiers that are granted access to this variable.
type StackSpecScopedVariable_Scope_0_Containers_0_Identifiers struct {
	union json.RawMessage
}

// StackSpecScopedVariableScope0Containers0Ids0 defines model for .
type StackSpecScopedVariableScope0Containers0Ids0 = []string

// StackSpecScopedVariable_Scope_0_Containers_0_Ids A list of container IDs that are granted access to this variable.
type StackSpecScopedVariable_Scope_0_Containers_0_Ids struct {
	union json.RawMessage
}

// StackSpecScopedVariable_Scope_0_Containers Describes the containers that have access to this scoped variable.
type StackSpecScopedVariable_Scope_0_Containers struct {
	union json.RawMessage
}

// StackSpecScopedVariable_Scope defines model for StackSpecScopedVariable.Scope.
type StackSpecScopedVariable_Scope struct {
	union json.RawMessage
}

// StackState defines model for StackState.
type StackState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the stack.
	Current StackStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// StackStateCurrent The current state of the stack.
type StackStateCurrent string

// StackSummary A summary of the stack this container was created format.
type StackSummary struct {
	// BuildId The ID of the stack build this container is associated with.
	BuildId *string `json:"build_id,omitempty"`

	// Id A 24 character hex string used to identify a unique resource.
	Id *ID `json:"id,omitempty"`

	// Identifier The container identifier, usually the key to the container section of a stack file.
	Identifier *string `json:"identifier,omitempty"`
}

// StackVariable A variable specified in a stack spec.
type StackVariable = string

// State Information regarding the current state of the resource.
type State struct {
	Changed DateTime `json:"changed"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// StateCountSummary A summary of resources by state
type StateCountSummary struct {
	// Available The total number of this resource available, less any deleted ones.
	Available int `json:"available"`

	// State A count of this resource, grouped by state.
	State map[string]int `json:"state"`

	// Total The total number of this resource
	Total int `json:"total"`
}

// StorageSpec Information about the storage resources for a given server.
type StorageSpec struct {
	// Count The number of storage devices for a given server.
	Count int `json:"count"`

	// Extra Extra information about the storage resources for a given server.
	Extra map[string]string `json:"extra"`

	// SizeGb The total amount of storage on a given server, in GB.
	SizeGb int `json:"size_gb"`

	// Type The type of the storage device(s).
	Type string `json:"type"`
}

// StripeCreditCard A payment method that utilizes a credit card via Stripe.
type StripeCreditCard struct {
	Details struct {
		// Brand The brand of card.
		Brand      string `json:"brand"`
		Expiration struct {
			// Month The month the billing method expires.
			Month int `json:"month"`

			// Year The year the billing method expires.
			Year int `json:"year"`
		} `json:"expiration"`

		// Last4 The last 4 digits of the card.
		Last4 string `json:"last_4"`

		// Name The name on the credit card.
		Name string `json:"name"`
	} `json:"details"`
	Type StripeCreditCardType `json:"type"`
}

// StripeCreditCardType defines model for StripeCreditCard.Type.
type StripeCreditCardType string

// StripeUsBankAcct A payment method that utilizes a US bank account via Stripe.
type StripeUsBankAcct struct {
	Details struct {
		// Last4 The last 4 numbers of the bank account number.
		Last4 string `json:"last_4"`

		// Name The name of the owner of the bank account.
		Name string `json:"name"`
	} `json:"details"`
	Type StripeUsBankAcctType `json:"type"`
}

// StripeUsBankAcctType defines model for StripeUsBankAcct.Type.
type StripeUsBankAcctType string

// SupportPlan Information about a billing support plan.
type SupportPlan struct {
	// Contract A boolean where true represents the plan is a long term contract, not just month to month.
	Contract bool `json:"contract"`

	// Default This returns true if it shows up.
	Default bool `json:"default"`

	// Description Information about the billing support plan that describes the plan.
	Description string `json:"description"`

	// Features Information about billing support plan features.
	Features SupportPlanFeatures `json:"features"`

	// Name The name of the support plan.
	Name string `json:"name"`

	// Price An object holding information about term and amount that relates to a specific billing component.
	Price BillingAmount `json:"price"`
}

// SupportPlanFeatures Information about billing support plan features.
type SupportPlanFeatures struct {
	// EngineeringSupport A boolean where true indicates the contract includes support for engineering.
	EngineeringSupport bool `json:"engineering_support"`

	// GuaranteedResponseTime The time in which this support contract guarantees response time.
	GuaranteedResponseTime *string `json:"guaranteed_response_time"`

	// UptimeSla A boolean where true represents the contract has an uptime SLA agreement.
	UptimeSla bool `json:"uptime_sla"`
}

// TaskState defines model for TaskState.
type TaskState struct {
	Changed *DateTime `json:"changed,omitempty"`

	// Current The current state of the task.
	Current *TaskStateCurrent `json:"current,omitempty"`
}

// TaskStateCurrent The current state of the task.
type TaskStateCurrent string

// TaskStep A step for a given job task.
type TaskStep struct {
	// Caption A short description of the step.
	Caption   string   `json:"caption"`
	Completed DateTime `json:"completed"`

	// Description A more verbose description.
	Description string   `json:"description"`
	Started     DateTime `json:"started"`
}

// TcpRouterConfig Additional configuration options for TCP mode routers
type TcpRouterConfig struct {
	Details map[string]interface{} `json:"details"`
	Type    TcpRouterConfigType    `json:"type"`
}

// TcpRouterConfigType defines model for TcpRouterConfig.Type.
type TcpRouterConfigType string

// TcpTransportConfig Additional configuration options for the TCP transport mode.
type TcpTransportConfig struct {
	Details struct {
		Connections map[string]interface{} `json:"connections"`

		// Telemetry Configuration options for how telemetry is handled on the load balancer.
		Telemetry map[string]interface{} `json:"telemetry"`
	} `json:"details"`
	Type TcpTransportConfigType `json:"type"`
}

// TcpTransportConfigType defines model for TcpTransportConfig.Type.
type TcpTransportConfigType string

// TelemetryReportRequest A summary of report requests and when they occured.
type TelemetryReportRequest struct {
	End DateTime `json:"end"`

	// InstanceId The ID of the instance this telemetry reporting pertains to.
	InstanceId string   `json:"instance_id"`
	Start      DateTime `json:"start"`
}

// Term Information about a billing term.
type Term struct {
	End DateTime `json:"end"`

	// Renew The term renewal period.
	Renew *TermRenew `json:"renew"`
	Start DateTime   `json:"start"`
}

// TermRenew The term renewal period.
type TermRenew string

// TierPlan A TierPlan object describes the attributes of a subscription tier
type TierPlan struct {
	AdvancedFeatures struct {
		Autoscale            bool  `json:"autoscale"`
		Deployments          bool  `json:"deployments"`
		ExternalVolumes      *bool `json:"external_volumes,omitempty"`
		Geodns               bool  `json:"geodns"`
		Gpu                  bool  `json:"gpu"`
		Ial                  bool  `json:"ial"`
		ProviderMultiAccount bool  `json:"provider_multi_account"`
		VirtualProvider      bool  `json:"virtual_provider"`
	} `json:"advanced_features"`

	// Builds An object holding information about servers included in Billing tier
	Builds      BillingBuilds `json:"builds"`
	Code        string        `json:"code"`
	Description string        `json:"description"`

	// DnsLinkedRecords Generic structure for a resource with an included allotment, optional hard cap, and per-unit overage cost.
	DnsLinkedRecords ResourceAllowance `json:"dns_linked_records"`

	// DnsZones Generic structure for a resource with an included allotment, optional hard cap, and per-unit overage cost.
	DnsZones   ResourceAllowance `json:"dns_zones"`
	Generation int               `json:"generation"`
	Hidden     bool              `json:"hidden"`

	// Hubs An array of hub IDs with access to the tier.
	Hubs *[]Identifier `json:"hubs"`
	Id   string        `json:"id"`

	// ImageStorage An object holding information about servers included in Billing tier
	ImageStorage        BillingImageStorage `json:"image_storage"`
	MaxDailyApiRequests *int                `json:"max_daily_api_requests"`
	MaxMembers          *int                `json:"max_members"`
	MaxNodes            *int                `json:"max_nodes"`

	// Members Generic structure for a resource with an included allotment, optional hard cap, and per-unit overage cost.
	Members ResourceAllowance `json:"members"`
	Name    string            `json:"name"`

	// Price An object holding information about term and amount that relates to a specific billing component.
	Price BillingAmount `json:"price"`

	// Ram An object holding information about servers included in Billing tier
	Ram BillingRam `json:"ram"`

	// Servers Generic structure for a resource with an included allotment, optional hard cap, and per-unit overage cost.
	Servers ResourceAllowance `json:"servers"`
	Usable  bool              `json:"usable"`
}

// TlsCertificate A TLS certificate.
type TlsCertificate struct {
	// Domains A list of domains associated with the certificate.
	Domains []string `json:"domains"`

	// Events A collection of timestamps for each event in the TLS certificate's lifetime.
	Events struct {
		Created   DateTime `json:"created"`
		Deleted   DateTime `json:"deleted"`
		Generated DateTime `json:"generated"`
		Updated   DateTime `json:"updated"`
	} `json:"events"`
	Expires DateTime `json:"expires"`
	HubId   *ID      `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id    ID `json:"id"`
	State struct {
		Changed DateTime `json:"changed"`

		// Current The current state of the TLS certificate.
		Current TlsCertificateStateCurrent `json:"current"`

		// Error An error, if any, that has occurred for this resource.
		Error *struct {
			// Message Details about the error that has occurred.
			Message *string   `json:"message,omitempty"`
			Time    *DateTime `json:"time,omitempty"`
		} `json:"error,omitempty"`
	} `json:"state"`

	// UserSupplied Whether or not this certificate was uploaded instead of generated by the platform.
	UserSupplied bool `json:"user_supplied"`
}

// TlsCertificateStateCurrent The current state of the TLS certificate.
type TlsCertificateStateCurrent string

// TriggerKey A pipeline trigger key resource.
type TriggerKey struct {
	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the trigger key's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Ips An array of ips this trigger key is usable from.
	Ips []string `json:"ips"`

	// Name The name of the trigger key.
	Name string `json:"name"`

	// PipelineId The ID for the pipeline related to this trigger key.
	PipelineId string `json:"pipeline_id"`

	// Secret The secret used when calling the trigger key programmatically.
	Secret string          `json:"secret"`
	State  TriggerKeyState `json:"state"`
}

// TriggerKeyState defines model for TriggerKeyState.
type TriggerKeyState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the trigger key.
	Current TriggerKeyStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// TriggerKeyStateCurrent The current state of the trigger key.
type TriggerKeyStateCurrent string

// TwoFactorAuthRecovery defines model for TwoFactorAuthRecovery.
type TwoFactorAuthRecovery struct {
	RecoveryCodes []string `json:"recovery_codes"`
	TotpPasscode  string   `json:"totp_passcode"`
}

// TwoFactorAuthSetup defines model for TwoFactorAuthSetup.
type TwoFactorAuthSetup struct {
	Qr     string `json:"qr"`
	Secret string `json:"secret"`
}

// URLSource The `URL` type of scoped variable `value`, referred to as a source. This means the value of this variable is the result of calling the given URL. It is dynamic, in that Cycle will refetch the contents on every start.
type URLSource struct {
	Details struct {
		// AuthTokenUrl A URL that can be provided to authenticate with a third party secret service. Cycle will make a request to this URL before fetching the secret URL, and use the response as the value of an Authorization header when requesting the secret.
		AuthTokenUrl *string `json:"auth_token_url"`

		// Headers Additional headers that can be attached to the URL request. Useful for adding metadata to third-party services.
		Headers map[string]interface{} `json:"headers"`

		// Url The URL to call to produce the value.
		Url string `json:"url"`
	} `json:"details"`

	// Type The type of source value, can be either `raw` or `url`.
	Type URLSourceType `json:"type"`
}

// URLSourceType The type of source value, can be either `raw` or `url`.
type URLSourceType string

// UdpRouterConfig Additional configuration options for UDP mode routers
type UdpRouterConfig struct {
	Details map[string]interface{} `json:"details"`
	Type    UdpRouterConfigType    `json:"type"`
}

// UdpRouterConfigType defines model for UdpRouterConfig.Type.
type UdpRouterConfigType string

// UdpTransportConfig Additional configuration options for the UDP transport mode.
type UdpTransportConfig struct {
	Details struct {
		// Telemetry Configuration options for how telemetry is handled on the load balancer.
		Telemetry map[string]interface{} `json:"telemetry"`
	} `json:"details"`
	Type UdpTransportConfigType `json:"type"`
}

// UdpTransportConfigType defines model for UdpTransportConfig.Type.
type UdpTransportConfigType string

// UsageDatum Server usage data.
type UsageDatum struct {
	// MemoryGb A number in GB representing memory.
	MemoryGb int `json:"memory_gb"`

	// Nodes The number of nodes the data is pulled from.
	Nodes int      `json:"nodes"`
	Time  DateTime `json:"time"`
}

// UserScope A type of creator and a matching identifier.
type UserScope struct {
	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Type The type of user that created the resource.
	Type UserScopeType `json:"type"`
}

// UserScopeType The type of user that created the resource.
type UserScopeType string

// V1LbConfig defines model for V1LbConfig.
type V1LbConfig struct {
	ControllerTemplate *V1LbController `json:"controller_template"`

	// Controllers A configuration for a specific port.
	Controllers []V1LbController `json:"controllers"`
	Waf         *WafConfig       `json:"waf"`
}

// V1LbConfigRouter A specific router configuration that describes how traffic matching the rule is handled.
type V1LbConfigRouter struct {
	Config struct {
		// DestinationPrioritization Hints to the load balancer how to prioritize traffic to instances.
		// **random**: Chooses a random instance. **latency**: Prioritizes lower latency instances. **fixed**: The order of the destinations will be the same regardless of instance or load balancer location.  Used primarily with source IP routing.
		DestinationPrioritization *V1LbConfigRouterConfigDestinationPrioritization `json:"destination_prioritization"`

		// DestinationRetries If a destination is unavailable, retry up to [x] times, instead of immediately failing with a 503/504 error.
		DestinationRetries int `json:"destination_retries"`

		// Extension Additional configuration options specific to the selected mode (tcp/http).
		Extension *V1LbConfigRouter_Config_Extension `json:"extension,omitempty"`

		// StickySessions If a request comes in from the same origin, ensure it hits the same destination.
		StickySessions bool `json:"sticky_sessions"`

		// Timeouts Defines how the length of various sorts of timeouts when communicating with the destination.
		Timeouts struct {
			// DestinationConnection A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
			DestinationConnection Duration `json:"destination_connection"`
		} `json:"timeouts"`

		// Tls TLS termination configuration. If null, the platform will use the default configuration. Port 443 by default has TLS termination enabled.
		Tls *struct {
			// AllowInsecure If enabled, accept TLS traffic with an invalid certificate. This is usually done for development/testing, and is not recommended for production use.
			AllowInsecure *bool `json:"allow_insecure"`

			// ClientAuth Defines how to validate the connecting TLS certificate.
			// `none`: Do not require a TLS certificate to be sent
			// `request`: Asks the client to send a TLS certificate, but does not require nor validate it.
			// `require`: Requires a certificate be sent for the request to be valid, but does not validate the certificate.
			// `require-verify`: Requires both that the client send a certificate, and that the certificate is valid. This is required when using https.
			ClientAuth *V1LbConfigRouterConfigTlsClientAuth `json:"client_auth"`

			// ClientCertAuth A PEM encoded string of certificates.
			ClientCertAuth *string `json:"client_cert_auth"`

			// ServerName [Advanced] Change the domain the controller listens on.
			ServerName *string `json:"server_name"`
		} `json:"tls"`
	} `json:"config"`

	// Match The ruleset for this router to be selected. If both `domains`` and `internal_port` are null, then this match acts as a wildcard and will match all.
	Match struct {
		// Containers Match traffic destined (or not destined) for a particular container.
		Containers *struct {
			// Exclude Match any traffic that would NOT be routed to one of these containers.
			Exclude *[]HybridIdentifier `json:"exclude"`

			// Include Match any traffic that would be routed to one of these containers.
			Include *[]HybridIdentifier `json:"include"`
		} `json:"containers"`

		// Domains The specific domains to match against.
		Domains *[]string `json:"domains"`

		// InternalPorts The specific ports to match against.
		InternalPorts *[]int  `json:"internal_ports"`
		Path          *string `json:"path"`
	} `json:"match"`

	// Mode How to route the traffic to the destination.
	// `random`: Pick a valid destination at random.
	// `round-robin`: Send each request to the 'next' destination on the list, restarting from the beginning when the last destination is used.
	// `source-ip`: Utilizes a hash function to ensure traffic from an IP will always hit the same destination instance.
	Mode V1LbConfigRouterMode `json:"mode"`
}

// V1LbConfigRouterConfigDestinationPrioritization Hints to the load balancer how to prioritize traffic to instances.
// **random**: Chooses a random instance. **latency**: Prioritizes lower latency instances. **fixed**: The order of the destinations will be the same regardless of instance or load balancer location.  Used primarily with source IP routing.
type V1LbConfigRouterConfigDestinationPrioritization string

// V1LbConfigRouter_Config_Extension Additional configuration options specific to the selected mode (tcp/http).
type V1LbConfigRouter_Config_Extension struct {
	union json.RawMessage
}

// V1LbConfigRouterConfigTlsClientAuth Defines how to validate the connecting TLS certificate.
// `none`: Do not require a TLS certificate to be sent
// `request`: Asks the client to send a TLS certificate, but does not require nor validate it.
// `require`: Requires a certificate be sent for the request to be valid, but does not validate the certificate.
// `require-verify`: Requires both that the client send a certificate, and that the certificate is valid. This is required when using https.
type V1LbConfigRouterConfigTlsClientAuth string

// V1LbConfigRouterMode How to route the traffic to the destination.
// `random`: Pick a valid destination at random.
// `round-robin`: Send each request to the 'next' destination on the list, restarting from the beginning when the last destination is used.
// `source-ip`: Utilizes a hash function to ensure traffic from an IP will always hit the same destination instance.
type V1LbConfigRouterMode string

// V1LbController defines model for V1LbController.
type V1LbController struct {
	// Identifier A human-readable identifier for this controller. It will default to the port, i.e. `port-443`, but can be renamed to anything, such as the service this controller represents.
	Identifier string `json:"identifier"`

	// Port The port inbound trafic is accepted on.
	Port int `json:"port"`

	// Transport Defines how traffic comes in to the load balancer, and how the load balancer handles it.
	Transport *struct {
		// Config Defines how the transport for this controller operates.
		Config struct {
			// Extension Extended configurations for the specified transport mode (http/tcp)
			Extension *V1LbController_Transport_Config_Extension `json:"extension,omitempty"`

			// Ingress Defines how traffic gets into the load balancer.
			Ingress struct {
				Tls *struct {
					// Enable Enables or disables TLS.
					Enable bool `json:"enable"`
				} `json:"tls"`
			} `json:"ingress"`

			// Performance Enable/disable performance mode. If enabled, some telemetry will be disabled to dedicate full processing to handling requests.
			// You will not see per-request breakdowns or URL logging if performance mode is enabled.
			Performance bool `json:"performance"`

			// Timeouts Defines settings for various types of timeouts.
			Timeouts struct {
				// Idle A string signifying a duration of time. Valid time units are "ns", "us" (or "s"), "ms", "s", "m", "h", "d", "w", "y".
				Idle Duration `json:"idle"`
			} `json:"timeouts"`

			// Verbosity Verbosity describes the level of logging detail for the controller
			Verbosity V1LbControllerTransportConfigVerbosity `json:"verbosity"`
		} `json:"config"`

		// Disable When true, this controller is disabled and will not be used.
		Disable bool `json:"disable"`

		// Mode The kind of traffic (http/tcp/udp) that will be sent to the load balancer.
		Mode V1LbControllerTransportMode `json:"mode"`

		// Routers Defines where traffic is sent. Many can be defined per controller.
		Routers []V1LbConfigRouter `json:"routers"`
	} `json:"transport"`
	Waf *WafConfig `json:"waf"`
}

// V1LbController_Transport_Config_Extension Extended configurations for the specified transport mode (http/tcp)
type V1LbController_Transport_Config_Extension struct {
	union json.RawMessage
}

// V1LbControllerTransportConfigVerbosity Verbosity describes the level of logging detail for the controller
type V1LbControllerTransportConfigVerbosity string

// V1LbControllerTransportMode The kind of traffic (http/tcp/udp) that will be sent to the load balancer.
type V1LbControllerTransportMode string

// V1LbType defines model for V1LbType.
type V1LbType struct {
	Details V1LbConfig `json:"details"`

	// Ipv4 Allow / disallow traffic to be routed via IPv4.
	Ipv4 bool `json:"ipv4"`

	// Ipv6 Allow / disallow traffic to be routed via IPv6.
	Ipv6 bool         `json:"ipv6"`
	Type V1LbTypeType `json:"type"`
}

// V1LbTypeType defines model for V1LbType.Type.
type V1LbTypeType string

// VPNInfoReturn A summary of a VPN service for a given environment.
type VPNInfoReturn struct {
	Service *VpnEnvironmentService `json:"service"`

	// Url A url associated with the VPN service.
	Url string `json:"url"`
}

// VPNLogin A VPN login event record.
type VPNLogin struct {
	// EnvironmentId The ID of the environment the VPN service is in.
	EnvironmentId string `json:"environment_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Ip The IP address of the machine the user has logged in from.
	Ip string `json:"ip"`

	// Success A boolean where true means the login attempt was successful.
	Success bool     `json:"success"`
	Time    DateTime `json:"time"`

	// Username The username used when logging in.
	Username string `json:"username"`
}

// VPNUsers A VPN user for a given VPN.
type VPNUsers struct {
	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// EnvironmentId An identifier for the environment the VPN service is associated with.
	EnvironmentId string `json:"environment_id"`

	// Events A collection of timestamps for each event in the VPN user's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id        ID       `json:"id"`
	LastLogin DateTime `json:"last_login"`

	// Username The username for the login.
	Username string `json:"username"`
}

// VariableString A string value for a pipeline that supports a variable. To use as a variable, set this string to `{{variable}}` where `variable` is a custom name.
type VariableString = string

// Version Version can be any string, but if it begins with a "v", semantic version will be enforced. A [Semantic Version](https://semver.org/) string. Follows the format vMAJOR.MINOR.PATCH-build.
type Version = string

// VirtualMachine Describes a virtual machine running on the Cycle Platform.
type VirtualMachine struct {
	// Annotations Metadata annotations for the virtual machine.
	Annotations *map[string]interface{} `json:"annotations"`

	// Config Defines the network and deployment configurations for a virtual machine.
	Config VirtualMachineConfig `json:"config"`

	// ContainerId A 24 character hex string used to identify a unique resource.
	ContainerId *ID `json:"container_id,omitempty"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Deprecate A boolean flag indicating if this virtual machine is deprecated.
	Deprecate bool `json:"deprecate"`

	// Environment Basic information about the environment this virtual machine is in.
	Environment struct {
		// Cluster A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
		// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
		// have the identifier of `my-container` and is automatically created by the platform.
		//
		// The identifier does not have to be unique.
		Cluster Identifier `json:"cluster"`

		// Id A 24 character hex string used to identify a unique resource.
		Id ID `json:"id"`
	} `json:"environment"`

	// Events A collection of timestamps for each event in the virtual machine's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Started DateTime `json:"started"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`

	// Image Represents the image used by a virtual machine. It can either reference a URL where the image is located or specify a base image provided by Cycle.
	Image VirtualMachineImage `json:"image"`

	// Lock Prevents this virtual machine from being deleted when true.
	Lock bool                `json:"lock"`
	Meta *VirtualMachineMeta `json:"meta"`

	// Name A user-defined name for the virtual machine.
	Name string `json:"name"`

	// RootPassword The generated root password for the virtual machine. Only visible by the owner, or if it was created in the last ten minutes.
	RootPassword *struct {
		Changed DateTime `json:"changed"`

		// Current The root password.
		Current *string `json:"current"`
	} `json:"root_password,omitempty"`

	// SshKeys An array of IDs corresponding to SSH keys that have been assigned to this virtual machine.
	SshKeys *[]ID                   `json:"ssh_keys,omitempty"`
	State   VirtualMachineState     `json:"state"`
	Volumes *[]VirtualMachineVolume `json:"volumes,omitempty"`
}

// VirtualMachineAttachmentTypeIso Details of an ISO attachment for a virtual machine.
type VirtualMachineAttachmentTypeIso struct {
	Details struct {
		// Url The URL of the ISO to download and attach to this virtual machine.
		Url string `json:"url"`
	} `json:"details"`

	// Type The type of the attachment (iso)
	Type VirtualMachineAttachmentTypeIsoType `json:"type"`
}

// VirtualMachineAttachmentTypeIsoType The type of the attachment (iso)
type VirtualMachineAttachmentTypeIsoType string

// VirtualMachineBaseImage Represents a virtual machine base OS image provided by Cycle.
type VirtualMachineBaseImage struct {
	// Description A detailed description of the base image.
	Description string `json:"description"`

	// Homepage The official homepage for the base image.
	Homepage string `json:"homepage"`

	// Title The name of the base image (e.g., "Alpine Linux").
	Title string `json:"title"`

	// Versions A list of available versions for the base image, including details like version number and disk image URL.
	Versions []struct {
		// DiskImageUrl The URL where the disk image can be downloaded.
		DiskImageUrl string `json:"disk_image_url"`

		// Identifier A unique identifier for the version.
		Identifier string `json:"identifier"`

		// Supported A flag indicating whether the version is currently supported.
		Supported bool `json:"supported"`

		// Uefi Whether the image supports UEFI.
		Uefi bool `json:"uefi"`

		// Version The version number of the base image.
		Version string `json:"version"`
	} `json:"versions"`
}

// VirtualMachineConfig Defines the network and deployment configurations for a virtual machine.
type VirtualMachineConfig struct {
	// Deploy Represents the deployment configuration for a virtual machine, including constraints, shutdown/startup policies, restart conditions, and telemetry settings.
	Deploy VirtualMachineDeployConfig `json:"deploy"`

	// Network Defines the network settings for a virtual machine, including public access mode, hostname, and ports.
	Network VirtualMachineNetworkConfig `json:"network"`

	// Resources Defines the resource settings for a virtual machine, including CPU and RAM.
	Resources VirtualMachineResourcesConfig `json:"resources"`

	// Runtime Defines the runtime settings for a virtual machine.
	Runtime *VirtualMachineRuntimeConfig `json:"runtime,omitempty"`
}

// VirtualMachineCpuConfigCustom Custom CPU selection with model and feature flags.
type VirtualMachineCpuConfigCustom struct {
	Details struct {
		// FeatureFlags Additional CPU feature flags to enable. Will start with a "+" or "-" to include or exclude.
		FeatureFlags *[]string `json:"feature_flags"`

		// Model CPU model string (for example "Skylake-Client").
		Model string `json:"model"`
	} `json:"details"`

	// Type Custom CPU definition.
	Type VirtualMachineCpuConfigCustomType `json:"type"`
}

// VirtualMachineCpuConfigCustomType Custom CPU definition.
type VirtualMachineCpuConfigCustomType string

// VirtualMachineCpuConfigDefault Predefined CPU selection.
type VirtualMachineCpuConfigDefault struct {
	// Details An object with no properties.
	Details map[string]interface{} `json:"details"`

	// Type Predefined CPU type.
	Type VirtualMachineCpuConfigDefaultType `json:"type"`
}

// VirtualMachineCpuConfigDefaultType Predefined CPU type.
type VirtualMachineCpuConfigDefaultType string

// VirtualMachineCpuResources Defines the CPU configuration of a virtual machine. Set **either** `cores` or `cpus`.
type VirtualMachineCpuResources struct {
	Cores *struct {
		// Allocate If true, reserves the cores so they cannot be used by any other virtual machine.
		Allocate *bool `json:"allocate"`

		// Number The number of cores to assign to this virtual machine. Must be between 1 and 32.
		Number int `json:"number"`
	} `json:"cores,omitempty"`

	// Cpus The specific cores/range of cores to allocate to the virtual machine. An 'x' indicates the maximum core for a given machine.
	Cpus *string `json:"cpus"`
}

// VirtualMachineDeployConfig Represents the deployment configuration for a virtual machine, including constraints, shutdown/startup policies, restart conditions, and telemetry settings.
type VirtualMachineDeployConfig struct {
	Constraints *VirtualMachineDeployConstraints `json:"constraints"`
	Shutdown    *VirtualMachineShutdownPolicy    `json:"shutdown"`
	Startup     *VirtualMachineStartupPolicy     `json:"startup"`
	Telemetry   *VirtualMachineTelemetryConfig   `json:"telemetry"`
}

// VirtualMachineDeployConstraints Constraints define node-level and resource restrictions for the virtual machine deployment.
type VirtualMachineDeployConstraints struct {
	Containers *[]string                      `json:"containers,omitempty"`
	Node       *VirtualMachineNodeConstraints `json:"node"`
	Secrets    *[]string                      `json:"secrets,omitempty"`
}

// VirtualMachineDeployTags Tags that define node requirements for the deployment. The `any` tag must match at least one condition, while `all` must match all conditions.
type VirtualMachineDeployTags struct {
	All *[]string `json:"all,omitempty"`
	Any *[]string `json:"any,omitempty"`
}

// VirtualMachineImage Represents the image used by a virtual machine. It can either reference a URL where the image is located or specify a base image provided by Cycle.
type VirtualMachineImage struct {
	union json.RawMessage
}

// VirtualMachineImageSourceBase A virtual machine image sourced from a Cycle base image.
type VirtualMachineImageSourceBase struct {
	Details struct {
		// Identifier The base image identifier.
		Identifier string `json:"identifier"`
	} `json:"details"`
	Type VirtualMachineImageSourceBaseType `json:"type"`
}

// VirtualMachineImageSourceBaseType defines model for VirtualMachineImageSourceBase.Type.
type VirtualMachineImageSourceBaseType string

// VirtualMachineImageSourceExternalVolume A virtual machine image sourced from a SAN target.
type VirtualMachineImageSourceExternalVolume struct {
	Details struct {
		// Id A 24 character hex string used to identify a unique resource.
		Id *ID `json:"id,omitempty"`

		// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
		// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
		// have the identifier of `my-container` and is automatically created by the platform.
		//
		// The identifier does not have to be unique.
		Identifier *Identifier `json:"identifier,omitempty"`
	} `json:"details"`
	Type VirtualMachineImageSourceExternalVolumeType `json:"type"`
}

// VirtualMachineImageSourceExternalVolumeType defines model for VirtualMachineImageSourceExternalVolume.Type.
type VirtualMachineImageSourceExternalVolumeType string

// VirtualMachineImageSourceIpxe A virtual machine image sourced from an IPXE script.
type VirtualMachineImageSourceIpxe struct {
	Details struct {
		// ChainUrl A URL that points to an IPXE script.
		ChainUrl *string `json:"chain_url"`

		// Script An inline IPXE script.
		Script *string `json:"script"`
	} `json:"details"`
	Type VirtualMachineImageSourceIpxeType `json:"type"`
}

// VirtualMachineImageSourceIpxeType defines model for VirtualMachineImageSourceIpxe.Type.
type VirtualMachineImageSourceIpxeType string

// VirtualMachineImageSourceUrl A virtual machine image sourced from a URL.
type VirtualMachineImageSourceUrl struct {
	Details struct {
		// Url The URL where a custom image is located.
		Url string `json:"url"`
	} `json:"details"`
	Type VirtualMachineImageSourceUrlType `json:"type"`
}

// VirtualMachineImageSourceUrlType defines model for VirtualMachineImageSourceUrl.Type.
type VirtualMachineImageSourceUrlType string

// VirtualMachineIncludes All includable resources linkable to the given virtual machine.
type VirtualMachineIncludes struct {
	Clusters   *map[string]Cluster   `json:"clusters,omitempty"`
	Containers *map[string]Container `json:"containers,omitempty"`

	// Creators An identity that created a resource.
	Creators                *CreatorInclude         `json:"creators,omitempty"`
	Environments            *map[string]Environment `json:"environments,omitempty"`
	EnvironmentsIdentifiers *map[string]ID          `json:"environments:identifiers,omitempty"`
}

// VirtualMachineIpAllocateAction defines model for VirtualMachineIpAllocateAction.
type VirtualMachineIpAllocateAction struct {
	// Action The action to take.
	Action   VirtualMachineIpAllocateActionAction `json:"action"`
	Contents struct {
		// IpId A 24 character hex string used to identify a unique resource.
		IpId *ID `json:"ip_id,omitempty"`
	} `json:"contents"`
}

// VirtualMachineIpAllocateActionAction The action to take.
type VirtualMachineIpAllocateActionAction string

// VirtualMachineIpUnallocateAction defines model for VirtualMachineIpUnallocateAction.
type VirtualMachineIpUnallocateAction struct {
	// Action The action to take.
	Action   VirtualMachineIpUnallocateActionAction `json:"action"`
	Contents struct {
		// IpId A 24 character hex string used to identify a unique resource.
		IpId ID `json:"ip_id"`
	} `json:"contents"`
}

// VirtualMachineIpUnallocateActionAction The action to take.
type VirtualMachineIpUnallocateActionAction string

// VirtualMachineMeta Fields that can be included on a per-virtual machine basis, specific to that virtual machine.
type VirtualMachineMeta struct {
	Domains *[]struct {
		// Fqdn The fully qualified domain name.
		Fqdn   string     `json:"fqdn"`
		Record *DnsRecord `json:"record"`
	} `json:"domains,omitempty"`

	// HypervisorIps An array of private IP addresses associated with the hypervisor for this virtual machine..
	HypervisorIps *struct {
		Ipv4 *string `json:"ipv4,omitempty"`
		Ipv6 *string `json:"ipv6,omitempty"`
	} `json:"hypervisor_ips,omitempty"`

	// Ips An array of public IP addresses associated with this virtual machine.
	Ips *[]Ip `json:"ips,omitempty"`

	// Server The server the virtual machine is deployed to.
	Server *Server `json:"server"`
}

// VirtualMachineNetworkConfig Defines the network settings for a virtual machine, including public access mode, hostname, and ports.
type VirtualMachineNetworkConfig struct {
	// EgressViaGateway True indicates that traffic should leave via the gateway, not the underlying host.
	EgressViaGateway bool `json:"egress_via_gateway"`

	// Hostname The hostname assigned to the virtual machine.
	Hostname string `json:"hostname"`

	// Ports Port configurations for the virtual machine.
	Ports *[]string `json:"ports,omitempty"`

	// Public Controls the public network mode for the virtual machine.
	Public VirtualMachineNetworkConfigPublic `json:"public"`
}

// VirtualMachineNetworkConfigPublic Controls the public network mode for the virtual machine.
type VirtualMachineNetworkConfigPublic string

// VirtualMachineNodeConstraints Node-level constraints for the virtual machine deployment, specifying tags that must or must not be present.
type VirtualMachineNodeConstraints struct {
	// Tags Tags that define node requirements for the deployment. The `any` tag must match at least one condition, while `all` must match all conditions.
	Tags VirtualMachineDeployTags `json:"tags"`
}

// VirtualMachineRamResources Defines the RAM configuration of a virtual machine.
type VirtualMachineRamResources struct {
	// Allocate Whether or not the RAM set in limit should be preallocated.
	Allocate *bool `json:"allocate"`

	// Limit The limit (maximum) amount of RAM the virtual machine can consume. Must be at least 512M and less than 65GB.
	Limit string `json:"limit"`
}

// VirtualMachineReconfigureAction defines model for VirtualMachineReconfigureAction.
type VirtualMachineReconfigureAction struct {
	// Action The action to take.
	Action VirtualMachineReconfigureActionAction `json:"action"`

	// Contents Defines the network and deployment configurations for a virtual machine.
	Contents VirtualMachineConfig `json:"contents"`
}

// VirtualMachineReconfigureActionAction The action to take.
type VirtualMachineReconfigureActionAction string

// VirtualMachineReconfigureVolumesAction defines model for VirtualMachineReconfigureVolumesAction.
type VirtualMachineReconfigureVolumesAction struct {
	// Action The action to take.
	Action VirtualMachineReconfigureVolumesActionAction `json:"action"`

	// Contents A map of volume objects where the key is the id and the value is the volume's config.
	Contents map[string]VirtualMachineVolumeConfig `json:"contents"`
}

// VirtualMachineReconfigureVolumesActionAction The action to take.
type VirtualMachineReconfigureVolumesActionAction string

// VirtualMachineResourcesConfig Defines the resource settings for a virtual machine, including CPU and RAM.
type VirtualMachineResourcesConfig struct {
	// Cpu Defines the CPU configuration of a virtual machine. Set **either** `cores` or `cpus`.
	Cpu VirtualMachineCpuResources `json:"cpu"`

	// Ram Defines the RAM configuration of a virtual machine.
	Ram VirtualMachineRamResources `json:"ram"`
}

// VirtualMachineRestartAction defines model for VirtualMachineRestartAction.
type VirtualMachineRestartAction struct {
	// Action The name of the action to perform.
	Action VirtualMachineRestartActionAction `json:"action"`
}

// VirtualMachineRestartActionAction The name of the action to perform.
type VirtualMachineRestartActionAction string

// VirtualMachineRootPwChangeAction defines model for VirtualMachineRootPwChangeAction.
type VirtualMachineRootPwChangeAction struct {
	// Action The action to take.
	Action   VirtualMachineRootPwChangeActionAction `json:"action"`
	Contents struct {
		// Password The new password. Must be at least 10 characters.
		Password string `json:"password"`
	} `json:"contents"`
}

// VirtualMachineRootPwChangeActionAction The action to take.
type VirtualMachineRootPwChangeActionAction string

// VirtualMachineRuntimeConfig Defines the runtime settings for a virtual machine.
type VirtualMachineRuntimeConfig struct {
	// Attach An array of attachments to 'plug in' to the virtual machine.
	Attach *[]VirtualMachineRuntimeConfigAttachment `json:"attach"`

	// Hardware Hardware parameters applied for VM runtime.
	Hardware *VirtualMachineRuntimeConfigHardware `json:"hardware,omitempty"`

	// OsFlavor The type of operating system that will be installed to the virtual machine. Allows for preconfigured settings, such as virtio-win drivers for Windows.
	OsFlavor *string `json:"os_flavor,omitempty"`
}

// VirtualMachineRuntimeConfigAttachment Additional attachment (ISO, etc) added during runtime.
type VirtualMachineRuntimeConfigAttachment struct {
	union json.RawMessage
}

// VirtualMachineRuntimeConfigHardware Hardware parameters applied for VM runtime.
type VirtualMachineRuntimeConfigHardware struct {
	// Cpu CPU configuration for the VM. Discriminated by `type`.
	Cpu VirtualMachineRuntimeConfigHardware_Cpu `json:"cpu"`

	// MachineType QEMU machine type to emulate.
	MachineType *VirtualMachineRuntimeConfigHardwareMachineType `json:"machine_type"`
}

// VirtualMachineRuntimeConfigHardware_Cpu CPU configuration for the VM. Discriminated by `type`.
type VirtualMachineRuntimeConfigHardware_Cpu struct {
	union json.RawMessage
}

// VirtualMachineRuntimeConfigHardwareMachineType QEMU machine type to emulate.
type VirtualMachineRuntimeConfigHardwareMachineType string

// VirtualMachineShutdownPolicy The shutdown policy defines how the virtual machine should handle shutdown, including a timeout and signals to be sent during shutdown.
type VirtualMachineShutdownPolicy struct {
	// GracefulTimeout The timeout period for graceful shutdown.
	GracefulTimeout *Duration `json:"graceful_timeout"`
}

// VirtualMachineSosConnection Connection details for connecting to a virtual machine using serial-over-SSH.
type VirtualMachineSosConnection struct {
	// Address The serial-over-SSH connection address.
	Address string `json:"address"`

	// Secret The secret used to connect.
	Secret string `json:"secret"`

	// Token A token used to connect to a virtual machine using serial-over-SSH.
	Token VirtualMachineSosToken `json:"token"`
}

// VirtualMachineSosToken A token used to connect to a virtual machine using serial-over-SSH.
type VirtualMachineSosToken struct {
	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the serial-over-SSH token's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Expires DateTime `json:"expires"`
		Used    DateTime `json:"used"`
	} `json:"events"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Valid A boolean where true represents the token as being a valid token to be used for connection.
	Valid bool `json:"valid"`

	// VirtualMachineId The ID of the virtual machine being connected to.
	VirtualMachineId string `json:"virtual_machine_id"`
}

// VirtualMachineSshIncludes All includable resources linkable to the given virtual machine SSH key.
type VirtualMachineSshIncludes struct {
	// Creators An identity that created a resource.
	Creators                *CreatorInclude         `json:"creators,omitempty"`
	Environments            *map[string]Environment `json:"environments,omitempty"`
	EnvironmentsIdentifiers *map[string]ID          `json:"environments:identifiers,omitempty"`
}

// VirtualMachineSshKey Describes an SSH key used to access a virtual machine.
type VirtualMachineSshKey struct {
	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// EnvironmentId A 24 character hex string used to identify a unique resource.
	EnvironmentId ID `json:"environment_id"`

	// HubId A 24 character hex string used to identify a unique resource.
	HubId ID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Name A user-defined name for the SSH key.
	Name string `json:"name"`

	// PublicKey The public key value of this SSH key.
	PublicKey string `json:"public_key"`
	State     struct {
		Changed DateTime `json:"changed"`

		// Current The current state of the SSH key.
		Current VirtualMachineSshKeyStateCurrent `json:"current"`

		// Error An error, if any, that has occurred for this resource.
		Error *struct {
			// Message Details about the error that has occurred.
			Message *string   `json:"message,omitempty"`
			Time    *DateTime `json:"time,omitempty"`
		} `json:"error,omitempty"`
	} `json:"state"`
}

// VirtualMachineSshKeyStateCurrent The current state of the SSH key.
type VirtualMachineSshKeyStateCurrent string

// VirtualMachineStartAction defines model for VirtualMachineStartAction.
type VirtualMachineStartAction struct {
	Action VirtualMachineStartActionAction `json:"action"`
}

// VirtualMachineStartActionAction defines model for VirtualMachineStartAction.Action.
type VirtualMachineStartActionAction string

// VirtualMachineStartupPolicy The startup policy defines how the virtual machine should handle startup, including a possible delay before starting the machine.
type VirtualMachineStartupPolicy struct {
	// Delay Delay before startup.
	Delay *Duration `json:"delay"`
}

// VirtualMachineState defines model for VirtualMachineState.
type VirtualMachineState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the virtual machine.
	Current VirtualMachineStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// VirtualMachineStateCurrent The current state of the virtual machine.
type VirtualMachineStateCurrent string

// VirtualMachineStopAction defines model for VirtualMachineStopAction.
type VirtualMachineStopAction struct {
	Action VirtualMachineStopActionAction `json:"action"`
}

// VirtualMachineStopActionAction defines model for VirtualMachineStopAction.Action.
type VirtualMachineStopActionAction string

// VirtualMachineTask defines model for VirtualMachineTask.
type VirtualMachineTask struct {
	union json.RawMessage
}

// VirtualMachineTelemetryConfig The telemetry configuration defines how telemetry data is handled, including retention, interval, and whether telemetry is disabled.
type VirtualMachineTelemetryConfig struct {
	// Disable Whether telemetry collection is disabled.
	Disable bool `json:"disable"`

	// Interval Telemetry collection interval.
	Interval *Duration `json:"interval"`

	// Retention Data retention duration for telemetry.
	Retention *Duration `json:"retention"`
}

// VirtualMachineVolume Represents a storage volume attached to a virtual machine.
type VirtualMachineVolume struct {
	// Config Represents the configuration for a volume attached to a virtual machine.
	Config VirtualMachineVolumeConfig `json:"config"`

	// Hash A unique hash identifying the volume for the virtual machine.
	Hash string `json:"hash"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`
}

// VirtualMachineVolumeConfig Represents the configuration for a volume attached to a virtual machine.
type VirtualMachineVolumeConfig struct {
	// External Configuration details for a SAN volume.
	External *struct {
		// Id A 24 character hex string used to identify a unique resource.
		Id *ID `json:"id,omitempty"`
	} `json:"external,omitempty"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`

	// Local Configuration details for a local volume.
	Local *struct {
		// MaxSize The maximum size allowed for the local volume.
		MaxSize string `json:"max_size"`

		// StoragePool Indicates if the volume is part of a storage pool.
		StoragePool *bool `json:"storage_pool,omitempty"`
	} `json:"local,omitempty"`

	// ReadOnly Specifies if the volume is mounted as read-only.
	ReadOnly bool `json:"read_only"`
}

// VirtualProviderGenerateIsoAction defines model for VirtualProviderGenerateIsoAction.
type VirtualProviderGenerateIsoAction struct {
	// Action The action to take.
	Action VirtualProviderGenerateIsoActionAction `json:"action"`
}

// VirtualProviderGenerateIsoActionAction The action to take.
type VirtualProviderGenerateIsoActionAction string

// VirtualProviderIso The ISO image for a virtual provider.
type VirtualProviderIso struct {
	Backend *struct {
		// FileId Unique identifier for the ISO file.
		FileId *string `json:"file_id,omitempty"`

		// FileName Name of the ISO file.
		FileName *string `json:"file_name,omitempty"`

		// Provider The provider responsible for storing the ISO.
		Provider *VirtualProviderIsoBackendProvider `json:"provider,omitempty"`

		// Size Size of the ISO file in bytes.
		Size *int64 `json:"size,omitempty"`
	} `json:"backend"`
	Config struct {
		Ipxe *struct {
			// DnsIp DNS IP assigned to the IPXE boot.
			DnsIp *string `json:"dns_ip"`

			// GatewayIp Gateway IP assigned to the IPXE boot.
			GatewayIp *string `json:"gateway_ip"`

			// Netmask Netmask assigned to the IPXE boot.
			Netmask *string `json:"netmask"`

			// NetworkInterface Network interface for the IPXE boot.
			NetworkInterface *int `json:"network_interface"`

			// StaticIp Static IP assigned to the IPXE boot.
			StaticIp *string `json:"static_ip"`

			// VlanId VLAN ID for the IPXE boot.
			VlanId *int `json:"vlan_id"`
		} `json:"ipxe"`
		Server *struct {
			// AdditionalKernelArgs Appends additional kernel arguments when booting CycleOS.
			AdditionalKernelArgs *string `json:"additional_kernel_args"`

			// Bonds An array of bonds
			Bonds *[]VirtualProviderIsoBond `json:"bonds,omitempty"`

			// Nics An array of server network interfaces.
			Nics                  []VirtualProviderIsoNic                              `json:"nics"`
			SdnNeighborPreference *VirtualProviderIsoConfigServerSdnNeighborPreference `json:"sdn_neighbor_preference"`
			Storage               *struct {
				ConditionalFormat *bool `json:"conditional_format,omitempty"`
			} `json:"storage"`
		} `json:"server"`

		// Token Authentication token for the ISO.
		Token string `json:"token"`
	} `json:"config"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the ISO's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// HubId A 24 character hex string used to identify a unique resource.
	HubId ID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// IntegrationId A 24 character hex string used to identify a unique resource.
	IntegrationId ID `json:"integration_id"`

	// Name The name of the ISO.
	Name  string `json:"name"`
	State struct {
		Changed DateTime `json:"changed"`

		// Current The current state of the environment.
		Current VirtualProviderIsoStateCurrent `json:"current"`

		// Error An error, if any, that has occurred for this resource.
		Error *struct {
			// Message Details about the error that has occurred.
			Message *string   `json:"message,omitempty"`
			Time    *DateTime `json:"time,omitempty"`
		} `json:"error,omitempty"`
	} `json:"state"`
}

// VirtualProviderIsoBackendProvider The provider responsible for storing the ISO.
type VirtualProviderIsoBackendProvider string

// VirtualProviderIsoConfigServerSdnNeighborPreference defines model for VirtualProviderIso.Config.Server.SdnNeighborPreference.
type VirtualProviderIsoConfigServerSdnNeighborPreference string

// VirtualProviderIsoStateCurrent The current state of the environment.
type VirtualProviderIsoStateCurrent string

// VirtualProviderIsoBond Server ISO bond.
type VirtualProviderIsoBond struct {
	InterfaceName string `json:"interface_name"`
	Interfaces    *[]struct {
		// InterfaceName The name of the interface on the server.
		InterfaceName *string `json:"interface_name"`

		// MacAddress The mac address of the server.
		MacAddress *string `json:"mac_address"`
	} `json:"interfaces,omitempty"`

	// Mode balance-rr - Rotate packets evenly across all links.
	// active-backup - One link active, failover to backup if needed.
	// balance-xor - Distributes based on a hash (MAC/IP/port).
	// lacp - Standard link aggregations using LACP.
	// balance-tlb - Adaptive transmit-side balancing (no switch config needed)..
	// balance-alb - TLB + receive load balancing (no switch config needed)..
	Mode VirtualProviderIsoBondMode `json:"mode"`
}

// VirtualProviderIsoBondMode balance-rr - Rotate packets evenly across all links.
// active-backup - One link active, failover to backup if needed.
// balance-xor - Distributes based on a hash (MAC/IP/port).
// lacp - Standard link aggregations using LACP.
// balance-tlb - Adaptive transmit-side balancing (no switch config needed)..
// balance-alb - TLB + receive load balancing (no switch config needed)..
type VirtualProviderIsoBondMode string

// VirtualProviderIsoIncludes A resource that is associated with an ISO.
type VirtualProviderIsoIncludes struct {
	Integrations *map[string]Integration `json:"integrations,omitempty"`
}

// VirtualProviderIsoNic Server ISO network interface.
type VirtualProviderIsoNic struct {
	// Dhcp The DHCP configuration for the network interface.
	Dhcp *struct {
		Mode VirtualProviderIsoNicDhcpMode `json:"mode"`
	} `json:"dhcp"`

	// L2 Configuration options for extending the L2 network into containers directly via a bridge.
	L2 *struct {
		// Domain A standardized name for different layer-2 networks that can be configured on virtual provider hosts.
		//  Containers will utilize this name to determine which network to attach to on the host, if set in the config.
		Domain L2Domain `json:"domain"`
	} `json:"l2"`

	// Match The criteria used to match the server to the interface.
	Match struct {
		// InterfaceName The name of the interface on the server.
		InterfaceName *string `json:"interface_name"`

		// MacAddress The mac address of the server.
		MacAddress *string `json:"mac_address"`
	} `json:"match"`

	// Static The static configuration for the network interface.
	Static *struct {
		// Ipv4 The static subconfiguration for ipv4 or ipv6.
		Ipv4 *VirtualProviderIsoNicStaticFlavor `json:"ipv4,omitempty"`

		// Ipv6 The static subconfiguration for ipv4 or ipv6.
		Ipv6 *VirtualProviderIsoNicStaticFlavor `json:"ipv6,omitempty"`
	} `json:"static"`

	// VlanId VLAN ID for the serer.
	VlanId *int `json:"vlan_id"`
}

// VirtualProviderIsoNicDhcpMode defines model for VirtualProviderIsoNic.Dhcp.Mode.
type VirtualProviderIsoNicDhcpMode string

// VirtualProviderIsoNicStaticFlavor The static subconfiguration for ipv4 or ipv6.
type VirtualProviderIsoNicStaticFlavor struct {
	// GatewayIp An IP address is a numerical label that uniquely identifies a device on a network and enables it to send and receive data.
	GatewayIp *IpAddress `json:"gateway_ip,omitempty"`

	// Ip An IP address is a numerical label that uniquely identifies a device on a network and enables it to send and receive data.
	Ip *IpAddress `json:"ip,omitempty"`

	// Network A CIDR (Classless Inter-Domain Routing) string is a notation used to represent an IP address and its associated network prefix.
	// It combines an IP address with a suffix that indicates how many bits are fixed for routing.
	Network Cidr `json:"network"`
}

// VirtualProviderIsoTask defines model for VirtualProviderIsoTask.
type VirtualProviderIsoTask struct {
	union json.RawMessage
}

// VolumeSummary A summary of relevant volume information.
type VolumeSummary struct {
	// Config Configuration settings for container volumes.
	Config ContainerVolume `json:"config"`

	// External The ID of external volume, if applicable.
	External *struct {
		// Id A 24 character hex string used to identify a unique resource.
		Id *ID `json:"id,omitempty"`
	} `json:"external"`

	// Hash A unique hash for the given volume.
	Hash string `json:"hash"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`
}

// VpnEnvironmentService Information about the environments vpn service(s).
type VpnEnvironmentService struct {
	// AutoUpdate A boolean representing if this service container is set to autoupdate or not
	AutoUpdate *bool `json:"auto_update,omitempty"`

	// Config The config object for the VPN service.
	Config *struct {
		// AllowInternet If true, routes all traffic through the VPN, even non-Cycle traffic.
		AllowInternet bool `json:"allow_internet"`

		// Auth Auth configuration for the VPN.
		Auth struct {
			// CycleAccounts If true, allows any Cycle account with access to the environment to log in to the VPN using their Cycle email and password.
			CycleAccounts bool `json:"cycle_accounts"`

			// VpnAccounts If true, allows the custom VPN accounts to log in to the VPN.
			VpnAccounts *bool `json:"vpn_accounts,omitempty"`

			// Webhook A webhook endpoint to hit. Will be passed the login credentials provided to the user, and should return a 200 status if the login is permitted.
			Webhook *string `json:"webhook"`
		} `json:"auth"`

		// CustomDirectives Additional OpenVPN directives that will be appended to the server configuration on service start. Each line should follow standard OpenVPN syntax.
		CustomDirectives *string `json:"custom_directives"`
	} `json:"config"`

	// ContainerId The ID of the VPN service container
	ContainerId string `json:"container_id"`

	// Enable Whether or not the VPN service is enabled.
	Enable bool `json:"enable"`
}

// VpnReconfigureAction defines model for VpnReconfigureAction.
type VpnReconfigureAction struct {
	// Action The action to take.
	Action VpnReconfigureActionAction `json:"action"`

	// Contents Additional information the platform needs to create this job.
	Contents struct {
		// AutoUpdate A boolean representing if this service container is set to autoupdate or not
		AutoUpdate *bool `json:"auto_update"`

		// Config The config object for the VPN service, in this case without the required fields normally found in a VPN config object.
		Config *struct {
			// AllowInternet If true, routes all traffic through the VPN, even non-Cycle traffic.
			AllowInternet *bool `json:"allow_internet,omitempty"`

			// Auth Auth configuration for the VPN.
			Auth *struct {
				// CycleAccounts If true, allows any Cycle account with access to the environment to log in to the VPN using their Cycle email and password.
				CycleAccounts bool `json:"cycle_accounts"`

				// VpnAccounts If true, allows the custom VPN accounts to log in to the VPN.
				VpnAccounts *bool `json:"vpn_accounts,omitempty"`

				// Webhook A webhook endpoint to hit. Will be passed the login credentials provided to the user, and should return a 200 status if the login is permitted.
				Webhook *string `json:"webhook"`
			} `json:"auth,omitempty"`

			// CustomDirectives Additional OpenVPN directives that will be appended to the server configuration on service start. Each line should follow standard OpenVPN syntax.
			CustomDirectives *string `json:"custom_directives"`
		} `json:"config"`

		// Enable A boolean where true means the VPN service is enabled.
		Enable *bool `json:"enable,omitempty"`

		// HighAvailability A boolean where `true` represents the desire to run the environment vpn service in high availability mode.
		HighAvailability *bool `json:"high_availability"`
	} `json:"contents"`
}

// VpnReconfigureActionAction The action to take.
type VpnReconfigureActionAction string

// VpnResetAction This will reset the VPN certificates and restart the container. Should be done when the certificates expire, every 1000 days. Then, you will need to redownload the VPN config in order to connect.
type VpnResetAction struct {
	// Action The name of the action to perform.
	Action VpnResetActionAction `json:"action"`
}

// VpnResetActionAction The name of the action to perform.
type VpnResetActionAction string

// VpnTask defines model for VpnTask.
type VpnTask struct {
	union json.RawMessage
}

// WafConfig Additional configuration options for the web application firewall.
type WafConfig struct {
	Rules []struct {
		// Conditions An array of the specific conditions for the rule.
		Conditions []struct {
			// Operator A string that indicates the range of values relative to the value property.
			Operator WafConfigRulesConditionsOperator `json:"operator"`

			// Type A string that describes the match type for the condition.
			Type WafConfigRulesConditionsType `json:"type"`

			// Value The value corresponding to the condition type.
			Value string `json:"value"`
		} `json:"conditions"`

		// Description Some information about the rule.
		Description string    `json:"description"`
		Expires     *DateTime `json:"expires,omitempty"`

		// Match A string that describes if both attributes need to be true (match all) or if only one of the conditions needs to be true (match any).
		Match WafConfigRulesMatch `json:"match"`

		// Skip A boolean that indicates if the rule should be active or skipped.
		Skip bool `json:"skip"`

		// Type A string that describes if the role should allow or deny traffic based on the conditions.
		Type WafConfigRulesType `json:"type"`
	} `json:"rules"`
}

// WafConfigRulesConditionsOperator A string that indicates the range of values relative to the value property.
type WafConfigRulesConditionsOperator string

// WafConfigRulesConditionsType A string that describes the match type for the condition.
type WafConfigRulesConditionsType string

// WafConfigRulesMatch A string that describes if both attributes need to be true (match all) or if only one of the conditions needs to be true (match any).
type WafConfigRulesMatch string

// WafConfigRulesType A string that describes if the role should allow or deny traffic based on the conditions.
type WafConfigRulesType string

// WebhookGetStep A pipeline step that will make a GET request to the specified endpoint.
type WebhookGetStep struct {
	// Action The action that the step takes.
	Action  WebhookGetStepAction `json:"action"`
	Details struct {
		// Headers An optional map of headers to send with the request.
		Headers *map[string]string  `json:"headers"`
		Options *WebhookStepOptions `json:"options"`

		// Url The url to submit a POST request to.
		Url string `json:"url"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// WebhookGetStepAction The action that the step takes.
type WebhookGetStepAction string

// WebhookPostStep A pipeline step that will make a POST request to the specified endpoints. The webhook will post the full body of the resource referenced by the step.
// For example if you were to reference a step creating a container, you would receive that container object in the post body.
// You may also specify a custom body instead.
type WebhookPostStep struct {
	// Action The action that the step takes.
	Action  WebhookPostStepAction `json:"action"`
	Details struct {
		// Body An optional POST body to send with the request. Cannot be used with `from``.
		Body *string `json:"body"`

		// From Takes the output from a previous step and uses it as the body for the POST request. Cannot be used with `body`. String format is <stageIdentifier/stepIdentifier>
		From *string `json:"from"`

		// Headers An optional map of headers to send with the request.
		Headers *map[string]string  `json:"headers"`
		Options *WebhookStepOptions `json:"options"`

		// Url The url to submit a POST request to.
		Url string `json:"url"`
	} `json:"details"`

	// Identifier An identifier for the step.
	Identifier *string `json:"identifier,omitempty"`
	Options    *struct {
		Skip *bool `json:"skip,omitempty"`
	} `json:"options,omitempty"`
}

// WebhookPostStepAction The action that the step takes.
type WebhookPostStepAction string

// WebhookStepOptions Options for configuring webhook pipeline steps.
type WebhookStepOptions struct {
	FailOn *struct {
		// HttpCodes A list of http response codes that will trigger a failure.
		HttpCodes *[]int `json:"http_codes"`

		// Not If true, will fail on any codes NOT defined in the http_codes array.
		Not bool `json:"not"`
	} `json:"fail_on"`

	// Interval How long to wait between retries on wait.
	Interval    *Duration `json:"interval"`
	MaxAttempts *int      `json:"max_attempts"`
	RetryOn     *struct {
		// HttpCodes A list of http response codes that will trigger a retry.
		HttpCodes *[]int `json:"http_codes"`

		// Not If true, will retry on any codes NOT defined in the http_codes array.
		Not bool `json:"not"`
	} `json:"retry_on"`
}

// WebhookURL A URL describing the destination Cycle should send a POST webhook payload to.
type WebhookURL = string

// Controllers Optionally included resources for load balancer controllers
type Controllers struct {
	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`

	// Sources A resource associated with an image source.
	Sources *ImageSourceIncludes `json:"sources,omitempty"`

	// StackBuilds A resource that is associated with a stack build.
	StackBuilds *StackBuildIncludes `json:"stack_builds,omitempty"`

	// Stacks A resource associated with a stack.
	Stacks *StackIncludes `json:"stacks,omitempty"`
}

// FilterParam defines model for FilterParam.
type FilterParam = map[string]interface{}

// MembershipIncludeParam defines model for MembershipIncludeParam.
type MembershipIncludeParam = []string

// OrderIncludeParam defines model for OrderIncludeParam.
type OrderIncludeParam = []string

// PageParam defines model for PageParam.
type PageParam struct {
	// Number The page to jump to
	Number *float32 `json:"number,omitempty"`

	// Size The number of resources returned per page.
	Size *float32 `json:"size,omitempty"`
}

// RecordIncludeParam defines model for RecordIncludeParam.
type RecordIncludeParam = []string

// SortParam defines model for SortParam.
type SortParam = []string

// DefaultError An error response.
type DefaultError = ErrorEnvelope

// UpdateAccountJSONBody defines parameters for UpdateAccount.
type UpdateAccountJSONBody struct {
	// AllowSupportLogin If true, Cycle employees will have the ability, upon consent, to access the account for support purposes. This access will be logged.
	AllowSupportLogin *bool `json:"allow_support_login,omitempty"`

	// Name The new name on the Account.
	Name *struct {
		First *string `json:"first,omitempty"`
		Last  *string `json:"last,omitempty"`
	} `json:"name,omitempty"`
}

// DisableTwoFactorAuthJSONBody defines parameters for DisableTwoFactorAuth.
type DisableTwoFactorAuthJSONBody struct {
	// Token A valid existing two-factor auth token, for verification.
	Token string `json:"token"`
}

// RecoverTwoFactorAuthJSONBody defines parameters for RecoverTwoFactorAuth.
type RecoverTwoFactorAuthJSONBody struct {
	// Email The user's email
	Email         string   `json:"email"`
	Password      string   `json:"password"`
	RecoveryCodes []string `json:"recovery_codes"`
	Token         *string  `json:"token,omitempty"`
}

// EnableTwoFactorAuthJSONBody defines parameters for EnableTwoFactorAuth.
type EnableTwoFactorAuthJSONBody struct {
	// Token The token used to authenticate the two-factor setup.
	Token string `json:"token"`
}

// GetAccountInvitesParams defines parameters for GetAccountInvites.
type GetAccountInvitesParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta    *[]GetAccountInvitesParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
	Include *MembershipIncludeParam        `form:"include,omitempty" json:"include,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetAccountInvitesParamsMeta defines parameters for GetAccountInvites.
type GetAccountInvitesParamsMeta string

// GetAccountInvitesParamsInclude defines parameters for GetAccountInvites.
type GetAccountInvitesParamsInclude string

// UpdateAccountInviteJSONBody defines parameters for UpdateAccountInvite.
type UpdateAccountInviteJSONBody struct {
	// Accept If true, the Invite will be accepted and the associated Account will join the Hub.
	Accept *bool `json:"accept,omitempty"`

	// Decline If true, the Invite will be declined and the associated Account will NOT join the Hub.
	Decline *bool `json:"decline,omitempty"`
}

// UpdateAccountInviteParams defines parameters for UpdateAccountInvite.
type UpdateAccountInviteParams struct {
	Include *MembershipIncludeParam `form:"include,omitempty" json:"include,omitempty"`
}

// UpdateAccountInviteParamsInclude defines parameters for UpdateAccountInvite.
type UpdateAccountInviteParamsInclude string

// GetAccountLoginsParams defines parameters for GetAccountLogins.
type GetAccountLoginsParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetAccountMembershipsParams defines parameters for GetAccountMemberships.
type GetAccountMembershipsParams struct {
	Include *MembershipIncludeParam `form:"include,omitempty" json:"include,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetAccountMembershipsParamsInclude defines parameters for GetAccountMemberships.
type GetAccountMembershipsParamsInclude string

// ChangePasswordJSONBody defines parameters for ChangePassword.
type ChangePasswordJSONBody struct {
	// Current Current Password
	Current string `json:"current"`

	// New New Password
	New string `json:"new"`
}

// ResetPasswordJSONBody defines parameters for ResetPassword.
type ResetPasswordJSONBody = map[string]interface{}

// GetAnnouncementsParams defines parameters for GetAnnouncements.
type GetAnnouncementsParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Range The start date from when to fetch the Announcements
		Range *GetAnnouncementsParamsFilterRange `json:"range,omitempty"`

		// Resolved Get only Announcements that have been resolved, or only those that have not.
		Resolved *GetAnnouncementsParamsFilterResolved `json:"resolved,omitempty"`
	} `json:"filter,omitempty"`
}

// GetAnnouncementsParamsFilterRange defines parameters for GetAnnouncements.
type GetAnnouncementsParamsFilterRange string

// GetAnnouncementsParamsFilterResolved defines parameters for GetAnnouncements.
type GetAnnouncementsParamsFilterResolved string

// GetCreditsParams defines parameters for GetCredits.
type GetCreditsParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Search Use a text-based search to filter the credits.
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the credit's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetInvoicesParams defines parameters for GetInvoices.
type GetInvoicesParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`

	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetInvoicesParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		RangeEnd   *DateTime `json:"range-end,omitempty"`
		RangeStart *DateTime `json:"range-start,omitempty"`

		// Search `filter[search]=value` search for the specified text on supported fields.
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the invoice's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`
}

// GetInvoicesParamsMeta defines parameters for GetInvoices.
type GetInvoicesParamsMeta string

// GetInvoiceParams defines parameters for GetInvoice.
type GetInvoiceParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetInvoiceParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Token Token can be optionally provided for authentication outside of the hub context.
	Token *string `form:"token,omitempty" json:"token,omitempty"`
}

// GetInvoiceParamsMeta defines parameters for GetInvoice.
type GetInvoiceParamsMeta string

// CreateInvoiceJobJSONBody defines parameters for CreateInvoiceJob.
type CreateInvoiceJobJSONBody struct {
	// Action The name of the action to perform.
	Action CreateInvoiceJobJSONBodyAction `json:"action"`
}

// CreateInvoiceJobJSONBodyAction defines parameters for CreateInvoiceJob.
type CreateInvoiceJobJSONBodyAction string

// GetBillingMethodsParams defines parameters for GetBillingMethods.
type GetBillingMethodsParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// CreateBillingMethodJSONBody defines parameters for CreateBillingMethod.
type CreateBillingMethodJSONBody struct {
	// Address Address information for a given billing method.
	Address    Address `json:"address"`
	CreditCard *struct {
		Cvv        string `json:"cvv"`
		Expiration struct {
			Month float32 `json:"month"`
			Year  float32 `json:"year"`
		} `json:"expiration"`
		Name   string `json:"name"`
		Number string `json:"number"`
	} `json:"credit_card"`

	// DirectPayment Only available for hubs that have direct billing enabled. Contact Cycle staff at support@cycle.io for any questions.
	DirectPayment *struct {
		// Instructions Any additional instructions for an organization's billing dept., etc. that should be known about this payment method.
		Instructions string `json:"instructions"`

		// Preference The preference for how the payment will be sent.
		Preference CreateBillingMethodJSONBodyDirectPaymentPreference `json:"preference"`
	} `json:"direct_payment"`

	// Name A name for the billing method.
	Name string `json:"name"`

	// Primary A boolean where true represents a billing method being primary.
	Primary    bool `json:"primary"`
	UsBankAcct *struct {
		// AccountHolderName The name of the account holder.
		AccountHolderName string `json:"account_holder_name"`

		// AccountHolderType Whether this account is owned by a business or an individual.
		AccountHolderType CreateBillingMethodJSONBodyUsBankAcctAccountHolderType `json:"account_holder_type"`

		// AccountNumber The number of the bank account.
		AccountNumber string `json:"account_number"`

		// RoutingNumber The routing number of the bank where the account lives.
		RoutingNumber string `json:"routing_number"`
	} `json:"us_bank_acct"`
}

// CreateBillingMethodJSONBodyDirectPaymentPreference defines parameters for CreateBillingMethod.
type CreateBillingMethodJSONBodyDirectPaymentPreference string

// CreateBillingMethodJSONBodyUsBankAcctAccountHolderType defines parameters for CreateBillingMethod.
type CreateBillingMethodJSONBodyUsBankAcctAccountHolderType string

// UpdateBillingMethodJSONBody defines parameters for UpdateBillingMethod.
type UpdateBillingMethodJSONBody struct {
	// Name A name for the billing method.
	Name *string `json:"name,omitempty"`

	// Primary A boolean where true represents a billing method being primary.
	Primary *bool `json:"primary,omitempty"`
}

// CreateBillingMethodJobJSONBody defines parameters for CreateBillingMethodJob.
type CreateBillingMethodJobJSONBody struct {
	// Action The name of the action to perform.
	Action   CreateBillingMethodJobJSONBodyAction `json:"action"`
	Contents struct {
		MicroDeposits []int `json:"micro_deposits"`
	} `json:"contents"`
}

// CreateBillingMethodJobJSONBodyAction defines parameters for CreateBillingMethodJob.
type CreateBillingMethodJobJSONBodyAction string

// GetOrdersParams defines parameters for GetOrders.
type GetOrdersParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page    *PageParam             `json:"page,omitempty"`
	Meta    *[]GetOrdersParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
	Include *OrderIncludeParam     `form:"include,omitempty" json:"include,omitempty"`
}

// GetOrdersParamsMeta defines parameters for GetOrders.
type GetOrdersParamsMeta string

// GetOrdersParamsInclude defines parameters for GetOrders.
type GetOrdersParamsInclude string

// CreateOrderJSONBody defines parameters for CreateOrder.
type CreateOrderJSONBody struct {
	// PromoCode String that defines a promo code
	PromoCode *string `json:"promo_code,omitempty"`

	// SupportPlanId ID associated with the support plan
	SupportPlanId *string `json:"support_plan_id,omitempty"`

	// TermLength String that defines term length
	TermLength *CreateOrderJSONBodyTermLength `json:"term_length,omitempty"`

	// TierPlanId ID associated with the tier plan
	TierPlanId *string `json:"tier_plan_id,omitempty"`
}

// CreateOrderParams defines parameters for CreateOrder.
type CreateOrderParams struct {
	Meta    *[]CreateOrderParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
	Include *OrderIncludeParam       `form:"include,omitempty" json:"include,omitempty"`
}

// CreateOrderParamsMeta defines parameters for CreateOrder.
type CreateOrderParamsMeta string

// CreateOrderParamsInclude defines parameters for CreateOrder.
type CreateOrderParamsInclude string

// CreateOrderJSONBodyTermLength defines parameters for CreateOrder.
type CreateOrderJSONBodyTermLength string

// GetBillingOrderParams defines parameters for GetBillingOrder.
type GetBillingOrderParams struct {
	Meta    *[]GetBillingOrderParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
	Include *OrderIncludeParam           `form:"include,omitempty" json:"include,omitempty"`
}

// GetBillingOrderParamsMeta defines parameters for GetBillingOrder.
type GetBillingOrderParamsMeta string

// GetBillingOrderParamsInclude defines parameters for GetBillingOrder.
type GetBillingOrderParamsInclude string

// UpdateBillingOrderJSONBody defines parameters for UpdateBillingOrder.
type UpdateBillingOrderJSONBody struct {
	// PromoCode String that defines a promo code
	PromoCode *string `json:"promo_code,omitempty"`

	// SupportPlanId ID associated with the support plan
	SupportPlanId *string `json:"support_plan_id,omitempty"`

	// TermLength String that defines term length
	TermLength *UpdateBillingOrderJSONBodyTermLength `json:"term_length,omitempty"`

	// TierPlanId ID associated with the tier plan
	TierPlanId *string `json:"tier_plan_id,omitempty"`
}

// UpdateBillingOrderParams defines parameters for UpdateBillingOrder.
type UpdateBillingOrderParams struct {
	Meta    *[]UpdateBillingOrderParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
	Include *OrderIncludeParam              `form:"include,omitempty" json:"include,omitempty"`
}

// UpdateBillingOrderParamsMeta defines parameters for UpdateBillingOrder.
type UpdateBillingOrderParamsMeta string

// UpdateBillingOrderParamsInclude defines parameters for UpdateBillingOrder.
type UpdateBillingOrderParamsInclude string

// UpdateBillingOrderJSONBodyTermLength defines parameters for UpdateBillingOrder.
type UpdateBillingOrderJSONBodyTermLength string

// CreateOrderJobJSONBody defines parameters for CreateOrderJob.
type CreateOrderJobJSONBody struct {
	// Action The name of the action to perform
	Action CreateOrderJobJSONBodyAction `json:"action"`
}

// CreateOrderJobJSONBodyAction defines parameters for CreateOrderJob.
type CreateOrderJobJSONBodyAction string

// GetBillingSupportPlansParams defines parameters for GetBillingSupportPlans.
type GetBillingSupportPlansParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetBillingServicesParams defines parameters for GetBillingServices.
type GetBillingServicesParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetBillingOveragesParams defines parameters for GetBillingOverages.
type GetBillingOveragesParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetChangelogParams defines parameters for GetChangelog.
type GetChangelogParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetContainersParams defines parameters for GetContainers.
type GetContainersParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetContainersParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetContainersParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Creator `filter[creator]=account-ID` filter for containers matching a particular creator, such as `account-ID` or `environment-ID`
		Creator *string `json:"creator,omitempty"`

		// Deployment `filter[deployment]=v1,v2` filter containers by deployment(s).
		Deployment *string `json:"deployment,omitempty"`

		// DeploymentStrategy `filter[deployment_strategy]=strategy` deployment strategy filtering by strategy string.  Submit the deployment strategy (example: "function") of the strategy you wish to filter for and the return will be any containers matching that description.
		DeploymentStrategy *string `json:"deployment_strategy,omitempty"`

		// Deprecated `filter[deprecated]=true` filter for containers that are deprecated.
		Deprecated *string `json:"deprecated,omitempty"`

		// Environment `filter[environment]=ID` environment filtering by ID.  Submit the ID of the environment you wish to filter for and the return will be any containers in that environment.
		Environment *string `json:"environment,omitempty"`

		// Identifier `filter[identifier]=value` List only those containers matching this identifier. May return multiple results.
		Identifier *string `json:"identifier,omitempty"`

		// Image `filter[image]=ID` image filtering by ID.  Submit the ID of the image you wish to filter for and the return will be any containers currently using the image.
		Image *string `json:"image,omitempty"`

		// PublicNetwork `filter[public_network]=value` public network filtering will allow you to filter by the containers network settings: `enabled`, `disabled`, `egress-only`.
		PublicNetwork *string   `json:"public_network,omitempty"`
		RangeEnd      *DateTime `json:"range-end,omitempty"`
		RangeStart    *DateTime `json:"range-start,omitempty"`

		// Search `filter[search]=value` search containers for a value associated with a field on the given container(s).
		Search *string `json:"search,omitempty"`

		// Service `filter[service]=value` service filtering will allow you to filter by service type: `loadbalancer`, `discovery`, `vpn`.
		Service *string `json:"service,omitempty"`

		// Stack `filter[stack]=ID` stack filtering by ID.  Submit the ID of the stack you wish to filter for and the return will be any containers deployed associated with 'containers' from the stack.
		Stack *string `json:"stack,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the container's current state.
		State *string `json:"state,omitempty"`

		// Tags `filter[tags]=tagone,tagtwo,tagthree` container filtering using server tags. If the container has the tags you submit it will be part of the return.
		Tags *string `json:"tags,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetContainersParamsMeta defines parameters for GetContainers.
type GetContainersParamsMeta string

// GetContainersParamsInclude defines parameters for GetContainers.
type GetContainersParamsInclude string

// CreateContainerJSONBody defines parameters for CreateContainer.
type CreateContainerJSONBody struct {
	// Annotations Custom meta data. Not utilized by Cycle.
	Annotations *map[string]interface{} `json:"annotations"`

	// Config A container configuration.
	Config     Config      `json:"config"`
	Deployment *Deployment `json:"deployment"`

	// EnvironmentId An identifier for the Environment this Container will be deployed to.
	EnvironmentId string      `json:"environment_id"`
	Identifier    *Identifier `json:"identifier"`

	// ImageId An identifier for the Image used to create this Container.
	ImageId string `json:"image_id"`

	// Lock When set to true, prevents this Container from being deleted.
	Lock *bool `json:"lock,omitempty"`

	// Name A user defined name for the Container.
	Name string `json:"name"`

	// Stateful A boolean where true represents this Container is stateful.
	Stateful bool               `json:"stateful"`
	Volumes  *[]ContainerVolume `json:"volumes,omitempty"`
}

// GetContainerParams defines parameters for GetContainer.
type GetContainerParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetContainerParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetContainerParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetContainerParamsMeta defines parameters for GetContainer.
type GetContainerParamsMeta string

// GetContainerParamsInclude defines parameters for GetContainer.
type GetContainerParamsInclude string

// UpdateContainerJSONBody defines parameters for UpdateContainer.
type UpdateContainerJSONBody struct {
	// Annotation User meta data for the Container.
	Annotation *map[string]string `json:"annotation,omitempty"`

	// Deprecate Sets whether Container should be deprecated.
	Deprecate *bool `json:"deprecate,omitempty"`

	// Identifier The name for the identifier.
	Identifier *string `json:"identifier,omitempty"`

	// Lock When set to true, prevents this Container from being deleted.
	Lock *bool `json:"lock,omitempty"`

	// Name The name for the Container.
	Name *string `json:"name,omitempty"`
}

// GetContainerBackupsParams defines parameters for GetContainerBackups.
type GetContainerBackupsParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetContainerBackupsParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetContainerBackupsParamsInclude defines parameters for GetContainerBackups.
type GetContainerBackupsParamsInclude string

// GetContainerBackupParams defines parameters for GetContainerBackup.
type GetContainerBackupParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetContainerBackupParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetContainerBackupParamsInclude defines parameters for GetContainerBackup.
type GetContainerBackupParamsInclude string

// CreateContainerBackupJobJSONBody defines parameters for CreateContainerBackupJob.
type CreateContainerBackupJobJSONBody struct {
	// Action The action to take.
	Action CreateContainerBackupJobJSONBodyAction `json:"action"`

	// Contents Additional information the platform needs to create this Job.
	Contents struct {
		// InstanceId The ID of the instance this Container Backup is being restored to.
		InstanceId string `json:"instance_id"`
	} `json:"contents"`
}

// CreateContainerBackupJobJSONBodyAction defines parameters for CreateContainerBackupJob.
type CreateContainerBackupJobJSONBodyAction string

// GetCompatibleImagesParams defines parameters for GetCompatibleImages.
type GetCompatibleImagesParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetInstancesParams defines parameters for GetInstances.
type GetInstancesParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetInstancesParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetInstancesParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		RangeEnd   *DateTime `json:"range-end,omitempty"`
		RangeStart *DateTime `json:"range-start,omitempty"`

		// Search `filter[search]=value` search instances for a value associated with a field on the given instance(s).
		Search *string `json:"search,omitempty"`

		// Server `filter[server]=ID` server filtering by ID. Submit the ID of the server you wish to filter for and the return will be any instances of the container currently deployed to the given server.
		Server *string `json:"server,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the instance's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetInstancesParamsInclude defines parameters for GetInstances.
type GetInstancesParamsInclude string

// GetInstancesParamsMeta defines parameters for GetInstances.
type GetInstancesParamsMeta string

// CreateInstancesJSONBody defines parameters for CreateInstances.
type CreateInstancesJSONBody = []struct {
	// NewInstances The number of new Instances to be created on the given Server.
	NewInstances int `json:"new_instances"`

	// ServerId The ID of the Server the new Instance(s) should be deployed to.
	ServerId string `json:"server_id"`
}

// GetInstanceParams defines parameters for GetInstance.
type GetInstanceParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetInstanceParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetInstanceParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetInstanceParamsMeta defines parameters for GetInstance.
type GetInstanceParamsMeta string

// GetInstanceParamsInclude defines parameters for GetInstance.
type GetInstanceParamsInclude string

// GetInstanceTelemetryReportParams defines parameters for GetInstanceTelemetryReport.
type GetInstanceTelemetryReportParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		RangeEnd   *DateTime `json:"range-end,omitempty"`
		RangeStart *DateTime `json:"range-start,omitempty"`
	} `json:"filter,omitempty"`
}

// GetInstanceVolumesParams defines parameters for GetInstanceVolumes.
type GetInstanceVolumesParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetContainerServersParams defines parameters for GetContainerServers.
type GetContainerServersParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetContainerServersParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetContainerServersParamsMeta defines parameters for GetContainerServers.
type GetContainerServersParamsMeta string

// GetCompatibleServersParams defines parameters for GetCompatibleServers.
type GetCompatibleServersParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetCompatibleServersParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetCompatibleServersParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetCompatibleServersParamsMeta defines parameters for GetCompatibleServers.
type GetCompatibleServersParamsMeta string

// GetCompatibleServersParamsInclude defines parameters for GetCompatibleServers.
type GetCompatibleServersParamsInclude string

// GetTLSGenerationAttemptsParams defines parameters for GetTLSGenerationAttempts.
type GetTLSGenerationAttemptsParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Domain `filter[domain]=value` filter the return for TLS attempts by domain.
		Domain *string `json:"domain,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// LookupTLSCertificateParams defines parameters for LookupTLSCertificate.
type LookupTLSCertificateParams struct {
	// Domain The domain to lookup.
	Domain string `form:"domain" json:"domain"`

	// Private If true, will include the private key, bundle, and/or CSR for this certificate. Requires the `dns-certs-view` capability.
	Private *bool `form:"private,omitempty" json:"private,omitempty"`
}

// GetUserSuppliedCertificatesParams defines parameters for GetUserSuppliedCertificates.
type GetUserSuppliedCertificatesParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Domain `filter[domain]=value1` filter user certificates by associated domain.
		Domain *string `json:"domain,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow filtering by the current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// UploadUserSuppliedCertificateJSONBody defines parameters for UploadUserSuppliedCertificate.
type UploadUserSuppliedCertificateJSONBody struct {
	// Bundle A PEM encoded certificate bundle.
	Bundle string `json:"bundle"`

	// PrivateKey The certificate's private key.
	PrivateKey string `json:"private_key"`
}

// CreateUserSuppliedCertificateJobJSONBody defines parameters for CreateUserSuppliedCertificateJob.
type CreateUserSuppliedCertificateJobJSONBody struct {
	// Action The action that the job will take.
	//
	// **deprecate**: Cycle will deprecate this certificate, and try to find another usable certificate. If none exists, it will generate a new one
	// for the applicable domains.
	Action CreateUserSuppliedCertificateJobJSONBodyAction `json:"action"`
}

// CreateUserSuppliedCertificateJobJSONBodyAction defines parameters for CreateUserSuppliedCertificateJob.
type CreateUserSuppliedCertificateJobJSONBodyAction string

// GetDNSZonesParams defines parameters for GetDNSZones.
type GetDNSZonesParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetDNSZonesParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// State `filter[state]=value1,value2` state filtering will allow you to filter by the DNS Zone's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetDNSZonesParamsInclude defines parameters for GetDNSZones.
type GetDNSZonesParamsInclude string

// CreateDNSZoneJSONBody defines parameters for CreateDNSZone.
type CreateDNSZoneJSONBody struct {
	Acl *ACL `json:"acl"`

	// Hosted A boolean where true represents the desire for the origin to be of the type `hosted`.
	Hosted bool `json:"hosted"`

	// Origin The origin that will be created.
	Origin string `json:"origin"`
}

// UpdateDNSZoneJSONBody defines parameters for UpdateDNSZone.
type UpdateDNSZoneJSONBody struct {
	// Hosted A boolean where true represents the desire for the origin to be of the type `hosted`.
	Hosted *bool `json:"hosted"`
}

// UpdateDNSZoneParams defines parameters for UpdateDNSZone.
type UpdateDNSZoneParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]UpdateDNSZoneParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// UpdateDNSZoneParamsInclude defines parameters for UpdateDNSZone.
type UpdateDNSZoneParamsInclude string

// UpdateDNSZoneAccessJSONBody defines parameters for UpdateDNSZoneAccess.
type UpdateDNSZoneAccessJSONBody struct {
	Acl *ACL `json:"acl"`
}

// UpdateDNSZoneAccessParams defines parameters for UpdateDNSZoneAccess.
type UpdateDNSZoneAccessParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]UpdateDNSZoneAccessParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// UpdateDNSZoneAccessParamsInclude defines parameters for UpdateDNSZoneAccess.
type UpdateDNSZoneAccessParamsInclude string

// GetDNSZoneRecordsParams defines parameters for GetDNSZoneRecords.
type GetDNSZoneRecordsParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *RecordIncludeParam `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// State `filter[state]=value1,value2` state filtering will allow you to filter by the DNS record's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetDNSZoneRecordsParamsInclude defines parameters for GetDNSZoneRecords.
type GetDNSZoneRecordsParamsInclude string

// CreateDNSZoneRecordJSONBody defines parameters for CreateDNSZoneRecord.
type CreateDNSZoneRecordJSONBody struct {
	// Name A name for the given record where `@` represents the desire to use the root of the origin.
	Name string `json:"name"`

	// Type DNS record types the platform supports.
	Type DnsRecordTypes `json:"type"`
}

// CreateDNSZoneRecordParams defines parameters for CreateDNSZoneRecord.
type CreateDNSZoneRecordParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *RecordIncludeParam `form:"include,omitempty" json:"include,omitempty"`
}

// CreateDNSZoneRecordParamsInclude defines parameters for CreateDNSZoneRecord.
type CreateDNSZoneRecordParamsInclude string

// UpdateDNSZoneRecordJSONBody defines parameters for UpdateDNSZoneRecord.
type UpdateDNSZoneRecordJSONBody struct {
	// Type DNS record types the platform supports.
	Type DnsRecordTypes `json:"type"`
}

// UpdateDNSZoneRecordParams defines parameters for UpdateDNSZoneRecord.
type UpdateDNSZoneRecordParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *RecordIncludeParam `form:"include,omitempty" json:"include,omitempty"`
}

// UpdateDNSZoneRecordParamsInclude defines parameters for UpdateDNSZoneRecord.
type UpdateDNSZoneRecordParamsInclude string

// CreateDNSZoneRecordJobJSONBody defines parameters for CreateDNSZoneRecordJob.
type CreateDNSZoneRecordJobJSONBody struct {
	// Action The action that the job will take.
	Action CreateDNSZoneRecordJobJSONBodyAction `json:"action"`
}

// CreateDNSZoneRecordJobJSONBodyAction defines parameters for CreateDNSZoneRecordJob.
type CreateDNSZoneRecordJobJSONBodyAction string

// CreateDNSZoneJobJSONBody defines parameters for CreateDNSZoneJob.
type CreateDNSZoneJobJSONBody struct {
	// Action The action that the job will take.
	Action CreateDNSZoneJobJSONBodyAction `json:"action"`
}

// CreateDNSZoneJobJSONBodyAction defines parameters for CreateDNSZoneJob.
type CreateDNSZoneJobJSONBodyAction string

// GetEnvironmentsParams defines parameters for GetEnvironments.
type GetEnvironmentsParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetEnvironmentsParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetEnvironmentsParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Creator `filter[creator]=account-ID` filter for environments matching a particular creator, such as `account-ID`.
		Creator *string `json:"creator,omitempty"`

		// Identifier `filter[identifier]=value` List only those environments matching this identifier. May return multiple results.
		Identifier *string `json:"identifier,omitempty"`

		// Search `filter[search]=value` search for a value associated with a field on the given environment(s).
		Search *string `json:"search,omitempty"`

		// StackBuild `filter[stack_build]=ID` stack build filtering by ID.  Submit the ID of the stack build you wish to filter for and the return sill be any environments that have the stack build deployed to them.
		StackBuild *string `json:"stack_build,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the environment's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetEnvironmentsParamsMeta defines parameters for GetEnvironments.
type GetEnvironmentsParamsMeta string

// GetEnvironmentsParamsInclude defines parameters for GetEnvironments.
type GetEnvironmentsParamsInclude string

// CreateEnvironmentJSONBody defines parameters for CreateEnvironment.
type CreateEnvironmentJSONBody struct {
	// About Contains details regarding the Environment.
	About struct {
		// Description A custom description for this Environment.
		Description string `json:"description"`
	} `json:"about"`
	Acl *ACL `json:"acl"`

	// Cluster The cluster this Environment is associated with.
	Cluster string `json:"cluster"`

	// Features An object representing specialized features configured for this environment.
	Features EnvironmentFeatures `json:"features"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Name A user defined name for the Environment.
	Name string `json:"name"`
}

// GetEnvironmentParams defines parameters for GetEnvironment.
type GetEnvironmentParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetEnvironmentParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetEnvironmentParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetEnvironmentParamsMeta defines parameters for GetEnvironment.
type GetEnvironmentParamsMeta string

// GetEnvironmentParamsInclude defines parameters for GetEnvironment.
type GetEnvironmentParamsInclude string

// UpdateEnvironmentJSONBody defines parameters for UpdateEnvironment.
type UpdateEnvironmentJSONBody struct {
	About      *EnvironmentAbout `json:"about"`
	Identifier *string           `json:"identifier"`
	Name       *string           `json:"name"`
	Version    *string           `json:"version"`
}

// UpdateEnvironmentAccessJSONBody defines parameters for UpdateEnvironmentAccess.
type UpdateEnvironmentAccessJSONBody struct {
	Acl *ACL `json:"acl"`
}

// ExportStackJSONBody defines parameters for ExportStack.
type ExportStackJSONBody struct {
	// DeploymentTags Defines which deployment containers to include in the stack export. By default, no containers tagged in a deployment are exported.
	// This option includes all containers with the specific, comma separated deployment tags in the final output in addition to the
	// containers that are not part of any deployment.
	DeploymentTags *[]string `json:"deployment_tags,omitempty"`

	// ResolveOrigins When set to true, Cycle will resolve image origins and inline them into the stack, essentially making this stack portable outside the hub it's currently used in.
	// By default, this is set to false, and the export will just reference existing image sources used by this stack in your hub by ID.
	ResolveOrigins *bool `json:"resolve_origins,omitempty"`
}

// GetScopedVariablesParams defines parameters for GetScopedVariables.
type GetScopedVariablesParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Container `filter[container]=value` List only those scoped variables assigned to the specified container ID.
		Container *string `json:"container,omitempty"`

		// Identifier `filter[identifier]=value` List only those scoped variables matching this identifier. May return multiple results.
		Identifier *string `json:"identifier,omitempty"`

		// Search `filter[search]=value` search for a value associated with a field on the given scoped variable(s).
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the scoped variable's current state.
		State *string `json:"state,omitempty"`
	} `form:"filter,omitempty" json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// CreateScopedVariableJSONBody defines parameters for CreateScopedVariable.
type CreateScopedVariableJSONBody struct {
	// Access The way the scoped variable is accessed.
	Access     *ScopedVariableAccess `json:"access,omitempty"`
	Deployment *Deployment           `json:"deployment"`

	// Identifier An identifier for this Scoped Variable.
	Identifier string `json:"identifier"`

	// Scope Information about the assignment of the scoped variable and how it is invoked.
	Scope ScopedVariableScope `json:"scope"`

	// Source The source or value of the Scoped Variable.
	Source CreateScopedVariableJSONBody_Source `json:"source"`
}

// CreateScopedVariableJSONBody_Source defines parameters for CreateScopedVariable.
type CreateScopedVariableJSONBody_Source struct {
	union json.RawMessage
}

// UpdateScopedVariableJSONBody defines parameters for UpdateScopedVariable.
type UpdateScopedVariableJSONBody struct {
	// Access The way the scoped variable is accessed.
	Access *ScopedVariableAccess `json:"access,omitempty"`

	// Identifier An identifier, similar to a key in an Environment variable.  Its used when envoking the Scoped Variable.
	Identifier *string `json:"identifier,omitempty"`

	// Scope Information about the assignment of the scoped variable and how it is invoked.
	Scope *ScopedVariableScope `json:"scope,omitempty"`

	// Source The source or value of the Scoped Variable.
	Source *UpdateScopedVariableJSONBody_Source `json:"source,omitempty"`
}

// UpdateScopedVariableJSONBody_Source defines parameters for UpdateScopedVariable.
type UpdateScopedVariableJSONBody_Source struct {
	union json.RawMessage
}

// CreateDiscoveryServiceJobJSONBody defines parameters for CreateDiscoveryServiceJob.
type CreateDiscoveryServiceJobJSONBody struct {
	// Action The name of the action to perform.
	Action   CreateDiscoveryServiceJobJSONBodyAction `json:"action"`
	Contents struct {
		// AutoUpdate A boolean where `true` represents the desire to automatically update the environment discovery service.
		AutoUpdate *bool            `json:"auto_update"`
		Config     *DiscoveryConfig `json:"config"`

		// HighAvailability A boolean where `true` represents the desire to run the environment discovery service in high availability mode.
		HighAvailability *bool `json:"high_availability"`
	} `json:"contents"`
}

// CreateDiscoveryServiceJobJSONBodyAction defines parameters for CreateDiscoveryServiceJob.
type CreateDiscoveryServiceJobJSONBodyAction string

// CreateGatewayServiceJobJSONBody defines parameters for CreateGatewayServiceJob.
type CreateGatewayServiceJobJSONBody struct {
	// Action The name of the action to perform.
	Action   CreateGatewayServiceJobJSONBodyAction `json:"action"`
	Contents struct {
		// AutoUpdate A boolean where `true` represents the desire to automatically update the environment gateway service.
		AutoUpdate *bool `json:"auto_update"`
	} `json:"contents"`
}

// CreateGatewayServiceJobJSONBodyAction defines parameters for CreateGatewayServiceJob.
type CreateGatewayServiceJobJSONBodyAction string

// CreateLoadBalancerServiceJobJSONBody defines parameters for CreateLoadBalancerServiceJob.
type CreateLoadBalancerServiceJobJSONBody struct {
	// Action The name of the action to perform.
	Action   CreateLoadBalancerServiceJobJSONBodyAction `json:"action"`
	Contents struct {
		// AutoUpdate A boolean representing if this service container is set to autoupdate or not
		AutoUpdate *bool               `json:"auto_update"`
		Config     *LoadBalancerConfig `json:"config"`

		// HighAvailability A boolean where `true` represents the desire to run the environment load balancer service in high availability mode.
		HighAvailability *bool `json:"high_availability"`
	} `json:"contents"`
}

// CreateLoadBalancerServiceJobJSONBodyAction defines parameters for CreateLoadBalancerServiceJob.
type CreateLoadBalancerServiceJobJSONBodyAction string

// GetLoadBalancerLatestTelemetryReportParams defines parameters for GetLoadBalancerLatestTelemetryReport.
type GetLoadBalancerLatestTelemetryReportParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	// On this endpoint, you MUST pass filter[controller].
	Filter struct {
		// Controller `filter[controller]=port-123` filter for a specific controller to load telemetry for. THIS FILTER IS REQUIRED.
		Controller *string `json:"controller,omitempty"`
	} `json:"filter"`
}

// GetLoadBalancerTelemetryLatestControllersParams defines parameters for GetLoadBalancerTelemetryLatestControllers.
type GetLoadBalancerTelemetryLatestControllersParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetLoadBalancerTelemetryLatestControllersParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetLoadBalancerTelemetryLatestControllersParamsInclude defines parameters for GetLoadBalancerTelemetryLatestControllers.
type GetLoadBalancerTelemetryLatestControllersParamsInclude string

// GetLoadBalancerTelemetryReportParams defines parameters for GetLoadBalancerTelemetryReport.
type GetLoadBalancerTelemetryReportParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter struct {
		Controller DateTime  `json:"controller"`
		RangeEnd   *DateTime `json:"range-end,omitempty"`
		RangeStart *DateTime `json:"range-start,omitempty"`
	} `json:"filter"`
}

// CreateSchedulerServiceJobJSONBody defines parameters for CreateSchedulerServiceJob.
type CreateSchedulerServiceJobJSONBody struct {
	// Action The name of the action to perform.
	Action   CreateSchedulerServiceJobJSONBodyAction `json:"action"`
	Contents struct {
		// AutoUpdate A boolean where `true` represents the desire to automatically update the environment scheduler service.
		AutoUpdate *bool            `json:"auto_update"`
		Config     *SchedulerConfig `json:"config"`
	} `json:"contents"`
}

// CreateSchedulerServiceJobJSONBodyAction defines parameters for CreateSchedulerServiceJob.
type CreateSchedulerServiceJobJSONBodyAction string

// GetVPNLoginsParams defines parameters for GetVPNLogins.
type GetVPNLoginsParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// CreateVPNUserJSONBody defines parameters for CreateVPNUser.
type CreateVPNUserJSONBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// GetHubsParams defines parameters for GetHubs.
type GetHubsParams struct {
	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Identifier `filter[identifier]=value` List only those environments matching this identifier. May return multiple results.
		Identifier *string `json:"identifier,omitempty"`

		// Search `filter[search]=value` search hubs for a value associated with a field on the given Hub(s).
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the Hub's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`
}

// CreateHubJSONBody defines parameters for CreateHub.
type CreateHubJSONBody struct {
	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Name A name for the Hub.
	Name *string `json:"name,omitempty"`

	// Webhooks Hub related webhooks. When supplied, the given webhook will be called with a payload any time one of these events occurs.
	Webhooks *HubWebhooks `json:"webhooks,omitempty"`
}

// DeleteHubJSONBody defines parameters for DeleteHub.
type DeleteHubJSONBody struct {
	Options *struct {
		// Force If force is set to true, this will force delete the hub, even if there are servers running on it.
		Force *bool `json:"force,omitempty"`
	} `json:"options,omitempty"`
}

// GetHubParams defines parameters for GetHub.
type GetHubParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetHubParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
}

// GetHubParamsMeta defines parameters for GetHub.
type GetHubParamsMeta string

// UpdateHubJSONBody defines parameters for UpdateHub.
type UpdateHubJSONBody struct {
	BillingContact *struct {
		LegalBusinessName *string `json:"legal_business_name"`
		Name              *string `json:"name"`
		TaxId             *string `json:"tax_id"`
	} `json:"billing_contact"`

	// BillingEmails Email addresses that will receive any invoices or billing related correspondence.
	BillingEmails *[]string `json:"billing_emails,omitempty"`
	Identifier    *string   `json:"identifier,omitempty"`

	// Name A name for the hub.
	Name *string `json:"name,omitempty"`

	// Security Security options for a hub.
	Security *HubSecurity `json:"security,omitempty"`

	// Webhooks Hub related webhooks. When supplied, the given webhook will be called with a payload any time one of these events occurs.
	Webhooks *HubWebhooks `json:"webhooks,omitempty"`
}

// GetHubActivityParams defines parameters for GetHubActivity.
type GetHubActivityParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetHubActivityParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Container `filter[container]=ID` container filtering by ID. Submit the ID of the container you wish to filter for and the return will be any activity from that container.
		Container *string `json:"container,omitempty"`

		// Environment `filter[environment]=ID` environment filtering by ID. Submit the ID of the environment you wish to filter for and the return will be any activity from that environment.
		Environment *string `json:"environment,omitempty"`

		// Events `filter[events]=value` filter by event names.
		Events *string `json:"events,omitempty"`

		// Instance `filter[instance]=ID` instance filtering by ID. Submit the ID of the instance you wish to filter for and the return will be any activity from that instance.
		Instance *string `json:"instance,omitempty"`

		// Search `filter[search]=value` search activities for a value associated with a field on the given activity(s).
		Search *string `json:"search,omitempty"`

		// Server `filter[server]=ID` server filtering by ID. Submit the ID of the server you wish to filter for and the return will be any activity from that server.
		Server *string `json:"server,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the activity's current state.
		State *string `json:"state,omitempty"`

		// User `filter[user]=ID` user filtering by ID. Submit the ID of the user you wish to filter for and the return will be any activity from that user.
		User *string `json:"user,omitempty"`

		// Verbosity `filter[verbosity]=integer` filter the activity return by verbosity. The verbosity can be:
		//   `0` - Activity that users would find useful.
		//   `1` - Activity that can be useful when tracking down how something happened.
		//   `2` - Full activity, can be useful in debugging problems.
		Verbosity *int `json:"verbosity,omitempty"`

		// VirtualMachine `filter[virtual-machine]=ID` virtual machine filtering by ID. Submit the ID of the virtual machine you wish to filter for and the return will be any activity from that virtual machine.
		VirtualMachine *string `json:"virtual-machine,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetHubActivityParamsInclude defines parameters for GetHubActivity.
type GetHubActivityParamsInclude string

// GetApiKeysParams defines parameters for GetApiKeys.
type GetApiKeysParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// CreateApiKeyJSONBody defines parameters for CreateApiKey.
type CreateApiKeyJSONBody struct {
	// Ips An array of approved IPs from which this API Key can be used.
	Ips *[]string `json:"ips"`

	// Name A name given to the API Key.
	Name string `json:"name"`

	// RoleId A 24 character hex string used to identify a unique resource.
	RoleId ID `json:"role_id"`
}

// GetAPIKeyParams defines parameters for GetAPIKey.
type GetAPIKeyParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetAPIKeyParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetAPIKeyParamsInclude defines parameters for GetAPIKey.
type GetAPIKeyParamsInclude string

// UpdateAPIKeyJSONBody defines parameters for UpdateAPIKey.
type UpdateAPIKeyJSONBody struct {
	// Ips An array of approved IPs from which this API Key can be used.
	Ips *[]string `json:"ips"`

	// Name A name given to the API Key.
	Name *string `json:"name,omitempty"`

	// RoleId A 24 character hex string used to identify a unique resource.
	RoleId *ID `json:"role_id,omitempty"`
}

// GetIntegrationsParams defines parameters for GetIntegrations.
type GetIntegrationsParams struct {
	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetIntegrationsParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for. Supports filtering by state and a text search.
	Filter *struct {
		// Category `filter[category]=value` Filters integrations by their category. For example, `filter[category]=infrastructure-provider` would return only integrations that are capable of provisioning infrastructure.
		Category *string `json:"category,omitempty"`

		// Search `filter[search]=value` Performs a text search across relevant fields of the integrations. For example, `filter[search]=example` would return integrations that have "example" in any of the searchable fields
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value` Filters integrations by their current state. For example, `filter[state]=active` would return only integrations in an active state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`
}

// GetIntegrationsParamsMeta defines parameters for GetIntegrations.
type GetIntegrationsParamsMeta string

// CreateIntegrationJSONBody defines parameters for CreateIntegration.
type CreateIntegrationJSONBody struct {
	// Auth Authentication information for the integration.
	Auth *struct {
		// ApiKey API key for accessing the integration.
		ApiKey *string `json:"api_key"`

		// Base64Config Base64 encoded configuration for the integration.
		Base64Config *string `json:"base64_config"`

		// ClientId Client ID for the integration.
		ClientId *string `json:"client_id"`

		// KeyId Key ID for accessing the integration.
		KeyId *string `json:"key_id"`

		// Namespace The namespace associated with the integration.
		Namespace *string `json:"namespace"`

		// Region The region associated with the integration.
		Region *string `json:"region"`

		// Secret Secret for accessing the integration.
		Secret *string `json:"secret"`

		// SubscriptionId Subscription ID for the integration.
		SubscriptionId *string `json:"subscription_id"`
	} `json:"auth,omitempty"`

	// Extra Additional key-value pairs associated with the integration.
	Extra *map[string]string `json:"extra,omitempty"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`

	// Name A name for the integration.
	Name string `json:"name"`

	// Vendor Unique vendor for the integration, subject to validation.
	Vendor string `json:"vendor"`
}

// CreateIntegrationParams defines parameters for CreateIntegration.
type CreateIntegrationParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]CreateIntegrationParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
}

// CreateIntegrationParamsMeta defines parameters for CreateIntegration.
type CreateIntegrationParamsMeta string

// GetIntegrationParams defines parameters for GetIntegration.
type GetIntegrationParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetIntegrationParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
}

// GetIntegrationParamsMeta defines parameters for GetIntegration.
type GetIntegrationParamsMeta string

// UpdateIntegrationJSONBody defines parameters for UpdateIntegration.
type UpdateIntegrationJSONBody struct {
	Auth *IntegrationAuth `json:"auth"`

	// Extra Updated key-value pairs associated with the integration.
	Extra *map[string]string `json:"extra"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Name A new name for the integration.
	Name *string `json:"name"`
}

// UpdateIntegrationParams defines parameters for UpdateIntegration.
type UpdateIntegrationParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]UpdateIntegrationParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
}

// UpdateIntegrationParamsMeta defines parameters for UpdateIntegration.
type UpdateIntegrationParamsMeta string

// CreateIntegrationJobJSONBody defines parameters for CreateIntegrationJob.
type CreateIntegrationJobJSONBody struct {
	// Action The type of Job/selected Job action to create.
	Action CreateIntegrationJobJSONBodyAction `json:"action"`
}

// CreateIntegrationJobJSONBodyAction defines parameters for CreateIntegrationJob.
type CreateIntegrationJobJSONBodyAction string

// GetHubInvitesParams defines parameters for GetHubInvites.
type GetHubInvitesParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetHubInvitesParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetHubInvitesParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetHubInvitesParamsMeta defines parameters for GetHubInvites.
type GetHubInvitesParamsMeta string

// GetHubInvitesParamsInclude defines parameters for GetHubInvites.
type GetHubInvitesParamsInclude string

// CreateHubInviteJSONBody defines parameters for CreateHubInvite.
type CreateHubInviteJSONBody struct {
	// Permissions The Environment permissions the invitee will have
	Permissions *struct {
		// AllEnvironments Boolean value that indicates the user has access to all Environments
		AllEnvironments bool `json:"all_environments"`

		// Environments A list of objects that describe the specific environments the invitee will have access to
		Environments []struct {
			// Id The ID of the Environment
			Id string `json:"id"`

			// Manage Boolean indicating the invitee has manage rights to Environment
			Manage bool `json:"manage"`
		} `json:"environments"`
	} `json:"permissions,omitempty"`

	// Recipient The email address of the invitee.
	Recipient *string `json:"recipient,omitempty"`

	// RoleId A 24 character hex string used to identify a unique resource.
	RoleId *ID `json:"role_id,omitempty"`
}

// GetHubMembersParams defines parameters for GetHubMembers.
type GetHubMembersParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetHubMembersParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetHubMembersParamsInclude defines parameters for GetHubMembers.
type GetHubMembersParamsInclude string

// GetHubMemberAccountParams defines parameters for GetHubMemberAccount.
type GetHubMemberAccountParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetHubMemberAccountParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetHubMemberAccountParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetHubMemberAccountParamsMeta defines parameters for GetHubMemberAccount.
type GetHubMemberAccountParamsMeta string

// GetHubMemberAccountParamsInclude defines parameters for GetHubMemberAccount.
type GetHubMemberAccountParamsInclude string

// GetHubMemberParams defines parameters for GetHubMember.
type GetHubMemberParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetHubMemberParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetHubMemberParamsInclude defines parameters for GetHubMember.
type GetHubMemberParamsInclude string

// UpdateHubMemberJSONBody defines parameters for UpdateHubMember.
type UpdateHubMemberJSONBody struct {
	// Permissions Permissions information for an API Key
	Permissions *Permissions `json:"permissions,omitempty"`

	// RoleId A 24 character hex string used to identify a unique resource.
	RoleId *ID `json:"role_id,omitempty"`
}

// GetHubMembershipParams defines parameters for GetHubMembership.
type GetHubMembershipParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetHubMembershipParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetHubMembershipParamsInclude defines parameters for GetHubMembership.
type GetHubMembershipParamsInclude string

// GetRolesParams defines parameters for GetRoles.
type GetRolesParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort   *SortParam   `form:"sort,omitempty" json:"sort,omitempty"`
	Filter *FilterParam `json:"filter,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`

	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetRolesParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
}

// GetRolesParamsMeta defines parameters for GetRoles.
type GetRolesParamsMeta string

// CreateRoleJSONBody defines parameters for CreateRole.
type CreateRoleJSONBody struct {
	// Capabilities The list of platform level capabilities assigned to this Role.
	Capabilities *struct {
		All      bool         `json:"all"`
		Specific []Capability `json:"specific"`
	} `json:"capabilities"`

	// Extra Custom user-defined properties for storing extra information on the Role. Not utilized by Cycle.
	Extra      *map[string]string `json:"extra"`
	Identifier string             `json:"identifier"`

	// Name A name given to the Role.
	Name *string `json:"name"`

	// Rank An integer between 0 and 10 that indicates the Role hierarchy. An account can only edit a Role that is less than their rank. The 'owner' Role is rank 10.
	Rank int `json:"rank"`
}

// GetRoleParams defines parameters for GetRole.
type GetRoleParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetRoleParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
}

// GetRoleParamsMeta defines parameters for GetRole.
type GetRoleParamsMeta string

// UpdateRoleJSONBody defines parameters for UpdateRole.
type UpdateRoleJSONBody struct {
	// Capabilities The list of platform level capabilities assigned to this Role.
	Capabilities *struct {
		// All If true, the Role has all capabilities.
		All      bool         `json:"all"`
		Specific []Capability `json:"specific"`
	} `json:"capabilities"`

	// Extra Custom user-defined properties for storing extra information on the Role. Not utilized by Cycle.
	Extra      *map[string]string `json:"extra"`
	Identifier string             `json:"identifier"`

	// Name A name given to the Role.
	Name *string `json:"name"`
	Rank int     `json:"rank"`
}

// GetHubUsageParams defines parameters for GetHubUsage.
type GetHubUsageParams struct {
	Filter *FilterParam `json:"filter,omitempty"`
}

// GetImagesParams defines parameters for GetImages.
type GetImagesParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetImagesParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetImagesParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Identifier `filter[identifier]=value` List only those images matching this identifier. May return multiple results.
		Identifier *string `json:"identifier,omitempty"`

		// Search `filter[search]=value` search for a value associated with a field on the given Image(s).
		Search *string `json:"search,omitempty"`

		// SourceId `filter[source_id]=ID` Image filtering by source ID.  Submit the ID of the Image source you wish to filter for and the return will be any Images created from that source.
		SourceId *string `json:"source_id,omitempty"`

		// SourceType `filter[source_type]=value` filter images by the Image source's type.  Can be: `direct`, `stack-build`, or `bucket`
		SourceType *string `json:"source_type,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the Image's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetImagesParamsMeta defines parameters for GetImages.
type GetImagesParamsMeta string

// GetImagesParamsInclude defines parameters for GetImages.
type GetImagesParamsInclude string

// CreateImageJSONBody defines parameters for CreateImage.
type CreateImageJSONBody struct {
	// Build A build object, holding information important to the Image build.
	Build *struct {
		// Args An object holding key value build time arguments needed for the Image during build time.
		Args *map[string]string `json:"args,omitempty"`

		// UseDisk If true, will skip using /dev/shm when building an image on factory. Allows for building much larger images.
		UseDisk *bool `json:"use_disk,omitempty"`
	} `json:"build,omitempty"`

	// Name A name for the Image.
	Name *string `json:"name,omitempty"`

	// Override An override object to be used for a single Image create request.
	Override *struct {
		// Target For Image sources with `docker-hub` or `docker-registry` origin types. A target to be used for overridding the default target - should include an Image and a tag.
		Target *string `json:"target,omitempty"`

		// TargzUrl For Image sources with `docker-file` origin types. A URL pointing to a .tar.gz file of a repo with a Dockerfile in it - can be used instead of linking Cycle directly to a repository.
		TargzUrl *string `json:"targz_url,omitempty"`
	} `json:"override,omitempty"`

	// SourceId The ID for the Image source to be used.
	SourceId string `json:"source_id"`
}

// GetImageSourcesParams defines parameters for GetImageSources.
type GetImageSourcesParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetImageSourcesParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetImageSourcesParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Identifier `filter[identifier]=value` List only those image sources matching this identifier. May return multiple results.
		Identifier *string `json:"identifier,omitempty"`

		// Search `filter[search]=value` search for a value associated with a field on the given Image Source(s).
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the Image Source's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetImageSourcesParamsMeta defines parameters for GetImageSources.
type GetImageSourcesParamsMeta string

// GetImageSourcesParamsInclude defines parameters for GetImageSources.
type GetImageSourcesParamsInclude string

// CreateImageSourceJSONBody defines parameters for CreateImageSource.
type CreateImageSourceJSONBody struct {
	// About User defined information about the Image Source.
	About *struct {
		// Description A description of the Image Source.
		Description *string `json:"description"`
	} `json:"about,omitempty"`
	Acl     *ACL `json:"acl"`
	Builder *struct {
		// IntegrationId Either a resource ID (objectid - i.e. 651586fca6078e98982dbd90) or a resource Identifier (human-readable)
		IntegrationId HybridIdentifier `json:"integration_id"`
	} `json:"builder"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Name A name for the Image Source.
	Name *string `json:"name,omitempty"`

	// Origin The origin of the image.
	Origin ImageOrigin `json:"origin"`

	// Type The type of images in this source.
	Type ImageSourceType `json:"type"`
}

// GetImageSourceParams defines parameters for GetImageSource.
type GetImageSourceParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetImageSourceParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetImageSourceParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetImageSourceParamsMeta defines parameters for GetImageSource.
type GetImageSourceParamsMeta string

// GetImageSourceParamsInclude defines parameters for GetImageSource.
type GetImageSourceParamsInclude string

// UpdateImageSourceJSONBody defines parameters for UpdateImageSource.
type UpdateImageSourceJSONBody struct {
	// About User defined information about the image source.
	About *struct {
		// Description A description of the image source.
		Description *string `json:"description"`
	} `json:"about,omitempty"`
	Builder *struct {
		IntegrationId *HybridIdentifier `json:"integration_id"`
	} `json:"builder"`
	Identifier *Identifier `json:"identifier"`

	// Name A name for the image source.
	Name *string `json:"name,omitempty"`

	// Origin The origin of the image.
	Origin *ImageOrigin `json:"origin,omitempty"`
}

// UpdateImageSourceAccessJSONBody defines parameters for UpdateImageSourceAccess.
type UpdateImageSourceAccessJSONBody struct {
	Acl *ACL `json:"acl"`
}

// CreateImagesJobJSONBody defines parameters for CreateImagesJob.
type CreateImagesJobJSONBody struct {
	// Action The action is the Job type to create.
	Action CreateImagesJobJSONBodyAction `json:"action"`

	// Contents Additional contents needed by the platform to create the Job.
	Contents struct {
		// SourceIds A list of IDs to be pruned.
		SourceIds []string `json:"source_ids"`
	} `json:"contents"`
}

// CreateImagesJobJSONBodyAction defines parameters for CreateImagesJob.
type CreateImagesJobJSONBodyAction string

// GetImageParams defines parameters for GetImage.
type GetImageParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetImageParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetImageParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetImageParamsMeta defines parameters for GetImage.
type GetImageParamsMeta string

// GetImageParamsInclude defines parameters for GetImage.
type GetImageParamsInclude string

// UpdateImageJSONBody defines parameters for UpdateImage.
type UpdateImageJSONBody struct {
	// Name A name for the image.
	Name *string `json:"name,omitempty"`
}

// CreateImageJobJSONBody defines parameters for CreateImageJob.
type CreateImageJobJSONBody struct {
	Action CreateImageJobJSONBodyAction `json:"action"`
}

// CreateImageJobJSONBodyAction defines parameters for CreateImageJob.
type CreateImageJobJSONBodyAction string

// GetAutoScaleGroupsParams defines parameters for GetAutoScaleGroups.
type GetAutoScaleGroupsParams struct {
	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetAutoScaleGroupsParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Cluster `filter[cluster]=value` return a list of auto-scale groups that are associated with the specified cluster.
		Cluster *string `json:"cluster,omitempty"`

		// Identifier `filter[identifier]=value` list only those auto-scale groups matching this identifier. May return multiple results.
		Identifier *string `json:"identifier,omitempty"`

		// Search `filter[search]=value` search for a value associated with a field on the given auto-scale group(s).
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the provider's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`
}

// GetAutoScaleGroupsParamsInclude defines parameters for GetAutoScaleGroups.
type GetAutoScaleGroupsParamsInclude string

// CreateAutoScaleGroupJSONBody defines parameters for CreateAutoScaleGroup.
type CreateAutoScaleGroupJSONBody struct {
	Acl            *ACL                         `json:"acl"`
	Cluster        string                       `json:"cluster"`
	Identifier     string                       `json:"identifier"`
	Infrastructure AutoScaleGroupInfrastructure `json:"infrastructure"`
	Name           string                       `json:"name"`
	Scale          AutoScaleGroupScale          `json:"scale"`
}

// GetAutoScaleGroupParams defines parameters for GetAutoScaleGroup.
type GetAutoScaleGroupParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetAutoScaleGroupParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetAutoScaleGroupParamsInclude defines parameters for GetAutoScaleGroup.
type GetAutoScaleGroupParamsInclude string

// UpdateAutoScaleGroupJSONBody defines parameters for UpdateAutoScaleGroup.
type UpdateAutoScaleGroupJSONBody struct {
	Identifier     *string                       `json:"identifier"`
	Infrastructure *AutoScaleGroupInfrastructure `json:"infrastructure"`
	Name           *string                       `json:"name"`
	Scale          *AutoScaleGroupScale          `json:"scale"`
}

// UpdateAutoScaleGroupAccessJSONBody defines parameters for UpdateAutoScaleGroupAccess.
type UpdateAutoScaleGroupAccessJSONBody struct {
	Acl *ACL `json:"acl"`
}

// GetClustersParams defines parameters for GetClusters.
type GetClustersParams struct {
	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// CreateClusterJSONBody defines parameters for CreateCluster.
type CreateClusterJSONBody struct {
	Acl *ACL `json:"acl"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`
}

// UpdateClusterJSONBody defines parameters for UpdateCluster.
type UpdateClusterJSONBody = map[string]interface{}

// UpdateClusterAccessJSONBody defines parameters for UpdateClusterAccess.
type UpdateClusterAccessJSONBody struct {
	Acl *ACL `json:"acl"`
}

// GetExternalVolumesParams defines parameters for GetExternalVolumes.
type GetExternalVolumesParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetExternalVolumesParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma-separated list of include values. Included resources will show up under the root document's `include` field.
	// In the case of applying an include to a collection of resources, if multiple resources share the same include, it will only appear once in the return.
	Include *[]GetExternalVolumesParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Cluster `filter[search]=value` List only those attached volumes within the specified cluster.
		Cluster *string `json:"cluster,omitempty"`

		// Location `filter[location]=value` List only those attached volumes available at the specified location.
		Location *string `json:"location,omitempty"`

		// Server `filter[server-id]=value` List only those attached volumes attached to the specified server.
		Server *string `json:"server,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the attached volume's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetExternalVolumesParamsMeta defines parameters for GetExternalVolumes.
type GetExternalVolumesParamsMeta string

// GetExternalVolumesParamsInclude defines parameters for GetExternalVolumes.
type GetExternalVolumesParamsInclude string

// CreateExternalVolumeJSONBody defines parameters for CreateExternalVolume.
type CreateExternalVolumeJSONBody struct {
	// About Additional details about the external volume.
	About *struct {
		// Description A custom description for this external volume.
		Description string `json:"description"`
	} `json:"about"`
	Acl *ACL `json:"acl"`

	// Attachment Attachment configuration for an external volume.
	Attachment ExternalVolumeAttachment `json:"attachment"`

	// Cluster The cluster this external volume is associated with.
	Cluster string `json:"cluster"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// LocationId A 24 character hex string used to identify a unique resource.
	LocationId ID `json:"location_id"`

	// Name A custom name for the external volume.
	Name string `json:"name"`

	// Options Configuration options controlling the behavior of the volume.
	Options   ExternalVolumeOptions `json:"options"`
	ServerIds []ID                  `json:"server_ids"`

	// Source The source information for this volume.
	Source ExternalVolumeSource `json:"source"`
}

// CreateExternalVolumeParams defines parameters for CreateExternalVolume.
type CreateExternalVolumeParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]CreateExternalVolumeParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma-separated list of include values. Included resources will show up under the root document's `include` field.
	// In the case of applying an include to a collection of resources, if multiple resources share the same include, it will only appear once in the return.
	Include *[]CreateExternalVolumeParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// CreateExternalVolumeParamsMeta defines parameters for CreateExternalVolume.
type CreateExternalVolumeParamsMeta string

// CreateExternalVolumeParamsInclude defines parameters for CreateExternalVolume.
type CreateExternalVolumeParamsInclude string

// DeleteExternalVolumeJSONBody defines parameters for DeleteExternalVolume.
type DeleteExternalVolumeJSONBody struct {
	Options *struct {
		// SourceDevice If source device is set to true, this will delete the underlying source device.
		SourceDevice *bool `json:"source_device,omitempty"`
	} `json:"options,omitempty"`
}

// GetExternalVolumeParams defines parameters for GetExternalVolume.
type GetExternalVolumeParams struct {
	// Meta A comma-separated list of meta values. Meta values will show up under a resource's `meta` field.
	// In the case of applying a meta to a collection of resources, each resource will have its own relevant meta data.
	// In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetExternalVolumeParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma-separated list of include values. Included resources will show up under the root document's `include` field.
	// In the case of applying an include to a collection of resources, if multiple resources share the same include, it will only appear once in the return.
	Include *[]GetExternalVolumeParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetExternalVolumeParamsMeta defines parameters for GetExternalVolume.
type GetExternalVolumeParamsMeta string

// GetExternalVolumeParamsInclude defines parameters for GetExternalVolume.
type GetExternalVolumeParamsInclude string

// UpdateExternalVolumeJSONBody defines parameters for UpdateExternalVolume.
type UpdateExternalVolumeJSONBody struct {
	About *struct {
		// Description Updated description for the attached volume.
		Description *string `json:"description,omitempty"`
	} `json:"about,omitempty"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Name The new name of the external volume.
	Name *string `json:"name,omitempty"`

	// Options Configuration options controlling the behavior of the volume.
	Options *ExternalVolumeOptions `json:"options,omitempty"`
}

// UpdateExternalVolumeParams defines parameters for UpdateExternalVolume.
type UpdateExternalVolumeParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]UpdateExternalVolumeParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma-separated list of include values. Included resources will show up under the root document's `include` field.
	// In the case of applying an include to a collection of resources, if multiple resources share the same include, it will only appear once in the return.
	Include *[]UpdateExternalVolumeParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// UpdateExternalVolumeParamsMeta defines parameters for UpdateExternalVolume.
type UpdateExternalVolumeParamsMeta string

// UpdateExternalVolumeParamsInclude defines parameters for UpdateExternalVolume.
type UpdateExternalVolumeParamsInclude string

// UpdateExternalVolumeAccessJSONBody defines parameters for UpdateExternalVolumeAccess.
type UpdateExternalVolumeAccessJSONBody struct {
	Acl *ACL `json:"acl"`
}

// GetIpPoolsParams defines parameters for GetIpPools.
type GetIpPoolsParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetIpPoolsParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Available `filter[available]=true` filter for IPs that are available for use.
		Available *string `json:"available,omitempty"`

		// Location `filter[location]=ID` location filtering by ID. Submit the ID of the location you wish to filter by.
		Location *string `json:"location,omitempty"`

		// Server `filter[server]=ID` server filtering by ID. Submit the ID of the server you wish to filter for and the return will be any IP pool associated with that server.
		Server *string `json:"server,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the IP's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetIpPoolsParamsInclude defines parameters for GetIpPools.
type GetIpPoolsParamsInclude string

// CreateIpPoolJSONBody defines parameters for CreateIpPool.
type CreateIpPoolJSONBody struct {
	Block struct {
		// Cidr A CIDR (Classless Inter-Domain Routing) string is a notation used to represent an IP address and its associated network prefix.
		// It combines an IP address with a suffix that indicates how many bits are fixed for routing.
		Cidr Cidr `json:"cidr"`

		// Gateway An IP address is a numerical label that uniquely identifies a device on a network and enables it to send and receive data.
		Gateway IpAddress `json:"gateway"`

		// Network A CIDR (Classless Inter-Domain Routing) string is a notation used to represent an IP address and its associated network prefix.
		// It combines an IP address with a suffix that indicates how many bits are fixed for routing.
		Network *Cidr `json:"network,omitempty"`
	} `json:"block"`

	// Options Options for an IP.
	Options *IpOptions `json:"options,omitempty"`

	// ServerId A 24 character hex string used to identify a unique resource.
	ServerId ID `json:"server_id"`
}

// GetIPPoolParams defines parameters for GetIPPool.
type GetIPPoolParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetIPPoolParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetIPPoolParamsInclude defines parameters for GetIPPool.
type GetIPPoolParamsInclude string

// GetProviderLocationsParams defines parameters for GetProviderLocations.
type GetProviderLocationsParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetProviderServersParams defines parameters for GetProviderServers.
type GetProviderServersParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// LocationIds `filter[location_ids]=value` List only those provider servers matching this location. May return multiple results.
		LocationIds *string `json:"location_ids,omitempty"`
	} `json:"filter,omitempty"`
}

// GetServersParams defines parameters for GetServers.
type GetServersParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetServersParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetServersParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Cluster `filter[cluster]=clusterIdentifier` filtering by cluster.  Enter the cluster identifier and the return will include servers belonging to the specified cluster.
		Cluster *string `json:"cluster,omitempty"`

		// Location `filter[location]=location` filtering by location.  Enter the location id and the return will include servers belonging to the specified location.
		Location *string `json:"location,omitempty"`

		// Providers `filter[providers]=providerone,providertwo` filtering by provider.  Enter one or more providers (commas separated) and the return will include servers that match any providers in the list.
		Providers *string `json:"providers,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the provider's current state.
		State *string `json:"state,omitempty"`

		// Tags `filter[tags]=tagone,tagtwo,tagthree` filtering by Server tag.  Enter one or more tags (comma separated) and the return will include servers that match any tags in the list.
		Tags *string `json:"tags,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetServersParamsMeta defines parameters for GetServers.
type GetServersParamsMeta string

// GetServersParamsInclude defines parameters for GetServers.
type GetServersParamsInclude string

// CreateServerJSONBody defines parameters for CreateServer.
type CreateServerJSONBody struct {
	// Cluster The existing or new cluster this infrastructure should be provisioned in.
	Cluster string `json:"cluster"`

	// Servers An array of servers to provision.
	Servers []struct {
		Advanced *[]struct {
			// ProvisionOptions Advanced options to apply to the provisioning of a server.
			ProvisionOptions *struct {
				// AttachedStorageSize For providers that support setting this value dynamically; A number representing the GB size of the volume to be attached to the server.
				AttachedStorageSize *int `json:"attached_storage_size"`

				// EncryptStorage For providers that support this setting, this option will encrypt storage for server.
				EncryptStorage *bool `json:"encrypt_storage"`

				// ReservationId A reservation ID to be used to provision a server that has been reserved at the provider.
				ReservationId *string `json:"reservation_id"`
			} `json:"provision_options"`
			Zone *string `json:"zone"`
		} `json:"advanced,omitempty"`

		// Hostnames An array of hostnames for the given servers.
		Hostnames *[]string `json:"hostnames,omitempty"`

		// IntegrationId A 24 character hex string used to identify a unique resource.
		IntegrationId ID `json:"integration_id"`

		// LocationId The location ID of the Server.
		LocationId string `json:"location_id"`

		// ModelId The model ID of the Server.
		ModelId string `json:"model_id"`

		// Quantity The number of this Server at this location to deploy.
		Quantity int `json:"quantity"`
	} `json:"servers"`
}

// GetServerTagsParams defines parameters for GetServerTags.
type GetServerTagsParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Cluster `filter[cluster]=clusterone,clustertwo` filtering by cluster.  Enter one or more clusters (commas separated) and the return will include tags from servers that match any cluster(s) in the list.
		Cluster *string `json:"cluster,omitempty"`
	} `json:"filter,omitempty"`
}

// DeleteServerJSONBody defines parameters for DeleteServer.
type DeleteServerJSONBody struct {
	Options *struct {
		// Force If force is set to true, this will force delete the server, even if there are instances running on it.
		Force *bool `json:"force,omitempty"`
	} `json:"options,omitempty"`
}

// GetServerParams defines parameters for GetServer.
type GetServerParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetServerParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetServerParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`
}

// GetServerParamsInclude defines parameters for GetServer.
type GetServerParamsInclude string

// GetServerParamsMeta defines parameters for GetServer.
type GetServerParamsMeta string

// UpdateServerJSONBody defines parameters for UpdateServer.
type UpdateServerJSONBody struct {
	// Constraints Server constriants.
	Constraints struct {
		// Allow Server constraints for the given Server.
		Allow *struct {
			// Overcommit A boolean where true represents the desire for the Server to allow the overcommitting of shares.
			Overcommit bool `json:"overcommit"`

			// OvercommitMultiple An integer that describes the capability of a server to overcommit shares.  This will allow more containers to run on a given server based on the servers available CPU cores. 1 CPU core = 10 shares by default.
			OvercommitMultiple *int `json:"overcommit_multiple"`

			// Pool A boolean where true represents the Server can accept containers with no tags set.
			Pool bool `json:"pool"`

			// Services A boolean where true represents the Server being a target for service containers.
			Services bool `json:"services"`
		} `json:"allow,omitempty"`

		// Tags A list of Server tags.
		Tags *[]string `json:"tags,omitempty"`
	} `json:"constraints"`

	// Nickname A custom name given to the server for identification purposes. Does not affect server hostname.
	Nickname *string `json:"nickname"`
}

// GetServerInstancesParams defines parameters for GetServerInstances.
type GetServerInstancesParams struct {
	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetServerInstancesParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetServerInstancesParamsInclude defines parameters for GetServerInstances.
type GetServerInstancesParamsInclude string

// GetServerTelemetryParams defines parameters for GetServerTelemetry.
type GetServerTelemetryParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		RangeEnd   *DateTime `json:"range-end,omitempty"`
		RangeStart *DateTime `json:"range-start,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetInfrastructureSummaryParams defines parameters for GetInfrastructureSummary.
type GetInfrastructureSummaryParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Cluster `filter[cluster]=value` return an infrastructure summary only for the specified cluster.
		Cluster *string `json:"cluster,omitempty"`
	} `json:"filter,omitempty"`
}

// GetVirtualProviderIsosParams defines parameters for GetVirtualProviderIsos.
type GetVirtualProviderIsosParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetVirtualProviderIsosParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetVirtualProviderIsosParamsInclude defines parameters for GetVirtualProviderIsos.
type GetVirtualProviderIsosParamsInclude string

// CreateVirtualProviderIsoJSONBody defines parameters for CreateVirtualProviderIso.
type CreateVirtualProviderIsoJSONBody struct {
	Config struct {
		Ipxe *struct {
			// DnsIp DNS IP assigned to the IPXE boot.
			DnsIp *string `json:"dns_ip"`

			// GatewayIp Gateway IP assigned to the IPXE boot.
			GatewayIp *string `json:"gateway_ip"`

			// Netmask Netmask assigned to the IPXE boot.
			Netmask *string `json:"netmask"`

			// NetworkInterface Network interface for the IPXE boot.
			NetworkInterface *int `json:"network_interface"`

			// StaticIp Static IP assigned to the IPXE boot.
			StaticIp *string `json:"static_ip"`

			// VlanId VLAN ID for the IPXE boot.
			VlanId *int `json:"vlan_id"`
		} `json:"ipxe"`
		Server *struct {
			// AdditionalKernelArgs Appends additional kernel arguments when booting CycleOS.
			AdditionalKernelArgs *string `json:"additional_kernel_args"`

			// Bonds An array of bonds
			Bonds *[]VirtualProviderIsoBond `json:"bonds,omitempty"`

			// Nics An array of server network interfaces.
			Nics                  *[]VirtualProviderIsoNic                                           `json:"nics,omitempty"`
			SdnNeighborPreference *CreateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreference `json:"sdn_neighbor_preference"`
			Storage               *struct {
				ConditionalFormat *bool `json:"conditional_format,omitempty"`
			} `json:"storage"`
		} `json:"server"`

		// Token Authentication token for the ISO.
		Token string `json:"token"`
	} `json:"config"`

	// Name The name of the ISO.
	Name string `json:"name"`
}

// CreateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreference defines parameters for CreateVirtualProviderIso.
type CreateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreference string

// GetVirtualProviderIsoParams defines parameters for GetVirtualProviderIso.
type GetVirtualProviderIsoParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetVirtualProviderIsoParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetVirtualProviderIsoParamsInclude defines parameters for GetVirtualProviderIso.
type GetVirtualProviderIsoParamsInclude string

// UpdateVirtualProviderIsoJSONBody defines parameters for UpdateVirtualProviderIso.
type UpdateVirtualProviderIsoJSONBody struct {
	Config *struct {
		// Ipxe ISO IPXE configuration. Only available when ISO is in new state.
		Ipxe *struct {
			// DnsIp DNS IP assigned to the IPXE boot.
			DnsIp *string `json:"dns_ip"`

			// GatewayIp Gateway IP assigned to the IPXE boot.
			GatewayIp *string `json:"gateway_ip"`

			// Netmask Netmask assigned to the IPXE boot.
			Netmask *string `json:"netmask"`

			// NetworkInterface Network interface for the IPXE boot.
			NetworkInterface *int `json:"network_interface"`

			// StaticIp Static IP assigned to the IPXE boot.
			StaticIp *string `json:"static_ip"`

			// VlanId VLAN ID for the IPXE boot.
			VlanId *int `json:"vlan_id"`
		} `json:"ipxe"`
		Server *struct {
			// AdditionalKernelArgs Appends additional kernel arguments when booting CycleOS.
			AdditionalKernelArgs *string `json:"additional_kernel_args"`

			// Bonds An array of bonds
			Bonds *[]VirtualProviderIsoBond `json:"bonds,omitempty"`

			// Nics An array of server network interfaces.
			Nics                  []VirtualProviderIsoNic                                            `json:"nics"`
			SdnNeighborPreference *UpdateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreference `json:"sdn_neighbor_preference"`
			Storage               *struct {
				ConditionalFormat *bool `json:"conditional_format,omitempty"`
			} `json:"storage"`
		} `json:"server"`

		// Token Authentication token for the ISO. Only available when ISO is in new state.
		Token *string `json:"token,omitempty"`
	} `json:"config,omitempty"`

	// Name The name of the ISO.
	Name *string `json:"name,omitempty"`
}

// UpdateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreference defines parameters for UpdateVirtualProviderIso.
type UpdateVirtualProviderIsoJSONBodyConfigServerSdnNeighborPreference string

// GetJobsParams defines parameters for GetJobs.
type GetJobsParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetJobsParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		RangeEnd   *DateTime `json:"range-end,omitempty"`
		RangeStart *DateTime `json:"range-start,omitempty"`

		// Search `filter[search]=value` search jobs for a value associated with a field on the given job(s).
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the job's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetJobsParamsInclude defines parameters for GetJobs.
type GetJobsParamsInclude string

// GetEventsParams_Filter defines parameters for GetEvents.
type GetEventsParams_Filter struct {
	// Cluster Specify the cluster associated with the events.
	Cluster *string `json:"cluster,omitempty"`

	// Container A 24 character hex string used to identify a unique resource.
	Container *ID `json:"container,omitempty"`

	// Environment A 24 character hex string used to identify a unique resource.
	Environment *ID        `json:"environment,omitempty"`
	Event       *EventType `json:"event,omitempty"`

	// Pipeline A 24 character hex string used to identify a unique resource.
	Pipeline   *ID       `json:"pipeline,omitempty"`
	RangeEnd   *DateTime `json:"range-end,omitempty"`
	RangeStart *DateTime `json:"range-start,omitempty"`

	// Stack A 24 character hex string used to identify a unique resource.
	Stack *ID `json:"stack,omitempty"`

	// Tags Filter by tags associated with the events.
	Tags *string `json:"tags,omitempty"`

	// Type Filter by the type of event.
	Type                 *GetEventsParamsFilterType `json:"type,omitempty"`
	AdditionalProperties map[string]interface{}     `json:"-"`
}

// GetEventsParams defines parameters for GetEvents.
type GetEventsParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	//
	// To search via labels, use `label:<label key>` as the filter. For example in URL parameters, `filter[label:test]=abc`.
	Filter *GetEventsParams_Filter `json:"filter,omitempty"`
}

// GetEventsParamsFilterType defines parameters for GetEvents.
type GetEventsParamsFilterType string

// GenerateAggregatedEventsJSONBody defines parameters for GenerateAggregatedEvents.
type GenerateAggregatedEventsJSONBody struct {
	// Criteria The criteria to add to the first match. Cycle will automatically provide the hub ID.
	Criteria *map[string]interface{} `json:"criteria,omitempty"`

	// Pipeline The aggregation pipeline. Supports Mongo-style syntax and operators.
	Pipeline *[]map[string]interface{} `json:"pipeline,omitempty"`
}

// GenerateAggregatedEventsParams defines parameters for GenerateAggregatedEvents.
type GenerateAggregatedEventsParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		RangeEnd   *DateTime `json:"range-end,omitempty"`
		RangeStart *DateTime `json:"range-start,omitempty"`
	} `json:"filter,omitempty"`
}

// AggregateLogsJSONBody defines parameters for AggregateLogs.
type AggregateLogsJSONBody struct {
	// ContextWindowSize Context window size indicates how many log lines after a match to return in the response.
	// This allows greater context around the matched lines.
	ContextWindowSize *int `json:"context_window_size"`

	// Limit Describes the maximum number of log lines the query will return.
	Limit *int `json:"limit"`

	// Local Indicates that only locally cached log lines should be queried.  If true, logs in object storage will not be returned.
	Local *bool `json:"local"`
	Scope struct {
		// DateRange The date range used to narrow log aggregation.
		DateRange *struct {
			End   *DateTime `json:"end,omitempty"`
			Start *DateTime `json:"start,omitempty"`
		} `json:"date_range,omitempty"`

		// Ids The ID or IDs used to narrow log aggregation.
		Ids *[]ID `json:"ids"`

		// Type The type of resource used to narrow log aggregation.
		Type AggregateLogsJSONBodyScopeType `json:"type"`
	} `json:"scope"`
	Search *[]struct {
		// Match The search input is a string input that is used to in the aggregate to narrow the log line results.
		Match string `json:"match"`

		// Type The input type used to query logs. When set to regexp, a regex expression will be used to find a log line with a message matching the expression.  When set to 'raw', the aggregate will look for an exact string match.
		Type AggregateLogsJSONBodySearchType `json:"type"`
	} `json:"search,omitempty"`
}

// AggregateLogsJSONBodyScopeType defines parameters for AggregateLogs.
type AggregateLogsJSONBodyScopeType string

// AggregateLogsJSONBodySearchType defines parameters for AggregateLogs.
type AggregateLogsJSONBodySearchType string

// GetMetricsParams_Filter defines parameters for GetMetrics.
type GetMetricsParams_Filter struct {
	// Cluster Specify the cluster associated with the metrics.
	Cluster *string `json:"cluster,omitempty"`

	// Container Specify the container associated with the metrics.
	Container *string `json:"container,omitempty"`

	// Environment A 24 character hex string used to identify a unique resource.
	Environment *ID `json:"environment,omitempty"`

	// Metric Specify the metric to filter by.
	Metric *string `json:"metric,omitempty"`

	// Pipeline A 24 character hex string used to identify a unique resource.
	Pipeline   *ID       `json:"pipeline,omitempty"`
	RangeEnd   *DateTime `json:"range-end,omitempty"`
	RangeStart *DateTime `json:"range-start,omitempty"`

	// Stack A 24 character hex string used to identify a unique resource.
	Stack *ID `json:"stack,omitempty"`

	// Tags Filter by tags associated with the metrics
	Tags *string `json:"tags,omitempty"`

	// Type Filter by the type of metric.
	Type                 *GetMetricsParamsFilterType `json:"type,omitempty"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// GetMetricsParams defines parameters for GetMetrics.
type GetMetricsParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	//
	// To search via labels, use `label:<label key>` as the filter. For example in URL parameters, `filter[label:test]=abc`.
	Filter *GetMetricsParams_Filter `json:"filter,omitempty"`
}

// GetMetricsParamsFilterType defines parameters for GetMetrics.
type GetMetricsParamsFilterType string

// GenerateAggregatedMetricsJSONBody defines parameters for GenerateAggregatedMetrics.
type GenerateAggregatedMetricsJSONBody struct {
	// Criteria The criteria to add to the first match. Cycle will automatically provide the hub ID.
	Criteria *map[string]interface{} `json:"criteria,omitempty"`

	// Pipeline The aggregation pipeline. Supports Mongo-style syntax and operators.
	Pipeline *[]map[string]interface{} `json:"pipeline,omitempty"`
}

// GenerateAggregatedMetricsParams defines parameters for GenerateAggregatedMetrics.
type GenerateAggregatedMetricsParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		RangeEnd   *DateTime `json:"range-end,omitempty"`
		RangeStart *DateTime `json:"range-start,omitempty"`
	} `json:"filter,omitempty"`
}

// GetPipelinesParams defines parameters for GetPipelines.
type GetPipelinesParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetPipelinesParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Identifier `filter[identifier]=value` List only those pipelines matching this identifier. May return multiple results.
		Identifier *string `json:"identifier,omitempty"`

		// Search `filter[search]=value` search for a value associated with a field on the given pipelines(s).
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the Pipeline's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetPipelinesParamsInclude defines parameters for GetPipelines.
type GetPipelinesParamsInclude string

// CreatePipelineJSONBody defines parameters for CreatePipeline.
type CreatePipelineJSONBody struct {
	Acl *ACL `json:"acl"`

	// Disable A boolean where true signifies the Pipeline is disabled.
	Disable *bool `json:"disable,omitempty"`

	// Dynamic Setting to true enables variable and other advanced logic support on this Pipeline. This is a one-way toggle. Once set to true, it cannot be set back to false.
	Dynamic *bool `json:"dynamic,omitempty"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Name A name for the Pipeline.
	Name string `json:"name"`

	// Stages An array of stages.
	Stages *[]PipelineStage `json:"stages,omitempty"`
}

// ClonePipelineJSONBody defines parameters for ClonePipeline.
type ClonePipelineJSONBody struct {
	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`

	// Name The name of the cloned pipeline.
	Name string `json:"name"`

	// PipelineId A 24 character hex string used to identify a unique resource.
	PipelineId ID `json:"pipeline_id"`
}

// GetPipelineParams defines parameters for GetPipeline.
type GetPipelineParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetPipelineParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetPipelineParamsInclude defines parameters for GetPipeline.
type GetPipelineParamsInclude string

// UpdatePipelineJSONBody defines parameters for UpdatePipeline.
type UpdatePipelineJSONBody struct {
	// Disable A boolean where true signifies the Pipeline is disabled.
	Disable *bool `json:"disable,omitempty"`

	// Dynamic Setting to true enables variable and other advanced logic support on this Pipeline. This is a one-way toggle. Once set to true, it cannot be set back to false.
	Dynamic *bool `json:"dynamic,omitempty"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Name A name for the Pipeline.
	Name *string `json:"name,omitempty"`

	// Stages An array of stages.
	Stages *[]PipelineStage `json:"stages,omitempty"`
}

// UpdatePipelineAccessJSONBody defines parameters for UpdatePipelineAccess.
type UpdatePipelineAccessJSONBody struct {
	Acl *ACL `json:"acl"`
}

// GetPipelineTriggerKeysParams defines parameters for GetPipelineTriggerKeys.
type GetPipelineTriggerKeysParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Search `filter[search]=value` search for a value associated with a field on the given Trigger Key(s).
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the Trigger Key's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// CreatePipelineTriggerKeyJSONBody defines parameters for CreatePipelineTriggerKey.
type CreatePipelineTriggerKeyJSONBody struct {
	// Ips An array of ips this Trigger Key is usable from.
	Ips *[]string `json:"ips,omitempty"`

	// Name A name for the Trigger Key.
	Name string `json:"name"`
}

// UpdatePipelineTriggerKeyJSONBody defines parameters for UpdatePipelineTriggerKey.
type UpdatePipelineTriggerKeyJSONBody struct {
	// Ips List of IP Restrictions
	Ips *[]string `json:"ips,omitempty"`

	// Name Set name of Trigger Key
	Name *string `json:"name,omitempty"`
}

// GetPipelineRunsParams defines parameters for GetPipelineRuns.
type GetPipelineRunsParams struct {
	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetPipelineRunsParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetPipelineRunsParamsInclude defines parameters for GetPipelineRuns.
type GetPipelineRunsParamsInclude string

// GetPipelineRunParams defines parameters for GetPipelineRun.
type GetPipelineRunParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetPipelineRunParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetPipelineRunParamsInclude defines parameters for GetPipelineRun.
type GetPipelineRunParamsInclude string

// TriggerPipelineJSONBody defines parameters for TriggerPipeline.
type TriggerPipelineJSONBody struct {
	Advanced *struct {
		// SkipLocks To enable skip locks, pass the current UNIX timestamp. Must be accurate within 10 minutes of the current UTC time.
		// This will skip lock checks when running a pipeline - the user takes all risk of ensuring two pipeline runs won't make conflicting changes.
		SkipLocks *int `json:"skip_locks"`

		// SubQueue Sub queue allows multiple concurrent pipeline runs.
		SubQueue *string `json:"sub_queue"`
	} `json:"advanced,omitempty"`

	// Secret The trigger key secret.
	Secret string `json:"secret"`

	// Variables A map of variables to pass into the pipeline when it runs.
	Variables map[string]string `json:"variables"`
}

// GetNetworksParams defines parameters for GetNetworks.
type GetNetworksParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetNetworksParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Environment `filter[environment]=ID` Filter networks based on linked environment. Submit the ID of the environment you wish to filter for.
		Environment *string `json:"environment,omitempty"`

		// Search `filter[search]=value` search for a value associated with a field on the given Network(s).
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the network's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetNetworksParamsInclude defines parameters for GetNetworks.
type GetNetworksParamsInclude string

// CreateNetworkJSONBody defines parameters for CreateNetwork.
type CreateNetworkJSONBody struct {
	Acl *ACL `json:"acl"`

	// Cluster The infrastructure cluster the environments belonging to this network belong to.
	Cluster string `json:"cluster"`

	// Environments An array of environment Ids
	Environments []string `json:"environments"`

	// Identifier A network identifier used to construct http calls that specifically use this network over another.
	Identifier string     `json:"identifier"`
	L2         *NetworkL2 `json:"l2"`

	// Name The name of the network.
	Name string `json:"name"`
}

// CreateNetworkParams defines parameters for CreateNetwork.
type CreateNetworkParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]CreateNetworkParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// CreateNetworkParamsInclude defines parameters for CreateNetwork.
type CreateNetworkParamsInclude string

// GetNetworkParams defines parameters for GetNetwork.
type GetNetworkParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetNetworkParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetNetworkParamsInclude defines parameters for GetNetwork.
type GetNetworkParamsInclude string

// UpdateNetworkJSONBody defines parameters for UpdateNetwork.
type UpdateNetworkJSONBody struct {
	// Name The name of the network.
	Name *string `json:"name,omitempty"`
}

// UpdateNetworkParams defines parameters for UpdateNetwork.
type UpdateNetworkParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]UpdateNetworkParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// UpdateNetworkParamsInclude defines parameters for UpdateNetwork.
type UpdateNetworkParamsInclude string

// UpdateNetworkAccessJSONBody defines parameters for UpdateNetworkAccess.
type UpdateNetworkAccessJSONBody struct {
	Acl *ACL `json:"acl"`
}

// UpdateNetworkAccessParams defines parameters for UpdateNetworkAccess.
type UpdateNetworkAccessParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]UpdateNetworkAccessParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// UpdateNetworkAccessParamsInclude defines parameters for UpdateNetworkAccess.
type UpdateNetworkAccessParamsInclude string

// GetStacksParams defines parameters for GetStacks.
type GetStacksParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetStacksParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetStacksParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Identifier `filter[identifier]=value` List only those stacks matching this identifier. May return multiple results.
		Identifier *string `json:"identifier,omitempty"`

		// Search `filter[search]=value` search for a value associated with a field on the given Stack(s).
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the Stack's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetStacksParamsMeta defines parameters for GetStacks.
type GetStacksParamsMeta string

// GetStacksParamsInclude defines parameters for GetStacks.
type GetStacksParamsInclude string

// CreateStackJSONBody defines parameters for CreateStack.
type CreateStackJSONBody struct {
	Acl *ACL `json:"acl"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Name A name for the Stack.
	Name string `json:"name"`

	// Source A source for a stack to be created from.
	Source StackSource `json:"source"`

	// Variables A map of default variable values used when building this Stack. A variable can be added anywhere in a Stack using the format `{{var}}` where `var` would be a key in this map.
	Variables *map[string]string `json:"variables,omitempty"`
}

// UpdateStackJSONBody defines parameters for UpdateStack.
type UpdateStackJSONBody struct {
	// Name A name for the Stack.
	Name *string `json:"name,omitempty"`

	// Source A source for a stack to be created from.
	Source *StackSource `json:"source,omitempty"`

	// Variables A map of default variable values used when building this Stack. A variable can be added anywhere in a Stack using the format `{{var}}` where `var` would be a key in this map.
	Variables *map[string]string `json:"variables,omitempty"`
}

// UpdateStackAccessJSONBody defines parameters for UpdateStackAccess.
type UpdateStackAccessJSONBody struct {
	Acl *ACL `json:"acl"`
}

// GetStackBuildsParams defines parameters for GetStackBuilds.
type GetStackBuildsParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetStackBuildsParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Search `filter[search]=value` search for a value associated with a field on the given Stack Build(s).
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the Stack Build's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetStackBuildsParamsMeta defines parameters for GetStackBuilds.
type GetStackBuildsParamsMeta string

// CreateStackBuildJSONBody defines parameters for CreateStackBuild.
type CreateStackBuildJSONBody struct {
	// About Information about the stack build.
	About *StackBuildAbout `json:"about,omitempty"`

	// Instructions Additional instructions used when generating this stack build.
	Instructions *StackBuildInstructions `json:"instructions,omitempty"`
}

// CreateStackJobJSONBody defines parameters for CreateStackJob.
type CreateStackJobJSONBody struct {
	// Action The Job to do.
	Action CreateStackJobJSONBodyAction `json:"action"`
}

// CreateStackJobJSONBodyAction defines parameters for CreateStackJob.
type CreateStackJobJSONBodyAction string

// LookupComponentsJSONBody defines parameters for LookupComponents.
type LookupComponentsJSONBody struct {
	Components []struct {
		Id   string       `json:"id"`
		Type ResourceType `json:"type"`
	} `json:"components"`
}

// LookupIdentifierParams defines parameters for LookupIdentifier.
type LookupIdentifierParams struct {
	// Identifier A base64 encoded resource identifier string.
	Identifier string `form:"identifier" json:"identifier"`

	// DesiredComponent The type of resource to lookup from the identifier string.
	DesiredComponent LookupIdentifierParamsDesiredComponent `form:"desired-component" json:"desired-component"`
}

// LookupIdentifierParamsDesiredComponent defines parameters for LookupIdentifier.
type LookupIdentifierParamsDesiredComponent string

// GetVirtualMachinesParams defines parameters for GetVirtualMachines.
type GetVirtualMachinesParams struct {
	// Meta A comma-separated list of meta values. Meta values will show up under a resource's `meta` field.
	// In the case of applying a meta to a collection of resources, each resource will have its own relevant meta data.
	// In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetVirtualMachinesParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma-separated list of include values. Included resources will show up under the root document's `include` field.
	// In the case of applying an include to a collection of resources, if multiple resources share the same include, it will only appear once in the return.
	Include *[]GetVirtualMachinesParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Creator `filter[creator]=account-ID` Filter for virtual machines matching a particular creator, such as `account-<ID>` or `environment-<ID>`.
		Creator *string `json:"creator,omitempty"`

		// Environment `filter[environment]=ID` Filter virtual machines by environment ID. Submit the ID of the environment you wish to filter for.
		Environment *string `json:"environment,omitempty"`

		// Identifier `filter[identifier]=value` List only those virtual machines matching this identifier. May return multiple results.
		Identifier *string `json:"identifier,omitempty"`

		// PublicNetwork `filter[public_network]=value` Filter virtual machines by their public network status.
		PublicNetwork *GetVirtualMachinesParamsFilterPublicNetwork `json:"public_network,omitempty"`
		RangeEnd      *DateTime                                    `json:"range-end,omitempty"`
		RangeStart    *DateTime                                    `json:"range-start,omitempty"`

		// Search `filter[search]=value` Search virtual machines for a value associated with a field.
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value` Filter virtual machines by their current state.
		State *GetVirtualMachinesParamsFilterState `json:"state,omitempty"`

		// Tags `filter[tags]=value` Filter virtual machines by their tags.
		Tags *string `json:"tags,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetVirtualMachinesParamsMeta defines parameters for GetVirtualMachines.
type GetVirtualMachinesParamsMeta string

// GetVirtualMachinesParamsInclude defines parameters for GetVirtualMachines.
type GetVirtualMachinesParamsInclude string

// GetVirtualMachinesParamsFilterPublicNetwork defines parameters for GetVirtualMachines.
type GetVirtualMachinesParamsFilterPublicNetwork string

// GetVirtualMachinesParamsFilterState defines parameters for GetVirtualMachines.
type GetVirtualMachinesParamsFilterState string

// CreateVirtualMachineJSONBody defines parameters for CreateVirtualMachine.
type CreateVirtualMachineJSONBody struct {
	// Annotations Custom meta data. Not utilized by Cycle.
	Annotations *map[string]interface{} `json:"annotations"`

	// Config Defines the network and deployment configurations for a virtual machine.
	Config VirtualMachineConfig `json:"config"`

	// EnvironmentId The ID of the environment this virtual machine will be deployed to.
	EnvironmentId string `json:"environment_id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Image Represents the image used by a virtual machine. It can either reference a URL where the image is located or specify a base image provided by Cycle.
	Image VirtualMachineImage `json:"image"`

	// Lock Prevents this virtual machine from being deleted when true.
	Lock bool `json:"lock"`

	// Name A user-defined name for the virtual machine.
	Name string `json:"name"`

	// SshKeys An array of SSH key IDs that should be applied to this virtual machine.
	SshKeys *[]ID                         `json:"ssh_keys,omitempty"`
	Volumes *[]VirtualMachineVolumeConfig `json:"volumes,omitempty"`
}

// CreateVirtualMachineParams defines parameters for CreateVirtualMachine.
type CreateVirtualMachineParams struct {
	// Meta A comma-separated list of meta values. Meta values will show up under a resource's `meta` field.
	// In the case of applying a meta to a collection of resources, each resource will have its own relevant meta data.
	// In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]CreateVirtualMachineParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma-separated list of include values. Included resources will show up under the root document's `include` field.
	// In the case of applying an include to a collection of resources, if multiple resources share the same include, it will only appear once in the return.
	Include *[]CreateVirtualMachineParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// CreateVirtualMachineParamsMeta defines parameters for CreateVirtualMachine.
type CreateVirtualMachineParamsMeta string

// CreateVirtualMachineParamsInclude defines parameters for CreateVirtualMachine.
type CreateVirtualMachineParamsInclude string

// GetVirtualMachineSshKeysParams defines parameters for GetVirtualMachineSshKeys.
type GetVirtualMachineSshKeysParams struct {
	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Creator `filter[creator]=account-ID` Filter for SSH keys matching a particular creator, such as `account-<ID>` or `environment-<ID>`.
		Creator *string `json:"creator,omitempty"`

		// Environment `filter[environment]=ID` Filter SSH keys by environment ID. Submit the ID of the environment you wish to filter for.
		Environment *string `json:"environment,omitempty"`

		// Identifier `filter[identifier]=value` List only those SSH keys matching this identifier. May return multiple results.
		Identifier *string   `json:"identifier,omitempty"`
		RangeEnd   *DateTime `json:"range-end,omitempty"`
		RangeStart *DateTime `json:"range-start,omitempty"`

		// Search `filter[search]=value` Search SSH keys for a value associated with a field.
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value` Filter virtual machines by their current state.
		State *GetVirtualMachineSshKeysParamsFilterState `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Include A comma-separated list of include values. Included resources will show up under the root document's `include` field.
	// In the case of applying an include to a collection of resources, if multiple resources share the same include, it will only appear once in the return.
	Include *[]GetVirtualMachineSshKeysParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetVirtualMachineSshKeysParamsFilterState defines parameters for GetVirtualMachineSshKeys.
type GetVirtualMachineSshKeysParamsFilterState string

// GetVirtualMachineSshKeysParamsInclude defines parameters for GetVirtualMachineSshKeys.
type GetVirtualMachineSshKeysParamsInclude string

// CreateVirtualMachineSshKeyJSONBody defines parameters for CreateVirtualMachineSshKey.
type CreateVirtualMachineSshKeyJSONBody struct {
	// EnvironmentId A 24 character hex string used to identify a unique resource.
	EnvironmentId ID `json:"environment_id"`

	// Name A user-defined name for the SSH key.
	Name string `json:"name"`

	// PublicKey The public key of the SSH key.
	PublicKey string `json:"public_key"`
}

// CreateVirtualMachineSshKeyParams defines parameters for CreateVirtualMachineSshKey.
type CreateVirtualMachineSshKeyParams struct {
	// Include A comma-separated list of include values. Included resources will show up under the root document's `include` field.
	// In the case of applying an include to a collection of resources, if multiple resources share the same include, it will only appear once in the return.
	Include *[]CreateVirtualMachineSshKeyParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// CreateVirtualMachineSshKeyParamsInclude defines parameters for CreateVirtualMachineSshKey.
type CreateVirtualMachineSshKeyParamsInclude string

// GetVirtualMachineSshKeyParams defines parameters for GetVirtualMachineSshKey.
type GetVirtualMachineSshKeyParams struct {
	// Include A comma-separated list of include values. Included resources will show up under the root document's `include` field.
	// In the case of applying an include to a collection of resources, if multiple resources share the same include, it will only appear once in the return.
	Include *[]GetVirtualMachineSshKeyParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetVirtualMachineSshKeyParamsInclude defines parameters for GetVirtualMachineSshKey.
type GetVirtualMachineSshKeyParamsInclude string

// UpdateVirtualMachineSshKeyJSONBody defines parameters for UpdateVirtualMachineSshKey.
type UpdateVirtualMachineSshKeyJSONBody struct {
	// Name The name of the virtual machine SSH key.
	Name *string `json:"name,omitempty"`
}

// UpdateVirtualMachineSshKeyParams defines parameters for UpdateVirtualMachineSshKey.
type UpdateVirtualMachineSshKeyParams struct {
	// Include A comma-separated list of include values. Included resources will show up under the root document's `include` field.
	// In the case of applying an include to a collection of resources, if multiple resources share the same include, it will only appear once in the return.
	Include *[]UpdateVirtualMachineSshKeyParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// UpdateVirtualMachineSshKeyParamsInclude defines parameters for UpdateVirtualMachineSshKey.
type UpdateVirtualMachineSshKeyParamsInclude string

// GetVirtualMachineParams defines parameters for GetVirtualMachine.
type GetVirtualMachineParams struct {
	// Meta A comma-separated list of meta values. Meta values will show up under a resource's `meta` field.
	// In the case of applying a meta to a collection of resources, each resource will have its own relevant meta data.
	// In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetVirtualMachineParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma-separated list of include values. Included resources will show up under the root document's `include` field.
	// In the case of applying an include to a collection of resources, if multiple resources share the same include, it will only appear once in the return.
	Include *[]GetVirtualMachineParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetVirtualMachineParamsMeta defines parameters for GetVirtualMachine.
type GetVirtualMachineParamsMeta string

// GetVirtualMachineParamsInclude defines parameters for GetVirtualMachine.
type GetVirtualMachineParamsInclude string

// UpdateVirtualMachineJSONBody defines parameters for UpdateVirtualMachine.
type UpdateVirtualMachineJSONBody struct {
	// Annotations Metadata annotations for the virtual machine.
	Annotations *map[string]string `json:"annotations,omitempty"`

	// Deprecate A boolean flag indicating if this virtual machine is deprecated.
	Deprecate *bool `json:"deprecate,omitempty"`

	// Identifier The identifier of the virtual machine.
	Identifier *string `json:"identifier,omitempty"`

	// Lock Prevents this virtual machine from being deleted when true.
	Lock *bool `json:"lock,omitempty"`

	// Name The name of the virtual machine.
	Name *string `json:"name,omitempty"`

	// SshKeys An array of SSH key IDs that should be applied to this virtual machine.
	SshKeys *[]ID `json:"ssh_keys,omitempty"`
}

// UpdateAccountJSONRequestBody defines body for UpdateAccount for application/json ContentType.
type UpdateAccountJSONRequestBody UpdateAccountJSONBody

// DisableTwoFactorAuthJSONRequestBody defines body for DisableTwoFactorAuth for application/json ContentType.
type DisableTwoFactorAuthJSONRequestBody DisableTwoFactorAuthJSONBody

// RecoverTwoFactorAuthJSONRequestBody defines body for RecoverTwoFactorAuth for application/json ContentType.
type RecoverTwoFactorAuthJSONRequestBody RecoverTwoFactorAuthJSONBody

// EnableTwoFactorAuthJSONRequestBody defines body for EnableTwoFactorAuth for application/json ContentType.
type EnableTwoFactorAuthJSONRequestBody EnableTwoFactorAuthJSONBody

// UpdateAccountInviteJSONRequestBody defines body for UpdateAccountInvite for application/json ContentType.
type UpdateAccountInviteJSONRequestBody UpdateAccountInviteJSONBody

// ChangePasswordJSONRequestBody defines body for ChangePassword for application/json ContentType.
type ChangePasswordJSONRequestBody ChangePasswordJSONBody

// ResetPasswordJSONRequestBody defines body for ResetPassword for application/json ContentType.
type ResetPasswordJSONRequestBody = ResetPasswordJSONBody

// CreateInvoiceJobJSONRequestBody defines body for CreateInvoiceJob for application/json ContentType.
type CreateInvoiceJobJSONRequestBody CreateInvoiceJobJSONBody

// CreateBillingMethodJSONRequestBody defines body for CreateBillingMethod for application/json ContentType.
type CreateBillingMethodJSONRequestBody CreateBillingMethodJSONBody

// UpdateBillingMethodJSONRequestBody defines body for UpdateBillingMethod for application/json ContentType.
type UpdateBillingMethodJSONRequestBody UpdateBillingMethodJSONBody

// CreateBillingMethodJobJSONRequestBody defines body for CreateBillingMethodJob for application/json ContentType.
type CreateBillingMethodJobJSONRequestBody CreateBillingMethodJobJSONBody

// CreateOrderJSONRequestBody defines body for CreateOrder for application/json ContentType.
type CreateOrderJSONRequestBody CreateOrderJSONBody

// UpdateBillingOrderJSONRequestBody defines body for UpdateBillingOrder for application/json ContentType.
type UpdateBillingOrderJSONRequestBody UpdateBillingOrderJSONBody

// CreateOrderJobJSONRequestBody defines body for CreateOrderJob for application/json ContentType.
type CreateOrderJobJSONRequestBody CreateOrderJobJSONBody

// CreateContainerJSONRequestBody defines body for CreateContainer for application/json ContentType.
type CreateContainerJSONRequestBody CreateContainerJSONBody

// UpdateContainerJSONRequestBody defines body for UpdateContainer for application/json ContentType.
type UpdateContainerJSONRequestBody UpdateContainerJSONBody

// CreateContainerBackupJobJSONRequestBody defines body for CreateContainerBackupJob for application/json ContentType.
type CreateContainerBackupJobJSONRequestBody CreateContainerBackupJobJSONBody

// CreateFunctionJobJSONRequestBody defines body for CreateFunctionJob for application/json ContentType.
type CreateFunctionJobJSONRequestBody = FunctionTask

// CreateInstancesJSONRequestBody defines body for CreateInstances for application/json ContentType.
type CreateInstancesJSONRequestBody = CreateInstancesJSONBody

// CreateInstanceJobJSONRequestBody defines body for CreateInstanceJob for application/json ContentType.
type CreateInstanceJobJSONRequestBody = InstanceTask

// CreateContainerJobJSONRequestBody defines body for CreateContainerJob for application/json ContentType.
type CreateContainerJobJSONRequestBody = ContainerTask

// UploadUserSuppliedCertificateJSONRequestBody defines body for UploadUserSuppliedCertificate for application/json ContentType.
type UploadUserSuppliedCertificateJSONRequestBody UploadUserSuppliedCertificateJSONBody

// CreateUserSuppliedCertificateJobJSONRequestBody defines body for CreateUserSuppliedCertificateJob for application/json ContentType.
type CreateUserSuppliedCertificateJobJSONRequestBody CreateUserSuppliedCertificateJobJSONBody

// CreateDNSZoneJSONRequestBody defines body for CreateDNSZone for application/json ContentType.
type CreateDNSZoneJSONRequestBody CreateDNSZoneJSONBody

// UpdateDNSZoneJSONRequestBody defines body for UpdateDNSZone for application/json ContentType.
type UpdateDNSZoneJSONRequestBody UpdateDNSZoneJSONBody

// UpdateDNSZoneAccessJSONRequestBody defines body for UpdateDNSZoneAccess for application/json ContentType.
type UpdateDNSZoneAccessJSONRequestBody UpdateDNSZoneAccessJSONBody

// CreateDNSZoneRecordJSONRequestBody defines body for CreateDNSZoneRecord for application/json ContentType.
type CreateDNSZoneRecordJSONRequestBody CreateDNSZoneRecordJSONBody

// UpdateDNSZoneRecordJSONRequestBody defines body for UpdateDNSZoneRecord for application/json ContentType.
type UpdateDNSZoneRecordJSONRequestBody UpdateDNSZoneRecordJSONBody

// CreateDNSZoneRecordJobJSONRequestBody defines body for CreateDNSZoneRecordJob for application/json ContentType.
type CreateDNSZoneRecordJobJSONRequestBody CreateDNSZoneRecordJobJSONBody

// CreateDNSZoneJobJSONRequestBody defines body for CreateDNSZoneJob for application/json ContentType.
type CreateDNSZoneJobJSONRequestBody CreateDNSZoneJobJSONBody

// CreateEnvironmentJSONRequestBody defines body for CreateEnvironment for application/json ContentType.
type CreateEnvironmentJSONRequestBody CreateEnvironmentJSONBody

// UpdateEnvironmentJSONRequestBody defines body for UpdateEnvironment for application/json ContentType.
type UpdateEnvironmentJSONRequestBody UpdateEnvironmentJSONBody

// UpdateEnvironmentAccessJSONRequestBody defines body for UpdateEnvironmentAccess for application/json ContentType.
type UpdateEnvironmentAccessJSONRequestBody UpdateEnvironmentAccessJSONBody

// ExportStackJSONRequestBody defines body for ExportStack for application/json ContentType.
type ExportStackJSONRequestBody ExportStackJSONBody

// CreateScopedVariableJSONRequestBody defines body for CreateScopedVariable for application/json ContentType.
type CreateScopedVariableJSONRequestBody CreateScopedVariableJSONBody

// UpdateScopedVariableJSONRequestBody defines body for UpdateScopedVariable for application/json ContentType.
type UpdateScopedVariableJSONRequestBody UpdateScopedVariableJSONBody

// CreateDiscoveryServiceJobJSONRequestBody defines body for CreateDiscoveryServiceJob for application/json ContentType.
type CreateDiscoveryServiceJobJSONRequestBody CreateDiscoveryServiceJobJSONBody

// CreateGatewayServiceJobJSONRequestBody defines body for CreateGatewayServiceJob for application/json ContentType.
type CreateGatewayServiceJobJSONRequestBody CreateGatewayServiceJobJSONBody

// CreateLoadBalancerServiceJobJSONRequestBody defines body for CreateLoadBalancerServiceJob for application/json ContentType.
type CreateLoadBalancerServiceJobJSONRequestBody CreateLoadBalancerServiceJobJSONBody

// CreateSchedulerServiceJobJSONRequestBody defines body for CreateSchedulerServiceJob for application/json ContentType.
type CreateSchedulerServiceJobJSONRequestBody CreateSchedulerServiceJobJSONBody

// CreateVPNServiceJobJSONRequestBody defines body for CreateVPNServiceJob for application/json ContentType.
type CreateVPNServiceJobJSONRequestBody = VpnTask

// CreateVPNUserJSONRequestBody defines body for CreateVPNUser for application/json ContentType.
type CreateVPNUserJSONRequestBody CreateVPNUserJSONBody

// CreateEnvironmentJobJSONRequestBody defines body for CreateEnvironmentJob for application/json ContentType.
type CreateEnvironmentJobJSONRequestBody = EnvironmentTask

// CreateHubJSONRequestBody defines body for CreateHub for application/json ContentType.
type CreateHubJSONRequestBody CreateHubJSONBody

// DeleteHubJSONRequestBody defines body for DeleteHub for application/json ContentType.
type DeleteHubJSONRequestBody DeleteHubJSONBody

// UpdateHubJSONRequestBody defines body for UpdateHub for application/json ContentType.
type UpdateHubJSONRequestBody UpdateHubJSONBody

// CreateApiKeyJSONRequestBody defines body for CreateApiKey for application/json ContentType.
type CreateApiKeyJSONRequestBody CreateApiKeyJSONBody

// UpdateAPIKeyJSONRequestBody defines body for UpdateAPIKey for application/json ContentType.
type UpdateAPIKeyJSONRequestBody UpdateAPIKeyJSONBody

// CreateIntegrationJSONRequestBody defines body for CreateIntegration for application/json ContentType.
type CreateIntegrationJSONRequestBody CreateIntegrationJSONBody

// UpdateIntegrationJSONRequestBody defines body for UpdateIntegration for application/json ContentType.
type UpdateIntegrationJSONRequestBody UpdateIntegrationJSONBody

// CreateIntegrationJobJSONRequestBody defines body for CreateIntegrationJob for application/json ContentType.
type CreateIntegrationJobJSONRequestBody CreateIntegrationJobJSONBody

// CreateHubInviteJSONRequestBody defines body for CreateHubInvite for application/json ContentType.
type CreateHubInviteJSONRequestBody CreateHubInviteJSONBody

// UpdateHubMemberJSONRequestBody defines body for UpdateHubMember for application/json ContentType.
type UpdateHubMemberJSONRequestBody UpdateHubMemberJSONBody

// CreateRoleJSONRequestBody defines body for CreateRole for application/json ContentType.
type CreateRoleJSONRequestBody CreateRoleJSONBody

// UpdateRoleJSONRequestBody defines body for UpdateRole for application/json ContentType.
type UpdateRoleJSONRequestBody UpdateRoleJSONBody

// CreateImageJSONRequestBody defines body for CreateImage for application/json ContentType.
type CreateImageJSONRequestBody CreateImageJSONBody

// CreateImageSourceJSONRequestBody defines body for CreateImageSource for application/json ContentType.
type CreateImageSourceJSONRequestBody CreateImageSourceJSONBody

// UpdateImageSourceJSONRequestBody defines body for UpdateImageSource for application/json ContentType.
type UpdateImageSourceJSONRequestBody UpdateImageSourceJSONBody

// UpdateImageSourceAccessJSONRequestBody defines body for UpdateImageSourceAccess for application/json ContentType.
type UpdateImageSourceAccessJSONRequestBody UpdateImageSourceAccessJSONBody

// CreateImagesJobJSONRequestBody defines body for CreateImagesJob for application/json ContentType.
type CreateImagesJobJSONRequestBody CreateImagesJobJSONBody

// UpdateImageJSONRequestBody defines body for UpdateImage for application/json ContentType.
type UpdateImageJSONRequestBody UpdateImageJSONBody

// CreateImageJobJSONRequestBody defines body for CreateImageJob for application/json ContentType.
type CreateImageJobJSONRequestBody CreateImageJobJSONBody

// CreateAutoScaleGroupJSONRequestBody defines body for CreateAutoScaleGroup for application/json ContentType.
type CreateAutoScaleGroupJSONRequestBody CreateAutoScaleGroupJSONBody

// UpdateAutoScaleGroupJSONRequestBody defines body for UpdateAutoScaleGroup for application/json ContentType.
type UpdateAutoScaleGroupJSONRequestBody UpdateAutoScaleGroupJSONBody

// UpdateAutoScaleGroupAccessJSONRequestBody defines body for UpdateAutoScaleGroupAccess for application/json ContentType.
type UpdateAutoScaleGroupAccessJSONRequestBody UpdateAutoScaleGroupAccessJSONBody

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody CreateClusterJSONBody

// UpdateClusterJSONRequestBody defines body for UpdateCluster for application/json ContentType.
type UpdateClusterJSONRequestBody = UpdateClusterJSONBody

// UpdateClusterAccessJSONRequestBody defines body for UpdateClusterAccess for application/json ContentType.
type UpdateClusterAccessJSONRequestBody UpdateClusterAccessJSONBody

// CreateClusterJobJSONRequestBody defines body for CreateClusterJob for application/json ContentType.
type CreateClusterJobJSONRequestBody = ClusterTask

// CreateExternalVolumeJSONRequestBody defines body for CreateExternalVolume for application/json ContentType.
type CreateExternalVolumeJSONRequestBody CreateExternalVolumeJSONBody

// DeleteExternalVolumeJSONRequestBody defines body for DeleteExternalVolume for application/json ContentType.
type DeleteExternalVolumeJSONRequestBody DeleteExternalVolumeJSONBody

// UpdateExternalVolumeJSONRequestBody defines body for UpdateExternalVolume for application/json ContentType.
type UpdateExternalVolumeJSONRequestBody UpdateExternalVolumeJSONBody

// UpdateExternalVolumeAccessJSONRequestBody defines body for UpdateExternalVolumeAccess for application/json ContentType.
type UpdateExternalVolumeAccessJSONRequestBody UpdateExternalVolumeAccessJSONBody

// CreateExternalVolumeJobJSONRequestBody defines body for CreateExternalVolumeJob for application/json ContentType.
type CreateExternalVolumeJobJSONRequestBody = ExternalVolumeTask

// CreateIpPoolJSONRequestBody defines body for CreateIpPool for application/json ContentType.
type CreateIpPoolJSONRequestBody CreateIpPoolJSONBody

// CreateIpPoolJobJSONRequestBody defines body for CreateIpPoolJob for application/json ContentType.
type CreateIpPoolJobJSONRequestBody = IpPoolTask

// CreateServerJSONRequestBody defines body for CreateServer for application/json ContentType.
type CreateServerJSONRequestBody CreateServerJSONBody

// DeleteServerJSONRequestBody defines body for DeleteServer for application/json ContentType.
type DeleteServerJSONRequestBody DeleteServerJSONBody

// UpdateServerJSONRequestBody defines body for UpdateServer for application/json ContentType.
type UpdateServerJSONRequestBody UpdateServerJSONBody

// CreateServerJobJSONRequestBody defines body for CreateServerJob for application/json ContentType.
type CreateServerJobJSONRequestBody = ServerTask

// CreateVirtualProviderIsoJSONRequestBody defines body for CreateVirtualProviderIso for application/json ContentType.
type CreateVirtualProviderIsoJSONRequestBody CreateVirtualProviderIsoJSONBody

// UpdateVirtualProviderIsoJSONRequestBody defines body for UpdateVirtualProviderIso for application/json ContentType.
type UpdateVirtualProviderIsoJSONRequestBody UpdateVirtualProviderIsoJSONBody

// CreateVirtualProviderIsoJobJSONRequestBody defines body for CreateVirtualProviderIsoJob for application/json ContentType.
type CreateVirtualProviderIsoJobJSONRequestBody = VirtualProviderIsoTask

// GenerateAggregatedEventsJSONRequestBody defines body for GenerateAggregatedEvents for application/json ContentType.
type GenerateAggregatedEventsJSONRequestBody GenerateAggregatedEventsJSONBody

// AggregateLogsJSONRequestBody defines body for AggregateLogs for application/json ContentType.
type AggregateLogsJSONRequestBody AggregateLogsJSONBody

// GenerateAggregatedMetricsJSONRequestBody defines body for GenerateAggregatedMetrics for application/json ContentType.
type GenerateAggregatedMetricsJSONRequestBody GenerateAggregatedMetricsJSONBody

// CreatePipelineJSONRequestBody defines body for CreatePipeline for application/json ContentType.
type CreatePipelineJSONRequestBody CreatePipelineJSONBody

// ClonePipelineJSONRequestBody defines body for ClonePipeline for application/json ContentType.
type ClonePipelineJSONRequestBody ClonePipelineJSONBody

// UpdatePipelineJSONRequestBody defines body for UpdatePipeline for application/json ContentType.
type UpdatePipelineJSONRequestBody UpdatePipelineJSONBody

// UpdatePipelineAccessJSONRequestBody defines body for UpdatePipelineAccess for application/json ContentType.
type UpdatePipelineAccessJSONRequestBody UpdatePipelineAccessJSONBody

// CreatePipelineTriggerKeyJSONRequestBody defines body for CreatePipelineTriggerKey for application/json ContentType.
type CreatePipelineTriggerKeyJSONRequestBody CreatePipelineTriggerKeyJSONBody

// UpdatePipelineTriggerKeyJSONRequestBody defines body for UpdatePipelineTriggerKey for application/json ContentType.
type UpdatePipelineTriggerKeyJSONRequestBody UpdatePipelineTriggerKeyJSONBody

// CreatePipelineJobJSONRequestBody defines body for CreatePipelineJob for application/json ContentType.
type CreatePipelineJobJSONRequestBody = PipelineTask

// TriggerPipelineJSONRequestBody defines body for TriggerPipeline for application/json ContentType.
type TriggerPipelineJSONRequestBody TriggerPipelineJSONBody

// CreateNetworkJSONRequestBody defines body for CreateNetwork for application/json ContentType.
type CreateNetworkJSONRequestBody CreateNetworkJSONBody

// UpdateNetworkJSONRequestBody defines body for UpdateNetwork for application/json ContentType.
type UpdateNetworkJSONRequestBody UpdateNetworkJSONBody

// UpdateNetworkAccessJSONRequestBody defines body for UpdateNetworkAccess for application/json ContentType.
type UpdateNetworkAccessJSONRequestBody UpdateNetworkAccessJSONBody

// CreateNetworkJobJSONRequestBody defines body for CreateNetworkJob for application/json ContentType.
type CreateNetworkJobJSONRequestBody = SdnNetworkTask

// CreateStackJSONRequestBody defines body for CreateStack for application/json ContentType.
type CreateStackJSONRequestBody CreateStackJSONBody

// UpdateStackJSONRequestBody defines body for UpdateStack for application/json ContentType.
type UpdateStackJSONRequestBody UpdateStackJSONBody

// UpdateStackAccessJSONRequestBody defines body for UpdateStackAccess for application/json ContentType.
type UpdateStackAccessJSONRequestBody UpdateStackAccessJSONBody

// CreateStackBuildJSONRequestBody defines body for CreateStackBuild for application/json ContentType.
type CreateStackBuildJSONRequestBody CreateStackBuildJSONBody

// CreateStackBuildJobJSONRequestBody defines body for CreateStackBuildJob for application/json ContentType.
type CreateStackBuildJobJSONRequestBody = StackBuildTask

// CreateStackJobJSONRequestBody defines body for CreateStackJob for application/json ContentType.
type CreateStackJobJSONRequestBody CreateStackJobJSONBody

// LookupComponentsJSONRequestBody defines body for LookupComponents for application/json ContentType.
type LookupComponentsJSONRequestBody LookupComponentsJSONBody

// CreateVirtualMachineJSONRequestBody defines body for CreateVirtualMachine for application/json ContentType.
type CreateVirtualMachineJSONRequestBody CreateVirtualMachineJSONBody

// CreateVirtualMachineSshKeyJSONRequestBody defines body for CreateVirtualMachineSshKey for application/json ContentType.
type CreateVirtualMachineSshKeyJSONRequestBody CreateVirtualMachineSshKeyJSONBody

// UpdateVirtualMachineSshKeyJSONRequestBody defines body for UpdateVirtualMachineSshKey for application/json ContentType.
type UpdateVirtualMachineSshKeyJSONRequestBody UpdateVirtualMachineSshKeyJSONBody

// UpdateVirtualMachineJSONRequestBody defines body for UpdateVirtualMachine for application/json ContentType.
type UpdateVirtualMachineJSONRequestBody UpdateVirtualMachineJSONBody

// CreateVirtualMachineJobJSONRequestBody defines body for CreateVirtualMachineJob for application/json ContentType.
type CreateVirtualMachineJobJSONRequestBody = VirtualMachineTask

// Getter for additional properties for GetEventsParams_Filter. Returns the specified
// element and whether it was found
func (a GetEventsParams_Filter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GetEventsParams_Filter
func (a *GetEventsParams_Filter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GetEventsParams_Filter to handle AdditionalProperties
func (a *GetEventsParams_Filter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cluster"]; found {
		err = json.Unmarshal(raw, &a.Cluster)
		if err != nil {
			return fmt.Errorf("error reading 'cluster': %w", err)
		}
		delete(object, "cluster")
	}

	if raw, found := object["container"]; found {
		err = json.Unmarshal(raw, &a.Container)
		if err != nil {
			return fmt.Errorf("error reading 'container': %w", err)
		}
		delete(object, "container")
	}

	if raw, found := object["environment"]; found {
		err = json.Unmarshal(raw, &a.Environment)
		if err != nil {
			return fmt.Errorf("error reading 'environment': %w", err)
		}
		delete(object, "environment")
	}

	if raw, found := object["event"]; found {
		err = json.Unmarshal(raw, &a.Event)
		if err != nil {
			return fmt.Errorf("error reading 'event': %w", err)
		}
		delete(object, "event")
	}

	if raw, found := object["pipeline"]; found {
		err = json.Unmarshal(raw, &a.Pipeline)
		if err != nil {
			return fmt.Errorf("error reading 'pipeline': %w", err)
		}
		delete(object, "pipeline")
	}

	if raw, found := object["range-end"]; found {
		err = json.Unmarshal(raw, &a.RangeEnd)
		if err != nil {
			return fmt.Errorf("error reading 'range-end': %w", err)
		}
		delete(object, "range-end")
	}

	if raw, found := object["range-start"]; found {
		err = json.Unmarshal(raw, &a.RangeStart)
		if err != nil {
			return fmt.Errorf("error reading 'range-start': %w", err)
		}
		delete(object, "range-start")
	}

	if raw, found := object["stack"]; found {
		err = json.Unmarshal(raw, &a.Stack)
		if err != nil {
			return fmt.Errorf("error reading 'stack': %w", err)
		}
		delete(object, "stack")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GetEventsParams_Filter to handle AdditionalProperties
func (a GetEventsParams_Filter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Cluster != nil {
		object["cluster"], err = json.Marshal(a.Cluster)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cluster': %w", err)
		}
	}

	if a.Container != nil {
		object["container"], err = json.Marshal(a.Container)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'container': %w", err)
		}
	}

	if a.Environment != nil {
		object["environment"], err = json.Marshal(a.Environment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'environment': %w", err)
		}
	}

	if a.Event != nil {
		object["event"], err = json.Marshal(a.Event)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'event': %w", err)
		}
	}

	if a.Pipeline != nil {
		object["pipeline"], err = json.Marshal(a.Pipeline)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pipeline': %w", err)
		}
	}

	if a.RangeEnd != nil {
		object["range-end"], err = json.Marshal(a.RangeEnd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'range-end': %w", err)
		}
	}

	if a.RangeStart != nil {
		object["range-start"], err = json.Marshal(a.RangeStart)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'range-start': %w", err)
		}
	}

	if a.Stack != nil {
		object["stack"], err = json.Marshal(a.Stack)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stack': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for GetMetricsParams_Filter. Returns the specified
// element and whether it was found
func (a GetMetricsParams_Filter) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GetMetricsParams_Filter
func (a *GetMetricsParams_Filter) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GetMetricsParams_Filter to handle AdditionalProperties
func (a *GetMetricsParams_Filter) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cluster"]; found {
		err = json.Unmarshal(raw, &a.Cluster)
		if err != nil {
			return fmt.Errorf("error reading 'cluster': %w", err)
		}
		delete(object, "cluster")
	}

	if raw, found := object["container"]; found {
		err = json.Unmarshal(raw, &a.Container)
		if err != nil {
			return fmt.Errorf("error reading 'container': %w", err)
		}
		delete(object, "container")
	}

	if raw, found := object["environment"]; found {
		err = json.Unmarshal(raw, &a.Environment)
		if err != nil {
			return fmt.Errorf("error reading 'environment': %w", err)
		}
		delete(object, "environment")
	}

	if raw, found := object["metric"]; found {
		err = json.Unmarshal(raw, &a.Metric)
		if err != nil {
			return fmt.Errorf("error reading 'metric': %w", err)
		}
		delete(object, "metric")
	}

	if raw, found := object["pipeline"]; found {
		err = json.Unmarshal(raw, &a.Pipeline)
		if err != nil {
			return fmt.Errorf("error reading 'pipeline': %w", err)
		}
		delete(object, "pipeline")
	}

	if raw, found := object["range-end"]; found {
		err = json.Unmarshal(raw, &a.RangeEnd)
		if err != nil {
			return fmt.Errorf("error reading 'range-end': %w", err)
		}
		delete(object, "range-end")
	}

	if raw, found := object["range-start"]; found {
		err = json.Unmarshal(raw, &a.RangeStart)
		if err != nil {
			return fmt.Errorf("error reading 'range-start': %w", err)
		}
		delete(object, "range-start")
	}

	if raw, found := object["stack"]; found {
		err = json.Unmarshal(raw, &a.Stack)
		if err != nil {
			return fmt.Errorf("error reading 'stack': %w", err)
		}
		delete(object, "stack")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GetMetricsParams_Filter to handle AdditionalProperties
func (a GetMetricsParams_Filter) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Cluster != nil {
		object["cluster"], err = json.Marshal(a.Cluster)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cluster': %w", err)
		}
	}

	if a.Container != nil {
		object["container"], err = json.Marshal(a.Container)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'container': %w", err)
		}
	}

	if a.Environment != nil {
		object["environment"], err = json.Marshal(a.Environment)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'environment': %w", err)
		}
	}

	if a.Metric != nil {
		object["metric"], err = json.Marshal(a.Metric)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'metric': %w", err)
		}
	}

	if a.Pipeline != nil {
		object["pipeline"], err = json.Marshal(a.Pipeline)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pipeline': %w", err)
		}
	}

	if a.RangeEnd != nil {
		object["range-end"], err = json.Marshal(a.RangeEnd)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'range-end': %w", err)
		}
	}

	if a.RangeStart != nil {
		object["range-start"], err = json.Marshal(a.RangeStart)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'range-start': %w", err)
		}
	}

	if a.Stack != nil {
		object["stack"], err = json.Marshal(a.Stack)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stack': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PublicAccount_Events. Returns the specified
// element and whether it was found
func (a PublicAccount_Events) Get(fieldName string) (value DateTime, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PublicAccount_Events
func (a *PublicAccount_Events) Set(fieldName string, value DateTime) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DateTime)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PublicAccount_Events to handle AdditionalProperties
func (a *PublicAccount_Events) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["last_login"]; found {
		err = json.Unmarshal(raw, &a.LastLogin)
		if err != nil {
			return fmt.Errorf("error reading 'last_login': %w", err)
		}
		delete(object, "last_login")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DateTime)
		for fieldName, fieldBuf := range object {
			var fieldVal DateTime
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PublicAccount_Events to handle AdditionalProperties
func (a PublicAccount_Events) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.LastLogin != nil {
		object["last_login"], err = json.Marshal(a.LastLogin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'last_login': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsClusterReconfigureMonitoringTierAction returns the union data inside the ClusterTask as a ClusterReconfigureMonitoringTierAction
func (t ClusterTask) AsClusterReconfigureMonitoringTierAction() (ClusterReconfigureMonitoringTierAction, error) {
	var body ClusterReconfigureMonitoringTierAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromClusterReconfigureMonitoringTierAction overwrites any union data inside the ClusterTask as the provided ClusterReconfigureMonitoringTierAction
func (t *ClusterTask) FromClusterReconfigureMonitoringTierAction(v ClusterReconfigureMonitoringTierAction) error {
	v.Action = "features.monitoring.tier.reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeClusterReconfigureMonitoringTierAction performs a merge with any union data inside the ClusterTask, using the provided ClusterReconfigureMonitoringTierAction
func (t *ClusterTask) MergeClusterReconfigureMonitoringTierAction(v ClusterReconfigureMonitoringTierAction) error {
	v.Action = "features.monitoring.tier.reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ClusterTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ClusterTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "features.monitoring.tier.reconfigure":
		return t.AsClusterReconfigureMonitoringTierAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ClusterTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ClusterTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsContainerStartAction returns the union data inside the ContainerTask as a ContainerStartAction
func (t ContainerTask) AsContainerStartAction() (ContainerStartAction, error) {
	var body ContainerStartAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerStartAction overwrites any union data inside the ContainerTask as the provided ContainerStartAction
func (t *ContainerTask) FromContainerStartAction(v ContainerStartAction) error {
	v.Action = "start"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerStartAction performs a merge with any union data inside the ContainerTask, using the provided ContainerStartAction
func (t *ContainerTask) MergeContainerStartAction(v ContainerStartAction) error {
	v.Action = "start"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerStopAction returns the union data inside the ContainerTask as a ContainerStopAction
func (t ContainerTask) AsContainerStopAction() (ContainerStopAction, error) {
	var body ContainerStopAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerStopAction overwrites any union data inside the ContainerTask as the provided ContainerStopAction
func (t *ContainerTask) FromContainerStopAction(v ContainerStopAction) error {
	v.Action = "stop"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerStopAction performs a merge with any union data inside the ContainerTask, using the provided ContainerStopAction
func (t *ContainerTask) MergeContainerStopAction(v ContainerStopAction) error {
	v.Action = "stop"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerRestartAction returns the union data inside the ContainerTask as a ContainerRestartAction
func (t ContainerTask) AsContainerRestartAction() (ContainerRestartAction, error) {
	var body ContainerRestartAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerRestartAction overwrites any union data inside the ContainerTask as the provided ContainerRestartAction
func (t *ContainerTask) FromContainerRestartAction(v ContainerRestartAction) error {
	v.Action = "restart"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerRestartAction performs a merge with any union data inside the ContainerTask, using the provided ContainerRestartAction
func (t *ContainerTask) MergeContainerRestartAction(v ContainerRestartAction) error {
	v.Action = "restart"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerReconfigureAction returns the union data inside the ContainerTask as a ContainerReconfigureAction
func (t ContainerTask) AsContainerReconfigureAction() (ContainerReconfigureAction, error) {
	var body ContainerReconfigureAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerReconfigureAction overwrites any union data inside the ContainerTask as the provided ContainerReconfigureAction
func (t *ContainerTask) FromContainerReconfigureAction(v ContainerReconfigureAction) error {
	v.Action = "reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerReconfigureAction performs a merge with any union data inside the ContainerTask, using the provided ContainerReconfigureAction
func (t *ContainerTask) MergeContainerReconfigureAction(v ContainerReconfigureAction) error {
	v.Action = "reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerReconfigureVolumesAction returns the union data inside the ContainerTask as a ContainerReconfigureVolumesAction
func (t ContainerTask) AsContainerReconfigureVolumesAction() (ContainerReconfigureVolumesAction, error) {
	var body ContainerReconfigureVolumesAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerReconfigureVolumesAction overwrites any union data inside the ContainerTask as the provided ContainerReconfigureVolumesAction
func (t *ContainerTask) FromContainerReconfigureVolumesAction(v ContainerReconfigureVolumesAction) error {
	v.Action = "volumes.reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerReconfigureVolumesAction performs a merge with any union data inside the ContainerTask, using the provided ContainerReconfigureVolumesAction
func (t *ContainerTask) MergeContainerReconfigureVolumesAction(v ContainerReconfigureVolumesAction) error {
	v.Action = "volumes.reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerReimageAction returns the union data inside the ContainerTask as a ContainerReimageAction
func (t ContainerTask) AsContainerReimageAction() (ContainerReimageAction, error) {
	var body ContainerReimageAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerReimageAction overwrites any union data inside the ContainerTask as the provided ContainerReimageAction
func (t *ContainerTask) FromContainerReimageAction(v ContainerReimageAction) error {
	v.Action = "reimage"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerReimageAction performs a merge with any union data inside the ContainerTask, using the provided ContainerReimageAction
func (t *ContainerTask) MergeContainerReimageAction(v ContainerReimageAction) error {
	v.Action = "reimage"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerScaleAction returns the union data inside the ContainerTask as a ContainerScaleAction
func (t ContainerTask) AsContainerScaleAction() (ContainerScaleAction, error) {
	var body ContainerScaleAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerScaleAction overwrites any union data inside the ContainerTask as the provided ContainerScaleAction
func (t *ContainerTask) FromContainerScaleAction(v ContainerScaleAction) error {
	v.Action = "scale"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerScaleAction performs a merge with any union data inside the ContainerTask, using the provided ContainerScaleAction
func (t *ContainerTask) MergeContainerScaleAction(v ContainerScaleAction) error {
	v.Action = "scale"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContainerTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ContainerTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "reconfigure":
		return t.AsContainerReconfigureAction()
	case "reimage":
		return t.AsContainerReimageAction()
	case "restart":
		return t.AsContainerRestartAction()
	case "scale":
		return t.AsContainerScaleAction()
	case "start":
		return t.AsContainerStartAction()
	case "stop":
		return t.AsContainerStopAction()
	case "volumes.reconfigure":
		return t.AsContainerReconfigureVolumesAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ContainerTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContainerTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentStartAction returns the union data inside the EnvironmentTask as a EnvironmentStartAction
func (t EnvironmentTask) AsEnvironmentStartAction() (EnvironmentStartAction, error) {
	var body EnvironmentStartAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentStartAction overwrites any union data inside the EnvironmentTask as the provided EnvironmentStartAction
func (t *EnvironmentTask) FromEnvironmentStartAction(v EnvironmentStartAction) error {
	v.Action = "start"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentStartAction performs a merge with any union data inside the EnvironmentTask, using the provided EnvironmentStartAction
func (t *EnvironmentTask) MergeEnvironmentStartAction(v EnvironmentStartAction) error {
	v.Action = "start"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentStopAction returns the union data inside the EnvironmentTask as a EnvironmentStopAction
func (t EnvironmentTask) AsEnvironmentStopAction() (EnvironmentStopAction, error) {
	var body EnvironmentStopAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentStopAction overwrites any union data inside the EnvironmentTask as the provided EnvironmentStopAction
func (t *EnvironmentTask) FromEnvironmentStopAction(v EnvironmentStopAction) error {
	v.Action = "stop"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentStopAction performs a merge with any union data inside the EnvironmentTask, using the provided EnvironmentStopAction
func (t *EnvironmentTask) MergeEnvironmentStopAction(v EnvironmentStopAction) error {
	v.Action = "stop"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentInitializeAction returns the union data inside the EnvironmentTask as a EnvironmentInitializeAction
func (t EnvironmentTask) AsEnvironmentInitializeAction() (EnvironmentInitializeAction, error) {
	var body EnvironmentInitializeAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentInitializeAction overwrites any union data inside the EnvironmentTask as the provided EnvironmentInitializeAction
func (t *EnvironmentTask) FromEnvironmentInitializeAction(v EnvironmentInitializeAction) error {
	v.Action = "initialize"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentInitializeAction performs a merge with any union data inside the EnvironmentTask, using the provided EnvironmentInitializeAction
func (t *EnvironmentTask) MergeEnvironmentInitializeAction(v EnvironmentInitializeAction) error {
	v.Action = "initialize"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentReconfigureDeploymentsAction returns the union data inside the EnvironmentTask as a EnvironmentReconfigureDeploymentsAction
func (t EnvironmentTask) AsEnvironmentReconfigureDeploymentsAction() (EnvironmentReconfigureDeploymentsAction, error) {
	var body EnvironmentReconfigureDeploymentsAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentReconfigureDeploymentsAction overwrites any union data inside the EnvironmentTask as the provided EnvironmentReconfigureDeploymentsAction
func (t *EnvironmentTask) FromEnvironmentReconfigureDeploymentsAction(v EnvironmentReconfigureDeploymentsAction) error {
	v.Action = "deployments.reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentReconfigureDeploymentsAction performs a merge with any union data inside the EnvironmentTask, using the provided EnvironmentReconfigureDeploymentsAction
func (t *EnvironmentTask) MergeEnvironmentReconfigureDeploymentsAction(v EnvironmentReconfigureDeploymentsAction) error {
	v.Action = "deployments.reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentReconfigureMonitoringAction returns the union data inside the EnvironmentTask as a EnvironmentReconfigureMonitoringAction
func (t EnvironmentTask) AsEnvironmentReconfigureMonitoringAction() (EnvironmentReconfigureMonitoringAction, error) {
	var body EnvironmentReconfigureMonitoringAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentReconfigureMonitoringAction overwrites any union data inside the EnvironmentTask as the provided EnvironmentReconfigureMonitoringAction
func (t *EnvironmentTask) FromEnvironmentReconfigureMonitoringAction(v EnvironmentReconfigureMonitoringAction) error {
	v.Action = "monitoring.reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentReconfigureMonitoringAction performs a merge with any union data inside the EnvironmentTask, using the provided EnvironmentReconfigureMonitoringAction
func (t *EnvironmentTask) MergeEnvironmentReconfigureMonitoringAction(v EnvironmentReconfigureMonitoringAction) error {
	v.Action = "monitoring.reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EnvironmentTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "deployments.reconfigure":
		return t.AsEnvironmentReconfigureDeploymentsAction()
	case "initialize":
		return t.AsEnvironmentInitializeAction()
	case "monitoring.reconfigure":
		return t.AsEnvironmentReconfigureMonitoringAction()
	case "start":
		return t.AsEnvironmentStartAction()
	case "stop":
		return t.AsEnvironmentStopAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EnvironmentTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsExternalVolumeAttachmentBlock returns the union data inside the ExternalVolumeAttachment as a ExternalVolumeAttachmentBlock
func (t ExternalVolumeAttachment) AsExternalVolumeAttachmentBlock() (ExternalVolumeAttachmentBlock, error) {
	var body ExternalVolumeAttachmentBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalVolumeAttachmentBlock overwrites any union data inside the ExternalVolumeAttachment as the provided ExternalVolumeAttachmentBlock
func (t *ExternalVolumeAttachment) FromExternalVolumeAttachmentBlock(v ExternalVolumeAttachmentBlock) error {
	v.Type = "block"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalVolumeAttachmentBlock performs a merge with any union data inside the ExternalVolumeAttachment, using the provided ExternalVolumeAttachmentBlock
func (t *ExternalVolumeAttachment) MergeExternalVolumeAttachmentBlock(v ExternalVolumeAttachmentBlock) error {
	v.Type = "block"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExternalVolumeAttachmentFileSystem returns the union data inside the ExternalVolumeAttachment as a ExternalVolumeAttachmentFileSystem
func (t ExternalVolumeAttachment) AsExternalVolumeAttachmentFileSystem() (ExternalVolumeAttachmentFileSystem, error) {
	var body ExternalVolumeAttachmentFileSystem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalVolumeAttachmentFileSystem overwrites any union data inside the ExternalVolumeAttachment as the provided ExternalVolumeAttachmentFileSystem
func (t *ExternalVolumeAttachment) FromExternalVolumeAttachmentFileSystem(v ExternalVolumeAttachmentFileSystem) error {
	v.Type = "filesystem"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalVolumeAttachmentFileSystem performs a merge with any union data inside the ExternalVolumeAttachment, using the provided ExternalVolumeAttachmentFileSystem
func (t *ExternalVolumeAttachment) MergeExternalVolumeAttachmentFileSystem(v ExternalVolumeAttachmentFileSystem) error {
	v.Type = "filesystem"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ExternalVolumeAttachment) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ExternalVolumeAttachment) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "block":
		return t.AsExternalVolumeAttachmentBlock()
	case "filesystem":
		return t.AsExternalVolumeAttachmentFileSystem()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ExternalVolumeAttachment) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExternalVolumeAttachment) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSourceSanIscsi returns the union data inside the ExternalVolumeSource as a SourceSanIscsi
func (t ExternalVolumeSource) AsSourceSanIscsi() (SourceSanIscsi, error) {
	var body SourceSanIscsi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSourceSanIscsi overwrites any union data inside the ExternalVolumeSource as the provided SourceSanIscsi
func (t *ExternalVolumeSource) FromSourceSanIscsi(v SourceSanIscsi) error {
	v.Type = "san-iscsi"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSourceSanIscsi performs a merge with any union data inside the ExternalVolumeSource, using the provided SourceSanIscsi
func (t *ExternalVolumeSource) MergeSourceSanIscsi(v SourceSanIscsi) error {
	v.Type = "san-iscsi"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSourceCephRbd returns the union data inside the ExternalVolumeSource as a SourceCephRbd
func (t ExternalVolumeSource) AsSourceCephRbd() (SourceCephRbd, error) {
	var body SourceCephRbd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSourceCephRbd overwrites any union data inside the ExternalVolumeSource as the provided SourceCephRbd
func (t *ExternalVolumeSource) FromSourceCephRbd(v SourceCephRbd) error {
	v.Type = "ceph-rbd"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSourceCephRbd performs a merge with any union data inside the ExternalVolumeSource, using the provided SourceCephRbd
func (t *ExternalVolumeSource) MergeSourceCephRbd(v SourceCephRbd) error {
	v.Type = "ceph-rbd"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSourceAwsEbs returns the union data inside the ExternalVolumeSource as a SourceAwsEbs
func (t ExternalVolumeSource) AsSourceAwsEbs() (SourceAwsEbs, error) {
	var body SourceAwsEbs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSourceAwsEbs overwrites any union data inside the ExternalVolumeSource as the provided SourceAwsEbs
func (t *ExternalVolumeSource) FromSourceAwsEbs(v SourceAwsEbs) error {
	v.Type = "aws-ebs"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSourceAwsEbs performs a merge with any union data inside the ExternalVolumeSource, using the provided SourceAwsEbs
func (t *ExternalVolumeSource) MergeSourceAwsEbs(v SourceAwsEbs) error {
	v.Type = "aws-ebs"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ExternalVolumeSource) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ExternalVolumeSource) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "aws-ebs":
		return t.AsSourceAwsEbs()
	case "ceph-rbd":
		return t.AsSourceCephRbd()
	case "san-iscsi":
		return t.AsSourceSanIscsi()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ExternalVolumeSource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExternalVolumeSource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsExternalVolumeServersReconfigureAction returns the union data inside the ExternalVolumeTask as a ExternalVolumeServersReconfigureAction
func (t ExternalVolumeTask) AsExternalVolumeServersReconfigureAction() (ExternalVolumeServersReconfigureAction, error) {
	var body ExternalVolumeServersReconfigureAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalVolumeServersReconfigureAction overwrites any union data inside the ExternalVolumeTask as the provided ExternalVolumeServersReconfigureAction
func (t *ExternalVolumeTask) FromExternalVolumeServersReconfigureAction(v ExternalVolumeServersReconfigureAction) error {
	v.Action = "servers.reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalVolumeServersReconfigureAction performs a merge with any union data inside the ExternalVolumeTask, using the provided ExternalVolumeServersReconfigureAction
func (t *ExternalVolumeTask) MergeExternalVolumeServersReconfigureAction(v ExternalVolumeServersReconfigureAction) error {
	v.Action = "servers.reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ExternalVolumeTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ExternalVolumeTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "servers.reconfigure":
		return t.AsExternalVolumeServersReconfigureAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ExternalVolumeTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ExternalVolumeTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFunctionTriggerAction returns the union data inside the FunctionTask as a FunctionTriggerAction
func (t FunctionTask) AsFunctionTriggerAction() (FunctionTriggerAction, error) {
	var body FunctionTriggerAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionTriggerAction overwrites any union data inside the FunctionTask as the provided FunctionTriggerAction
func (t *FunctionTask) FromFunctionTriggerAction(v FunctionTriggerAction) error {
	v.Action = "trigger"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionTriggerAction performs a merge with any union data inside the FunctionTask, using the provided FunctionTriggerAction
func (t *FunctionTask) MergeFunctionTriggerAction(v FunctionTriggerAction) error {
	v.Action = "trigger"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FunctionTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t FunctionTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "trigger":
		return t.AsFunctionTriggerAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t FunctionTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FunctionTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDirectImageSourceType returns the union data inside the Image_Source as a DirectImageSourceType
func (t Image_Source) AsDirectImageSourceType() (DirectImageSourceType, error) {
	var body DirectImageSourceType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDirectImageSourceType overwrites any union data inside the Image_Source as the provided DirectImageSourceType
func (t *Image_Source) FromDirectImageSourceType(v DirectImageSourceType) error {
	v.Type = "direct"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDirectImageSourceType performs a merge with any union data inside the Image_Source, using the provided DirectImageSourceType
func (t *Image_Source) MergeDirectImageSourceType(v DirectImageSourceType) error {
	v.Type = "direct"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackImageSourceType returns the union data inside the Image_Source as a StackImageSourceType
func (t Image_Source) AsStackImageSourceType() (StackImageSourceType, error) {
	var body StackImageSourceType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackImageSourceType overwrites any union data inside the Image_Source as the provided StackImageSourceType
func (t *Image_Source) FromStackImageSourceType(v StackImageSourceType) error {
	v.Type = "stack-build"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackImageSourceType performs a merge with any union data inside the Image_Source, using the provided StackImageSourceType
func (t *Image_Source) MergeStackImageSourceType(v StackImageSourceType) error {
	v.Type = "stack-build"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBucketImageSourceType returns the union data inside the Image_Source as a BucketImageSourceType
func (t Image_Source) AsBucketImageSourceType() (BucketImageSourceType, error) {
	var body BucketImageSourceType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBucketImageSourceType overwrites any union data inside the Image_Source as the provided BucketImageSourceType
func (t *Image_Source) FromBucketImageSourceType(v BucketImageSourceType) error {
	v.Type = "bucket"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBucketImageSourceType performs a merge with any union data inside the Image_Source, using the provided BucketImageSourceType
func (t *Image_Source) MergeBucketImageSourceType(v BucketImageSourceType) error {
	v.Type = "bucket"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Image_Source) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Image_Source) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "bucket":
		return t.AsBucketImageSourceType()
	case "direct":
		return t.AsDirectImageSourceType()
	case "stack-build":
		return t.AsStackImageSourceType()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Image_Source) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Image_Source) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDockerHubOrigin returns the union data inside the ImageOrigin as a DockerHubOrigin
func (t ImageOrigin) AsDockerHubOrigin() (DockerHubOrigin, error) {
	var body DockerHubOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerHubOrigin overwrites any union data inside the ImageOrigin as the provided DockerHubOrigin
func (t *ImageOrigin) FromDockerHubOrigin(v DockerHubOrigin) error {
	v.Type = "docker-hub"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerHubOrigin performs a merge with any union data inside the ImageOrigin, using the provided DockerHubOrigin
func (t *ImageOrigin) MergeDockerHubOrigin(v DockerHubOrigin) error {
	v.Type = "docker-hub"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerFileOrigin returns the union data inside the ImageOrigin as a DockerFileOrigin
func (t ImageOrigin) AsDockerFileOrigin() (DockerFileOrigin, error) {
	var body DockerFileOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerFileOrigin overwrites any union data inside the ImageOrigin as the provided DockerFileOrigin
func (t *ImageOrigin) FromDockerFileOrigin(v DockerFileOrigin) error {
	v.Type = "docker-file"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerFileOrigin performs a merge with any union data inside the ImageOrigin, using the provided DockerFileOrigin
func (t *ImageOrigin) MergeDockerFileOrigin(v DockerFileOrigin) error {
	v.Type = "docker-file"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerRegistryOrigin returns the union data inside the ImageOrigin as a DockerRegistryOrigin
func (t ImageOrigin) AsDockerRegistryOrigin() (DockerRegistryOrigin, error) {
	var body DockerRegistryOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerRegistryOrigin overwrites any union data inside the ImageOrigin as the provided DockerRegistryOrigin
func (t *ImageOrigin) FromDockerRegistryOrigin(v DockerRegistryOrigin) error {
	v.Type = "docker-registry"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerRegistryOrigin performs a merge with any union data inside the ImageOrigin, using the provided DockerRegistryOrigin
func (t *ImageOrigin) MergeDockerRegistryOrigin(v DockerRegistryOrigin) error {
	v.Type = "docker-registry"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOciRegistryOrigin returns the union data inside the ImageOrigin as a OciRegistryOrigin
func (t ImageOrigin) AsOciRegistryOrigin() (OciRegistryOrigin, error) {
	var body OciRegistryOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOciRegistryOrigin overwrites any union data inside the ImageOrigin as the provided OciRegistryOrigin
func (t *ImageOrigin) FromOciRegistryOrigin(v OciRegistryOrigin) error {
	v.Type = "oci-registry"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOciRegistryOrigin performs a merge with any union data inside the ImageOrigin, using the provided OciRegistryOrigin
func (t *ImageOrigin) MergeOciRegistryOrigin(v OciRegistryOrigin) error {
	v.Type = "oci-registry"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCycleUploadOrigin returns the union data inside the ImageOrigin as a CycleUploadOrigin
func (t ImageOrigin) AsCycleUploadOrigin() (CycleUploadOrigin, error) {
	var body CycleUploadOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCycleUploadOrigin overwrites any union data inside the ImageOrigin as the provided CycleUploadOrigin
func (t *ImageOrigin) FromCycleUploadOrigin(v CycleUploadOrigin) error {
	v.Type = "cycle-upload"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCycleUploadOrigin performs a merge with any union data inside the ImageOrigin, using the provided CycleUploadOrigin
func (t *ImageOrigin) MergeCycleUploadOrigin(v CycleUploadOrigin) error {
	v.Type = "cycle-upload"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCycleSourceOrigin returns the union data inside the ImageOrigin as a CycleSourceOrigin
func (t ImageOrigin) AsCycleSourceOrigin() (CycleSourceOrigin, error) {
	var body CycleSourceOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCycleSourceOrigin overwrites any union data inside the ImageOrigin as the provided CycleSourceOrigin
func (t *ImageOrigin) FromCycleSourceOrigin(v CycleSourceOrigin) error {
	v.Type = "cycle-source"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCycleSourceOrigin performs a merge with any union data inside the ImageOrigin, using the provided CycleSourceOrigin
func (t *ImageOrigin) MergeCycleSourceOrigin(v CycleSourceOrigin) error {
	v.Type = "cycle-source"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNoneOrigin returns the union data inside the ImageOrigin as a NoneOrigin
func (t ImageOrigin) AsNoneOrigin() (NoneOrigin, error) {
	var body NoneOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNoneOrigin overwrites any union data inside the ImageOrigin as the provided NoneOrigin
func (t *ImageOrigin) FromNoneOrigin(v NoneOrigin) error {
	v.Type = "none"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNoneOrigin performs a merge with any union data inside the ImageOrigin, using the provided NoneOrigin
func (t *ImageOrigin) MergeNoneOrigin(v NoneOrigin) error {
	v.Type = "none"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ImageOrigin) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ImageOrigin) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "cycle-source":
		return t.AsCycleSourceOrigin()
	case "cycle-upload":
		return t.AsCycleUploadOrigin()
	case "docker-file":
		return t.AsDockerFileOrigin()
	case "docker-hub":
		return t.AsDockerHubOrigin()
	case "docker-registry":
		return t.AsDockerRegistryOrigin()
	case "none":
		return t.AsNoneOrigin()
	case "oci-registry":
		return t.AsOciRegistryOrigin()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ImageOrigin) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ImageOrigin) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsInstanceMigrateAction returns the union data inside the InstanceTask as a InstanceMigrateAction
func (t InstanceTask) AsInstanceMigrateAction() (InstanceMigrateAction, error) {
	var body InstanceMigrateAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceMigrateAction overwrites any union data inside the InstanceTask as the provided InstanceMigrateAction
func (t *InstanceTask) FromInstanceMigrateAction(v InstanceMigrateAction) error {
	v.Action = "migration.start"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceMigrateAction performs a merge with any union data inside the InstanceTask, using the provided InstanceMigrateAction
func (t *InstanceTask) MergeInstanceMigrateAction(v InstanceMigrateAction) error {
	v.Action = "migration.start"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceRevertMigrationAction returns the union data inside the InstanceTask as a InstanceRevertMigrationAction
func (t InstanceTask) AsInstanceRevertMigrationAction() (InstanceRevertMigrationAction, error) {
	var body InstanceRevertMigrationAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceRevertMigrationAction overwrites any union data inside the InstanceTask as the provided InstanceRevertMigrationAction
func (t *InstanceTask) FromInstanceRevertMigrationAction(v InstanceRevertMigrationAction) error {
	v.Action = "migration.revert"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceRevertMigrationAction performs a merge with any union data inside the InstanceTask, using the provided InstanceRevertMigrationAction
func (t *InstanceTask) MergeInstanceRevertMigrationAction(v InstanceRevertMigrationAction) error {
	v.Action = "migration.revert"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceExtendVolumeAction returns the union data inside the InstanceTask as a InstanceExtendVolumeAction
func (t InstanceTask) AsInstanceExtendVolumeAction() (InstanceExtendVolumeAction, error) {
	var body InstanceExtendVolumeAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceExtendVolumeAction overwrites any union data inside the InstanceTask as the provided InstanceExtendVolumeAction
func (t *InstanceTask) FromInstanceExtendVolumeAction(v InstanceExtendVolumeAction) error {
	v.Action = "volume.extend"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceExtendVolumeAction performs a merge with any union data inside the InstanceTask, using the provided InstanceExtendVolumeAction
func (t *InstanceTask) MergeInstanceExtendVolumeAction(v InstanceExtendVolumeAction) error {
	v.Action = "volume.extend"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInstanceTrafficDrainReconfigure returns the union data inside the InstanceTask as a InstanceTrafficDrainReconfigure
func (t InstanceTask) AsInstanceTrafficDrainReconfigure() (InstanceTrafficDrainReconfigure, error) {
	var body InstanceTrafficDrainReconfigure
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInstanceTrafficDrainReconfigure overwrites any union data inside the InstanceTask as the provided InstanceTrafficDrainReconfigure
func (t *InstanceTask) FromInstanceTrafficDrainReconfigure(v InstanceTrafficDrainReconfigure) error {
	v.Action = "traffic-drain.reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInstanceTrafficDrainReconfigure performs a merge with any union data inside the InstanceTask, using the provided InstanceTrafficDrainReconfigure
func (t *InstanceTask) MergeInstanceTrafficDrainReconfigure(v InstanceTrafficDrainReconfigure) error {
	v.Action = "traffic-drain.reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t InstanceTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t InstanceTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "migration.revert":
		return t.AsInstanceRevertMigrationAction()
	case "migration.start":
		return t.AsInstanceMigrateAction()
	case "traffic-drain.reconfigure":
		return t.AsInstanceTrafficDrainReconfigure()
	case "volume.extend":
		return t.AsInstanceExtendVolumeAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t InstanceTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *InstanceTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIntegrationAdvancedOptionBoolean returns the union data inside the IntegrationDefinition_ExtendedConfiguration_Options_Item as a IntegrationAdvancedOptionBoolean
func (t IntegrationDefinition_ExtendedConfiguration_Options_Item) AsIntegrationAdvancedOptionBoolean() (IntegrationAdvancedOptionBoolean, error) {
	var body IntegrationAdvancedOptionBoolean
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegrationAdvancedOptionBoolean overwrites any union data inside the IntegrationDefinition_ExtendedConfiguration_Options_Item as the provided IntegrationAdvancedOptionBoolean
func (t *IntegrationDefinition_ExtendedConfiguration_Options_Item) FromIntegrationAdvancedOptionBoolean(v IntegrationAdvancedOptionBoolean) error {
	v.Type = "bool"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegrationAdvancedOptionBoolean performs a merge with any union data inside the IntegrationDefinition_ExtendedConfiguration_Options_Item, using the provided IntegrationAdvancedOptionBoolean
func (t *IntegrationDefinition_ExtendedConfiguration_Options_Item) MergeIntegrationAdvancedOptionBoolean(v IntegrationAdvancedOptionBoolean) error {
	v.Type = "bool"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegrationAdvancedOptionInt returns the union data inside the IntegrationDefinition_ExtendedConfiguration_Options_Item as a IntegrationAdvancedOptionInt
func (t IntegrationDefinition_ExtendedConfiguration_Options_Item) AsIntegrationAdvancedOptionInt() (IntegrationAdvancedOptionInt, error) {
	var body IntegrationAdvancedOptionInt
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegrationAdvancedOptionInt overwrites any union data inside the IntegrationDefinition_ExtendedConfiguration_Options_Item as the provided IntegrationAdvancedOptionInt
func (t *IntegrationDefinition_ExtendedConfiguration_Options_Item) FromIntegrationAdvancedOptionInt(v IntegrationAdvancedOptionInt) error {
	v.Type = "int"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegrationAdvancedOptionInt performs a merge with any union data inside the IntegrationDefinition_ExtendedConfiguration_Options_Item, using the provided IntegrationAdvancedOptionInt
func (t *IntegrationDefinition_ExtendedConfiguration_Options_Item) MergeIntegrationAdvancedOptionInt(v IntegrationAdvancedOptionInt) error {
	v.Type = "int"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegrationAdvancedOptionString returns the union data inside the IntegrationDefinition_ExtendedConfiguration_Options_Item as a IntegrationAdvancedOptionString
func (t IntegrationDefinition_ExtendedConfiguration_Options_Item) AsIntegrationAdvancedOptionString() (IntegrationAdvancedOptionString, error) {
	var body IntegrationAdvancedOptionString
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegrationAdvancedOptionString overwrites any union data inside the IntegrationDefinition_ExtendedConfiguration_Options_Item as the provided IntegrationAdvancedOptionString
func (t *IntegrationDefinition_ExtendedConfiguration_Options_Item) FromIntegrationAdvancedOptionString(v IntegrationAdvancedOptionString) error {
	v.Type = "string"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegrationAdvancedOptionString performs a merge with any union data inside the IntegrationDefinition_ExtendedConfiguration_Options_Item, using the provided IntegrationAdvancedOptionString
func (t *IntegrationDefinition_ExtendedConfiguration_Options_Item) MergeIntegrationAdvancedOptionString(v IntegrationAdvancedOptionString) error {
	v.Type = "string"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IntegrationDefinition_ExtendedConfiguration_Options_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t IntegrationDefinition_ExtendedConfiguration_Options_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "bool":
		return t.AsIntegrationAdvancedOptionBoolean()
	case "int":
		return t.AsIntegrationAdvancedOptionInt()
	case "string":
		return t.AsIntegrationAdvancedOptionString()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t IntegrationDefinition_ExtendedConfiguration_Options_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IntegrationDefinition_ExtendedConfiguration_Options_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIpPoolInitializeAction returns the union data inside the IpPoolTask as a IpPoolInitializeAction
func (t IpPoolTask) AsIpPoolInitializeAction() (IpPoolInitializeAction, error) {
	var body IpPoolInitializeAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIpPoolInitializeAction overwrites any union data inside the IpPoolTask as the provided IpPoolInitializeAction
func (t *IpPoolTask) FromIpPoolInitializeAction(v IpPoolInitializeAction) error {
	v.Action = "initialize"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIpPoolInitializeAction performs a merge with any union data inside the IpPoolTask, using the provided IpPoolInitializeAction
func (t *IpPoolTask) MergeIpPoolInitializeAction(v IpPoolInitializeAction) error {
	v.Action = "initialize"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIpPoolReconfigureOptionsAction returns the union data inside the IpPoolTask as a IpPoolReconfigureOptionsAction
func (t IpPoolTask) AsIpPoolReconfigureOptionsAction() (IpPoolReconfigureOptionsAction, error) {
	var body IpPoolReconfigureOptionsAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIpPoolReconfigureOptionsAction overwrites any union data inside the IpPoolTask as the provided IpPoolReconfigureOptionsAction
func (t *IpPoolTask) FromIpPoolReconfigureOptionsAction(v IpPoolReconfigureOptionsAction) error {
	v.Action = "options.reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIpPoolReconfigureOptionsAction performs a merge with any union data inside the IpPoolTask, using the provided IpPoolReconfigureOptionsAction
func (t *IpPoolTask) MergeIpPoolReconfigureOptionsAction(v IpPoolReconfigureOptionsAction) error {
	v.Action = "options.reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IpPoolTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t IpPoolTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "initialize":
		return t.AsIpPoolInitializeAction()
	case "options.reconfigure":
		return t.AsIpPoolReconfigureOptionsAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t IpPoolTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IpPoolTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsV1LbType returns the union data inside the LoadBalancerConfig as a V1LbType
func (t LoadBalancerConfig) AsV1LbType() (V1LbType, error) {
	var body V1LbType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbType overwrites any union data inside the LoadBalancerConfig as the provided V1LbType
func (t *LoadBalancerConfig) FromV1LbType(v V1LbType) error {
	v.Type = "v1"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbType performs a merge with any union data inside the LoadBalancerConfig, using the provided V1LbType
func (t *LoadBalancerConfig) MergeV1LbType(v V1LbType) error {
	v.Type = "v1"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHaProxyLbType returns the union data inside the LoadBalancerConfig as a HaProxyLbType
func (t LoadBalancerConfig) AsHaProxyLbType() (HaProxyLbType, error) {
	var body HaProxyLbType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHaProxyLbType overwrites any union data inside the LoadBalancerConfig as the provided HaProxyLbType
func (t *LoadBalancerConfig) FromHaProxyLbType(v HaProxyLbType) error {
	v.Type = "haproxy"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHaProxyLbType performs a merge with any union data inside the LoadBalancerConfig, using the provided HaProxyLbType
func (t *LoadBalancerConfig) MergeHaProxyLbType(v HaProxyLbType) error {
	v.Type = "haproxy"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDefaultLbType returns the union data inside the LoadBalancerConfig as a DefaultLbType
func (t LoadBalancerConfig) AsDefaultLbType() (DefaultLbType, error) {
	var body DefaultLbType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDefaultLbType overwrites any union data inside the LoadBalancerConfig as the provided DefaultLbType
func (t *LoadBalancerConfig) FromDefaultLbType(v DefaultLbType) error {
	v.Type = "default"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDefaultLbType performs a merge with any union data inside the LoadBalancerConfig, using the provided DefaultLbType
func (t *LoadBalancerConfig) MergeDefaultLbType(v DefaultLbType) error {
	v.Type = "default"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LoadBalancerConfig) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t LoadBalancerConfig) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "default":
		return t.AsDefaultLbType()
	case "haproxy":
		return t.AsHaProxyLbType()
	case "v1":
		return t.AsV1LbType()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t LoadBalancerConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LoadBalancerConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStripeCreditCard returns the union data inside the MethodSource as a StripeCreditCard
func (t MethodSource) AsStripeCreditCard() (StripeCreditCard, error) {
	var body StripeCreditCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStripeCreditCard overwrites any union data inside the MethodSource as the provided StripeCreditCard
func (t *MethodSource) FromStripeCreditCard(v StripeCreditCard) error {
	v.Type = "stripe-credit-card"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStripeCreditCard performs a merge with any union data inside the MethodSource, using the provided StripeCreditCard
func (t *MethodSource) MergeStripeCreditCard(v StripeCreditCard) error {
	v.Type = "stripe-credit-card"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStripeUsBankAcct returns the union data inside the MethodSource as a StripeUsBankAcct
func (t MethodSource) AsStripeUsBankAcct() (StripeUsBankAcct, error) {
	var body StripeUsBankAcct
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStripeUsBankAcct overwrites any union data inside the MethodSource as the provided StripeUsBankAcct
func (t *MethodSource) FromStripeUsBankAcct(v StripeUsBankAcct) error {
	v.Type = "stripe-us-bank-acct"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStripeUsBankAcct performs a merge with any union data inside the MethodSource, using the provided StripeUsBankAcct
func (t *MethodSource) MergeStripeUsBankAcct(v StripeUsBankAcct) error {
	v.Type = "stripe-us-bank-acct"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDirectPayment returns the union data inside the MethodSource as a DirectPayment
func (t MethodSource) AsDirectPayment() (DirectPayment, error) {
	var body DirectPayment
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDirectPayment overwrites any union data inside the MethodSource as the provided DirectPayment
func (t *MethodSource) FromDirectPayment(v DirectPayment) error {
	v.Type = "direct-payment"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDirectPayment performs a merge with any union data inside the MethodSource, using the provided DirectPayment
func (t *MethodSource) MergeDirectPayment(v DirectPayment) error {
	v.Type = "direct-payment"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t MethodSource) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t MethodSource) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "direct-payment":
		return t.AsDirectPayment()
	case "stripe-credit-card":
		return t.AsStripeCreditCard()
	case "stripe-us-bank-acct":
		return t.AsStripeUsBankAcct()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t MethodSource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *MethodSource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDateTime returns the union data inside the Metric_Points_Item as a DateTime
func (t Metric_Points_Item) AsDateTime() (DateTime, error) {
	var body DateTime
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateTime overwrites any union data inside the Metric_Points_Item as the provided DateTime
func (t *Metric_Points_Item) FromDateTime(v DateTime) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateTime performs a merge with any union data inside the Metric_Points_Item, using the provided DateTime
func (t *Metric_Points_Item) MergeDateTime(v DateTime) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMetricPoints1 returns the union data inside the Metric_Points_Item as a MetricPoints1
func (t Metric_Points_Item) AsMetricPoints1() (MetricPoints1, error) {
	var body MetricPoints1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMetricPoints1 overwrites any union data inside the Metric_Points_Item as the provided MetricPoints1
func (t *Metric_Points_Item) FromMetricPoints1(v MetricPoints1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMetricPoints1 performs a merge with any union data inside the Metric_Points_Item, using the provided MetricPoints1
func (t *Metric_Points_Item) MergeMetricPoints1(v MetricPoints1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Metric_Points_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Metric_Points_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNetworkL2DhcpDetails returns the union data inside the NetworkL2_Ips as a NetworkL2DhcpDetails
func (t NetworkL2_Ips) AsNetworkL2DhcpDetails() (NetworkL2DhcpDetails, error) {
	var body NetworkL2DhcpDetails
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkL2DhcpDetails overwrites any union data inside the NetworkL2_Ips as the provided NetworkL2DhcpDetails
func (t *NetworkL2_Ips) FromNetworkL2DhcpDetails(v NetworkL2DhcpDetails) error {
	v.Method = "dhcp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkL2DhcpDetails performs a merge with any union data inside the NetworkL2_Ips, using the provided NetworkL2DhcpDetails
func (t *NetworkL2_Ips) MergeNetworkL2DhcpDetails(v NetworkL2DhcpDetails) error {
	v.Method = "dhcp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetworkL2StaticDetails returns the union data inside the NetworkL2_Ips as a NetworkL2StaticDetails
func (t NetworkL2_Ips) AsNetworkL2StaticDetails() (NetworkL2StaticDetails, error) {
	var body NetworkL2StaticDetails
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkL2StaticDetails overwrites any union data inside the NetworkL2_Ips as the provided NetworkL2StaticDetails
func (t *NetworkL2_Ips) FromNetworkL2StaticDetails(v NetworkL2StaticDetails) error {
	v.Method = "static"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkL2StaticDetails performs a merge with any union data inside the NetworkL2_Ips, using the provided NetworkL2StaticDetails
func (t *NetworkL2_Ips) MergeNetworkL2StaticDetails(v NetworkL2StaticDetails) error {
	v.Method = "static"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NetworkL2_Ips) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"method"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t NetworkL2_Ips) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "dhcp":
		return t.AsNetworkL2DhcpDetails()
	case "static":
		return t.AsNetworkL2StaticDetails()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t NetworkL2_Ips) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NetworkL2_Ips) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsImageCreateStep returns the union data inside the PipelineSteps as a ImageCreateStep
func (t PipelineSteps) AsImageCreateStep() (ImageCreateStep, error) {
	var body ImageCreateStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageCreateStep overwrites any union data inside the PipelineSteps as the provided ImageCreateStep
func (t *PipelineSteps) FromImageCreateStep(v ImageCreateStep) error {
	v.Action = "image.create"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageCreateStep performs a merge with any union data inside the PipelineSteps, using the provided ImageCreateStep
func (t *PipelineSteps) MergeImageCreateStep(v ImageCreateStep) error {
	v.Action = "image.create"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageImportStep returns the union data inside the PipelineSteps as a ImageImportStep
func (t PipelineSteps) AsImageImportStep() (ImageImportStep, error) {
	var body ImageImportStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageImportStep overwrites any union data inside the PipelineSteps as the provided ImageImportStep
func (t *PipelineSteps) FromImageImportStep(v ImageImportStep) error {
	v.Action = "image.import"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageImportStep performs a merge with any union data inside the PipelineSteps, using the provided ImageImportStep
func (t *PipelineSteps) MergeImageImportStep(v ImageImportStep) error {
	v.Action = "image.import"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImagesPruneStep returns the union data inside the PipelineSteps as a ImagesPruneStep
func (t PipelineSteps) AsImagesPruneStep() (ImagesPruneStep, error) {
	var body ImagesPruneStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImagesPruneStep overwrites any union data inside the PipelineSteps as the provided ImagesPruneStep
func (t *PipelineSteps) FromImagesPruneStep(v ImagesPruneStep) error {
	v.Action = "images.prune"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImagesPruneStep performs a merge with any union data inside the PipelineSteps, using the provided ImagesPruneStep
func (t *PipelineSteps) MergeImagesPruneStep(v ImagesPruneStep) error {
	v.Action = "images.prune"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageCreateImportStep returns the union data inside the PipelineSteps as a ImageCreateImportStep
func (t PipelineSteps) AsImageCreateImportStep() (ImageCreateImportStep, error) {
	var body ImageCreateImportStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageCreateImportStep overwrites any union data inside the PipelineSteps as the provided ImageCreateImportStep
func (t *PipelineSteps) FromImageCreateImportStep(v ImageCreateImportStep) error {
	v.Action = "image.create-import"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageCreateImportStep performs a merge with any union data inside the PipelineSteps, using the provided ImageCreateImportStep
func (t *PipelineSteps) MergeImageCreateImportStep(v ImageCreateImportStep) error {
	v.Action = "image.create-import"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerCreateStep returns the union data inside the PipelineSteps as a ContainerCreateStep
func (t PipelineSteps) AsContainerCreateStep() (ContainerCreateStep, error) {
	var body ContainerCreateStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerCreateStep overwrites any union data inside the PipelineSteps as the provided ContainerCreateStep
func (t *PipelineSteps) FromContainerCreateStep(v ContainerCreateStep) error {
	v.Action = "container.create"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerCreateStep performs a merge with any union data inside the PipelineSteps, using the provided ContainerCreateStep
func (t *PipelineSteps) MergeContainerCreateStep(v ContainerCreateStep) error {
	v.Action = "container.create"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerStartStep returns the union data inside the PipelineSteps as a ContainerStartStep
func (t PipelineSteps) AsContainerStartStep() (ContainerStartStep, error) {
	var body ContainerStartStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerStartStep overwrites any union data inside the PipelineSteps as the provided ContainerStartStep
func (t *PipelineSteps) FromContainerStartStep(v ContainerStartStep) error {
	v.Action = "container.start"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerStartStep performs a merge with any union data inside the PipelineSteps, using the provided ContainerStartStep
func (t *PipelineSteps) MergeContainerStartStep(v ContainerStartStep) error {
	v.Action = "container.start"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerStopStep returns the union data inside the PipelineSteps as a ContainerStopStep
func (t PipelineSteps) AsContainerStopStep() (ContainerStopStep, error) {
	var body ContainerStopStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerStopStep overwrites any union data inside the PipelineSteps as the provided ContainerStopStep
func (t *PipelineSteps) FromContainerStopStep(v ContainerStopStep) error {
	v.Action = "container.stop"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerStopStep performs a merge with any union data inside the PipelineSteps, using the provided ContainerStopStep
func (t *PipelineSteps) MergeContainerStopStep(v ContainerStopStep) error {
	v.Action = "container.stop"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerDeleteStep returns the union data inside the PipelineSteps as a ContainerDeleteStep
func (t PipelineSteps) AsContainerDeleteStep() (ContainerDeleteStep, error) {
	var body ContainerDeleteStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerDeleteStep overwrites any union data inside the PipelineSteps as the provided ContainerDeleteStep
func (t *PipelineSteps) FromContainerDeleteStep(v ContainerDeleteStep) error {
	v.Action = "container.delete"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerDeleteStep performs a merge with any union data inside the PipelineSteps, using the provided ContainerDeleteStep
func (t *PipelineSteps) MergeContainerDeleteStep(v ContainerDeleteStep) error {
	v.Action = "container.delete"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerReimageStep returns the union data inside the PipelineSteps as a ContainerReimageStep
func (t PipelineSteps) AsContainerReimageStep() (ContainerReimageStep, error) {
	var body ContainerReimageStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerReimageStep overwrites any union data inside the PipelineSteps as the provided ContainerReimageStep
func (t *PipelineSteps) FromContainerReimageStep(v ContainerReimageStep) error {
	v.Action = "container.reimage"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerReimageStep performs a merge with any union data inside the PipelineSteps, using the provided ContainerReimageStep
func (t *PipelineSteps) MergeContainerReimageStep(v ContainerReimageStep) error {
	v.Action = "container.reimage"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerRestartStep returns the union data inside the PipelineSteps as a ContainerRestartStep
func (t PipelineSteps) AsContainerRestartStep() (ContainerRestartStep, error) {
	var body ContainerRestartStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerRestartStep overwrites any union data inside the PipelineSteps as the provided ContainerRestartStep
func (t *PipelineSteps) FromContainerRestartStep(v ContainerRestartStep) error {
	v.Action = "container.restart"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerRestartStep performs a merge with any union data inside the PipelineSteps, using the provided ContainerRestartStep
func (t *PipelineSteps) MergeContainerRestartStep(v ContainerRestartStep) error {
	v.Action = "container.restart"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerFunctionTriggerStep returns the union data inside the PipelineSteps as a ContainerFunctionTriggerStep
func (t PipelineSteps) AsContainerFunctionTriggerStep() (ContainerFunctionTriggerStep, error) {
	var body ContainerFunctionTriggerStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerFunctionTriggerStep overwrites any union data inside the PipelineSteps as the provided ContainerFunctionTriggerStep
func (t *PipelineSteps) FromContainerFunctionTriggerStep(v ContainerFunctionTriggerStep) error {
	v.Action = "container.function.trigger"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerFunctionTriggerStep performs a merge with any union data inside the PipelineSteps, using the provided ContainerFunctionTriggerStep
func (t *PipelineSteps) MergeContainerFunctionTriggerStep(v ContainerFunctionTriggerStep) error {
	v.Action = "container.function.trigger"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentCreateStep returns the union data inside the PipelineSteps as a EnvironmentCreateStep
func (t PipelineSteps) AsEnvironmentCreateStep() (EnvironmentCreateStep, error) {
	var body EnvironmentCreateStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentCreateStep overwrites any union data inside the PipelineSteps as the provided EnvironmentCreateStep
func (t *PipelineSteps) FromEnvironmentCreateStep(v EnvironmentCreateStep) error {
	v.Action = "environment.create"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentCreateStep performs a merge with any union data inside the PipelineSteps, using the provided EnvironmentCreateStep
func (t *PipelineSteps) MergeEnvironmentCreateStep(v EnvironmentCreateStep) error {
	v.Action = "environment.create"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentStartStep returns the union data inside the PipelineSteps as a EnvironmentStartStep
func (t PipelineSteps) AsEnvironmentStartStep() (EnvironmentStartStep, error) {
	var body EnvironmentStartStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentStartStep overwrites any union data inside the PipelineSteps as the provided EnvironmentStartStep
func (t *PipelineSteps) FromEnvironmentStartStep(v EnvironmentStartStep) error {
	v.Action = "environment.start"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentStartStep performs a merge with any union data inside the PipelineSteps, using the provided EnvironmentStartStep
func (t *PipelineSteps) MergeEnvironmentStartStep(v EnvironmentStartStep) error {
	v.Action = "environment.start"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentStopStep returns the union data inside the PipelineSteps as a EnvironmentStopStep
func (t PipelineSteps) AsEnvironmentStopStep() (EnvironmentStopStep, error) {
	var body EnvironmentStopStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentStopStep overwrites any union data inside the PipelineSteps as the provided EnvironmentStopStep
func (t *PipelineSteps) FromEnvironmentStopStep(v EnvironmentStopStep) error {
	v.Action = "environment.stop"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentStopStep performs a merge with any union data inside the PipelineSteps, using the provided EnvironmentStopStep
func (t *PipelineSteps) MergeEnvironmentStopStep(v EnvironmentStopStep) error {
	v.Action = "environment.stop"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentDeleteStep returns the union data inside the PipelineSteps as a EnvironmentDeleteStep
func (t PipelineSteps) AsEnvironmentDeleteStep() (EnvironmentDeleteStep, error) {
	var body EnvironmentDeleteStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentDeleteStep overwrites any union data inside the PipelineSteps as the provided EnvironmentDeleteStep
func (t *PipelineSteps) FromEnvironmentDeleteStep(v EnvironmentDeleteStep) error {
	v.Action = "environment.delete"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentDeleteStep performs a merge with any union data inside the PipelineSteps, using the provided EnvironmentDeleteStep
func (t *PipelineSteps) MergeEnvironmentDeleteStep(v EnvironmentDeleteStep) error {
	v.Action = "environment.delete"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentDeploymentStartStep returns the union data inside the PipelineSteps as a EnvironmentDeploymentStartStep
func (t PipelineSteps) AsEnvironmentDeploymentStartStep() (EnvironmentDeploymentStartStep, error) {
	var body EnvironmentDeploymentStartStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentDeploymentStartStep overwrites any union data inside the PipelineSteps as the provided EnvironmentDeploymentStartStep
func (t *PipelineSteps) FromEnvironmentDeploymentStartStep(v EnvironmentDeploymentStartStep) error {
	v.Action = "environment.deployment.start"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentDeploymentStartStep performs a merge with any union data inside the PipelineSteps, using the provided EnvironmentDeploymentStartStep
func (t *PipelineSteps) MergeEnvironmentDeploymentStartStep(v EnvironmentDeploymentStartStep) error {
	v.Action = "environment.deployment.start"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentDeploymentStopStep returns the union data inside the PipelineSteps as a EnvironmentDeploymentStopStep
func (t PipelineSteps) AsEnvironmentDeploymentStopStep() (EnvironmentDeploymentStopStep, error) {
	var body EnvironmentDeploymentStopStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentDeploymentStopStep overwrites any union data inside the PipelineSteps as the provided EnvironmentDeploymentStopStep
func (t *PipelineSteps) FromEnvironmentDeploymentStopStep(v EnvironmentDeploymentStopStep) error {
	v.Action = "environment.deployment.stop"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentDeploymentStopStep performs a merge with any union data inside the PipelineSteps, using the provided EnvironmentDeploymentStopStep
func (t *PipelineSteps) MergeEnvironmentDeploymentStopStep(v EnvironmentDeploymentStopStep) error {
	v.Action = "environment.deployment.stop"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentDeploymentsTagStep returns the union data inside the PipelineSteps as a EnvironmentDeploymentsTagStep
func (t PipelineSteps) AsEnvironmentDeploymentsTagStep() (EnvironmentDeploymentsTagStep, error) {
	var body EnvironmentDeploymentsTagStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentDeploymentsTagStep overwrites any union data inside the PipelineSteps as the provided EnvironmentDeploymentsTagStep
func (t *PipelineSteps) FromEnvironmentDeploymentsTagStep(v EnvironmentDeploymentsTagStep) error {
	v.Action = "environment.deployments.tag"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentDeploymentsTagStep performs a merge with any union data inside the PipelineSteps, using the provided EnvironmentDeploymentsTagStep
func (t *PipelineSteps) MergeEnvironmentDeploymentsTagStep(v EnvironmentDeploymentsTagStep) error {
	v.Action = "environment.deployments.tag"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentDeploymentsPruneStep returns the union data inside the PipelineSteps as a EnvironmentDeploymentsPruneStep
func (t PipelineSteps) AsEnvironmentDeploymentsPruneStep() (EnvironmentDeploymentsPruneStep, error) {
	var body EnvironmentDeploymentsPruneStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentDeploymentsPruneStep overwrites any union data inside the PipelineSteps as the provided EnvironmentDeploymentsPruneStep
func (t *PipelineSteps) FromEnvironmentDeploymentsPruneStep(v EnvironmentDeploymentsPruneStep) error {
	v.Action = "environment.deployments.prune"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentDeploymentsPruneStep performs a merge with any union data inside the PipelineSteps, using the provided EnvironmentDeploymentsPruneStep
func (t *PipelineSteps) MergeEnvironmentDeploymentsPruneStep(v EnvironmentDeploymentsPruneStep) error {
	v.Action = "environment.deployments.prune"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentDeploymentHealthyWatchStep returns the union data inside the PipelineSteps as a EnvironmentDeploymentHealthyWatchStep
func (t PipelineSteps) AsEnvironmentDeploymentHealthyWatchStep() (EnvironmentDeploymentHealthyWatchStep, error) {
	var body EnvironmentDeploymentHealthyWatchStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentDeploymentHealthyWatchStep overwrites any union data inside the PipelineSteps as the provided EnvironmentDeploymentHealthyWatchStep
func (t *PipelineSteps) FromEnvironmentDeploymentHealthyWatchStep(v EnvironmentDeploymentHealthyWatchStep) error {
	v.Action = "environment.deployment.healthy.watch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentDeploymentHealthyWatchStep performs a merge with any union data inside the PipelineSteps, using the provided EnvironmentDeploymentHealthyWatchStep
func (t *PipelineSteps) MergeEnvironmentDeploymentHealthyWatchStep(v EnvironmentDeploymentHealthyWatchStep) error {
	v.Action = "environment.deployment.healthy.watch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackBuildCreateStep returns the union data inside the PipelineSteps as a StackBuildCreateStep
func (t PipelineSteps) AsStackBuildCreateStep() (StackBuildCreateStep, error) {
	var body StackBuildCreateStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackBuildCreateStep overwrites any union data inside the PipelineSteps as the provided StackBuildCreateStep
func (t *PipelineSteps) FromStackBuildCreateStep(v StackBuildCreateStep) error {
	v.Action = "stack.build.create"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackBuildCreateStep performs a merge with any union data inside the PipelineSteps, using the provided StackBuildCreateStep
func (t *PipelineSteps) MergeStackBuildCreateStep(v StackBuildCreateStep) error {
	v.Action = "stack.build.create"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackBuildGenerateStep returns the union data inside the PipelineSteps as a StackBuildGenerateStep
func (t PipelineSteps) AsStackBuildGenerateStep() (StackBuildGenerateStep, error) {
	var body StackBuildGenerateStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackBuildGenerateStep overwrites any union data inside the PipelineSteps as the provided StackBuildGenerateStep
func (t *PipelineSteps) FromStackBuildGenerateStep(v StackBuildGenerateStep) error {
	v.Action = "stack.build.generate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackBuildGenerateStep performs a merge with any union data inside the PipelineSteps, using the provided StackBuildGenerateStep
func (t *PipelineSteps) MergeStackBuildGenerateStep(v StackBuildGenerateStep) error {
	v.Action = "stack.build.generate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackBuildDeployStep returns the union data inside the PipelineSteps as a StackBuildDeployStep
func (t PipelineSteps) AsStackBuildDeployStep() (StackBuildDeployStep, error) {
	var body StackBuildDeployStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackBuildDeployStep overwrites any union data inside the PipelineSteps as the provided StackBuildDeployStep
func (t *PipelineSteps) FromStackBuildDeployStep(v StackBuildDeployStep) error {
	v.Action = "stack.build.deploy"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackBuildDeployStep performs a merge with any union data inside the PipelineSteps, using the provided StackBuildDeployStep
func (t *PipelineSteps) MergeStackBuildDeployStep(v StackBuildDeployStep) error {
	v.Action = "stack.build.deploy"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackPruneStep returns the union data inside the PipelineSteps as a StackPruneStep
func (t PipelineSteps) AsStackPruneStep() (StackPruneStep, error) {
	var body StackPruneStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackPruneStep overwrites any union data inside the PipelineSteps as the provided StackPruneStep
func (t *PipelineSteps) FromStackPruneStep(v StackPruneStep) error {
	v.Action = "stack.prune"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackPruneStep performs a merge with any union data inside the PipelineSteps, using the provided StackPruneStep
func (t *PipelineSteps) MergeStackPruneStep(v StackPruneStep) error {
	v.Action = "stack.prune"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookPostStep returns the union data inside the PipelineSteps as a WebhookPostStep
func (t PipelineSteps) AsWebhookPostStep() (WebhookPostStep, error) {
	var body WebhookPostStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookPostStep overwrites any union data inside the PipelineSteps as the provided WebhookPostStep
func (t *PipelineSteps) FromWebhookPostStep(v WebhookPostStep) error {
	v.Action = "webhook.post"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookPostStep performs a merge with any union data inside the PipelineSteps, using the provided WebhookPostStep
func (t *PipelineSteps) MergeWebhookPostStep(v WebhookPostStep) error {
	v.Action = "webhook.post"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookGetStep returns the union data inside the PipelineSteps as a WebhookGetStep
func (t PipelineSteps) AsWebhookGetStep() (WebhookGetStep, error) {
	var body WebhookGetStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookGetStep overwrites any union data inside the PipelineSteps as the provided WebhookGetStep
func (t *PipelineSteps) FromWebhookGetStep(v WebhookGetStep) error {
	v.Action = "webhook.get"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookGetStep performs a merge with any union data inside the PipelineSteps, using the provided WebhookGetStep
func (t *PipelineSteps) MergeWebhookGetStep(v WebhookGetStep) error {
	v.Action = "webhook.get"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSleepStep returns the union data inside the PipelineSteps as a SleepStep
func (t PipelineSteps) AsSleepStep() (SleepStep, error) {
	var body SleepStep
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSleepStep overwrites any union data inside the PipelineSteps as the provided SleepStep
func (t *PipelineSteps) FromSleepStep(v SleepStep) error {
	v.Action = "sleep"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSleepStep performs a merge with any union data inside the PipelineSteps, using the provided SleepStep
func (t *PipelineSteps) MergeSleepStep(v SleepStep) error {
	v.Action = "sleep"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PipelineSteps) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PipelineSteps) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "container.create":
		return t.AsContainerCreateStep()
	case "container.delete":
		return t.AsContainerDeleteStep()
	case "container.function.trigger":
		return t.AsContainerFunctionTriggerStep()
	case "container.reimage":
		return t.AsContainerReimageStep()
	case "container.restart":
		return t.AsContainerRestartStep()
	case "container.start":
		return t.AsContainerStartStep()
	case "container.stop":
		return t.AsContainerStopStep()
	case "environment.create":
		return t.AsEnvironmentCreateStep()
	case "environment.delete":
		return t.AsEnvironmentDeleteStep()
	case "environment.deployment.healthy.watch":
		return t.AsEnvironmentDeploymentHealthyWatchStep()
	case "environment.deployment.start":
		return t.AsEnvironmentDeploymentStartStep()
	case "environment.deployment.stop":
		return t.AsEnvironmentDeploymentStopStep()
	case "environment.deployments.prune":
		return t.AsEnvironmentDeploymentsPruneStep()
	case "environment.deployments.tag":
		return t.AsEnvironmentDeploymentsTagStep()
	case "environment.start":
		return t.AsEnvironmentStartStep()
	case "environment.stop":
		return t.AsEnvironmentStopStep()
	case "image.create":
		return t.AsImageCreateStep()
	case "image.create-import":
		return t.AsImageCreateImportStep()
	case "image.import":
		return t.AsImageImportStep()
	case "images.prune":
		return t.AsImagesPruneStep()
	case "sleep":
		return t.AsSleepStep()
	case "stack.build.create":
		return t.AsStackBuildCreateStep()
	case "stack.build.deploy":
		return t.AsStackBuildDeployStep()
	case "stack.build.generate":
		return t.AsStackBuildGenerateStep()
	case "stack.prune":
		return t.AsStackPruneStep()
	case "webhook.get":
		return t.AsWebhookGetStep()
	case "webhook.post":
		return t.AsWebhookPostStep()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PipelineSteps) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PipelineSteps) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPipelineTriggerAction returns the union data inside the PipelineTask as a PipelineTriggerAction
func (t PipelineTask) AsPipelineTriggerAction() (PipelineTriggerAction, error) {
	var body PipelineTriggerAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPipelineTriggerAction overwrites any union data inside the PipelineTask as the provided PipelineTriggerAction
func (t *PipelineTask) FromPipelineTriggerAction(v PipelineTriggerAction) error {
	v.Action = "trigger"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePipelineTriggerAction performs a merge with any union data inside the PipelineTask, using the provided PipelineTriggerAction
func (t *PipelineTask) MergePipelineTriggerAction(v PipelineTriggerAction) error {
	v.Action = "trigger"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPipelineRerunAction returns the union data inside the PipelineTask as a PipelineRerunAction
func (t PipelineTask) AsPipelineRerunAction() (PipelineRerunAction, error) {
	var body PipelineRerunAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPipelineRerunAction overwrites any union data inside the PipelineTask as the provided PipelineRerunAction
func (t *PipelineTask) FromPipelineRerunAction(v PipelineRerunAction) error {
	v.Action = "rerun"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePipelineRerunAction performs a merge with any union data inside the PipelineTask, using the provided PipelineRerunAction
func (t *PipelineTask) MergePipelineRerunAction(v PipelineRerunAction) error {
	v.Action = "rerun"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PipelineTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t PipelineTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "rerun":
		return t.AsPipelineRerunAction()
	case "trigger":
		return t.AsPipelineTriggerAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t PipelineTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PipelineTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRegistryAuthUser returns the union data inside the RegistryAuth as a RegistryAuthUser
func (t RegistryAuth) AsRegistryAuthUser() (RegistryAuthUser, error) {
	var body RegistryAuthUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegistryAuthUser overwrites any union data inside the RegistryAuth as the provided RegistryAuthUser
func (t *RegistryAuth) FromRegistryAuthUser(v RegistryAuthUser) error {
	v.Type = "user"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegistryAuthUser performs a merge with any union data inside the RegistryAuth, using the provided RegistryAuthUser
func (t *RegistryAuth) MergeRegistryAuthUser(v RegistryAuthUser) error {
	v.Type = "user"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRegistryAuthProvider returns the union data inside the RegistryAuth as a RegistryAuthProvider
func (t RegistryAuth) AsRegistryAuthProvider() (RegistryAuthProvider, error) {
	var body RegistryAuthProvider
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegistryAuthProvider overwrites any union data inside the RegistryAuth as the provided RegistryAuthProvider
func (t *RegistryAuth) FromRegistryAuthProvider(v RegistryAuthProvider) error {
	v.Type = "provider"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegistryAuthProvider performs a merge with any union data inside the RegistryAuth, using the provided RegistryAuthProvider
func (t *RegistryAuth) MergeRegistryAuthProvider(v RegistryAuthProvider) error {
	v.Type = "provider"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRegistryAuthWebhook returns the union data inside the RegistryAuth as a RegistryAuthWebhook
func (t RegistryAuth) AsRegistryAuthWebhook() (RegistryAuthWebhook, error) {
	var body RegistryAuthWebhook
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegistryAuthWebhook overwrites any union data inside the RegistryAuth as the provided RegistryAuthWebhook
func (t *RegistryAuth) FromRegistryAuthWebhook(v RegistryAuthWebhook) error {
	v.Type = "webhook"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegistryAuthWebhook performs a merge with any union data inside the RegistryAuth, using the provided RegistryAuthWebhook
func (t *RegistryAuth) MergeRegistryAuthWebhook(v RegistryAuthWebhook) error {
	v.Type = "webhook"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RegistryAuth) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RegistryAuth) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "provider":
		return t.AsRegistryAuthProvider()
	case "user":
		return t.AsRegistryAuthUser()
	case "webhook":
		return t.AsRegistryAuthWebhook()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RegistryAuth) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RegistryAuth) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCredentialsHTTP returns the union data inside the RepoType_Auth as a CredentialsHTTP
func (t RepoType_Auth) AsCredentialsHTTP() (CredentialsHTTP, error) {
	var body CredentialsHTTP
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCredentialsHTTP overwrites any union data inside the RepoType_Auth as the provided CredentialsHTTP
func (t *RepoType_Auth) FromCredentialsHTTP(v CredentialsHTTP) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCredentialsHTTP performs a merge with any union data inside the RepoType_Auth, using the provided CredentialsHTTP
func (t *RepoType_Auth) MergeCredentialsHTTP(v CredentialsHTTP) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCredentialsSSH returns the union data inside the RepoType_Auth as a CredentialsSSH
func (t RepoType_Auth) AsCredentialsSSH() (CredentialsSSH, error) {
	var body CredentialsSSH
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCredentialsSSH overwrites any union data inside the RepoType_Auth as the provided CredentialsSSH
func (t *RepoType_Auth) FromCredentialsSSH(v CredentialsSSH) error {
	v.Type = "ssh"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCredentialsSSH performs a merge with any union data inside the RepoType_Auth, using the provided CredentialsSSH
func (t *RepoType_Auth) MergeCredentialsSSH(v CredentialsSSH) error {
	v.Type = "ssh"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RepoType_Auth) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RepoType_Auth) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "http":
		return t.AsCredentialsHTTP()
	case "ssh":
		return t.AsCredentialsSSH()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RepoType_Auth) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RepoType_Auth) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsScaleThresholdMetricRam returns the union data inside the ScaleThresholdMetric as a ScaleThresholdMetricRam
func (t ScaleThresholdMetric) AsScaleThresholdMetricRam() (ScaleThresholdMetricRam, error) {
	var body ScaleThresholdMetricRam
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScaleThresholdMetricRam overwrites any union data inside the ScaleThresholdMetric as the provided ScaleThresholdMetricRam
func (t *ScaleThresholdMetric) FromScaleThresholdMetricRam(v ScaleThresholdMetricRam) error {
	v.Type = "ram"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScaleThresholdMetricRam performs a merge with any union data inside the ScaleThresholdMetric, using the provided ScaleThresholdMetricRam
func (t *ScaleThresholdMetric) MergeScaleThresholdMetricRam(v ScaleThresholdMetricRam) error {
	v.Type = "ram"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScaleThresholdMetricCpu returns the union data inside the ScaleThresholdMetric as a ScaleThresholdMetricCpu
func (t ScaleThresholdMetric) AsScaleThresholdMetricCpu() (ScaleThresholdMetricCpu, error) {
	var body ScaleThresholdMetricCpu
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScaleThresholdMetricCpu overwrites any union data inside the ScaleThresholdMetric as the provided ScaleThresholdMetricCpu
func (t *ScaleThresholdMetric) FromScaleThresholdMetricCpu(v ScaleThresholdMetricCpu) error {
	v.Type = "cpu"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScaleThresholdMetricCpu performs a merge with any union data inside the ScaleThresholdMetric, using the provided ScaleThresholdMetricCpu
func (t *ScaleThresholdMetric) MergeScaleThresholdMetricCpu(v ScaleThresholdMetricCpu) error {
	v.Type = "cpu"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScaleThresholdMetricNetworkConnections returns the union data inside the ScaleThresholdMetric as a ScaleThresholdMetricNetworkConnections
func (t ScaleThresholdMetric) AsScaleThresholdMetricNetworkConnections() (ScaleThresholdMetricNetworkConnections, error) {
	var body ScaleThresholdMetricNetworkConnections
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScaleThresholdMetricNetworkConnections overwrites any union data inside the ScaleThresholdMetric as the provided ScaleThresholdMetricNetworkConnections
func (t *ScaleThresholdMetric) FromScaleThresholdMetricNetworkConnections(v ScaleThresholdMetricNetworkConnections) error {
	v.Type = "network-connections"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScaleThresholdMetricNetworkConnections performs a merge with any union data inside the ScaleThresholdMetric, using the provided ScaleThresholdMetricNetworkConnections
func (t *ScaleThresholdMetric) MergeScaleThresholdMetricNetworkConnections(v ScaleThresholdMetricNetworkConnections) error {
	v.Type = "network-connections"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScaleThresholdMetricNetworkRequests returns the union data inside the ScaleThresholdMetric as a ScaleThresholdMetricNetworkRequests
func (t ScaleThresholdMetric) AsScaleThresholdMetricNetworkRequests() (ScaleThresholdMetricNetworkRequests, error) {
	var body ScaleThresholdMetricNetworkRequests
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScaleThresholdMetricNetworkRequests overwrites any union data inside the ScaleThresholdMetric as the provided ScaleThresholdMetricNetworkRequests
func (t *ScaleThresholdMetric) FromScaleThresholdMetricNetworkRequests(v ScaleThresholdMetricNetworkRequests) error {
	v.Type = "network-requests"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScaleThresholdMetricNetworkRequests performs a merge with any union data inside the ScaleThresholdMetric, using the provided ScaleThresholdMetricNetworkRequests
func (t *ScaleThresholdMetric) MergeScaleThresholdMetricNetworkRequests(v ScaleThresholdMetricNetworkRequests) error {
	v.Type = "network-requests"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScaleThresholdMetricNetworkThroughput returns the union data inside the ScaleThresholdMetric as a ScaleThresholdMetricNetworkThroughput
func (t ScaleThresholdMetric) AsScaleThresholdMetricNetworkThroughput() (ScaleThresholdMetricNetworkThroughput, error) {
	var body ScaleThresholdMetricNetworkThroughput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScaleThresholdMetricNetworkThroughput overwrites any union data inside the ScaleThresholdMetric as the provided ScaleThresholdMetricNetworkThroughput
func (t *ScaleThresholdMetric) FromScaleThresholdMetricNetworkThroughput(v ScaleThresholdMetricNetworkThroughput) error {
	v.Type = "network-throughput"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScaleThresholdMetricNetworkThroughput performs a merge with any union data inside the ScaleThresholdMetric, using the provided ScaleThresholdMetricNetworkThroughput
func (t *ScaleThresholdMetric) MergeScaleThresholdMetricNetworkThroughput(v ScaleThresholdMetricNetworkThroughput) error {
	v.Type = "network-throughput"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsScaleThresholdMetricCustom returns the union data inside the ScaleThresholdMetric as a ScaleThresholdMetricCustom
func (t ScaleThresholdMetric) AsScaleThresholdMetricCustom() (ScaleThresholdMetricCustom, error) {
	var body ScaleThresholdMetricCustom
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromScaleThresholdMetricCustom overwrites any union data inside the ScaleThresholdMetric as the provided ScaleThresholdMetricCustom
func (t *ScaleThresholdMetric) FromScaleThresholdMetricCustom(v ScaleThresholdMetricCustom) error {
	v.Type = "custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeScaleThresholdMetricCustom performs a merge with any union data inside the ScaleThresholdMetric, using the provided ScaleThresholdMetricCustom
func (t *ScaleThresholdMetric) MergeScaleThresholdMetricCustom(v ScaleThresholdMetricCustom) error {
	v.Type = "custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScaleThresholdMetric) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ScaleThresholdMetric) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "cpu":
		return t.AsScaleThresholdMetricCpu()
	case "custom":
		return t.AsScaleThresholdMetricCustom()
	case "network-connections":
		return t.AsScaleThresholdMetricNetworkConnections()
	case "network-requests":
		return t.AsScaleThresholdMetricNetworkRequests()
	case "network-throughput":
		return t.AsScaleThresholdMetricNetworkThroughput()
	case "ram":
		return t.AsScaleThresholdMetricRam()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ScaleThresholdMetric) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScaleThresholdMetric) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsURLSource returns the union data inside the ScopedVariable_Source as a URLSource
func (t ScopedVariable_Source) AsURLSource() (URLSource, error) {
	var body URLSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromURLSource overwrites any union data inside the ScopedVariable_Source as the provided URLSource
func (t *ScopedVariable_Source) FromURLSource(v URLSource) error {
	v.Type = "url"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeURLSource performs a merge with any union data inside the ScopedVariable_Source, using the provided URLSource
func (t *ScopedVariable_Source) MergeURLSource(v URLSource) error {
	v.Type = "url"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRawSource returns the union data inside the ScopedVariable_Source as a RawSource
func (t ScopedVariable_Source) AsRawSource() (RawSource, error) {
	var body RawSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRawSource overwrites any union data inside the ScopedVariable_Source as the provided RawSource
func (t *ScopedVariable_Source) FromRawSource(v RawSource) error {
	v.Type = "raw"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRawSource performs a merge with any union data inside the ScopedVariable_Source, using the provided RawSource
func (t *ScopedVariable_Source) MergeRawSource(v RawSource) error {
	v.Type = "raw"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScopedVariable_Source) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ScopedVariable_Source) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "raw":
		return t.AsRawSource()
	case "url":
		return t.AsURLSource()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ScopedVariable_Source) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScopedVariable_Source) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsReconfigureSdnNetworkAction returns the union data inside the SdnNetworkTask as a ReconfigureSdnNetworkAction
func (t SdnNetworkTask) AsReconfigureSdnNetworkAction() (ReconfigureSdnNetworkAction, error) {
	var body ReconfigureSdnNetworkAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReconfigureSdnNetworkAction overwrites any union data inside the SdnNetworkTask as the provided ReconfigureSdnNetworkAction
func (t *SdnNetworkTask) FromReconfigureSdnNetworkAction(v ReconfigureSdnNetworkAction) error {
	v.Action = "reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReconfigureSdnNetworkAction performs a merge with any union data inside the SdnNetworkTask, using the provided ReconfigureSdnNetworkAction
func (t *SdnNetworkTask) MergeReconfigureSdnNetworkAction(v ReconfigureSdnNetworkAction) error {
	v.Action = "reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SdnNetworkTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SdnNetworkTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "reconfigure":
		return t.AsReconfigureSdnNetworkAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SdnNetworkTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SdnNetworkTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsServerReconfigureSharedFsAction returns the union data inside the ServerTask as a ServerReconfigureSharedFsAction
func (t ServerTask) AsServerReconfigureSharedFsAction() (ServerReconfigureSharedFsAction, error) {
	var body ServerReconfigureSharedFsAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerReconfigureSharedFsAction overwrites any union data inside the ServerTask as the provided ServerReconfigureSharedFsAction
func (t *ServerTask) FromServerReconfigureSharedFsAction(v ServerReconfigureSharedFsAction) error {
	v.Action = "sharedfs.reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerReconfigureSharedFsAction performs a merge with any union data inside the ServerTask, using the provided ServerReconfigureSharedFsAction
func (t *ServerTask) MergeServerReconfigureSharedFsAction(v ServerReconfigureSharedFsAction) error {
	v.Action = "sharedfs.reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServerReconfigureFeaturesAction returns the union data inside the ServerTask as a ServerReconfigureFeaturesAction
func (t ServerTask) AsServerReconfigureFeaturesAction() (ServerReconfigureFeaturesAction, error) {
	var body ServerReconfigureFeaturesAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerReconfigureFeaturesAction overwrites any union data inside the ServerTask as the provided ServerReconfigureFeaturesAction
func (t *ServerTask) FromServerReconfigureFeaturesAction(v ServerReconfigureFeaturesAction) error {
	v.Action = "features.reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerReconfigureFeaturesAction performs a merge with any union data inside the ServerTask, using the provided ServerReconfigureFeaturesAction
func (t *ServerTask) MergeServerReconfigureFeaturesAction(v ServerReconfigureFeaturesAction) error {
	v.Action = "features.reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServerRestartAction returns the union data inside the ServerTask as a ServerRestartAction
func (t ServerTask) AsServerRestartAction() (ServerRestartAction, error) {
	var body ServerRestartAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerRestartAction overwrites any union data inside the ServerTask as the provided ServerRestartAction
func (t *ServerTask) FromServerRestartAction(v ServerRestartAction) error {
	v.Action = "restart"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerRestartAction performs a merge with any union data inside the ServerTask, using the provided ServerRestartAction
func (t *ServerTask) MergeServerRestartAction(v ServerRestartAction) error {
	v.Action = "restart"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServerPowerOffAction returns the union data inside the ServerTask as a ServerPowerOffAction
func (t ServerTask) AsServerPowerOffAction() (ServerPowerOffAction, error) {
	var body ServerPowerOffAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerPowerOffAction overwrites any union data inside the ServerTask as the provided ServerPowerOffAction
func (t *ServerTask) FromServerPowerOffAction(v ServerPowerOffAction) error {
	v.Action = "power-off"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerPowerOffAction performs a merge with any union data inside the ServerTask, using the provided ServerPowerOffAction
func (t *ServerTask) MergeServerPowerOffAction(v ServerPowerOffAction) error {
	v.Action = "power-off"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServerAuthResetAction returns the union data inside the ServerTask as a ServerAuthResetAction
func (t ServerTask) AsServerAuthResetAction() (ServerAuthResetAction, error) {
	var body ServerAuthResetAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerAuthResetAction overwrites any union data inside the ServerTask as the provided ServerAuthResetAction
func (t *ServerTask) FromServerAuthResetAction(v ServerAuthResetAction) error {
	v.Action = "auth.reset"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerAuthResetAction performs a merge with any union data inside the ServerTask, using the provided ServerAuthResetAction
func (t *ServerTask) MergeServerAuthResetAction(v ServerAuthResetAction) error {
	v.Action = "auth.reset"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServerRestartComputeAction returns the union data inside the ServerTask as a ServerRestartComputeAction
func (t ServerTask) AsServerRestartComputeAction() (ServerRestartComputeAction, error) {
	var body ServerRestartComputeAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerRestartComputeAction overwrites any union data inside the ServerTask as the provided ServerRestartComputeAction
func (t *ServerTask) FromServerRestartComputeAction(v ServerRestartComputeAction) error {
	v.Action = "compute.restart"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerRestartComputeAction performs a merge with any union data inside the ServerTask, using the provided ServerRestartComputeAction
func (t *ServerTask) MergeServerRestartComputeAction(v ServerRestartComputeAction) error {
	v.Action = "compute.restart"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServerRestartComputeSpawnerAction returns the union data inside the ServerTask as a ServerRestartComputeSpawnerAction
func (t ServerTask) AsServerRestartComputeSpawnerAction() (ServerRestartComputeSpawnerAction, error) {
	var body ServerRestartComputeSpawnerAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerRestartComputeSpawnerAction overwrites any union data inside the ServerTask as the provided ServerRestartComputeSpawnerAction
func (t *ServerTask) FromServerRestartComputeSpawnerAction(v ServerRestartComputeSpawnerAction) error {
	v.Action = "compute.spawner.restart"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerRestartComputeSpawnerAction performs a merge with any union data inside the ServerTask, using the provided ServerRestartComputeSpawnerAction
func (t *ServerTask) MergeServerRestartComputeSpawnerAction(v ServerRestartComputeSpawnerAction) error {
	v.Action = "compute.spawner.restart"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServerEvacuateAction returns the union data inside the ServerTask as a ServerEvacuateAction
func (t ServerTask) AsServerEvacuateAction() (ServerEvacuateAction, error) {
	var body ServerEvacuateAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerEvacuateAction overwrites any union data inside the ServerTask as the provided ServerEvacuateAction
func (t *ServerTask) FromServerEvacuateAction(v ServerEvacuateAction) error {
	v.Action = "evacuation.start"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerEvacuateAction performs a merge with any union data inside the ServerTask, using the provided ServerEvacuateAction
func (t *ServerTask) MergeServerEvacuateAction(v ServerEvacuateAction) error {
	v.Action = "evacuation.start"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServerEvacuateResetAction returns the union data inside the ServerTask as a ServerEvacuateResetAction
func (t ServerTask) AsServerEvacuateResetAction() (ServerEvacuateResetAction, error) {
	var body ServerEvacuateResetAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerEvacuateResetAction overwrites any union data inside the ServerTask as the provided ServerEvacuateResetAction
func (t *ServerTask) FromServerEvacuateResetAction(v ServerEvacuateResetAction) error {
	v.Action = "evacuation.reset"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerEvacuateResetAction performs a merge with any union data inside the ServerTask, using the provided ServerEvacuateResetAction
func (t *ServerTask) MergeServerEvacuateResetAction(v ServerEvacuateResetAction) error {
	v.Action = "evacuation.reset"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServerUnquarantineAction returns the union data inside the ServerTask as a ServerUnquarantineAction
func (t ServerTask) AsServerUnquarantineAction() (ServerUnquarantineAction, error) {
	var body ServerUnquarantineAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerUnquarantineAction overwrites any union data inside the ServerTask as the provided ServerUnquarantineAction
func (t *ServerTask) FromServerUnquarantineAction(v ServerUnquarantineAction) error {
	v.Action = "unquarantine"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerUnquarantineAction performs a merge with any union data inside the ServerTask, using the provided ServerUnquarantineAction
func (t *ServerTask) MergeServerUnquarantineAction(v ServerUnquarantineAction) error {
	v.Action = "unquarantine"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ServerTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ServerTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "auth.reset":
		return t.AsServerAuthResetAction()
	case "compute.restart":
		return t.AsServerRestartComputeAction()
	case "compute.spawner.restart":
		return t.AsServerRestartComputeSpawnerAction()
	case "evacuation.reset":
		return t.AsServerEvacuateResetAction()
	case "evacuation.start":
		return t.AsServerEvacuateAction()
	case "features.reconfigure":
		return t.AsServerReconfigureFeaturesAction()
	case "power-off":
		return t.AsServerPowerOffAction()
	case "restart":
		return t.AsServerRestartAction()
	case "sharedfs.reconfigure":
		return t.AsServerReconfigureSharedFsAction()
	case "unquarantine":
		return t.AsServerUnquarantineAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ServerTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ServerTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackBuildGenerateAction returns the union data inside the StackBuildTask as a StackBuildGenerateAction
func (t StackBuildTask) AsStackBuildGenerateAction() (StackBuildGenerateAction, error) {
	var body StackBuildGenerateAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackBuildGenerateAction overwrites any union data inside the StackBuildTask as the provided StackBuildGenerateAction
func (t *StackBuildTask) FromStackBuildGenerateAction(v StackBuildGenerateAction) error {
	v.Action = "generate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackBuildGenerateAction performs a merge with any union data inside the StackBuildTask, using the provided StackBuildGenerateAction
func (t *StackBuildTask) MergeStackBuildGenerateAction(v StackBuildGenerateAction) error {
	v.Action = "generate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackBuildDeployAction returns the union data inside the StackBuildTask as a StackBuildDeployAction
func (t StackBuildTask) AsStackBuildDeployAction() (StackBuildDeployAction, error) {
	var body StackBuildDeployAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackBuildDeployAction overwrites any union data inside the StackBuildTask as the provided StackBuildDeployAction
func (t *StackBuildTask) FromStackBuildDeployAction(v StackBuildDeployAction) error {
	v.Action = "deploy"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackBuildDeployAction performs a merge with any union data inside the StackBuildTask, using the provided StackBuildDeployAction
func (t *StackBuildTask) MergeStackBuildDeployAction(v StackBuildDeployAction) error {
	v.Action = "deploy"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackBuildTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t StackBuildTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "deploy":
		return t.AsStackBuildDeployAction()
	case "generate":
		return t.AsStackBuildGenerateAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t StackBuildTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackBuildTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCredentialsHTTP returns the union data inside the StackRepoSource_Details_Auth as a CredentialsHTTP
func (t StackRepoSource_Details_Auth) AsCredentialsHTTP() (CredentialsHTTP, error) {
	var body CredentialsHTTP
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCredentialsHTTP overwrites any union data inside the StackRepoSource_Details_Auth as the provided CredentialsHTTP
func (t *StackRepoSource_Details_Auth) FromCredentialsHTTP(v CredentialsHTTP) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCredentialsHTTP performs a merge with any union data inside the StackRepoSource_Details_Auth, using the provided CredentialsHTTP
func (t *StackRepoSource_Details_Auth) MergeCredentialsHTTP(v CredentialsHTTP) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCredentialsSSH returns the union data inside the StackRepoSource_Details_Auth as a CredentialsSSH
func (t StackRepoSource_Details_Auth) AsCredentialsSSH() (CredentialsSSH, error) {
	var body CredentialsSSH
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCredentialsSSH overwrites any union data inside the StackRepoSource_Details_Auth as the provided CredentialsSSH
func (t *StackRepoSource_Details_Auth) FromCredentialsSSH(v CredentialsSSH) error {
	v.Type = "ssh"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCredentialsSSH performs a merge with any union data inside the StackRepoSource_Details_Auth, using the provided CredentialsSSH
func (t *StackRepoSource_Details_Auth) MergeCredentialsSSH(v CredentialsSSH) error {
	v.Type = "ssh"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackRepoSource_Details_Auth) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t StackRepoSource_Details_Auth) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "http":
		return t.AsCredentialsHTTP()
	case "ssh":
		return t.AsCredentialsSSH()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t StackRepoSource_Details_Auth) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackRepoSource_Details_Auth) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackRepoSource returns the union data inside the StackSource as a StackRepoSource
func (t StackSource) AsStackRepoSource() (StackRepoSource, error) {
	var body StackRepoSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackRepoSource overwrites any union data inside the StackSource as the provided StackRepoSource
func (t *StackSource) FromStackRepoSource(v StackRepoSource) error {
	v.Type = "git-repo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackRepoSource performs a merge with any union data inside the StackSource, using the provided StackRepoSource
func (t *StackSource) MergeStackRepoSource(v StackRepoSource) error {
	v.Type = "git-repo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackRawSource returns the union data inside the StackSource as a StackRawSource
func (t StackSource) AsStackRawSource() (StackRawSource, error) {
	var body StackRawSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackRawSource overwrites any union data inside the StackSource as the provided StackRawSource
func (t *StackSource) FromStackRawSource(v StackRawSource) error {
	v.Type = "raw"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackRawSource performs a merge with any union data inside the StackSource, using the provided StackRawSource
func (t *StackSource) MergeStackRawSource(v StackRawSource) error {
	v.Type = "raw"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSource) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t StackSource) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "git-repo":
		return t.AsStackRepoSource()
	case "raw":
		return t.AsStackRawSource()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t StackSource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecAbout0 returns the union data inside the StackSpec_About as a StackSpecAbout0
func (t StackSpec_About) AsStackSpecAbout0() (StackSpecAbout0, error) {
	var body StackSpecAbout0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecAbout0 overwrites any union data inside the StackSpec_About as the provided StackSpecAbout0
func (t *StackSpec_About) FromStackSpecAbout0(v StackSpecAbout0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecAbout0 performs a merge with any union data inside the StackSpec_About, using the provided StackSpecAbout0
func (t *StackSpec_About) MergeStackSpecAbout0(v StackSpecAbout0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpec_About as a StackVariable
func (t StackSpec_About) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpec_About as the provided StackVariable
func (t *StackSpec_About) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpec_About, using the provided StackVariable
func (t *StackSpec_About) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpec_About) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpec_About) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecAnnotations0 returns the union data inside the StackSpec_Annotations as a StackSpecAnnotations0
func (t StackSpec_Annotations) AsStackSpecAnnotations0() (StackSpecAnnotations0, error) {
	var body StackSpecAnnotations0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecAnnotations0 overwrites any union data inside the StackSpec_Annotations as the provided StackSpecAnnotations0
func (t *StackSpec_Annotations) FromStackSpecAnnotations0(v StackSpecAnnotations0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecAnnotations0 performs a merge with any union data inside the StackSpec_Annotations, using the provided StackSpecAnnotations0
func (t *StackSpec_Annotations) MergeStackSpecAnnotations0(v StackSpecAnnotations0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpec_Annotations as a StackVariable
func (t StackSpec_Annotations) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpec_Annotations as the provided StackVariable
func (t *StackSpec_Annotations) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpec_Annotations, using the provided StackVariable
func (t *StackSpec_Annotations) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpec_Annotations) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpec_Annotations) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainers0 returns the union data inside the StackSpec_Containers as a StackSpecContainers0
func (t StackSpec_Containers) AsStackSpecContainers0() (StackSpecContainers0, error) {
	var body StackSpecContainers0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainers0 overwrites any union data inside the StackSpec_Containers as the provided StackSpecContainers0
func (t *StackSpec_Containers) FromStackSpecContainers0(v StackSpecContainers0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainers0 performs a merge with any union data inside the StackSpec_Containers, using the provided StackSpecContainers0
func (t *StackSpec_Containers) MergeStackSpecContainers0(v StackSpecContainers0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpec_Containers as a StackVariable
func (t StackSpec_Containers) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpec_Containers as the provided StackVariable
func (t *StackSpec_Containers) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpec_Containers, using the provided StackVariable
func (t *StackSpec_Containers) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpec_Containers) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpec_Containers) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecMonitoringConfig returns the union data inside the StackSpec_Monitoring as a StackSpecMonitoringConfig
func (t StackSpec_Monitoring) AsStackSpecMonitoringConfig() (StackSpecMonitoringConfig, error) {
	var body StackSpecMonitoringConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecMonitoringConfig overwrites any union data inside the StackSpec_Monitoring as the provided StackSpecMonitoringConfig
func (t *StackSpec_Monitoring) FromStackSpecMonitoringConfig(v StackSpecMonitoringConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecMonitoringConfig performs a merge with any union data inside the StackSpec_Monitoring, using the provided StackSpecMonitoringConfig
func (t *StackSpec_Monitoring) MergeStackSpecMonitoringConfig(v StackSpecMonitoringConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpec_Monitoring as a StackVariable
func (t StackSpec_Monitoring) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpec_Monitoring as the provided StackVariable
func (t *StackSpec_Monitoring) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpec_Monitoring, using the provided StackVariable
func (t *StackSpec_Monitoring) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpec_Monitoring) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpec_Monitoring) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariables0 returns the union data inside the StackSpec_ScopedVariables as a StackSpecScopedVariables0
func (t StackSpec_ScopedVariables) AsStackSpecScopedVariables0() (StackSpecScopedVariables0, error) {
	var body StackSpecScopedVariables0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariables0 overwrites any union data inside the StackSpec_ScopedVariables as the provided StackSpecScopedVariables0
func (t *StackSpec_ScopedVariables) FromStackSpecScopedVariables0(v StackSpecScopedVariables0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariables0 performs a merge with any union data inside the StackSpec_ScopedVariables, using the provided StackSpecScopedVariables0
func (t *StackSpec_ScopedVariables) MergeStackSpecScopedVariables0(v StackSpecScopedVariables0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpec_ScopedVariables as a StackVariable
func (t StackSpec_ScopedVariables) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpec_ScopedVariables as the provided StackVariable
func (t *StackSpec_ScopedVariables) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpec_ScopedVariables, using the provided StackVariable
func (t *StackSpec_ScopedVariables) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpec_ScopedVariables) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpec_ScopedVariables) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecServices0 returns the union data inside the StackSpec_Services as a StackSpecServices0
func (t StackSpec_Services) AsStackSpecServices0() (StackSpecServices0, error) {
	var body StackSpecServices0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecServices0 overwrites any union data inside the StackSpec_Services as the provided StackSpecServices0
func (t *StackSpec_Services) FromStackSpecServices0(v StackSpecServices0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecServices0 performs a merge with any union data inside the StackSpec_Services, using the provided StackSpecServices0
func (t *StackSpec_Services) MergeStackSpecServices0(v StackSpecServices0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpec_Services as a StackVariable
func (t StackSpec_Services) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpec_Services as the provided StackVariable
func (t *StackSpec_Services) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpec_Services, using the provided StackVariable
func (t *StackSpec_Services) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpec_Services) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpec_Services) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerAnnotations0 returns the union data inside the StackSpecContainer_Annotations as a StackSpecContainerAnnotations0
func (t StackSpecContainer_Annotations) AsStackSpecContainerAnnotations0() (StackSpecContainerAnnotations0, error) {
	var body StackSpecContainerAnnotations0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerAnnotations0 overwrites any union data inside the StackSpecContainer_Annotations as the provided StackSpecContainerAnnotations0
func (t *StackSpecContainer_Annotations) FromStackSpecContainerAnnotations0(v StackSpecContainerAnnotations0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerAnnotations0 performs a merge with any union data inside the StackSpecContainer_Annotations, using the provided StackSpecContainerAnnotations0
func (t *StackSpecContainer_Annotations) MergeStackSpecContainerAnnotations0(v StackSpecContainerAnnotations0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainer_Annotations as a StackVariable
func (t StackSpecContainer_Annotations) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainer_Annotations as the provided StackVariable
func (t *StackSpecContainer_Annotations) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainer_Annotations, using the provided StackVariable
func (t *StackSpecContainer_Annotations) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainer_Annotations) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainer_Annotations) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeploy returns the union data inside the StackSpecContainer_Config_0_Deploy as a StackSpecContainerConfigDeploy
func (t StackSpecContainer_Config_0_Deploy) AsStackSpecContainerConfigDeploy() (StackSpecContainerConfigDeploy, error) {
	var body StackSpecContainerConfigDeploy
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeploy overwrites any union data inside the StackSpecContainer_Config_0_Deploy as the provided StackSpecContainerConfigDeploy
func (t *StackSpecContainer_Config_0_Deploy) FromStackSpecContainerConfigDeploy(v StackSpecContainerConfigDeploy) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeploy performs a merge with any union data inside the StackSpecContainer_Config_0_Deploy, using the provided StackSpecContainerConfigDeploy
func (t *StackSpecContainer_Config_0_Deploy) MergeStackSpecContainerConfigDeploy(v StackSpecContainerConfigDeploy) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainer_Config_0_Deploy as a StackVariable
func (t StackSpecContainer_Config_0_Deploy) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainer_Config_0_Deploy as the provided StackVariable
func (t *StackSpecContainer_Config_0_Deploy) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainer_Config_0_Deploy, using the provided StackVariable
func (t *StackSpecContainer_Config_0_Deploy) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainer_Config_0_Deploy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainer_Config_0_Deploy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigNetwork returns the union data inside the StackSpecContainer_Config_0_Network as a StackSpecContainerConfigNetwork
func (t StackSpecContainer_Config_0_Network) AsStackSpecContainerConfigNetwork() (StackSpecContainerConfigNetwork, error) {
	var body StackSpecContainerConfigNetwork
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigNetwork overwrites any union data inside the StackSpecContainer_Config_0_Network as the provided StackSpecContainerConfigNetwork
func (t *StackSpecContainer_Config_0_Network) FromStackSpecContainerConfigNetwork(v StackSpecContainerConfigNetwork) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigNetwork performs a merge with any union data inside the StackSpecContainer_Config_0_Network, using the provided StackSpecContainerConfigNetwork
func (t *StackSpecContainer_Config_0_Network) MergeStackSpecContainerConfigNetwork(v StackSpecContainerConfigNetwork) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainer_Config_0_Network as a StackVariable
func (t StackSpecContainer_Config_0_Network) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainer_Config_0_Network as the provided StackVariable
func (t *StackSpecContainer_Config_0_Network) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainer_Config_0_Network, using the provided StackVariable
func (t *StackSpecContainer_Config_0_Network) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainer_Config_0_Network) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainer_Config_0_Network) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfig0 returns the union data inside the StackSpecContainer_Config as a StackSpecContainerConfig0
func (t StackSpecContainer_Config) AsStackSpecContainerConfig0() (StackSpecContainerConfig0, error) {
	var body StackSpecContainerConfig0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfig0 overwrites any union data inside the StackSpecContainer_Config as the provided StackSpecContainerConfig0
func (t *StackSpecContainer_Config) FromStackSpecContainerConfig0(v StackSpecContainerConfig0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfig0 performs a merge with any union data inside the StackSpecContainer_Config, using the provided StackSpecContainerConfig0
func (t *StackSpecContainer_Config) MergeStackSpecContainerConfig0(v StackSpecContainerConfig0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainer_Config as a StackVariable
func (t StackSpecContainer_Config) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainer_Config as the provided StackVariable
func (t *StackSpecContainer_Config) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainer_Config, using the provided StackVariable
func (t *StackSpecContainer_Config) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainer_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainer_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerDeprecate0 returns the union data inside the StackSpecContainer_Deprecate as a StackSpecContainerDeprecate0
func (t StackSpecContainer_Deprecate) AsStackSpecContainerDeprecate0() (StackSpecContainerDeprecate0, error) {
	var body StackSpecContainerDeprecate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerDeprecate0 overwrites any union data inside the StackSpecContainer_Deprecate as the provided StackSpecContainerDeprecate0
func (t *StackSpecContainer_Deprecate) FromStackSpecContainerDeprecate0(v StackSpecContainerDeprecate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerDeprecate0 performs a merge with any union data inside the StackSpecContainer_Deprecate, using the provided StackSpecContainerDeprecate0
func (t *StackSpecContainer_Deprecate) MergeStackSpecContainerDeprecate0(v StackSpecContainerDeprecate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainer_Deprecate as a StackVariable
func (t StackSpecContainer_Deprecate) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainer_Deprecate as the provided StackVariable
func (t *StackSpecContainer_Deprecate) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainer_Deprecate, using the provided StackVariable
func (t *StackSpecContainer_Deprecate) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainer_Deprecate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainer_Deprecate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerImage returns the union data inside the StackSpecContainer_Image as a StackSpecContainerImage
func (t StackSpecContainer_Image) AsStackSpecContainerImage() (StackSpecContainerImage, error) {
	var body StackSpecContainerImage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerImage overwrites any union data inside the StackSpecContainer_Image as the provided StackSpecContainerImage
func (t *StackSpecContainer_Image) FromStackSpecContainerImage(v StackSpecContainerImage) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerImage performs a merge with any union data inside the StackSpecContainer_Image, using the provided StackSpecContainerImage
func (t *StackSpecContainer_Image) MergeStackSpecContainerImage(v StackSpecContainerImage) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainer_Image as a StackVariable
func (t StackSpecContainer_Image) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainer_Image as the provided StackVariable
func (t *StackSpecContainer_Image) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainer_Image, using the provided StackVariable
func (t *StackSpecContainer_Image) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainer_Image) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainer_Image) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerLock0 returns the union data inside the StackSpecContainer_Lock as a StackSpecContainerLock0
func (t StackSpecContainer_Lock) AsStackSpecContainerLock0() (StackSpecContainerLock0, error) {
	var body StackSpecContainerLock0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerLock0 overwrites any union data inside the StackSpecContainer_Lock as the provided StackSpecContainerLock0
func (t *StackSpecContainer_Lock) FromStackSpecContainerLock0(v StackSpecContainerLock0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerLock0 performs a merge with any union data inside the StackSpecContainer_Lock, using the provided StackSpecContainerLock0
func (t *StackSpecContainer_Lock) MergeStackSpecContainerLock0(v StackSpecContainerLock0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainer_Lock as a StackVariable
func (t StackSpecContainer_Lock) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainer_Lock as the provided StackVariable
func (t *StackSpecContainer_Lock) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainer_Lock, using the provided StackVariable
func (t *StackSpecContainer_Lock) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainer_Lock) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainer_Lock) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerStateful0 returns the union data inside the StackSpecContainer_Stateful as a StackSpecContainerStateful0
func (t StackSpecContainer_Stateful) AsStackSpecContainerStateful0() (StackSpecContainerStateful0, error) {
	var body StackSpecContainerStateful0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerStateful0 overwrites any union data inside the StackSpecContainer_Stateful as the provided StackSpecContainerStateful0
func (t *StackSpecContainer_Stateful) FromStackSpecContainerStateful0(v StackSpecContainerStateful0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerStateful0 performs a merge with any union data inside the StackSpecContainer_Stateful, using the provided StackSpecContainerStateful0
func (t *StackSpecContainer_Stateful) MergeStackSpecContainerStateful0(v StackSpecContainerStateful0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainer_Stateful as a StackVariable
func (t StackSpecContainer_Stateful) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainer_Stateful as the provided StackVariable
func (t *StackSpecContainer_Stateful) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainer_Stateful, using the provided StackVariable
func (t *StackSpecContainer_Stateful) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainer_Stateful) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainer_Stateful) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerVolumes0 returns the union data inside the StackSpecContainer_Volumes as a StackSpecContainerVolumes0
func (t StackSpecContainer_Volumes) AsStackSpecContainerVolumes0() (StackSpecContainerVolumes0, error) {
	var body StackSpecContainerVolumes0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerVolumes0 overwrites any union data inside the StackSpecContainer_Volumes as the provided StackSpecContainerVolumes0
func (t *StackSpecContainer_Volumes) FromStackSpecContainerVolumes0(v StackSpecContainerVolumes0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerVolumes0 performs a merge with any union data inside the StackSpecContainer_Volumes, using the provided StackSpecContainerVolumes0
func (t *StackSpecContainer_Volumes) MergeStackSpecContainerVolumes0(v StackSpecContainerVolumes0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainer_Volumes as a StackVariable
func (t StackSpecContainer_Volumes) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainer_Volumes as the provided StackVariable
func (t *StackSpecContainer_Volumes) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainer_Volumes, using the provided StackVariable
func (t *StackSpecContainer_Volumes) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainer_Volumes) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainer_Volumes) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployConstraints0NodeTags0All0 returns the union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All as a StackSpecContainerConfigDeployConstraints0NodeTags0All0
func (t StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All) AsStackSpecContainerConfigDeployConstraints0NodeTags0All0() (StackSpecContainerConfigDeployConstraints0NodeTags0All0, error) {
	var body StackSpecContainerConfigDeployConstraints0NodeTags0All0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployConstraints0NodeTags0All0 overwrites any union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All as the provided StackSpecContainerConfigDeployConstraints0NodeTags0All0
func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All) FromStackSpecContainerConfigDeployConstraints0NodeTags0All0(v StackSpecContainerConfigDeployConstraints0NodeTags0All0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployConstraints0NodeTags0All0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All, using the provided StackSpecContainerConfigDeployConstraints0NodeTags0All0
func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All) MergeStackSpecContainerConfigDeployConstraints0NodeTags0All0(v StackSpecContainerConfigDeployConstraints0NodeTags0All0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All as a StackVariable
func (t StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_All) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployConstraints0NodeTags0Any0 returns the union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any as a StackSpecContainerConfigDeployConstraints0NodeTags0Any0
func (t StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any) AsStackSpecContainerConfigDeployConstraints0NodeTags0Any0() (StackSpecContainerConfigDeployConstraints0NodeTags0Any0, error) {
	var body StackSpecContainerConfigDeployConstraints0NodeTags0Any0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployConstraints0NodeTags0Any0 overwrites any union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any as the provided StackSpecContainerConfigDeployConstraints0NodeTags0Any0
func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any) FromStackSpecContainerConfigDeployConstraints0NodeTags0Any0(v StackSpecContainerConfigDeployConstraints0NodeTags0Any0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployConstraints0NodeTags0Any0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any, using the provided StackSpecContainerConfigDeployConstraints0NodeTags0Any0
func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any) MergeStackSpecContainerConfigDeployConstraints0NodeTags0Any0(v StackSpecContainerConfigDeployConstraints0NodeTags0Any0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any as a StackVariable
func (t StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags_0_Any) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployConstraints0NodeTags0 returns the union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags as a StackSpecContainerConfigDeployConstraints0NodeTags0
func (t StackSpecContainerConfigDeploy_Constraints_0_Node_Tags) AsStackSpecContainerConfigDeployConstraints0NodeTags0() (StackSpecContainerConfigDeployConstraints0NodeTags0, error) {
	var body StackSpecContainerConfigDeployConstraints0NodeTags0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployConstraints0NodeTags0 overwrites any union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags as the provided StackSpecContainerConfigDeployConstraints0NodeTags0
func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags) FromStackSpecContainerConfigDeployConstraints0NodeTags0(v StackSpecContainerConfigDeployConstraints0NodeTags0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployConstraints0NodeTags0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags, using the provided StackSpecContainerConfigDeployConstraints0NodeTags0
func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags) MergeStackSpecContainerConfigDeployConstraints0NodeTags0(v StackSpecContainerConfigDeployConstraints0NodeTags0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags as a StackVariable
func (t StackSpecContainerConfigDeploy_Constraints_0_Node_Tags) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Constraints_0_Node_Tags, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Constraints_0_Node_Tags) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Constraints_0_Node_Tags) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployConstraints0 returns the union data inside the StackSpecContainerConfigDeploy_Constraints as a StackSpecContainerConfigDeployConstraints0
func (t StackSpecContainerConfigDeploy_Constraints) AsStackSpecContainerConfigDeployConstraints0() (StackSpecContainerConfigDeployConstraints0, error) {
	var body StackSpecContainerConfigDeployConstraints0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployConstraints0 overwrites any union data inside the StackSpecContainerConfigDeploy_Constraints as the provided StackSpecContainerConfigDeployConstraints0
func (t *StackSpecContainerConfigDeploy_Constraints) FromStackSpecContainerConfigDeployConstraints0(v StackSpecContainerConfigDeployConstraints0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployConstraints0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Constraints, using the provided StackSpecContainerConfigDeployConstraints0
func (t *StackSpecContainerConfigDeploy_Constraints) MergeStackSpecContainerConfigDeployConstraints0(v StackSpecContainerConfigDeployConstraints0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Constraints as a StackVariable
func (t StackSpecContainerConfigDeploy_Constraints) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Constraints as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Constraints) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Constraints, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Constraints) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Constraints) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Constraints) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployFunction0MaxPoolSize0 returns the union data inside the StackSpecContainerConfigDeploy_Function_0_MaxPoolSize as a StackSpecContainerConfigDeployFunction0MaxPoolSize0
func (t StackSpecContainerConfigDeploy_Function_0_MaxPoolSize) AsStackSpecContainerConfigDeployFunction0MaxPoolSize0() (StackSpecContainerConfigDeployFunction0MaxPoolSize0, error) {
	var body StackSpecContainerConfigDeployFunction0MaxPoolSize0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployFunction0MaxPoolSize0 overwrites any union data inside the StackSpecContainerConfigDeploy_Function_0_MaxPoolSize as the provided StackSpecContainerConfigDeployFunction0MaxPoolSize0
func (t *StackSpecContainerConfigDeploy_Function_0_MaxPoolSize) FromStackSpecContainerConfigDeployFunction0MaxPoolSize0(v StackSpecContainerConfigDeployFunction0MaxPoolSize0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployFunction0MaxPoolSize0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Function_0_MaxPoolSize, using the provided StackSpecContainerConfigDeployFunction0MaxPoolSize0
func (t *StackSpecContainerConfigDeploy_Function_0_MaxPoolSize) MergeStackSpecContainerConfigDeployFunction0MaxPoolSize0(v StackSpecContainerConfigDeployFunction0MaxPoolSize0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Function_0_MaxPoolSize as a StackVariable
func (t StackSpecContainerConfigDeploy_Function_0_MaxPoolSize) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Function_0_MaxPoolSize as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Function_0_MaxPoolSize) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Function_0_MaxPoolSize, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Function_0_MaxPoolSize) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Function_0_MaxPoolSize) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Function_0_MaxPoolSize) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployFunction0MaxShardConcurrency0 returns the union data inside the StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency as a StackSpecContainerConfigDeployFunction0MaxShardConcurrency0
func (t StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency) AsStackSpecContainerConfigDeployFunction0MaxShardConcurrency0() (StackSpecContainerConfigDeployFunction0MaxShardConcurrency0, error) {
	var body StackSpecContainerConfigDeployFunction0MaxShardConcurrency0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployFunction0MaxShardConcurrency0 overwrites any union data inside the StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency as the provided StackSpecContainerConfigDeployFunction0MaxShardConcurrency0
func (t *StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency) FromStackSpecContainerConfigDeployFunction0MaxShardConcurrency0(v StackSpecContainerConfigDeployFunction0MaxShardConcurrency0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployFunction0MaxShardConcurrency0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency, using the provided StackSpecContainerConfigDeployFunction0MaxShardConcurrency0
func (t *StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency) MergeStackSpecContainerConfigDeployFunction0MaxShardConcurrency0(v StackSpecContainerConfigDeployFunction0MaxShardConcurrency0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency as a StackVariable
func (t StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Function_0_MaxShardConcurrency) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployFunction0 returns the union data inside the StackSpecContainerConfigDeploy_Function as a StackSpecContainerConfigDeployFunction0
func (t StackSpecContainerConfigDeploy_Function) AsStackSpecContainerConfigDeployFunction0() (StackSpecContainerConfigDeployFunction0, error) {
	var body StackSpecContainerConfigDeployFunction0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployFunction0 overwrites any union data inside the StackSpecContainerConfigDeploy_Function as the provided StackSpecContainerConfigDeployFunction0
func (t *StackSpecContainerConfigDeploy_Function) FromStackSpecContainerConfigDeployFunction0(v StackSpecContainerConfigDeployFunction0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployFunction0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Function, using the provided StackSpecContainerConfigDeployFunction0
func (t *StackSpecContainerConfigDeploy_Function) MergeStackSpecContainerConfigDeployFunction0(v StackSpecContainerConfigDeployFunction0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Function as a StackVariable
func (t StackSpecContainerConfigDeploy_Function) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Function as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Function) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Function, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Function) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Function) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Function) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployHealthCheck0Restart0 returns the union data inside the StackSpecContainerConfigDeploy_HealthCheck_0_Restart as a StackSpecContainerConfigDeployHealthCheck0Restart0
func (t StackSpecContainerConfigDeploy_HealthCheck_0_Restart) AsStackSpecContainerConfigDeployHealthCheck0Restart0() (StackSpecContainerConfigDeployHealthCheck0Restart0, error) {
	var body StackSpecContainerConfigDeployHealthCheck0Restart0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployHealthCheck0Restart0 overwrites any union data inside the StackSpecContainerConfigDeploy_HealthCheck_0_Restart as the provided StackSpecContainerConfigDeployHealthCheck0Restart0
func (t *StackSpecContainerConfigDeploy_HealthCheck_0_Restart) FromStackSpecContainerConfigDeployHealthCheck0Restart0(v StackSpecContainerConfigDeployHealthCheck0Restart0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployHealthCheck0Restart0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_HealthCheck_0_Restart, using the provided StackSpecContainerConfigDeployHealthCheck0Restart0
func (t *StackSpecContainerConfigDeploy_HealthCheck_0_Restart) MergeStackSpecContainerConfigDeployHealthCheck0Restart0(v StackSpecContainerConfigDeployHealthCheck0Restart0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_HealthCheck_0_Restart as a StackVariable
func (t StackSpecContainerConfigDeploy_HealthCheck_0_Restart) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_HealthCheck_0_Restart as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_HealthCheck_0_Restart) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_HealthCheck_0_Restart, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_HealthCheck_0_Restart) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_HealthCheck_0_Restart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_HealthCheck_0_Restart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployHealthCheck0Retries0 returns the union data inside the StackSpecContainerConfigDeploy_HealthCheck_0_Retries as a StackSpecContainerConfigDeployHealthCheck0Retries0
func (t StackSpecContainerConfigDeploy_HealthCheck_0_Retries) AsStackSpecContainerConfigDeployHealthCheck0Retries0() (StackSpecContainerConfigDeployHealthCheck0Retries0, error) {
	var body StackSpecContainerConfigDeployHealthCheck0Retries0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployHealthCheck0Retries0 overwrites any union data inside the StackSpecContainerConfigDeploy_HealthCheck_0_Retries as the provided StackSpecContainerConfigDeployHealthCheck0Retries0
func (t *StackSpecContainerConfigDeploy_HealthCheck_0_Retries) FromStackSpecContainerConfigDeployHealthCheck0Retries0(v StackSpecContainerConfigDeployHealthCheck0Retries0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployHealthCheck0Retries0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_HealthCheck_0_Retries, using the provided StackSpecContainerConfigDeployHealthCheck0Retries0
func (t *StackSpecContainerConfigDeploy_HealthCheck_0_Retries) MergeStackSpecContainerConfigDeployHealthCheck0Retries0(v StackSpecContainerConfigDeployHealthCheck0Retries0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_HealthCheck_0_Retries as a StackVariable
func (t StackSpecContainerConfigDeploy_HealthCheck_0_Retries) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_HealthCheck_0_Retries as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_HealthCheck_0_Retries) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_HealthCheck_0_Retries, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_HealthCheck_0_Retries) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_HealthCheck_0_Retries) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_HealthCheck_0_Retries) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployHealthCheck0 returns the union data inside the StackSpecContainerConfigDeploy_HealthCheck as a StackSpecContainerConfigDeployHealthCheck0
func (t StackSpecContainerConfigDeploy_HealthCheck) AsStackSpecContainerConfigDeployHealthCheck0() (StackSpecContainerConfigDeployHealthCheck0, error) {
	var body StackSpecContainerConfigDeployHealthCheck0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployHealthCheck0 overwrites any union data inside the StackSpecContainerConfigDeploy_HealthCheck as the provided StackSpecContainerConfigDeployHealthCheck0
func (t *StackSpecContainerConfigDeploy_HealthCheck) FromStackSpecContainerConfigDeployHealthCheck0(v StackSpecContainerConfigDeployHealthCheck0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployHealthCheck0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_HealthCheck, using the provided StackSpecContainerConfigDeployHealthCheck0
func (t *StackSpecContainerConfigDeploy_HealthCheck) MergeStackSpecContainerConfigDeployHealthCheck0(v StackSpecContainerConfigDeployHealthCheck0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_HealthCheck as a StackVariable
func (t StackSpecContainerConfigDeploy_HealthCheck) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_HealthCheck as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_HealthCheck) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_HealthCheck, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_HealthCheck) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_HealthCheck) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_HealthCheck) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployInstances0 returns the union data inside the StackSpecContainerConfigDeploy_Instances as a StackSpecContainerConfigDeployInstances0
func (t StackSpecContainerConfigDeploy_Instances) AsStackSpecContainerConfigDeployInstances0() (StackSpecContainerConfigDeployInstances0, error) {
	var body StackSpecContainerConfigDeployInstances0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployInstances0 overwrites any union data inside the StackSpecContainerConfigDeploy_Instances as the provided StackSpecContainerConfigDeployInstances0
func (t *StackSpecContainerConfigDeploy_Instances) FromStackSpecContainerConfigDeployInstances0(v StackSpecContainerConfigDeployInstances0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployInstances0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Instances, using the provided StackSpecContainerConfigDeployInstances0
func (t *StackSpecContainerConfigDeploy_Instances) MergeStackSpecContainerConfigDeployInstances0(v StackSpecContainerConfigDeployInstances0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Instances as a StackVariable
func (t StackSpecContainerConfigDeploy_Instances) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Instances as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Instances) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Instances, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Instances) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Instances) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Instances) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployRestart0MaxAttempts0 returns the union data inside the StackSpecContainerConfigDeploy_Restart_0_MaxAttempts as a StackSpecContainerConfigDeployRestart0MaxAttempts0
func (t StackSpecContainerConfigDeploy_Restart_0_MaxAttempts) AsStackSpecContainerConfigDeployRestart0MaxAttempts0() (StackSpecContainerConfigDeployRestart0MaxAttempts0, error) {
	var body StackSpecContainerConfigDeployRestart0MaxAttempts0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployRestart0MaxAttempts0 overwrites any union data inside the StackSpecContainerConfigDeploy_Restart_0_MaxAttempts as the provided StackSpecContainerConfigDeployRestart0MaxAttempts0
func (t *StackSpecContainerConfigDeploy_Restart_0_MaxAttempts) FromStackSpecContainerConfigDeployRestart0MaxAttempts0(v StackSpecContainerConfigDeployRestart0MaxAttempts0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployRestart0MaxAttempts0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Restart_0_MaxAttempts, using the provided StackSpecContainerConfigDeployRestart0MaxAttempts0
func (t *StackSpecContainerConfigDeploy_Restart_0_MaxAttempts) MergeStackSpecContainerConfigDeployRestart0MaxAttempts0(v StackSpecContainerConfigDeployRestart0MaxAttempts0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Restart_0_MaxAttempts as a StackVariable
func (t StackSpecContainerConfigDeploy_Restart_0_MaxAttempts) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Restart_0_MaxAttempts as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Restart_0_MaxAttempts) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Restart_0_MaxAttempts, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Restart_0_MaxAttempts) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Restart_0_MaxAttempts) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Restart_0_MaxAttempts) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployRestart0 returns the union data inside the StackSpecContainerConfigDeploy_Restart as a StackSpecContainerConfigDeployRestart0
func (t StackSpecContainerConfigDeploy_Restart) AsStackSpecContainerConfigDeployRestart0() (StackSpecContainerConfigDeployRestart0, error) {
	var body StackSpecContainerConfigDeployRestart0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployRestart0 overwrites any union data inside the StackSpecContainerConfigDeploy_Restart as the provided StackSpecContainerConfigDeployRestart0
func (t *StackSpecContainerConfigDeploy_Restart) FromStackSpecContainerConfigDeployRestart0(v StackSpecContainerConfigDeployRestart0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployRestart0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Restart, using the provided StackSpecContainerConfigDeployRestart0
func (t *StackSpecContainerConfigDeploy_Restart) MergeStackSpecContainerConfigDeployRestart0(v StackSpecContainerConfigDeployRestart0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Restart as a StackVariable
func (t StackSpecContainerConfigDeploy_Restart) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Restart as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Restart) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Restart, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Restart) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Restart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Restart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployShutdown0Signals0 returns the union data inside the StackSpecContainerConfigDeploy_Shutdown_0_Signals as a StackSpecContainerConfigDeployShutdown0Signals0
func (t StackSpecContainerConfigDeploy_Shutdown_0_Signals) AsStackSpecContainerConfigDeployShutdown0Signals0() (StackSpecContainerConfigDeployShutdown0Signals0, error) {
	var body StackSpecContainerConfigDeployShutdown0Signals0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployShutdown0Signals0 overwrites any union data inside the StackSpecContainerConfigDeploy_Shutdown_0_Signals as the provided StackSpecContainerConfigDeployShutdown0Signals0
func (t *StackSpecContainerConfigDeploy_Shutdown_0_Signals) FromStackSpecContainerConfigDeployShutdown0Signals0(v StackSpecContainerConfigDeployShutdown0Signals0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployShutdown0Signals0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Shutdown_0_Signals, using the provided StackSpecContainerConfigDeployShutdown0Signals0
func (t *StackSpecContainerConfigDeploy_Shutdown_0_Signals) MergeStackSpecContainerConfigDeployShutdown0Signals0(v StackSpecContainerConfigDeployShutdown0Signals0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Shutdown_0_Signals as a StackVariable
func (t StackSpecContainerConfigDeploy_Shutdown_0_Signals) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Shutdown_0_Signals as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Shutdown_0_Signals) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Shutdown_0_Signals, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Shutdown_0_Signals) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Shutdown_0_Signals) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Shutdown_0_Signals) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployShutdown0 returns the union data inside the StackSpecContainerConfigDeploy_Shutdown as a StackSpecContainerConfigDeployShutdown0
func (t StackSpecContainerConfigDeploy_Shutdown) AsStackSpecContainerConfigDeployShutdown0() (StackSpecContainerConfigDeployShutdown0, error) {
	var body StackSpecContainerConfigDeployShutdown0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployShutdown0 overwrites any union data inside the StackSpecContainerConfigDeploy_Shutdown as the provided StackSpecContainerConfigDeployShutdown0
func (t *StackSpecContainerConfigDeploy_Shutdown) FromStackSpecContainerConfigDeployShutdown0(v StackSpecContainerConfigDeployShutdown0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployShutdown0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Shutdown, using the provided StackSpecContainerConfigDeployShutdown0
func (t *StackSpecContainerConfigDeploy_Shutdown) MergeStackSpecContainerConfigDeployShutdown0(v StackSpecContainerConfigDeployShutdown0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Shutdown as a StackVariable
func (t StackSpecContainerConfigDeploy_Shutdown) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Shutdown as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Shutdown) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Shutdown, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Shutdown) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Shutdown) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Shutdown) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployStartup0 returns the union data inside the StackSpecContainerConfigDeploy_Startup as a StackSpecContainerConfigDeployStartup0
func (t StackSpecContainerConfigDeploy_Startup) AsStackSpecContainerConfigDeployStartup0() (StackSpecContainerConfigDeployStartup0, error) {
	var body StackSpecContainerConfigDeployStartup0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployStartup0 overwrites any union data inside the StackSpecContainerConfigDeploy_Startup as the provided StackSpecContainerConfigDeployStartup0
func (t *StackSpecContainerConfigDeploy_Startup) FromStackSpecContainerConfigDeployStartup0(v StackSpecContainerConfigDeployStartup0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployStartup0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Startup, using the provided StackSpecContainerConfigDeployStartup0
func (t *StackSpecContainerConfigDeploy_Startup) MergeStackSpecContainerConfigDeployStartup0(v StackSpecContainerConfigDeployStartup0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Startup as a StackVariable
func (t StackSpecContainerConfigDeploy_Startup) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Startup as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Startup) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Startup, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Startup) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Startup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Startup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployStateful0 returns the union data inside the StackSpecContainerConfigDeploy_Stateful as a StackSpecContainerConfigDeployStateful0
func (t StackSpecContainerConfigDeploy_Stateful) AsStackSpecContainerConfigDeployStateful0() (StackSpecContainerConfigDeployStateful0, error) {
	var body StackSpecContainerConfigDeployStateful0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployStateful0 overwrites any union data inside the StackSpecContainerConfigDeploy_Stateful as the provided StackSpecContainerConfigDeployStateful0
func (t *StackSpecContainerConfigDeploy_Stateful) FromStackSpecContainerConfigDeployStateful0(v StackSpecContainerConfigDeployStateful0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployStateful0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Stateful, using the provided StackSpecContainerConfigDeployStateful0
func (t *StackSpecContainerConfigDeploy_Stateful) MergeStackSpecContainerConfigDeployStateful0(v StackSpecContainerConfigDeployStateful0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Stateful as a StackVariable
func (t StackSpecContainerConfigDeploy_Stateful) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Stateful as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Stateful) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Stateful, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Stateful) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Stateful) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Stateful) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployTelemetry0Disable0 returns the union data inside the StackSpecContainerConfigDeploy_Telemetry_0_Disable as a StackSpecContainerConfigDeployTelemetry0Disable0
func (t StackSpecContainerConfigDeploy_Telemetry_0_Disable) AsStackSpecContainerConfigDeployTelemetry0Disable0() (StackSpecContainerConfigDeployTelemetry0Disable0, error) {
	var body StackSpecContainerConfigDeployTelemetry0Disable0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployTelemetry0Disable0 overwrites any union data inside the StackSpecContainerConfigDeploy_Telemetry_0_Disable as the provided StackSpecContainerConfigDeployTelemetry0Disable0
func (t *StackSpecContainerConfigDeploy_Telemetry_0_Disable) FromStackSpecContainerConfigDeployTelemetry0Disable0(v StackSpecContainerConfigDeployTelemetry0Disable0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployTelemetry0Disable0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Telemetry_0_Disable, using the provided StackSpecContainerConfigDeployTelemetry0Disable0
func (t *StackSpecContainerConfigDeploy_Telemetry_0_Disable) MergeStackSpecContainerConfigDeployTelemetry0Disable0(v StackSpecContainerConfigDeployTelemetry0Disable0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Telemetry_0_Disable as a StackVariable
func (t StackSpecContainerConfigDeploy_Telemetry_0_Disable) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Telemetry_0_Disable as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Telemetry_0_Disable) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Telemetry_0_Disable, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Telemetry_0_Disable) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Telemetry_0_Disable) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Telemetry_0_Disable) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployTelemetry0 returns the union data inside the StackSpecContainerConfigDeploy_Telemetry as a StackSpecContainerConfigDeployTelemetry0
func (t StackSpecContainerConfigDeploy_Telemetry) AsStackSpecContainerConfigDeployTelemetry0() (StackSpecContainerConfigDeployTelemetry0, error) {
	var body StackSpecContainerConfigDeployTelemetry0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployTelemetry0 overwrites any union data inside the StackSpecContainerConfigDeploy_Telemetry as the provided StackSpecContainerConfigDeployTelemetry0
func (t *StackSpecContainerConfigDeploy_Telemetry) FromStackSpecContainerConfigDeployTelemetry0(v StackSpecContainerConfigDeployTelemetry0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployTelemetry0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Telemetry, using the provided StackSpecContainerConfigDeployTelemetry0
func (t *StackSpecContainerConfigDeploy_Telemetry) MergeStackSpecContainerConfigDeployTelemetry0(v StackSpecContainerConfigDeployTelemetry0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Telemetry as a StackVariable
func (t StackSpecContainerConfigDeploy_Telemetry) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Telemetry as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Telemetry) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Telemetry, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Telemetry) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Telemetry) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Telemetry) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigDeployUpdate0 returns the union data inside the StackSpecContainerConfigDeploy_Update as a StackSpecContainerConfigDeployUpdate0
func (t StackSpecContainerConfigDeploy_Update) AsStackSpecContainerConfigDeployUpdate0() (StackSpecContainerConfigDeployUpdate0, error) {
	var body StackSpecContainerConfigDeployUpdate0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigDeployUpdate0 overwrites any union data inside the StackSpecContainerConfigDeploy_Update as the provided StackSpecContainerConfigDeployUpdate0
func (t *StackSpecContainerConfigDeploy_Update) FromStackSpecContainerConfigDeployUpdate0(v StackSpecContainerConfigDeployUpdate0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigDeployUpdate0 performs a merge with any union data inside the StackSpecContainerConfigDeploy_Update, using the provided StackSpecContainerConfigDeployUpdate0
func (t *StackSpecContainerConfigDeploy_Update) MergeStackSpecContainerConfigDeployUpdate0(v StackSpecContainerConfigDeployUpdate0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigDeploy_Update as a StackVariable
func (t StackSpecContainerConfigDeploy_Update) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigDeploy_Update as the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Update) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigDeploy_Update, using the provided StackVariable
func (t *StackSpecContainerConfigDeploy_Update) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigDeploy_Update) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigDeploy_Update) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerConfigNetworkPorts0 returns the union data inside the StackSpecContainerConfigNetwork_Ports as a StackSpecContainerConfigNetworkPorts0
func (t StackSpecContainerConfigNetwork_Ports) AsStackSpecContainerConfigNetworkPorts0() (StackSpecContainerConfigNetworkPorts0, error) {
	var body StackSpecContainerConfigNetworkPorts0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerConfigNetworkPorts0 overwrites any union data inside the StackSpecContainerConfigNetwork_Ports as the provided StackSpecContainerConfigNetworkPorts0
func (t *StackSpecContainerConfigNetwork_Ports) FromStackSpecContainerConfigNetworkPorts0(v StackSpecContainerConfigNetworkPorts0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerConfigNetworkPorts0 performs a merge with any union data inside the StackSpecContainerConfigNetwork_Ports, using the provided StackSpecContainerConfigNetworkPorts0
func (t *StackSpecContainerConfigNetwork_Ports) MergeStackSpecContainerConfigNetworkPorts0(v StackSpecContainerConfigNetworkPorts0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerConfigNetwork_Ports as a StackVariable
func (t StackSpecContainerConfigNetwork_Ports) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerConfigNetwork_Ports as the provided StackVariable
func (t *StackSpecContainerConfigNetwork_Ports) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerConfigNetwork_Ports, using the provided StackVariable
func (t *StackSpecContainerConfigNetwork_Ports) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerConfigNetwork_Ports) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerConfigNetwork_Ports) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerImageBuild0Args0 returns the union data inside the StackSpecContainerImage_Build_0_Args as a StackSpecContainerImageBuild0Args0
func (t StackSpecContainerImage_Build_0_Args) AsStackSpecContainerImageBuild0Args0() (StackSpecContainerImageBuild0Args0, error) {
	var body StackSpecContainerImageBuild0Args0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerImageBuild0Args0 overwrites any union data inside the StackSpecContainerImage_Build_0_Args as the provided StackSpecContainerImageBuild0Args0
func (t *StackSpecContainerImage_Build_0_Args) FromStackSpecContainerImageBuild0Args0(v StackSpecContainerImageBuild0Args0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerImageBuild0Args0 performs a merge with any union data inside the StackSpecContainerImage_Build_0_Args, using the provided StackSpecContainerImageBuild0Args0
func (t *StackSpecContainerImage_Build_0_Args) MergeStackSpecContainerImageBuild0Args0(v StackSpecContainerImageBuild0Args0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerImage_Build_0_Args as a StackVariable
func (t StackSpecContainerImage_Build_0_Args) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerImage_Build_0_Args as the provided StackVariable
func (t *StackSpecContainerImage_Build_0_Args) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerImage_Build_0_Args, using the provided StackVariable
func (t *StackSpecContainerImage_Build_0_Args) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerImage_Build_0_Args) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerImage_Build_0_Args) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerImageBuild0 returns the union data inside the StackSpecContainerImage_Build as a StackSpecContainerImageBuild0
func (t StackSpecContainerImage_Build) AsStackSpecContainerImageBuild0() (StackSpecContainerImageBuild0, error) {
	var body StackSpecContainerImageBuild0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerImageBuild0 overwrites any union data inside the StackSpecContainerImage_Build as the provided StackSpecContainerImageBuild0
func (t *StackSpecContainerImage_Build) FromStackSpecContainerImageBuild0(v StackSpecContainerImageBuild0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerImageBuild0 performs a merge with any union data inside the StackSpecContainerImage_Build, using the provided StackSpecContainerImageBuild0
func (t *StackSpecContainerImage_Build) MergeStackSpecContainerImageBuild0(v StackSpecContainerImageBuild0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerImage_Build as a StackVariable
func (t StackSpecContainerImage_Build) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerImage_Build as the provided StackVariable
func (t *StackSpecContainerImage_Build) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerImage_Build, using the provided StackVariable
func (t *StackSpecContainerImage_Build) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerImage_Build) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerImage_Build) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerImageBuilder0 returns the union data inside the StackSpecContainerImage_Builder as a StackSpecContainerImageBuilder0
func (t StackSpecContainerImage_Builder) AsStackSpecContainerImageBuilder0() (StackSpecContainerImageBuilder0, error) {
	var body StackSpecContainerImageBuilder0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerImageBuilder0 overwrites any union data inside the StackSpecContainerImage_Builder as the provided StackSpecContainerImageBuilder0
func (t *StackSpecContainerImage_Builder) FromStackSpecContainerImageBuilder0(v StackSpecContainerImageBuilder0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerImageBuilder0 performs a merge with any union data inside the StackSpecContainerImage_Builder, using the provided StackSpecContainerImageBuilder0
func (t *StackSpecContainerImage_Builder) MergeStackSpecContainerImageBuilder0(v StackSpecContainerImageBuilder0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerImage_Builder as a StackVariable
func (t StackSpecContainerImage_Builder) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerImage_Builder as the provided StackVariable
func (t *StackSpecContainerImage_Builder) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerImage_Builder, using the provided StackVariable
func (t *StackSpecContainerImage_Builder) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerImage_Builder) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerImage_Builder) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecImageOrigin returns the union data inside the StackSpecContainerImage_Origin as a StackSpecImageOrigin
func (t StackSpecContainerImage_Origin) AsStackSpecImageOrigin() (StackSpecImageOrigin, error) {
	var body StackSpecImageOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecImageOrigin overwrites any union data inside the StackSpecContainerImage_Origin as the provided StackSpecImageOrigin
func (t *StackSpecContainerImage_Origin) FromStackSpecImageOrigin(v StackSpecImageOrigin) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecImageOrigin performs a merge with any union data inside the StackSpecContainerImage_Origin, using the provided StackSpecImageOrigin
func (t *StackSpecContainerImage_Origin) MergeStackSpecImageOrigin(v StackSpecImageOrigin) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerImage_Origin as a StackVariable
func (t StackSpecContainerImage_Origin) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerImage_Origin as the provided StackVariable
func (t *StackSpecContainerImage_Origin) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerImage_Origin, using the provided StackVariable
func (t *StackSpecContainerImage_Origin) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerImage_Origin) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerImage_Origin) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerVolumeBlockDevice0 returns the union data inside the StackSpecContainerVolume_BlockDevice as a StackSpecContainerVolumeBlockDevice0
func (t StackSpecContainerVolume_BlockDevice) AsStackSpecContainerVolumeBlockDevice0() (StackSpecContainerVolumeBlockDevice0, error) {
	var body StackSpecContainerVolumeBlockDevice0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerVolumeBlockDevice0 overwrites any union data inside the StackSpecContainerVolume_BlockDevice as the provided StackSpecContainerVolumeBlockDevice0
func (t *StackSpecContainerVolume_BlockDevice) FromStackSpecContainerVolumeBlockDevice0(v StackSpecContainerVolumeBlockDevice0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerVolumeBlockDevice0 performs a merge with any union data inside the StackSpecContainerVolume_BlockDevice, using the provided StackSpecContainerVolumeBlockDevice0
func (t *StackSpecContainerVolume_BlockDevice) MergeStackSpecContainerVolumeBlockDevice0(v StackSpecContainerVolumeBlockDevice0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerVolume_BlockDevice as a StackVariable
func (t StackSpecContainerVolume_BlockDevice) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerVolume_BlockDevice as the provided StackVariable
func (t *StackSpecContainerVolume_BlockDevice) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerVolume_BlockDevice, using the provided StackVariable
func (t *StackSpecContainerVolume_BlockDevice) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerVolume_BlockDevice) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerVolume_BlockDevice) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerVolumeLocal0StoragePool0 returns the union data inside the StackSpecContainerVolume_Local_0_StoragePool as a StackSpecContainerVolumeLocal0StoragePool0
func (t StackSpecContainerVolume_Local_0_StoragePool) AsStackSpecContainerVolumeLocal0StoragePool0() (StackSpecContainerVolumeLocal0StoragePool0, error) {
	var body StackSpecContainerVolumeLocal0StoragePool0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerVolumeLocal0StoragePool0 overwrites any union data inside the StackSpecContainerVolume_Local_0_StoragePool as the provided StackSpecContainerVolumeLocal0StoragePool0
func (t *StackSpecContainerVolume_Local_0_StoragePool) FromStackSpecContainerVolumeLocal0StoragePool0(v StackSpecContainerVolumeLocal0StoragePool0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerVolumeLocal0StoragePool0 performs a merge with any union data inside the StackSpecContainerVolume_Local_0_StoragePool, using the provided StackSpecContainerVolumeLocal0StoragePool0
func (t *StackSpecContainerVolume_Local_0_StoragePool) MergeStackSpecContainerVolumeLocal0StoragePool0(v StackSpecContainerVolumeLocal0StoragePool0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerVolume_Local_0_StoragePool as a StackVariable
func (t StackSpecContainerVolume_Local_0_StoragePool) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerVolume_Local_0_StoragePool as the provided StackVariable
func (t *StackSpecContainerVolume_Local_0_StoragePool) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerVolume_Local_0_StoragePool, using the provided StackVariable
func (t *StackSpecContainerVolume_Local_0_StoragePool) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerVolume_Local_0_StoragePool) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerVolume_Local_0_StoragePool) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerVolumeLocal0 returns the union data inside the StackSpecContainerVolume_Local as a StackSpecContainerVolumeLocal0
func (t StackSpecContainerVolume_Local) AsStackSpecContainerVolumeLocal0() (StackSpecContainerVolumeLocal0, error) {
	var body StackSpecContainerVolumeLocal0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerVolumeLocal0 overwrites any union data inside the StackSpecContainerVolume_Local as the provided StackSpecContainerVolumeLocal0
func (t *StackSpecContainerVolume_Local) FromStackSpecContainerVolumeLocal0(v StackSpecContainerVolumeLocal0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerVolumeLocal0 performs a merge with any union data inside the StackSpecContainerVolume_Local, using the provided StackSpecContainerVolumeLocal0
func (t *StackSpecContainerVolume_Local) MergeStackSpecContainerVolumeLocal0(v StackSpecContainerVolumeLocal0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerVolume_Local as a StackVariable
func (t StackSpecContainerVolume_Local) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerVolume_Local as the provided StackVariable
func (t *StackSpecContainerVolume_Local) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerVolume_Local, using the provided StackVariable
func (t *StackSpecContainerVolume_Local) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerVolume_Local) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerVolume_Local) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerVolumeReadOnly0 returns the union data inside the StackSpecContainerVolume_ReadOnly as a StackSpecContainerVolumeReadOnly0
func (t StackSpecContainerVolume_ReadOnly) AsStackSpecContainerVolumeReadOnly0() (StackSpecContainerVolumeReadOnly0, error) {
	var body StackSpecContainerVolumeReadOnly0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerVolumeReadOnly0 overwrites any union data inside the StackSpecContainerVolume_ReadOnly as the provided StackSpecContainerVolumeReadOnly0
func (t *StackSpecContainerVolume_ReadOnly) FromStackSpecContainerVolumeReadOnly0(v StackSpecContainerVolumeReadOnly0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerVolumeReadOnly0 performs a merge with any union data inside the StackSpecContainerVolume_ReadOnly, using the provided StackSpecContainerVolumeReadOnly0
func (t *StackSpecContainerVolume_ReadOnly) MergeStackSpecContainerVolumeReadOnly0(v StackSpecContainerVolumeReadOnly0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerVolume_ReadOnly as a StackVariable
func (t StackSpecContainerVolume_ReadOnly) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerVolume_ReadOnly as the provided StackVariable
func (t *StackSpecContainerVolume_ReadOnly) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerVolume_ReadOnly, using the provided StackVariable
func (t *StackSpecContainerVolume_ReadOnly) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerVolume_ReadOnly) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerVolume_ReadOnly) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerVolumeRemoteAccess0Enable0 returns the union data inside the StackSpecContainerVolume_RemoteAccess_0_Enable as a StackSpecContainerVolumeRemoteAccess0Enable0
func (t StackSpecContainerVolume_RemoteAccess_0_Enable) AsStackSpecContainerVolumeRemoteAccess0Enable0() (StackSpecContainerVolumeRemoteAccess0Enable0, error) {
	var body StackSpecContainerVolumeRemoteAccess0Enable0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerVolumeRemoteAccess0Enable0 overwrites any union data inside the StackSpecContainerVolume_RemoteAccess_0_Enable as the provided StackSpecContainerVolumeRemoteAccess0Enable0
func (t *StackSpecContainerVolume_RemoteAccess_0_Enable) FromStackSpecContainerVolumeRemoteAccess0Enable0(v StackSpecContainerVolumeRemoteAccess0Enable0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerVolumeRemoteAccess0Enable0 performs a merge with any union data inside the StackSpecContainerVolume_RemoteAccess_0_Enable, using the provided StackSpecContainerVolumeRemoteAccess0Enable0
func (t *StackSpecContainerVolume_RemoteAccess_0_Enable) MergeStackSpecContainerVolumeRemoteAccess0Enable0(v StackSpecContainerVolumeRemoteAccess0Enable0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerVolume_RemoteAccess_0_Enable as a StackVariable
func (t StackSpecContainerVolume_RemoteAccess_0_Enable) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerVolume_RemoteAccess_0_Enable as the provided StackVariable
func (t *StackSpecContainerVolume_RemoteAccess_0_Enable) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerVolume_RemoteAccess_0_Enable, using the provided StackVariable
func (t *StackSpecContainerVolume_RemoteAccess_0_Enable) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerVolume_RemoteAccess_0_Enable) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerVolume_RemoteAccess_0_Enable) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerVolumeRemoteAccess0Ips0 returns the union data inside the StackSpecContainerVolume_RemoteAccess_0_Ips as a StackSpecContainerVolumeRemoteAccess0Ips0
func (t StackSpecContainerVolume_RemoteAccess_0_Ips) AsStackSpecContainerVolumeRemoteAccess0Ips0() (StackSpecContainerVolumeRemoteAccess0Ips0, error) {
	var body StackSpecContainerVolumeRemoteAccess0Ips0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerVolumeRemoteAccess0Ips0 overwrites any union data inside the StackSpecContainerVolume_RemoteAccess_0_Ips as the provided StackSpecContainerVolumeRemoteAccess0Ips0
func (t *StackSpecContainerVolume_RemoteAccess_0_Ips) FromStackSpecContainerVolumeRemoteAccess0Ips0(v StackSpecContainerVolumeRemoteAccess0Ips0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerVolumeRemoteAccess0Ips0 performs a merge with any union data inside the StackSpecContainerVolume_RemoteAccess_0_Ips, using the provided StackSpecContainerVolumeRemoteAccess0Ips0
func (t *StackSpecContainerVolume_RemoteAccess_0_Ips) MergeStackSpecContainerVolumeRemoteAccess0Ips0(v StackSpecContainerVolumeRemoteAccess0Ips0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerVolume_RemoteAccess_0_Ips as a StackVariable
func (t StackSpecContainerVolume_RemoteAccess_0_Ips) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerVolume_RemoteAccess_0_Ips as the provided StackVariable
func (t *StackSpecContainerVolume_RemoteAccess_0_Ips) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerVolume_RemoteAccess_0_Ips, using the provided StackVariable
func (t *StackSpecContainerVolume_RemoteAccess_0_Ips) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerVolume_RemoteAccess_0_Ips) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerVolume_RemoteAccess_0_Ips) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerVolumeRemoteAccess0Password0 returns the union data inside the StackSpecContainerVolume_RemoteAccess_0_Password as a StackSpecContainerVolumeRemoteAccess0Password0
func (t StackSpecContainerVolume_RemoteAccess_0_Password) AsStackSpecContainerVolumeRemoteAccess0Password0() (StackSpecContainerVolumeRemoteAccess0Password0, error) {
	var body StackSpecContainerVolumeRemoteAccess0Password0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerVolumeRemoteAccess0Password0 overwrites any union data inside the StackSpecContainerVolume_RemoteAccess_0_Password as the provided StackSpecContainerVolumeRemoteAccess0Password0
func (t *StackSpecContainerVolume_RemoteAccess_0_Password) FromStackSpecContainerVolumeRemoteAccess0Password0(v StackSpecContainerVolumeRemoteAccess0Password0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerVolumeRemoteAccess0Password0 performs a merge with any union data inside the StackSpecContainerVolume_RemoteAccess_0_Password, using the provided StackSpecContainerVolumeRemoteAccess0Password0
func (t *StackSpecContainerVolume_RemoteAccess_0_Password) MergeStackSpecContainerVolumeRemoteAccess0Password0(v StackSpecContainerVolumeRemoteAccess0Password0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerVolume_RemoteAccess_0_Password as a StackVariable
func (t StackSpecContainerVolume_RemoteAccess_0_Password) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerVolume_RemoteAccess_0_Password as the provided StackVariable
func (t *StackSpecContainerVolume_RemoteAccess_0_Password) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerVolume_RemoteAccess_0_Password, using the provided StackVariable
func (t *StackSpecContainerVolume_RemoteAccess_0_Password) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerVolume_RemoteAccess_0_Password) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerVolume_RemoteAccess_0_Password) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecContainerVolumeRemoteAccess0 returns the union data inside the StackSpecContainerVolume_RemoteAccess as a StackSpecContainerVolumeRemoteAccess0
func (t StackSpecContainerVolume_RemoteAccess) AsStackSpecContainerVolumeRemoteAccess0() (StackSpecContainerVolumeRemoteAccess0, error) {
	var body StackSpecContainerVolumeRemoteAccess0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecContainerVolumeRemoteAccess0 overwrites any union data inside the StackSpecContainerVolume_RemoteAccess as the provided StackSpecContainerVolumeRemoteAccess0
func (t *StackSpecContainerVolume_RemoteAccess) FromStackSpecContainerVolumeRemoteAccess0(v StackSpecContainerVolumeRemoteAccess0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecContainerVolumeRemoteAccess0 performs a merge with any union data inside the StackSpecContainerVolume_RemoteAccess, using the provided StackSpecContainerVolumeRemoteAccess0
func (t *StackSpecContainerVolume_RemoteAccess) MergeStackSpecContainerVolumeRemoteAccess0(v StackSpecContainerVolumeRemoteAccess0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecContainerVolume_RemoteAccess as a StackVariable
func (t StackSpecContainerVolume_RemoteAccess) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecContainerVolume_RemoteAccess as the provided StackVariable
func (t *StackSpecContainerVolume_RemoteAccess) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecContainerVolume_RemoteAccess, using the provided StackVariable
func (t *StackSpecContainerVolume_RemoteAccess) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecContainerVolume_RemoteAccess) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecContainerVolume_RemoteAccess) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDockerHubOrigin returns the union data inside the StackSpecImageOrigin as a DockerHubOrigin
func (t StackSpecImageOrigin) AsDockerHubOrigin() (DockerHubOrigin, error) {
	var body DockerHubOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerHubOrigin overwrites any union data inside the StackSpecImageOrigin as the provided DockerHubOrigin
func (t *StackSpecImageOrigin) FromDockerHubOrigin(v DockerHubOrigin) error {
	v.Type = "docker-hub"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerHubOrigin performs a merge with any union data inside the StackSpecImageOrigin, using the provided DockerHubOrigin
func (t *StackSpecImageOrigin) MergeDockerHubOrigin(v DockerHubOrigin) error {
	v.Type = "docker-hub"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerFileOrigin returns the union data inside the StackSpecImageOrigin as a DockerFileOrigin
func (t StackSpecImageOrigin) AsDockerFileOrigin() (DockerFileOrigin, error) {
	var body DockerFileOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerFileOrigin overwrites any union data inside the StackSpecImageOrigin as the provided DockerFileOrigin
func (t *StackSpecImageOrigin) FromDockerFileOrigin(v DockerFileOrigin) error {
	v.Type = "docker-file"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerFileOrigin performs a merge with any union data inside the StackSpecImageOrigin, using the provided DockerFileOrigin
func (t *StackSpecImageOrigin) MergeDockerFileOrigin(v DockerFileOrigin) error {
	v.Type = "docker-file"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerRegistryOrigin returns the union data inside the StackSpecImageOrigin as a DockerRegistryOrigin
func (t StackSpecImageOrigin) AsDockerRegistryOrigin() (DockerRegistryOrigin, error) {
	var body DockerRegistryOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerRegistryOrigin overwrites any union data inside the StackSpecImageOrigin as the provided DockerRegistryOrigin
func (t *StackSpecImageOrigin) FromDockerRegistryOrigin(v DockerRegistryOrigin) error {
	v.Type = "docker-registry"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerRegistryOrigin performs a merge with any union data inside the StackSpecImageOrigin, using the provided DockerRegistryOrigin
func (t *StackSpecImageOrigin) MergeDockerRegistryOrigin(v DockerRegistryOrigin) error {
	v.Type = "docker-registry"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOciRegistryOrigin returns the union data inside the StackSpecImageOrigin as a OciRegistryOrigin
func (t StackSpecImageOrigin) AsOciRegistryOrigin() (OciRegistryOrigin, error) {
	var body OciRegistryOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOciRegistryOrigin overwrites any union data inside the StackSpecImageOrigin as the provided OciRegistryOrigin
func (t *StackSpecImageOrigin) FromOciRegistryOrigin(v OciRegistryOrigin) error {
	v.Type = "oci-registry"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOciRegistryOrigin performs a merge with any union data inside the StackSpecImageOrigin, using the provided OciRegistryOrigin
func (t *StackSpecImageOrigin) MergeOciRegistryOrigin(v OciRegistryOrigin) error {
	v.Type = "oci-registry"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCycleSourceOrigin returns the union data inside the StackSpecImageOrigin as a CycleSourceOrigin
func (t StackSpecImageOrigin) AsCycleSourceOrigin() (CycleSourceOrigin, error) {
	var body CycleSourceOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCycleSourceOrigin overwrites any union data inside the StackSpecImageOrigin as the provided CycleSourceOrigin
func (t *StackSpecImageOrigin) FromCycleSourceOrigin(v CycleSourceOrigin) error {
	v.Type = "cycle-source"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCycleSourceOrigin performs a merge with any union data inside the StackSpecImageOrigin, using the provided CycleSourceOrigin
func (t *StackSpecImageOrigin) MergeCycleSourceOrigin(v CycleSourceOrigin) error {
	v.Type = "cycle-source"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecImageOrigin) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t StackSpecImageOrigin) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "cycle-source":
		return t.AsCycleSourceOrigin()
	case "docker-file":
		return t.AsDockerFileOrigin()
	case "docker-hub":
		return t.AsDockerHubOrigin()
	case "docker-registry":
		return t.AsDockerRegistryOrigin()
	case "oci-registry":
		return t.AsOciRegistryOrigin()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t StackSpecImageOrigin) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecImageOrigin) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableAccess0File0Decode0 returns the union data inside the StackSpecScopedVariable_Access_0_File_0_Decode as a StackSpecScopedVariableAccess0File0Decode0
func (t StackSpecScopedVariable_Access_0_File_0_Decode) AsStackSpecScopedVariableAccess0File0Decode0() (StackSpecScopedVariableAccess0File0Decode0, error) {
	var body StackSpecScopedVariableAccess0File0Decode0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableAccess0File0Decode0 overwrites any union data inside the StackSpecScopedVariable_Access_0_File_0_Decode as the provided StackSpecScopedVariableAccess0File0Decode0
func (t *StackSpecScopedVariable_Access_0_File_0_Decode) FromStackSpecScopedVariableAccess0File0Decode0(v StackSpecScopedVariableAccess0File0Decode0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableAccess0File0Decode0 performs a merge with any union data inside the StackSpecScopedVariable_Access_0_File_0_Decode, using the provided StackSpecScopedVariableAccess0File0Decode0
func (t *StackSpecScopedVariable_Access_0_File_0_Decode) MergeStackSpecScopedVariableAccess0File0Decode0(v StackSpecScopedVariableAccess0File0Decode0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecScopedVariable_Access_0_File_0_Decode as a StackVariable
func (t StackSpecScopedVariable_Access_0_File_0_Decode) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecScopedVariable_Access_0_File_0_Decode as the provided StackVariable
func (t *StackSpecScopedVariable_Access_0_File_0_Decode) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecScopedVariable_Access_0_File_0_Decode, using the provided StackVariable
func (t *StackSpecScopedVariable_Access_0_File_0_Decode) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Access_0_File_0_Decode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Access_0_File_0_Decode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableAccess0File0Gid0 returns the union data inside the StackSpecScopedVariable_Access_0_File_0_Gid as a StackSpecScopedVariableAccess0File0Gid0
func (t StackSpecScopedVariable_Access_0_File_0_Gid) AsStackSpecScopedVariableAccess0File0Gid0() (StackSpecScopedVariableAccess0File0Gid0, error) {
	var body StackSpecScopedVariableAccess0File0Gid0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableAccess0File0Gid0 overwrites any union data inside the StackSpecScopedVariable_Access_0_File_0_Gid as the provided StackSpecScopedVariableAccess0File0Gid0
func (t *StackSpecScopedVariable_Access_0_File_0_Gid) FromStackSpecScopedVariableAccess0File0Gid0(v StackSpecScopedVariableAccess0File0Gid0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableAccess0File0Gid0 performs a merge with any union data inside the StackSpecScopedVariable_Access_0_File_0_Gid, using the provided StackSpecScopedVariableAccess0File0Gid0
func (t *StackSpecScopedVariable_Access_0_File_0_Gid) MergeStackSpecScopedVariableAccess0File0Gid0(v StackSpecScopedVariableAccess0File0Gid0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecScopedVariable_Access_0_File_0_Gid as a StackVariable
func (t StackSpecScopedVariable_Access_0_File_0_Gid) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecScopedVariable_Access_0_File_0_Gid as the provided StackVariable
func (t *StackSpecScopedVariable_Access_0_File_0_Gid) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecScopedVariable_Access_0_File_0_Gid, using the provided StackVariable
func (t *StackSpecScopedVariable_Access_0_File_0_Gid) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Access_0_File_0_Gid) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Access_0_File_0_Gid) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableAccess0File0Uid0 returns the union data inside the StackSpecScopedVariable_Access_0_File_0_Uid as a StackSpecScopedVariableAccess0File0Uid0
func (t StackSpecScopedVariable_Access_0_File_0_Uid) AsStackSpecScopedVariableAccess0File0Uid0() (StackSpecScopedVariableAccess0File0Uid0, error) {
	var body StackSpecScopedVariableAccess0File0Uid0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableAccess0File0Uid0 overwrites any union data inside the StackSpecScopedVariable_Access_0_File_0_Uid as the provided StackSpecScopedVariableAccess0File0Uid0
func (t *StackSpecScopedVariable_Access_0_File_0_Uid) FromStackSpecScopedVariableAccess0File0Uid0(v StackSpecScopedVariableAccess0File0Uid0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableAccess0File0Uid0 performs a merge with any union data inside the StackSpecScopedVariable_Access_0_File_0_Uid, using the provided StackSpecScopedVariableAccess0File0Uid0
func (t *StackSpecScopedVariable_Access_0_File_0_Uid) MergeStackSpecScopedVariableAccess0File0Uid0(v StackSpecScopedVariableAccess0File0Uid0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecScopedVariable_Access_0_File_0_Uid as a StackVariable
func (t StackSpecScopedVariable_Access_0_File_0_Uid) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecScopedVariable_Access_0_File_0_Uid as the provided StackVariable
func (t *StackSpecScopedVariable_Access_0_File_0_Uid) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecScopedVariable_Access_0_File_0_Uid, using the provided StackVariable
func (t *StackSpecScopedVariable_Access_0_File_0_Uid) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Access_0_File_0_Uid) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Access_0_File_0_Uid) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableAccess0File0 returns the union data inside the StackSpecScopedVariable_Access_0_File as a StackSpecScopedVariableAccess0File0
func (t StackSpecScopedVariable_Access_0_File) AsStackSpecScopedVariableAccess0File0() (StackSpecScopedVariableAccess0File0, error) {
	var body StackSpecScopedVariableAccess0File0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableAccess0File0 overwrites any union data inside the StackSpecScopedVariable_Access_0_File as the provided StackSpecScopedVariableAccess0File0
func (t *StackSpecScopedVariable_Access_0_File) FromStackSpecScopedVariableAccess0File0(v StackSpecScopedVariableAccess0File0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableAccess0File0 performs a merge with any union data inside the StackSpecScopedVariable_Access_0_File, using the provided StackSpecScopedVariableAccess0File0
func (t *StackSpecScopedVariable_Access_0_File) MergeStackSpecScopedVariableAccess0File0(v StackSpecScopedVariableAccess0File0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecScopedVariable_Access_0_File as a StackVariable
func (t StackSpecScopedVariable_Access_0_File) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecScopedVariable_Access_0_File as the provided StackVariable
func (t *StackSpecScopedVariable_Access_0_File) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecScopedVariable_Access_0_File, using the provided StackVariable
func (t *StackSpecScopedVariable_Access_0_File) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Access_0_File) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Access_0_File) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableAccess0InternalApi0 returns the union data inside the StackSpecScopedVariable_Access_0_InternalApi as a StackSpecScopedVariableAccess0InternalApi0
func (t StackSpecScopedVariable_Access_0_InternalApi) AsStackSpecScopedVariableAccess0InternalApi0() (StackSpecScopedVariableAccess0InternalApi0, error) {
	var body StackSpecScopedVariableAccess0InternalApi0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableAccess0InternalApi0 overwrites any union data inside the StackSpecScopedVariable_Access_0_InternalApi as the provided StackSpecScopedVariableAccess0InternalApi0
func (t *StackSpecScopedVariable_Access_0_InternalApi) FromStackSpecScopedVariableAccess0InternalApi0(v StackSpecScopedVariableAccess0InternalApi0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableAccess0InternalApi0 performs a merge with any union data inside the StackSpecScopedVariable_Access_0_InternalApi, using the provided StackSpecScopedVariableAccess0InternalApi0
func (t *StackSpecScopedVariable_Access_0_InternalApi) MergeStackSpecScopedVariableAccess0InternalApi0(v StackSpecScopedVariableAccess0InternalApi0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecScopedVariable_Access_0_InternalApi as a StackVariable
func (t StackSpecScopedVariable_Access_0_InternalApi) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecScopedVariable_Access_0_InternalApi as the provided StackVariable
func (t *StackSpecScopedVariable_Access_0_InternalApi) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecScopedVariable_Access_0_InternalApi, using the provided StackVariable
func (t *StackSpecScopedVariable_Access_0_InternalApi) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Access_0_InternalApi) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Access_0_InternalApi) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableAccess0 returns the union data inside the StackSpecScopedVariable_Access as a StackSpecScopedVariableAccess0
func (t StackSpecScopedVariable_Access) AsStackSpecScopedVariableAccess0() (StackSpecScopedVariableAccess0, error) {
	var body StackSpecScopedVariableAccess0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableAccess0 overwrites any union data inside the StackSpecScopedVariable_Access as the provided StackSpecScopedVariableAccess0
func (t *StackSpecScopedVariable_Access) FromStackSpecScopedVariableAccess0(v StackSpecScopedVariableAccess0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableAccess0 performs a merge with any union data inside the StackSpecScopedVariable_Access, using the provided StackSpecScopedVariableAccess0
func (t *StackSpecScopedVariable_Access) MergeStackSpecScopedVariableAccess0(v StackSpecScopedVariableAccess0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecScopedVariable_Access as a StackVariable
func (t StackSpecScopedVariable_Access) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecScopedVariable_Access as the provided StackVariable
func (t *StackSpecScopedVariable_Access) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecScopedVariable_Access, using the provided StackVariable
func (t *StackSpecScopedVariable_Access) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Access) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Access) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableScope0Containers0Global0 returns the union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Global as a StackSpecScopedVariableScope0Containers0Global0
func (t StackSpecScopedVariable_Scope_0_Containers_0_Global) AsStackSpecScopedVariableScope0Containers0Global0() (StackSpecScopedVariableScope0Containers0Global0, error) {
	var body StackSpecScopedVariableScope0Containers0Global0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableScope0Containers0Global0 overwrites any union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Global as the provided StackSpecScopedVariableScope0Containers0Global0
func (t *StackSpecScopedVariable_Scope_0_Containers_0_Global) FromStackSpecScopedVariableScope0Containers0Global0(v StackSpecScopedVariableScope0Containers0Global0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableScope0Containers0Global0 performs a merge with any union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Global, using the provided StackSpecScopedVariableScope0Containers0Global0
func (t *StackSpecScopedVariable_Scope_0_Containers_0_Global) MergeStackSpecScopedVariableScope0Containers0Global0(v StackSpecScopedVariableScope0Containers0Global0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Global as a StackVariable
func (t StackSpecScopedVariable_Scope_0_Containers_0_Global) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Global as the provided StackVariable
func (t *StackSpecScopedVariable_Scope_0_Containers_0_Global) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Global, using the provided StackVariable
func (t *StackSpecScopedVariable_Scope_0_Containers_0_Global) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Scope_0_Containers_0_Global) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Scope_0_Containers_0_Global) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableScope0Containers0Identifiers0 returns the union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Identifiers as a StackSpecScopedVariableScope0Containers0Identifiers0
func (t StackSpecScopedVariable_Scope_0_Containers_0_Identifiers) AsStackSpecScopedVariableScope0Containers0Identifiers0() (StackSpecScopedVariableScope0Containers0Identifiers0, error) {
	var body StackSpecScopedVariableScope0Containers0Identifiers0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableScope0Containers0Identifiers0 overwrites any union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Identifiers as the provided StackSpecScopedVariableScope0Containers0Identifiers0
func (t *StackSpecScopedVariable_Scope_0_Containers_0_Identifiers) FromStackSpecScopedVariableScope0Containers0Identifiers0(v StackSpecScopedVariableScope0Containers0Identifiers0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableScope0Containers0Identifiers0 performs a merge with any union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Identifiers, using the provided StackSpecScopedVariableScope0Containers0Identifiers0
func (t *StackSpecScopedVariable_Scope_0_Containers_0_Identifiers) MergeStackSpecScopedVariableScope0Containers0Identifiers0(v StackSpecScopedVariableScope0Containers0Identifiers0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Identifiers as a StackVariable
func (t StackSpecScopedVariable_Scope_0_Containers_0_Identifiers) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Identifiers as the provided StackVariable
func (t *StackSpecScopedVariable_Scope_0_Containers_0_Identifiers) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Identifiers, using the provided StackVariable
func (t *StackSpecScopedVariable_Scope_0_Containers_0_Identifiers) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Scope_0_Containers_0_Identifiers) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Scope_0_Containers_0_Identifiers) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableScope0Containers0Ids0 returns the union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Ids as a StackSpecScopedVariableScope0Containers0Ids0
func (t StackSpecScopedVariable_Scope_0_Containers_0_Ids) AsStackSpecScopedVariableScope0Containers0Ids0() (StackSpecScopedVariableScope0Containers0Ids0, error) {
	var body StackSpecScopedVariableScope0Containers0Ids0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableScope0Containers0Ids0 overwrites any union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Ids as the provided StackSpecScopedVariableScope0Containers0Ids0
func (t *StackSpecScopedVariable_Scope_0_Containers_0_Ids) FromStackSpecScopedVariableScope0Containers0Ids0(v StackSpecScopedVariableScope0Containers0Ids0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableScope0Containers0Ids0 performs a merge with any union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Ids, using the provided StackSpecScopedVariableScope0Containers0Ids0
func (t *StackSpecScopedVariable_Scope_0_Containers_0_Ids) MergeStackSpecScopedVariableScope0Containers0Ids0(v StackSpecScopedVariableScope0Containers0Ids0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Ids as a StackVariable
func (t StackSpecScopedVariable_Scope_0_Containers_0_Ids) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Ids as the provided StackVariable
func (t *StackSpecScopedVariable_Scope_0_Containers_0_Ids) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecScopedVariable_Scope_0_Containers_0_Ids, using the provided StackVariable
func (t *StackSpecScopedVariable_Scope_0_Containers_0_Ids) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Scope_0_Containers_0_Ids) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Scope_0_Containers_0_Ids) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableScope0Containers0 returns the union data inside the StackSpecScopedVariable_Scope_0_Containers as a StackSpecScopedVariableScope0Containers0
func (t StackSpecScopedVariable_Scope_0_Containers) AsStackSpecScopedVariableScope0Containers0() (StackSpecScopedVariableScope0Containers0, error) {
	var body StackSpecScopedVariableScope0Containers0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableScope0Containers0 overwrites any union data inside the StackSpecScopedVariable_Scope_0_Containers as the provided StackSpecScopedVariableScope0Containers0
func (t *StackSpecScopedVariable_Scope_0_Containers) FromStackSpecScopedVariableScope0Containers0(v StackSpecScopedVariableScope0Containers0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableScope0Containers0 performs a merge with any union data inside the StackSpecScopedVariable_Scope_0_Containers, using the provided StackSpecScopedVariableScope0Containers0
func (t *StackSpecScopedVariable_Scope_0_Containers) MergeStackSpecScopedVariableScope0Containers0(v StackSpecScopedVariableScope0Containers0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecScopedVariable_Scope_0_Containers as a StackVariable
func (t StackSpecScopedVariable_Scope_0_Containers) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecScopedVariable_Scope_0_Containers as the provided StackVariable
func (t *StackSpecScopedVariable_Scope_0_Containers) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecScopedVariable_Scope_0_Containers, using the provided StackVariable
func (t *StackSpecScopedVariable_Scope_0_Containers) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Scope_0_Containers) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Scope_0_Containers) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableScope0 returns the union data inside the StackSpecScopedVariable_Scope as a StackSpecScopedVariableScope0
func (t StackSpecScopedVariable_Scope) AsStackSpecScopedVariableScope0() (StackSpecScopedVariableScope0, error) {
	var body StackSpecScopedVariableScope0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableScope0 overwrites any union data inside the StackSpecScopedVariable_Scope as the provided StackSpecScopedVariableScope0
func (t *StackSpecScopedVariable_Scope) FromStackSpecScopedVariableScope0(v StackSpecScopedVariableScope0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableScope0 performs a merge with any union data inside the StackSpecScopedVariable_Scope, using the provided StackSpecScopedVariableScope0
func (t *StackSpecScopedVariable_Scope) MergeStackSpecScopedVariableScope0(v StackSpecScopedVariableScope0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackVariable returns the union data inside the StackSpecScopedVariable_Scope as a StackVariable
func (t StackSpecScopedVariable_Scope) AsStackVariable() (StackVariable, error) {
	var body StackVariable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackVariable overwrites any union data inside the StackSpecScopedVariable_Scope as the provided StackVariable
func (t *StackSpecScopedVariable_Scope) FromStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackVariable performs a merge with any union data inside the StackSpecScopedVariable_Scope, using the provided StackVariable
func (t *StackSpecScopedVariable_Scope) MergeStackVariable(v StackVariable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Scope) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Scope) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTcpRouterConfig returns the union data inside the V1LbConfigRouter_Config_Extension as a TcpRouterConfig
func (t V1LbConfigRouter_Config_Extension) AsTcpRouterConfig() (TcpRouterConfig, error) {
	var body TcpRouterConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTcpRouterConfig overwrites any union data inside the V1LbConfigRouter_Config_Extension as the provided TcpRouterConfig
func (t *V1LbConfigRouter_Config_Extension) FromTcpRouterConfig(v TcpRouterConfig) error {
	v.Type = "tcp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTcpRouterConfig performs a merge with any union data inside the V1LbConfigRouter_Config_Extension, using the provided TcpRouterConfig
func (t *V1LbConfigRouter_Config_Extension) MergeTcpRouterConfig(v TcpRouterConfig) error {
	v.Type = "tcp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHttpRouterConfig returns the union data inside the V1LbConfigRouter_Config_Extension as a HttpRouterConfig
func (t V1LbConfigRouter_Config_Extension) AsHttpRouterConfig() (HttpRouterConfig, error) {
	var body HttpRouterConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHttpRouterConfig overwrites any union data inside the V1LbConfigRouter_Config_Extension as the provided HttpRouterConfig
func (t *V1LbConfigRouter_Config_Extension) FromHttpRouterConfig(v HttpRouterConfig) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHttpRouterConfig performs a merge with any union data inside the V1LbConfigRouter_Config_Extension, using the provided HttpRouterConfig
func (t *V1LbConfigRouter_Config_Extension) MergeHttpRouterConfig(v HttpRouterConfig) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUdpRouterConfig returns the union data inside the V1LbConfigRouter_Config_Extension as a UdpRouterConfig
func (t V1LbConfigRouter_Config_Extension) AsUdpRouterConfig() (UdpRouterConfig, error) {
	var body UdpRouterConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUdpRouterConfig overwrites any union data inside the V1LbConfigRouter_Config_Extension as the provided UdpRouterConfig
func (t *V1LbConfigRouter_Config_Extension) FromUdpRouterConfig(v UdpRouterConfig) error {
	v.Type = "udp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUdpRouterConfig performs a merge with any union data inside the V1LbConfigRouter_Config_Extension, using the provided UdpRouterConfig
func (t *V1LbConfigRouter_Config_Extension) MergeUdpRouterConfig(v UdpRouterConfig) error {
	v.Type = "udp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V1LbConfigRouter_Config_Extension) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t V1LbConfigRouter_Config_Extension) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "http":
		return t.AsHttpRouterConfig()
	case "tcp":
		return t.AsTcpRouterConfig()
	case "udp":
		return t.AsUdpRouterConfig()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t V1LbConfigRouter_Config_Extension) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V1LbConfigRouter_Config_Extension) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTcpTransportConfig returns the union data inside the V1LbController_Transport_Config_Extension as a TcpTransportConfig
func (t V1LbController_Transport_Config_Extension) AsTcpTransportConfig() (TcpTransportConfig, error) {
	var body TcpTransportConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTcpTransportConfig overwrites any union data inside the V1LbController_Transport_Config_Extension as the provided TcpTransportConfig
func (t *V1LbController_Transport_Config_Extension) FromTcpTransportConfig(v TcpTransportConfig) error {
	v.Type = "tcp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTcpTransportConfig performs a merge with any union data inside the V1LbController_Transport_Config_Extension, using the provided TcpTransportConfig
func (t *V1LbController_Transport_Config_Extension) MergeTcpTransportConfig(v TcpTransportConfig) error {
	v.Type = "tcp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHttpTransportConfig returns the union data inside the V1LbController_Transport_Config_Extension as a HttpTransportConfig
func (t V1LbController_Transport_Config_Extension) AsHttpTransportConfig() (HttpTransportConfig, error) {
	var body HttpTransportConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHttpTransportConfig overwrites any union data inside the V1LbController_Transport_Config_Extension as the provided HttpTransportConfig
func (t *V1LbController_Transport_Config_Extension) FromHttpTransportConfig(v HttpTransportConfig) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHttpTransportConfig performs a merge with any union data inside the V1LbController_Transport_Config_Extension, using the provided HttpTransportConfig
func (t *V1LbController_Transport_Config_Extension) MergeHttpTransportConfig(v HttpTransportConfig) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUdpTransportConfig returns the union data inside the V1LbController_Transport_Config_Extension as a UdpTransportConfig
func (t V1LbController_Transport_Config_Extension) AsUdpTransportConfig() (UdpTransportConfig, error) {
	var body UdpTransportConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUdpTransportConfig overwrites any union data inside the V1LbController_Transport_Config_Extension as the provided UdpTransportConfig
func (t *V1LbController_Transport_Config_Extension) FromUdpTransportConfig(v UdpTransportConfig) error {
	v.Type = "udp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUdpTransportConfig performs a merge with any union data inside the V1LbController_Transport_Config_Extension, using the provided UdpTransportConfig
func (t *V1LbController_Transport_Config_Extension) MergeUdpTransportConfig(v UdpTransportConfig) error {
	v.Type = "udp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V1LbController_Transport_Config_Extension) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t V1LbController_Transport_Config_Extension) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "http":
		return t.AsHttpTransportConfig()
	case "tcp":
		return t.AsTcpTransportConfig()
	case "udp":
		return t.AsUdpTransportConfig()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t V1LbController_Transport_Config_Extension) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V1LbController_Transport_Config_Extension) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVirtualMachineImageSourceUrl returns the union data inside the VirtualMachineImage as a VirtualMachineImageSourceUrl
func (t VirtualMachineImage) AsVirtualMachineImageSourceUrl() (VirtualMachineImageSourceUrl, error) {
	var body VirtualMachineImageSourceUrl
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineImageSourceUrl overwrites any union data inside the VirtualMachineImage as the provided VirtualMachineImageSourceUrl
func (t *VirtualMachineImage) FromVirtualMachineImageSourceUrl(v VirtualMachineImageSourceUrl) error {
	v.Type = "url"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineImageSourceUrl performs a merge with any union data inside the VirtualMachineImage, using the provided VirtualMachineImageSourceUrl
func (t *VirtualMachineImage) MergeVirtualMachineImageSourceUrl(v VirtualMachineImageSourceUrl) error {
	v.Type = "url"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualMachineImageSourceIpxe returns the union data inside the VirtualMachineImage as a VirtualMachineImageSourceIpxe
func (t VirtualMachineImage) AsVirtualMachineImageSourceIpxe() (VirtualMachineImageSourceIpxe, error) {
	var body VirtualMachineImageSourceIpxe
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineImageSourceIpxe overwrites any union data inside the VirtualMachineImage as the provided VirtualMachineImageSourceIpxe
func (t *VirtualMachineImage) FromVirtualMachineImageSourceIpxe(v VirtualMachineImageSourceIpxe) error {
	v.Type = "ipxe"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineImageSourceIpxe performs a merge with any union data inside the VirtualMachineImage, using the provided VirtualMachineImageSourceIpxe
func (t *VirtualMachineImage) MergeVirtualMachineImageSourceIpxe(v VirtualMachineImageSourceIpxe) error {
	v.Type = "ipxe"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualMachineImageSourceBase returns the union data inside the VirtualMachineImage as a VirtualMachineImageSourceBase
func (t VirtualMachineImage) AsVirtualMachineImageSourceBase() (VirtualMachineImageSourceBase, error) {
	var body VirtualMachineImageSourceBase
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineImageSourceBase overwrites any union data inside the VirtualMachineImage as the provided VirtualMachineImageSourceBase
func (t *VirtualMachineImage) FromVirtualMachineImageSourceBase(v VirtualMachineImageSourceBase) error {
	v.Type = "base"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineImageSourceBase performs a merge with any union data inside the VirtualMachineImage, using the provided VirtualMachineImageSourceBase
func (t *VirtualMachineImage) MergeVirtualMachineImageSourceBase(v VirtualMachineImageSourceBase) error {
	v.Type = "base"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualMachineImageSourceExternalVolume returns the union data inside the VirtualMachineImage as a VirtualMachineImageSourceExternalVolume
func (t VirtualMachineImage) AsVirtualMachineImageSourceExternalVolume() (VirtualMachineImageSourceExternalVolume, error) {
	var body VirtualMachineImageSourceExternalVolume
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineImageSourceExternalVolume overwrites any union data inside the VirtualMachineImage as the provided VirtualMachineImageSourceExternalVolume
func (t *VirtualMachineImage) FromVirtualMachineImageSourceExternalVolume(v VirtualMachineImageSourceExternalVolume) error {
	v.Type = "external-volume"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineImageSourceExternalVolume performs a merge with any union data inside the VirtualMachineImage, using the provided VirtualMachineImageSourceExternalVolume
func (t *VirtualMachineImage) MergeVirtualMachineImageSourceExternalVolume(v VirtualMachineImageSourceExternalVolume) error {
	v.Type = "external-volume"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VirtualMachineImage) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t VirtualMachineImage) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "base":
		return t.AsVirtualMachineImageSourceBase()
	case "external-volume":
		return t.AsVirtualMachineImageSourceExternalVolume()
	case "ipxe":
		return t.AsVirtualMachineImageSourceIpxe()
	case "url":
		return t.AsVirtualMachineImageSourceUrl()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t VirtualMachineImage) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VirtualMachineImage) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVirtualMachineAttachmentTypeIso returns the union data inside the VirtualMachineRuntimeConfigAttachment as a VirtualMachineAttachmentTypeIso
func (t VirtualMachineRuntimeConfigAttachment) AsVirtualMachineAttachmentTypeIso() (VirtualMachineAttachmentTypeIso, error) {
	var body VirtualMachineAttachmentTypeIso
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineAttachmentTypeIso overwrites any union data inside the VirtualMachineRuntimeConfigAttachment as the provided VirtualMachineAttachmentTypeIso
func (t *VirtualMachineRuntimeConfigAttachment) FromVirtualMachineAttachmentTypeIso(v VirtualMachineAttachmentTypeIso) error {
	v.Type = "iso"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineAttachmentTypeIso performs a merge with any union data inside the VirtualMachineRuntimeConfigAttachment, using the provided VirtualMachineAttachmentTypeIso
func (t *VirtualMachineRuntimeConfigAttachment) MergeVirtualMachineAttachmentTypeIso(v VirtualMachineAttachmentTypeIso) error {
	v.Type = "iso"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VirtualMachineRuntimeConfigAttachment) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t VirtualMachineRuntimeConfigAttachment) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "iso":
		return t.AsVirtualMachineAttachmentTypeIso()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t VirtualMachineRuntimeConfigAttachment) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VirtualMachineRuntimeConfigAttachment) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVirtualMachineCpuConfigDefault returns the union data inside the VirtualMachineRuntimeConfigHardware_Cpu as a VirtualMachineCpuConfigDefault
func (t VirtualMachineRuntimeConfigHardware_Cpu) AsVirtualMachineCpuConfigDefault() (VirtualMachineCpuConfigDefault, error) {
	var body VirtualMachineCpuConfigDefault
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineCpuConfigDefault overwrites any union data inside the VirtualMachineRuntimeConfigHardware_Cpu as the provided VirtualMachineCpuConfigDefault
func (t *VirtualMachineRuntimeConfigHardware_Cpu) FromVirtualMachineCpuConfigDefault(v VirtualMachineCpuConfigDefault) error {
	v.Type = "host"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineCpuConfigDefault performs a merge with any union data inside the VirtualMachineRuntimeConfigHardware_Cpu, using the provided VirtualMachineCpuConfigDefault
func (t *VirtualMachineRuntimeConfigHardware_Cpu) MergeVirtualMachineCpuConfigDefault(v VirtualMachineCpuConfigDefault) error {
	v.Type = "host"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualMachineCpuConfigCustom returns the union data inside the VirtualMachineRuntimeConfigHardware_Cpu as a VirtualMachineCpuConfigCustom
func (t VirtualMachineRuntimeConfigHardware_Cpu) AsVirtualMachineCpuConfigCustom() (VirtualMachineCpuConfigCustom, error) {
	var body VirtualMachineCpuConfigCustom
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineCpuConfigCustom overwrites any union data inside the VirtualMachineRuntimeConfigHardware_Cpu as the provided VirtualMachineCpuConfigCustom
func (t *VirtualMachineRuntimeConfigHardware_Cpu) FromVirtualMachineCpuConfigCustom(v VirtualMachineCpuConfigCustom) error {
	v.Type = "custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineCpuConfigCustom performs a merge with any union data inside the VirtualMachineRuntimeConfigHardware_Cpu, using the provided VirtualMachineCpuConfigCustom
func (t *VirtualMachineRuntimeConfigHardware_Cpu) MergeVirtualMachineCpuConfigCustom(v VirtualMachineCpuConfigCustom) error {
	v.Type = "custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VirtualMachineRuntimeConfigHardware_Cpu) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t VirtualMachineRuntimeConfigHardware_Cpu) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "custom":
		return t.AsVirtualMachineCpuConfigCustom()
	case "host":
		return t.AsVirtualMachineCpuConfigDefault()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t VirtualMachineRuntimeConfigHardware_Cpu) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VirtualMachineRuntimeConfigHardware_Cpu) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVirtualMachineStartAction returns the union data inside the VirtualMachineTask as a VirtualMachineStartAction
func (t VirtualMachineTask) AsVirtualMachineStartAction() (VirtualMachineStartAction, error) {
	var body VirtualMachineStartAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineStartAction overwrites any union data inside the VirtualMachineTask as the provided VirtualMachineStartAction
func (t *VirtualMachineTask) FromVirtualMachineStartAction(v VirtualMachineStartAction) error {
	v.Action = "start"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineStartAction performs a merge with any union data inside the VirtualMachineTask, using the provided VirtualMachineStartAction
func (t *VirtualMachineTask) MergeVirtualMachineStartAction(v VirtualMachineStartAction) error {
	v.Action = "start"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualMachineStopAction returns the union data inside the VirtualMachineTask as a VirtualMachineStopAction
func (t VirtualMachineTask) AsVirtualMachineStopAction() (VirtualMachineStopAction, error) {
	var body VirtualMachineStopAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineStopAction overwrites any union data inside the VirtualMachineTask as the provided VirtualMachineStopAction
func (t *VirtualMachineTask) FromVirtualMachineStopAction(v VirtualMachineStopAction) error {
	v.Action = "stop"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineStopAction performs a merge with any union data inside the VirtualMachineTask, using the provided VirtualMachineStopAction
func (t *VirtualMachineTask) MergeVirtualMachineStopAction(v VirtualMachineStopAction) error {
	v.Action = "stop"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualMachineRestartAction returns the union data inside the VirtualMachineTask as a VirtualMachineRestartAction
func (t VirtualMachineTask) AsVirtualMachineRestartAction() (VirtualMachineRestartAction, error) {
	var body VirtualMachineRestartAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineRestartAction overwrites any union data inside the VirtualMachineTask as the provided VirtualMachineRestartAction
func (t *VirtualMachineTask) FromVirtualMachineRestartAction(v VirtualMachineRestartAction) error {
	v.Action = "restart"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineRestartAction performs a merge with any union data inside the VirtualMachineTask, using the provided VirtualMachineRestartAction
func (t *VirtualMachineTask) MergeVirtualMachineRestartAction(v VirtualMachineRestartAction) error {
	v.Action = "restart"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualMachineReconfigureAction returns the union data inside the VirtualMachineTask as a VirtualMachineReconfigureAction
func (t VirtualMachineTask) AsVirtualMachineReconfigureAction() (VirtualMachineReconfigureAction, error) {
	var body VirtualMachineReconfigureAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineReconfigureAction overwrites any union data inside the VirtualMachineTask as the provided VirtualMachineReconfigureAction
func (t *VirtualMachineTask) FromVirtualMachineReconfigureAction(v VirtualMachineReconfigureAction) error {
	v.Action = "reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineReconfigureAction performs a merge with any union data inside the VirtualMachineTask, using the provided VirtualMachineReconfigureAction
func (t *VirtualMachineTask) MergeVirtualMachineReconfigureAction(v VirtualMachineReconfigureAction) error {
	v.Action = "reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualMachineRootPwChangeAction returns the union data inside the VirtualMachineTask as a VirtualMachineRootPwChangeAction
func (t VirtualMachineTask) AsVirtualMachineRootPwChangeAction() (VirtualMachineRootPwChangeAction, error) {
	var body VirtualMachineRootPwChangeAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineRootPwChangeAction overwrites any union data inside the VirtualMachineTask as the provided VirtualMachineRootPwChangeAction
func (t *VirtualMachineTask) FromVirtualMachineRootPwChangeAction(v VirtualMachineRootPwChangeAction) error {
	v.Action = "rootpw.change"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineRootPwChangeAction performs a merge with any union data inside the VirtualMachineTask, using the provided VirtualMachineRootPwChangeAction
func (t *VirtualMachineTask) MergeVirtualMachineRootPwChangeAction(v VirtualMachineRootPwChangeAction) error {
	v.Action = "rootpw.change"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualMachineIpAllocateAction returns the union data inside the VirtualMachineTask as a VirtualMachineIpAllocateAction
func (t VirtualMachineTask) AsVirtualMachineIpAllocateAction() (VirtualMachineIpAllocateAction, error) {
	var body VirtualMachineIpAllocateAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineIpAllocateAction overwrites any union data inside the VirtualMachineTask as the provided VirtualMachineIpAllocateAction
func (t *VirtualMachineTask) FromVirtualMachineIpAllocateAction(v VirtualMachineIpAllocateAction) error {
	v.Action = "ip.allocate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineIpAllocateAction performs a merge with any union data inside the VirtualMachineTask, using the provided VirtualMachineIpAllocateAction
func (t *VirtualMachineTask) MergeVirtualMachineIpAllocateAction(v VirtualMachineIpAllocateAction) error {
	v.Action = "ip.allocate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualMachineIpUnallocateAction returns the union data inside the VirtualMachineTask as a VirtualMachineIpUnallocateAction
func (t VirtualMachineTask) AsVirtualMachineIpUnallocateAction() (VirtualMachineIpUnallocateAction, error) {
	var body VirtualMachineIpUnallocateAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineIpUnallocateAction overwrites any union data inside the VirtualMachineTask as the provided VirtualMachineIpUnallocateAction
func (t *VirtualMachineTask) FromVirtualMachineIpUnallocateAction(v VirtualMachineIpUnallocateAction) error {
	v.Action = "ip.unallocate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineIpUnallocateAction performs a merge with any union data inside the VirtualMachineTask, using the provided VirtualMachineIpUnallocateAction
func (t *VirtualMachineTask) MergeVirtualMachineIpUnallocateAction(v VirtualMachineIpUnallocateAction) error {
	v.Action = "ip.unallocate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVirtualMachineReconfigureVolumesAction returns the union data inside the VirtualMachineTask as a VirtualMachineReconfigureVolumesAction
func (t VirtualMachineTask) AsVirtualMachineReconfigureVolumesAction() (VirtualMachineReconfigureVolumesAction, error) {
	var body VirtualMachineReconfigureVolumesAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualMachineReconfigureVolumesAction overwrites any union data inside the VirtualMachineTask as the provided VirtualMachineReconfigureVolumesAction
func (t *VirtualMachineTask) FromVirtualMachineReconfigureVolumesAction(v VirtualMachineReconfigureVolumesAction) error {
	v.Action = "volumes.reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualMachineReconfigureVolumesAction performs a merge with any union data inside the VirtualMachineTask, using the provided VirtualMachineReconfigureVolumesAction
func (t *VirtualMachineTask) MergeVirtualMachineReconfigureVolumesAction(v VirtualMachineReconfigureVolumesAction) error {
	v.Action = "volumes.reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VirtualMachineTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t VirtualMachineTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ip.allocate":
		return t.AsVirtualMachineIpAllocateAction()
	case "ip.unallocate":
		return t.AsVirtualMachineIpUnallocateAction()
	case "reconfigure":
		return t.AsVirtualMachineReconfigureAction()
	case "restart":
		return t.AsVirtualMachineRestartAction()
	case "rootpw.change":
		return t.AsVirtualMachineRootPwChangeAction()
	case "start":
		return t.AsVirtualMachineStartAction()
	case "stop":
		return t.AsVirtualMachineStopAction()
	case "volumes.reconfigure":
		return t.AsVirtualMachineReconfigureVolumesAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t VirtualMachineTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VirtualMachineTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVirtualProviderGenerateIsoAction returns the union data inside the VirtualProviderIsoTask as a VirtualProviderGenerateIsoAction
func (t VirtualProviderIsoTask) AsVirtualProviderGenerateIsoAction() (VirtualProviderGenerateIsoAction, error) {
	var body VirtualProviderGenerateIsoAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVirtualProviderGenerateIsoAction overwrites any union data inside the VirtualProviderIsoTask as the provided VirtualProviderGenerateIsoAction
func (t *VirtualProviderIsoTask) FromVirtualProviderGenerateIsoAction(v VirtualProviderGenerateIsoAction) error {
	v.Action = "generate"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVirtualProviderGenerateIsoAction performs a merge with any union data inside the VirtualProviderIsoTask, using the provided VirtualProviderGenerateIsoAction
func (t *VirtualProviderIsoTask) MergeVirtualProviderGenerateIsoAction(v VirtualProviderGenerateIsoAction) error {
	v.Action = "generate"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VirtualProviderIsoTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t VirtualProviderIsoTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "generate":
		return t.AsVirtualProviderGenerateIsoAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t VirtualProviderIsoTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VirtualProviderIsoTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVpnResetAction returns the union data inside the VpnTask as a VpnResetAction
func (t VpnTask) AsVpnResetAction() (VpnResetAction, error) {
	var body VpnResetAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVpnResetAction overwrites any union data inside the VpnTask as the provided VpnResetAction
func (t *VpnTask) FromVpnResetAction(v VpnResetAction) error {
	v.Action = "reset"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVpnResetAction performs a merge with any union data inside the VpnTask, using the provided VpnResetAction
func (t *VpnTask) MergeVpnResetAction(v VpnResetAction) error {
	v.Action = "reset"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVpnReconfigureAction returns the union data inside the VpnTask as a VpnReconfigureAction
func (t VpnTask) AsVpnReconfigureAction() (VpnReconfigureAction, error) {
	var body VpnReconfigureAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVpnReconfigureAction overwrites any union data inside the VpnTask as the provided VpnReconfigureAction
func (t *VpnTask) FromVpnReconfigureAction(v VpnReconfigureAction) error {
	v.Action = "reconfigure"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVpnReconfigureAction performs a merge with any union data inside the VpnTask, using the provided VpnReconfigureAction
func (t *VpnTask) MergeVpnReconfigureAction(v VpnReconfigureAction) error {
	v.Action = "reconfigure"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t VpnTask) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"action"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t VpnTask) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "reconfigure":
		return t.AsVpnReconfigureAction()
	case "reset":
		return t.AsVpnResetAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t VpnTask) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *VpnTask) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteAccount request
	DeleteAccount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccount request
	GetAccount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccountWithBody request with any body
	UpdateAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccount(ctx context.Context, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableTwoFactorAuthWithBody request with any body
	DisableTwoFactorAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DisableTwoFactorAuth(ctx context.Context, body DisableTwoFactorAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecoverTwoFactorAuthWithBody request with any body
	RecoverTwoFactorAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RecoverTwoFactorAuth(ctx context.Context, body RecoverTwoFactorAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTwoFactorAuthSetup request
	GetTwoFactorAuthSetup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableTwoFactorAuthWithBody request with any body
	EnableTwoFactorAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnableTwoFactorAuth(ctx context.Context, body EnableTwoFactorAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountInvites request
	GetAccountInvites(ctx context.Context, params *GetAccountInvitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccountInviteWithBody request with any body
	UpdateAccountInviteWithBody(ctx context.Context, inviteId string, params *UpdateAccountInviteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccountInvite(ctx context.Context, inviteId string, params *UpdateAccountInviteParams, body UpdateAccountInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountLogins request
	GetAccountLogins(ctx context.Context, params *GetAccountLoginsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountMemberships request
	GetAccountMemberships(ctx context.Context, params *GetAccountMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangePasswordWithBody request with any body
	ChangePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangePassword(ctx context.Context, body ChangePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPasswordWithBody request with any body
	ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPassword(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnnouncements request
	GetAnnouncements(ctx context.Context, params *GetAnnouncementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredits request
	GetCredits(ctx context.Context, params *GetCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCredit request
	GetCredit(ctx context.Context, creditsId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvoices request
	GetInvoices(ctx context.Context, params *GetInvoicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvoice request
	GetInvoice(ctx context.Context, invoiceId string, params *GetInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInvoiceJobWithBody request with any body
	CreateInvoiceJobWithBody(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInvoiceJob(ctx context.Context, invoiceId string, body CreateInvoiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingMethods request
	GetBillingMethods(ctx context.Context, params *GetBillingMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBillingMethodWithBody request with any body
	CreateBillingMethodWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBillingMethod(ctx context.Context, body CreateBillingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBillingMethod request
	DeleteBillingMethod(ctx context.Context, methodId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingMethod request
	GetBillingMethod(ctx context.Context, methodId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBillingMethodWithBody request with any body
	UpdateBillingMethodWithBody(ctx context.Context, methodId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBillingMethod(ctx context.Context, methodId string, body UpdateBillingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBillingMethodJobWithBody request with any body
	CreateBillingMethodJobWithBody(ctx context.Context, methodId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBillingMethodJob(ctx context.Context, methodId string, body CreateBillingMethodJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrders request
	GetOrders(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrderWithBody request with any body
	CreateOrderWithBody(ctx context.Context, params *CreateOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrder(ctx context.Context, params *CreateOrderParams, body CreateOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingOrder request
	GetBillingOrder(ctx context.Context, orderId string, params *GetBillingOrderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBillingOrderWithBody request with any body
	UpdateBillingOrderWithBody(ctx context.Context, orderId string, params *UpdateBillingOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBillingOrder(ctx context.Context, orderId string, params *UpdateBillingOrderParams, body UpdateBillingOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrderJobWithBody request with any body
	CreateOrderJobWithBody(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrderJob(ctx context.Context, orderId string, body CreateOrderJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingSupportPlans request
	GetBillingSupportPlans(ctx context.Context, params *GetBillingSupportPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingTiers request
	GetBillingTiers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingServices request
	GetBillingServices(ctx context.Context, params *GetBillingServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingOverages request
	GetBillingOverages(ctx context.Context, params *GetBillingOveragesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingService request
	GetBillingService(ctx context.Context, servicesId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingStatus request
	GetBillingStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChangelog request
	GetChangelog(ctx context.Context, params *GetChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainers request
	GetContainers(ctx context.Context, params *GetContainersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateContainerWithBody request with any body
	CreateContainerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateContainer(ctx context.Context, body CreateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteContainer request
	DeleteContainer(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainer request
	GetContainer(ctx context.Context, containerId string, params *GetContainerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateContainerWithBody request with any body
	UpdateContainerWithBody(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateContainer(ctx context.Context, containerId string, body UpdateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerBackups request
	GetContainerBackups(ctx context.Context, containerId string, params *GetContainerBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteContainerBackup request
	DeleteContainerBackup(ctx context.Context, containerId string, backupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerBackup request
	GetContainerBackup(ctx context.Context, containerId string, backupId string, params *GetContainerBackupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerBackupLogs request
	GetContainerBackupLogs(ctx context.Context, containerId string, backupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateContainerBackupJobWithBody request with any body
	CreateContainerBackupJobWithBody(ctx context.Context, containerId string, backupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateContainerBackupJob(ctx context.Context, containerId string, backupId string, body CreateContainerBackupJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompatibleImages request
	GetCompatibleImages(ctx context.Context, containerId string, params *GetCompatibleImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFunctionJobWithBody request with any body
	CreateFunctionJobWithBody(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFunctionJob(ctx context.Context, containerId string, body CreateFunctionJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteContainerInstances request
	DeleteContainerInstances(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstances request
	GetInstances(ctx context.Context, containerId string, params *GetInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInstancesWithBody request with any body
	CreateInstancesWithBody(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInstances(ctx context.Context, containerId string, body CreateInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInstance request
	DeleteInstance(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstance request
	GetInstance(ctx context.Context, containerId string, instanceId string, params *GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstanceConsoleStreamAuth request
	GetInstanceConsoleStreamAuth(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpireInstanceSSHCredentials request
	ExpireInstanceSSHCredentials(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateInstanceSSHCredentials request
	GenerateInstanceSSHCredentials(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInstanceJobWithBody request with any body
	CreateInstanceJobWithBody(ctx context.Context, containerId string, instanceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInstanceJob(ctx context.Context, containerId string, instanceId string, body CreateInstanceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstanceTelemetryReport request
	GetInstanceTelemetryReport(ctx context.Context, containerId string, instanceId string, params *GetInstanceTelemetryReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstanceTelemetryStreamAuth request
	GetInstanceTelemetryStreamAuth(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInstanceVolumes request
	GetInstanceVolumes(ctx context.Context, containerId string, instanceId string, params *GetInstanceVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerServers request
	GetContainerServers(ctx context.Context, containerId string, params *GetContainerServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCompatibleServers request
	GetCompatibleServers(ctx context.Context, containerId string, params *GetCompatibleServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerSummary request
	GetContainerSummary(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateContainerJobWithBody request with any body
	CreateContainerJobWithBody(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateContainerJob(ctx context.Context, containerId string, body CreateContainerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTLSGenerationAttempts request
	GetTLSGenerationAttempts(ctx context.Context, params *GetTLSGenerationAttemptsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LookupTLSCertificate request
	LookupTLSCertificate(ctx context.Context, params *LookupTLSCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserSuppliedCertificates request
	GetUserSuppliedCertificates(ctx context.Context, params *GetUserSuppliedCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadUserSuppliedCertificateWithBody request with any body
	UploadUserSuppliedCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadUserSuppliedCertificate(ctx context.Context, body UploadUserSuppliedCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserSuppliedCertificate request
	GetUserSuppliedCertificate(ctx context.Context, certificateId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserSuppliedCertificateJobWithBody request with any body
	CreateUserSuppliedCertificateJobWithBody(ctx context.Context, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserSuppliedCertificateJob(ctx context.Context, certificateId string, body CreateUserSuppliedCertificateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDNSZones request
	GetDNSZones(ctx context.Context, params *GetDNSZonesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDNSZoneWithBody request with any body
	CreateDNSZoneWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDNSZone(ctx context.Context, body CreateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDNSZone request
	DeleteDNSZone(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDNSZone request
	GetDNSZone(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDNSZoneWithBody request with any body
	UpdateDNSZoneWithBody(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDNSZone(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, body UpdateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDNSZoneAccessWithBody request with any body
	UpdateDNSZoneAccessWithBody(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDNSZoneAccess(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, body UpdateDNSZoneAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDNSZoneRecords request
	GetDNSZoneRecords(ctx context.Context, zoneId string, params *GetDNSZoneRecordsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDNSZoneRecordWithBody request with any body
	CreateDNSZoneRecordWithBody(ctx context.Context, zoneId string, params *CreateDNSZoneRecordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDNSZoneRecord(ctx context.Context, zoneId string, params *CreateDNSZoneRecordParams, body CreateDNSZoneRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDNSZoneRecord request
	DeleteDNSZoneRecord(ctx context.Context, zoneId string, recordId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDNSZoneRecordWithBody request with any body
	UpdateDNSZoneRecordWithBody(ctx context.Context, zoneId string, recordId string, params *UpdateDNSZoneRecordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDNSZoneRecord(ctx context.Context, zoneId string, recordId string, params *UpdateDNSZoneRecordParams, body UpdateDNSZoneRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDNSZoneRecordJobWithBody request with any body
	CreateDNSZoneRecordJobWithBody(ctx context.Context, zoneId string, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDNSZoneRecordJob(ctx context.Context, zoneId string, recordId string, body CreateDNSZoneRecordJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDNSZoneJobWithBody request with any body
	CreateDNSZoneJobWithBody(ctx context.Context, zoneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDNSZoneJob(ctx context.Context, zoneId string, body CreateDNSZoneJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironments request
	GetEnvironments(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEnvironmentWithBody request with any body
	CreateEnvironmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEnvironment(ctx context.Context, body CreateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEnvironment request
	DeleteEnvironment(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironment request
	GetEnvironment(ctx context.Context, environmentId string, params *GetEnvironmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEnvironmentWithBody request with any body
	UpdateEnvironmentWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEnvironment(ctx context.Context, environmentId string, body UpdateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEnvironmentAccessWithBody request with any body
	UpdateEnvironmentAccessWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEnvironmentAccess(ctx context.Context, environmentId string, body UpdateEnvironmentAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironmentDeployments request
	GetEnvironmentDeployments(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportStackWithBody request with any body
	ExportStackWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportStack(ctx context.Context, environmentId string, body ExportStackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScopedVariables request
	GetScopedVariables(ctx context.Context, environmentId string, params *GetScopedVariablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateScopedVariableWithBody request with any body
	CreateScopedVariableWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateScopedVariable(ctx context.Context, environmentId string, body CreateScopedVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteScopedVariable request
	DeleteScopedVariable(ctx context.Context, environmentId string, scopedVariableId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScopedVariable request
	GetScopedVariable(ctx context.Context, environmentId string, scopedVariableId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateScopedVariableWithBody request with any body
	UpdateScopedVariableWithBody(ctx context.Context, environmentId string, scopedVariableId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateScopedVariable(ctx context.Context, environmentId string, scopedVariableId string, body UpdateScopedVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDiscoveryServiceJobWithBody request with any body
	CreateDiscoveryServiceJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDiscoveryServiceJob(ctx context.Context, environmentId string, body CreateDiscoveryServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGatewayServiceJobWithBody request with any body
	CreateGatewayServiceJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGatewayServiceJob(ctx context.Context, environmentId string, body CreateGatewayServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoadBalancerService request
	GetLoadBalancerService(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLoadBalancerServiceJobWithBody request with any body
	CreateLoadBalancerServiceJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLoadBalancerServiceJob(ctx context.Context, environmentId string, body CreateLoadBalancerServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoadBalancerLatestTelemetryReport request
	GetLoadBalancerLatestTelemetryReport(ctx context.Context, environmentId string, params *GetLoadBalancerLatestTelemetryReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoadBalancerTelemetryLatestControllers request
	GetLoadBalancerTelemetryLatestControllers(ctx context.Context, environmentId string, params *GetLoadBalancerTelemetryLatestControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoadBalancerTelemetryReport request
	GetLoadBalancerTelemetryReport(ctx context.Context, environmentId string, params *GetLoadBalancerTelemetryReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSchedulerServiceJobWithBody request with any body
	CreateSchedulerServiceJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSchedulerServiceJob(ctx context.Context, environmentId string, body CreateSchedulerServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVPNService request
	GetVPNService(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVPNLogins request
	GetVPNLogins(ctx context.Context, environmentId string, params *GetVPNLoginsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVPNServiceJobWithBody request with any body
	CreateVPNServiceJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVPNServiceJob(ctx context.Context, environmentId string, body CreateVPNServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVPNUsers request
	GetVPNUsers(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVPNUserWithBody request with any body
	CreateVPNUserWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVPNUser(ctx context.Context, environmentId string, body CreateVPNUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVPNUser request
	DeleteVPNUser(ctx context.Context, environmentId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironmentSummary request
	GetEnvironmentSummary(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEnvironmentJobWithBody request with any body
	CreateEnvironmentJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEnvironmentJob(ctx context.Context, environmentId string, body CreateEnvironmentJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubs request
	GetHubs(ctx context.Context, params *GetHubsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHubWithBody request with any body
	CreateHubWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHub(ctx context.Context, body CreateHubJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubCapabilities request
	GetHubCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHubWithBody request with any body
	DeleteHubWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteHub(ctx context.Context, body DeleteHubJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHub request
	GetHub(ctx context.Context, params *GetHubParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateHubWithBody request with any body
	UpdateHubWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateHub(ctx context.Context, body UpdateHubJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubActivity request
	GetHubActivity(ctx context.Context, params *GetHubActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiKeys request
	GetApiKeys(ctx context.Context, params *GetApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApiKeyWithBody request with any body
	CreateApiKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApiKey(ctx context.Context, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAPIKey request
	DeleteAPIKey(ctx context.Context, apikeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAPIKey request
	GetAPIKey(ctx context.Context, apikeyId string, params *GetAPIKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAPIKeyWithBody request with any body
	UpdateAPIKeyWithBody(ctx context.Context, apikeyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAPIKey(ctx context.Context, apikeyId string, body UpdateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegrations request
	GetIntegrations(ctx context.Context, params *GetIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIntegrationWithBody request with any body
	CreateIntegrationWithBody(ctx context.Context, params *CreateIntegrationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIntegration(ctx context.Context, params *CreateIntegrationParams, body CreateIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableIntegrations request
	GetAvailableIntegrations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIntegration request
	DeleteIntegration(ctx context.Context, integrationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIntegration request
	GetIntegration(ctx context.Context, integrationId string, params *GetIntegrationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIntegrationWithBody request with any body
	UpdateIntegrationWithBody(ctx context.Context, integrationId string, params *UpdateIntegrationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIntegration(ctx context.Context, integrationId string, params *UpdateIntegrationParams, body UpdateIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIntegrationJobWithBody request with any body
	CreateIntegrationJobWithBody(ctx context.Context, integrationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIntegrationJob(ctx context.Context, integrationId string, body CreateIntegrationJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubInvites request
	GetHubInvites(ctx context.Context, params *GetHubInvitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHubInviteWithBody request with any body
	CreateHubInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHubInvite(ctx context.Context, body CreateHubInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHubInvite request
	DeleteHubInvite(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubMembers request
	GetHubMembers(ctx context.Context, params *GetHubMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubMemberAccount request
	GetHubMemberAccount(ctx context.Context, accountId string, params *GetHubMemberAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHubMember request
	DeleteHubMember(ctx context.Context, memberId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubMember request
	GetHubMember(ctx context.Context, memberId string, params *GetHubMemberParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateHubMemberWithBody request with any body
	UpdateHubMemberWithBody(ctx context.Context, memberId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateHubMember(ctx context.Context, memberId string, body UpdateHubMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubMembership request
	GetHubMembership(ctx context.Context, params *GetHubMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubNotificationSocketAuth request
	GetHubNotificationSocketAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoles request
	GetRoles(ctx context.Context, params *GetRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRoleWithBody request with any body
	CreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRole(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultHubRoles request
	GetDefaultHubRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRole request
	DeleteRole(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRole request
	GetRole(ctx context.Context, roleId string, params *GetRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoleWithBody request with any body
	UpdateRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRole(ctx context.Context, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHubUsage request
	GetHubUsage(ctx context.Context, params *GetHubUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImages request
	GetImages(ctx context.Context, params *GetImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImageWithBody request with any body
	CreateImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateImage(ctx context.Context, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImageSources request
	GetImageSources(ctx context.Context, params *GetImageSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImageSourceWithBody request with any body
	CreateImageSourceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateImageSource(ctx context.Context, body CreateImageSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImageSource request
	DeleteImageSource(ctx context.Context, sourceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImageSource request
	GetImageSource(ctx context.Context, sourceId string, params *GetImageSourceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateImageSourceWithBody request with any body
	UpdateImageSourceWithBody(ctx context.Context, sourceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateImageSource(ctx context.Context, sourceId string, body UpdateImageSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateImageSourceAccessWithBody request with any body
	UpdateImageSourceAccessWithBody(ctx context.Context, sourceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateImageSourceAccess(ctx context.Context, sourceId string, body UpdateImageSourceAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImagesJobWithBody request with any body
	CreateImagesJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateImagesJob(ctx context.Context, body CreateImagesJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImage request
	DeleteImage(ctx context.Context, imageId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImage request
	GetImage(ctx context.Context, imageId string, params *GetImageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateImageWithBody request with any body
	UpdateImageWithBody(ctx context.Context, imageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateImage(ctx context.Context, imageId string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImageBuildLog request
	GetImageBuildLog(ctx context.Context, imageId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImageJobWithBody request with any body
	CreateImageJobWithBody(ctx context.Context, imageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateImageJob(ctx context.Context, imageId string, body CreateImageJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutoScaleGroups request
	GetAutoScaleGroups(ctx context.Context, params *GetAutoScaleGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAutoScaleGroupWithBody request with any body
	CreateAutoScaleGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAutoScaleGroup(ctx context.Context, body CreateAutoScaleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAutoScaleGroup request
	DeleteAutoScaleGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutoScaleGroup request
	GetAutoScaleGroup(ctx context.Context, groupId string, params *GetAutoScaleGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAutoScaleGroupWithBody request with any body
	UpdateAutoScaleGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAutoScaleGroup(ctx context.Context, groupId string, body UpdateAutoScaleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAutoScaleGroupAccessWithBody request with any body
	UpdateAutoScaleGroupAccessWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAutoScaleGroupAccess(ctx context.Context, groupId string, body UpdateAutoScaleGroupAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusters request
	GetClusters(ctx context.Context, params *GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterWithBody request with any body
	CreateClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterWithBody request with any body
	UpdateClusterWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCluster(ctx context.Context, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterAccessWithBody request with any body
	UpdateClusterAccessWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateClusterAccess(ctx context.Context, clusterId string, body UpdateClusterAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterJobWithBody request with any body
	CreateClusterJobWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClusterJob(ctx context.Context, clusterId string, body CreateClusterJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeploymentStrategies request
	GetDeploymentStrategies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExternalVolumes request
	GetExternalVolumes(ctx context.Context, params *GetExternalVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateExternalVolumeWithBody request with any body
	CreateExternalVolumeWithBody(ctx context.Context, params *CreateExternalVolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateExternalVolume(ctx context.Context, params *CreateExternalVolumeParams, body CreateExternalVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExternalVolumeSources request
	GetExternalVolumeSources(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteExternalVolumeWithBody request with any body
	DeleteExternalVolumeWithBody(ctx context.Context, externalVolumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteExternalVolume(ctx context.Context, externalVolumeId string, body DeleteExternalVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExternalVolume request
	GetExternalVolume(ctx context.Context, externalVolumeId string, params *GetExternalVolumeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateExternalVolumeWithBody request with any body
	UpdateExternalVolumeWithBody(ctx context.Context, externalVolumeId string, params *UpdateExternalVolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateExternalVolume(ctx context.Context, externalVolumeId string, params *UpdateExternalVolumeParams, body UpdateExternalVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateExternalVolumeAccessWithBody request with any body
	UpdateExternalVolumeAccessWithBody(ctx context.Context, externalVolumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateExternalVolumeAccess(ctx context.Context, externalVolumeId string, body UpdateExternalVolumeAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateExternalVolumeJobWithBody request with any body
	CreateExternalVolumeJobWithBody(ctx context.Context, externalVolumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateExternalVolumeJob(ctx context.Context, externalVolumeId string, body CreateExternalVolumeJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIpPools request
	GetIpPools(ctx context.Context, params *GetIpPoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIpPoolWithBody request with any body
	CreateIpPoolWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIpPool(ctx context.Context, body CreateIpPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIPPool request
	DeleteIPPool(ctx context.Context, poolId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIPPool request
	GetIPPool(ctx context.Context, poolId string, params *GetIPPoolParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPoolIPs request
	GetPoolIPs(ctx context.Context, poolId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIpPoolJobWithBody request with any body
	CreateIpPoolJobWithBody(ctx context.Context, poolId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIpPoolJob(ctx context.Context, poolId string, body CreateIpPoolJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterMonitoringTiers request
	GetClusterMonitoringTiers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProviderLocations request
	GetProviderLocations(ctx context.Context, providerVendor string, params *GetProviderLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProviderServers request
	GetProviderServers(ctx context.Context, providerVendor string, params *GetProviderServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServers request
	GetServers(ctx context.Context, params *GetServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerWithBody request with any body
	CreateServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServer(ctx context.Context, body CreateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerTags request
	GetServerTags(ctx context.Context, params *GetServerTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerWithBody request with any body
	DeleteServerWithBody(ctx context.Context, serverId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteServer(ctx context.Context, serverId string, body DeleteServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServer request
	GetServer(ctx context.Context, serverId string, params *GetServerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServerWithBody request with any body
	UpdateServerWithBody(ctx context.Context, serverId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServer(ctx context.Context, serverId string, body UpdateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerConsole request
	GetServerConsole(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerInstances request
	GetServerInstances(ctx context.Context, serverId string, params *GetServerInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerJobWithBody request with any body
	CreateServerJobWithBody(ctx context.Context, serverId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerJob(ctx context.Context, serverId string, body CreateServerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerTelemetry request
	GetServerTelemetry(ctx context.Context, serverId string, params *GetServerTelemetryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerUsage request
	GetServerUsage(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInfrastructureSummary request
	GetInfrastructureSummary(ctx context.Context, params *GetInfrastructureSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualProviderIsos request
	GetVirtualProviderIsos(ctx context.Context, integrationId string, params *GetVirtualProviderIsosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVirtualProviderIsoWithBody request with any body
	CreateVirtualProviderIsoWithBody(ctx context.Context, integrationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVirtualProviderIso(ctx context.Context, integrationId string, body CreateVirtualProviderIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualProviderIso request
	DeleteVirtualProviderIso(ctx context.Context, integrationId string, isoId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualProviderIso request
	GetVirtualProviderIso(ctx context.Context, integrationId string, isoId string, params *GetVirtualProviderIsoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVirtualProviderIsoWithBody request with any body
	UpdateVirtualProviderIsoWithBody(ctx context.Context, integrationId string, isoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVirtualProviderIso(ctx context.Context, integrationId string, isoId string, body UpdateVirtualProviderIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualProviderIsoDownloadUrl request
	GetVirtualProviderIsoDownloadUrl(ctx context.Context, integrationId string, isoId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVirtualProviderIsoJobWithBody request with any body
	CreateVirtualProviderIsoJobWithBody(ctx context.Context, integrationId string, isoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVirtualProviderIsoJob(ctx context.Context, integrationId string, isoId string, body CreateVirtualProviderIsoJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobs request
	GetJobs(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestJobs request
	GetLatestJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEvents request
	GetEvents(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateAggregatedEventsWithBody request with any body
	GenerateAggregatedEventsWithBody(ctx context.Context, params *GenerateAggregatedEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateAggregatedEvents(ctx context.Context, params *GenerateAggregatedEventsParams, body GenerateAggregatedEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AggregateLogsWithBody request with any body
	AggregateLogsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AggregateLogs(ctx context.Context, body AggregateLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMetrics request
	GetMetrics(ctx context.Context, params *GetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateAggregatedMetricsWithBody request with any body
	GenerateAggregatedMetricsWithBody(ctx context.Context, params *GenerateAggregatedMetricsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateAggregatedMetrics(ctx context.Context, params *GenerateAggregatedMetricsParams, body GenerateAggregatedMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMonitoringMonitors request
	GetMonitoringMonitors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelines request
	GetPipelines(ctx context.Context, params *GetPipelinesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePipelineWithBody request with any body
	CreatePipelineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePipeline(ctx context.Context, body CreatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClonePipelineWithBody request with any body
	ClonePipelineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClonePipeline(ctx context.Context, body ClonePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePipeline request
	DeletePipeline(ctx context.Context, pipelineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipeline request
	GetPipeline(ctx context.Context, pipelineId string, params *GetPipelineParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePipelineWithBody request with any body
	UpdatePipelineWithBody(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePipeline(ctx context.Context, pipelineId string, body UpdatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePipelineAccessWithBody request with any body
	UpdatePipelineAccessWithBody(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePipelineAccess(ctx context.Context, pipelineId string, body UpdatePipelineAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelineTriggerKeys request
	GetPipelineTriggerKeys(ctx context.Context, pipelineId string, params *GetPipelineTriggerKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePipelineTriggerKeyWithBody request with any body
	CreatePipelineTriggerKeyWithBody(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePipelineTriggerKey(ctx context.Context, pipelineId string, body CreatePipelineTriggerKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePipelineTriggerKey request
	DeletePipelineTriggerKey(ctx context.Context, pipelineId string, triggerKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelineTriggerKey request
	GetPipelineTriggerKey(ctx context.Context, pipelineId string, triggerKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePipelineTriggerKeyWithBody request with any body
	UpdatePipelineTriggerKeyWithBody(ctx context.Context, pipelineId string, triggerKeyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePipelineTriggerKey(ctx context.Context, pipelineId string, triggerKeyId string, body UpdatePipelineTriggerKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelineRuns request
	GetPipelineRuns(ctx context.Context, pipelineId string, params *GetPipelineRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPipelineRun request
	GetPipelineRun(ctx context.Context, pipelineId string, runId string, params *GetPipelineRunParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePipelineJobWithBody request with any body
	CreatePipelineJobWithBody(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePipelineJob(ctx context.Context, pipelineId string, body CreatePipelineJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerPipelineWithBody request with any body
	TriggerPipelineWithBody(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TriggerPipeline(ctx context.Context, pipelineId string, body TriggerPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworks request
	GetNetworks(ctx context.Context, params *GetNetworksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNetworkWithBody request with any body
	CreateNetworkWithBody(ctx context.Context, params *CreateNetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNetwork(ctx context.Context, params *CreateNetworkParams, body CreateNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNetwork request
	DeleteNetwork(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetwork request
	GetNetwork(ctx context.Context, networkId string, params *GetNetworkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNetworkWithBody request with any body
	UpdateNetworkWithBody(ctx context.Context, networkId string, params *UpdateNetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNetwork(ctx context.Context, networkId string, params *UpdateNetworkParams, body UpdateNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNetworkAccessWithBody request with any body
	UpdateNetworkAccessWithBody(ctx context.Context, networkId string, params *UpdateNetworkAccessParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNetworkAccess(ctx context.Context, networkId string, params *UpdateNetworkAccessParams, body UpdateNetworkAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNetworkJobWithBody request with any body
	CreateNetworkJobWithBody(ctx context.Context, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNetworkJob(ctx context.Context, networkId string, body CreateNetworkJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchIndex request
	GetSearchIndex(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStacks request
	GetStacks(ctx context.Context, params *GetStacksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStackWithBody request with any body
	CreateStackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStack(ctx context.Context, body CreateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LookupStackBuild request
	LookupStackBuild(ctx context.Context, buildId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStack request
	DeleteStack(ctx context.Context, stackId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStack request
	GetStack(ctx context.Context, stackId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateStackWithBody request with any body
	UpdateStackWithBody(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateStack(ctx context.Context, stackId string, body UpdateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateStackAccessWithBody request with any body
	UpdateStackAccessWithBody(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateStackAccess(ctx context.Context, stackId string, body UpdateStackAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStackBuilds request
	GetStackBuilds(ctx context.Context, stackId string, params *GetStackBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStackBuildWithBody request with any body
	CreateStackBuildWithBody(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStackBuild(ctx context.Context, stackId string, body CreateStackBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStackBuild request
	DeleteStackBuild(ctx context.Context, stackId string, buildId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStackBuild request
	GetStackBuild(ctx context.Context, stackId string, buildId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStackBuildLog request
	GetStackBuildLog(ctx context.Context, stackId string, buildId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStackBuildJobWithBody request with any body
	CreateStackBuildJobWithBody(ctx context.Context, stackId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStackBuildJob(ctx context.Context, stackId string, buildId string, body CreateStackBuildJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStackJobWithBody request with any body
	CreateStackJobWithBody(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStackJob(ctx context.Context, stackId string, body CreateStackJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LookupComponentsWithBody request with any body
	LookupComponentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LookupComponents(ctx context.Context, body LookupComponentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LookupIdentifier request
	LookupIdentifier(ctx context.Context, params *LookupIdentifierParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualMachines request
	GetVirtualMachines(ctx context.Context, params *GetVirtualMachinesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVirtualMachineWithBody request with any body
	CreateVirtualMachineWithBody(ctx context.Context, params *CreateVirtualMachineParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVirtualMachine(ctx context.Context, params *CreateVirtualMachineParams, body CreateVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualMachineBaseImages request
	GetVirtualMachineBaseImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualMachineSshKeys request
	GetVirtualMachineSshKeys(ctx context.Context, params *GetVirtualMachineSshKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVirtualMachineSshKeyWithBody request with any body
	CreateVirtualMachineSshKeyWithBody(ctx context.Context, params *CreateVirtualMachineSshKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVirtualMachineSshKey(ctx context.Context, params *CreateVirtualMachineSshKeyParams, body CreateVirtualMachineSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualMachineSshKey request
	DeleteVirtualMachineSshKey(ctx context.Context, sshKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualMachineSshKey request
	GetVirtualMachineSshKey(ctx context.Context, sshKeyId string, params *GetVirtualMachineSshKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVirtualMachineSshKeyWithBody request with any body
	UpdateVirtualMachineSshKeyWithBody(ctx context.Context, sshKeyId string, params *UpdateVirtualMachineSshKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVirtualMachineSshKey(ctx context.Context, sshKeyId string, params *UpdateVirtualMachineSshKeyParams, body UpdateVirtualMachineSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVirtualMachine request
	DeleteVirtualMachine(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVirtualMachine request
	GetVirtualMachine(ctx context.Context, virtualMachineId string, params *GetVirtualMachineParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVirtualMachineWithBody request with any body
	UpdateVirtualMachineWithBody(ctx context.Context, virtualMachineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVirtualMachine(ctx context.Context, virtualMachineId string, body UpdateVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAvailableIps request
	GetAvailableIps(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExpireVirtualMachineSosCredentials request
	ExpireVirtualMachineSosCredentials(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateVirtualMachineSosCredentials request
	GenerateVirtualMachineSosCredentials(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVirtualMachineJobWithBody request with any body
	CreateVirtualMachineJobWithBody(ctx context.Context, virtualMachineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVirtualMachineJob(ctx context.Context, virtualMachineId string, body CreateVirtualMachineJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteAccount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccount(ctx context.Context, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableTwoFactorAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableTwoFactorAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableTwoFactorAuth(ctx context.Context, body DisableTwoFactorAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableTwoFactorAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverTwoFactorAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverTwoFactorAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecoverTwoFactorAuth(ctx context.Context, body RecoverTwoFactorAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecoverTwoFactorAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTwoFactorAuthSetup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTwoFactorAuthSetupRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableTwoFactorAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableTwoFactorAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableTwoFactorAuth(ctx context.Context, body EnableTwoFactorAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableTwoFactorAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountInvites(ctx context.Context, params *GetAccountInvitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountInvitesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccountInviteWithBody(ctx context.Context, inviteId string, params *UpdateAccountInviteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountInviteRequestWithBody(c.Server, inviteId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccountInvite(ctx context.Context, inviteId string, params *UpdateAccountInviteParams, body UpdateAccountInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccountInviteRequest(c.Server, inviteId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountLogins(ctx context.Context, params *GetAccountLoginsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountLoginsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountMemberships(ctx context.Context, params *GetAccountMembershipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountMembershipsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePassword(ctx context.Context, body ChangePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnnouncements(ctx context.Context, params *GetAnnouncementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnnouncementsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredits(ctx context.Context, params *GetCreditsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCreditsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCredit(ctx context.Context, creditsId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCreditRequest(c.Server, creditsId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoices(ctx context.Context, params *GetInvoicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvoicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoice(ctx context.Context, invoiceId string, params *GetInvoiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvoiceRequest(c.Server, invoiceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInvoiceJobWithBody(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInvoiceJobRequestWithBody(c.Server, invoiceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInvoiceJob(ctx context.Context, invoiceId string, body CreateInvoiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInvoiceJobRequest(c.Server, invoiceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingMethods(ctx context.Context, params *GetBillingMethodsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingMethodsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBillingMethodWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBillingMethodRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBillingMethod(ctx context.Context, body CreateBillingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBillingMethodRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBillingMethod(ctx context.Context, methodId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBillingMethodRequest(c.Server, methodId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingMethod(ctx context.Context, methodId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingMethodRequest(c.Server, methodId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBillingMethodWithBody(ctx context.Context, methodId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBillingMethodRequestWithBody(c.Server, methodId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBillingMethod(ctx context.Context, methodId string, body UpdateBillingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBillingMethodRequest(c.Server, methodId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBillingMethodJobWithBody(ctx context.Context, methodId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBillingMethodJobRequestWithBody(c.Server, methodId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBillingMethodJob(ctx context.Context, methodId string, body CreateBillingMethodJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBillingMethodJobRequest(c.Server, methodId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrders(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrdersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrderWithBody(ctx context.Context, params *CreateOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrder(ctx context.Context, params *CreateOrderParams, body CreateOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingOrder(ctx context.Context, orderId string, params *GetBillingOrderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingOrderRequest(c.Server, orderId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBillingOrderWithBody(ctx context.Context, orderId string, params *UpdateBillingOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBillingOrderRequestWithBody(c.Server, orderId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBillingOrder(ctx context.Context, orderId string, params *UpdateBillingOrderParams, body UpdateBillingOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBillingOrderRequest(c.Server, orderId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrderJobWithBody(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrderJobRequestWithBody(c.Server, orderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrderJob(ctx context.Context, orderId string, body CreateOrderJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrderJobRequest(c.Server, orderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingSupportPlans(ctx context.Context, params *GetBillingSupportPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingSupportPlansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingTiers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingTiersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingServices(ctx context.Context, params *GetBillingServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingOverages(ctx context.Context, params *GetBillingOveragesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingOveragesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingService(ctx context.Context, servicesId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingServiceRequest(c.Server, servicesId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChangelog(ctx context.Context, params *GetChangelogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChangelogRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainers(ctx context.Context, params *GetContainersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContainerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContainerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContainer(ctx context.Context, body CreateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContainerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteContainer(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteContainerRequest(c.Server, containerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainer(ctx context.Context, containerId string, params *GetContainerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerRequest(c.Server, containerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContainerWithBody(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContainerRequestWithBody(c.Server, containerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContainer(ctx context.Context, containerId string, body UpdateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContainerRequest(c.Server, containerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerBackups(ctx context.Context, containerId string, params *GetContainerBackupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerBackupsRequest(c.Server, containerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteContainerBackup(ctx context.Context, containerId string, backupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteContainerBackupRequest(c.Server, containerId, backupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerBackup(ctx context.Context, containerId string, backupId string, params *GetContainerBackupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerBackupRequest(c.Server, containerId, backupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerBackupLogs(ctx context.Context, containerId string, backupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerBackupLogsRequest(c.Server, containerId, backupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContainerBackupJobWithBody(ctx context.Context, containerId string, backupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContainerBackupJobRequestWithBody(c.Server, containerId, backupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContainerBackupJob(ctx context.Context, containerId string, backupId string, body CreateContainerBackupJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContainerBackupJobRequest(c.Server, containerId, backupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompatibleImages(ctx context.Context, containerId string, params *GetCompatibleImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompatibleImagesRequest(c.Server, containerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFunctionJobWithBody(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFunctionJobRequestWithBody(c.Server, containerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFunctionJob(ctx context.Context, containerId string, body CreateFunctionJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFunctionJobRequest(c.Server, containerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteContainerInstances(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteContainerInstancesRequest(c.Server, containerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstances(ctx context.Context, containerId string, params *GetInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstancesRequest(c.Server, containerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInstancesWithBody(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInstancesRequestWithBody(c.Server, containerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInstances(ctx context.Context, containerId string, body CreateInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInstancesRequest(c.Server, containerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInstance(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInstanceRequest(c.Server, containerId, instanceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstance(ctx context.Context, containerId string, instanceId string, params *GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceRequest(c.Server, containerId, instanceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstanceConsoleStreamAuth(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceConsoleStreamAuthRequest(c.Server, containerId, instanceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpireInstanceSSHCredentials(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpireInstanceSSHCredentialsRequest(c.Server, containerId, instanceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateInstanceSSHCredentials(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateInstanceSSHCredentialsRequest(c.Server, containerId, instanceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInstanceJobWithBody(ctx context.Context, containerId string, instanceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInstanceJobRequestWithBody(c.Server, containerId, instanceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInstanceJob(ctx context.Context, containerId string, instanceId string, body CreateInstanceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInstanceJobRequest(c.Server, containerId, instanceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstanceTelemetryReport(ctx context.Context, containerId string, instanceId string, params *GetInstanceTelemetryReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceTelemetryReportRequest(c.Server, containerId, instanceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstanceTelemetryStreamAuth(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceTelemetryStreamAuthRequest(c.Server, containerId, instanceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInstanceVolumes(ctx context.Context, containerId string, instanceId string, params *GetInstanceVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInstanceVolumesRequest(c.Server, containerId, instanceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerServers(ctx context.Context, containerId string, params *GetContainerServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerServersRequest(c.Server, containerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCompatibleServers(ctx context.Context, containerId string, params *GetCompatibleServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCompatibleServersRequest(c.Server, containerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerSummary(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerSummaryRequest(c.Server, containerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContainerJobWithBody(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContainerJobRequestWithBody(c.Server, containerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContainerJob(ctx context.Context, containerId string, body CreateContainerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContainerJobRequest(c.Server, containerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTLSGenerationAttempts(ctx context.Context, params *GetTLSGenerationAttemptsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTLSGenerationAttemptsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LookupTLSCertificate(ctx context.Context, params *LookupTLSCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLookupTLSCertificateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserSuppliedCertificates(ctx context.Context, params *GetUserSuppliedCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserSuppliedCertificatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadUserSuppliedCertificateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadUserSuppliedCertificateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadUserSuppliedCertificate(ctx context.Context, body UploadUserSuppliedCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadUserSuppliedCertificateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserSuppliedCertificate(ctx context.Context, certificateId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserSuppliedCertificateRequest(c.Server, certificateId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserSuppliedCertificateJobWithBody(ctx context.Context, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserSuppliedCertificateJobRequestWithBody(c.Server, certificateId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserSuppliedCertificateJob(ctx context.Context, certificateId string, body CreateUserSuppliedCertificateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserSuppliedCertificateJobRequest(c.Server, certificateId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDNSZones(ctx context.Context, params *GetDNSZonesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDNSZonesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNSZoneWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNSZoneRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNSZone(ctx context.Context, body CreateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNSZoneRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDNSZone(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDNSZoneRequest(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDNSZone(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDNSZoneRequest(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNSZoneWithBody(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNSZoneRequestWithBody(c.Server, zoneId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNSZone(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, body UpdateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNSZoneRequest(c.Server, zoneId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNSZoneAccessWithBody(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNSZoneAccessRequestWithBody(c.Server, zoneId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNSZoneAccess(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, body UpdateDNSZoneAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNSZoneAccessRequest(c.Server, zoneId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDNSZoneRecords(ctx context.Context, zoneId string, params *GetDNSZoneRecordsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDNSZoneRecordsRequest(c.Server, zoneId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNSZoneRecordWithBody(ctx context.Context, zoneId string, params *CreateDNSZoneRecordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNSZoneRecordRequestWithBody(c.Server, zoneId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNSZoneRecord(ctx context.Context, zoneId string, params *CreateDNSZoneRecordParams, body CreateDNSZoneRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNSZoneRecordRequest(c.Server, zoneId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDNSZoneRecord(ctx context.Context, zoneId string, recordId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDNSZoneRecordRequest(c.Server, zoneId, recordId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNSZoneRecordWithBody(ctx context.Context, zoneId string, recordId string, params *UpdateDNSZoneRecordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNSZoneRecordRequestWithBody(c.Server, zoneId, recordId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNSZoneRecord(ctx context.Context, zoneId string, recordId string, params *UpdateDNSZoneRecordParams, body UpdateDNSZoneRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNSZoneRecordRequest(c.Server, zoneId, recordId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNSZoneRecordJobWithBody(ctx context.Context, zoneId string, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNSZoneRecordJobRequestWithBody(c.Server, zoneId, recordId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNSZoneRecordJob(ctx context.Context, zoneId string, recordId string, body CreateDNSZoneRecordJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNSZoneRecordJobRequest(c.Server, zoneId, recordId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNSZoneJobWithBody(ctx context.Context, zoneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNSZoneJobRequestWithBody(c.Server, zoneId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNSZoneJob(ctx context.Context, zoneId string, body CreateDNSZoneJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNSZoneJobRequest(c.Server, zoneId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironments(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvironmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvironmentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvironment(ctx context.Context, body CreateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvironmentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEnvironment(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEnvironmentRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironment(ctx context.Context, environmentId string, params *GetEnvironmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentRequest(c.Server, environmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvironmentWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvironmentRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvironment(ctx context.Context, environmentId string, body UpdateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvironmentRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvironmentAccessWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvironmentAccessRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvironmentAccess(ctx context.Context, environmentId string, body UpdateEnvironmentAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvironmentAccessRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironmentDeployments(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentDeploymentsRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportStackWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportStackRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportStack(ctx context.Context, environmentId string, body ExportStackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportStackRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScopedVariables(ctx context.Context, environmentId string, params *GetScopedVariablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScopedVariablesRequest(c.Server, environmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScopedVariableWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScopedVariableRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateScopedVariable(ctx context.Context, environmentId string, body CreateScopedVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateScopedVariableRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteScopedVariable(ctx context.Context, environmentId string, scopedVariableId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteScopedVariableRequest(c.Server, environmentId, scopedVariableId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScopedVariable(ctx context.Context, environmentId string, scopedVariableId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScopedVariableRequest(c.Server, environmentId, scopedVariableId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScopedVariableWithBody(ctx context.Context, environmentId string, scopedVariableId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScopedVariableRequestWithBody(c.Server, environmentId, scopedVariableId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScopedVariable(ctx context.Context, environmentId string, scopedVariableId string, body UpdateScopedVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScopedVariableRequest(c.Server, environmentId, scopedVariableId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDiscoveryServiceJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDiscoveryServiceJobRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDiscoveryServiceJob(ctx context.Context, environmentId string, body CreateDiscoveryServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDiscoveryServiceJobRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGatewayServiceJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGatewayServiceJobRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGatewayServiceJob(ctx context.Context, environmentId string, body CreateGatewayServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGatewayServiceJobRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoadBalancerService(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoadBalancerServiceRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerServiceJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerServiceJobRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLoadBalancerServiceJob(ctx context.Context, environmentId string, body CreateLoadBalancerServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLoadBalancerServiceJobRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoadBalancerLatestTelemetryReport(ctx context.Context, environmentId string, params *GetLoadBalancerLatestTelemetryReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoadBalancerLatestTelemetryReportRequest(c.Server, environmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoadBalancerTelemetryLatestControllers(ctx context.Context, environmentId string, params *GetLoadBalancerTelemetryLatestControllersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoadBalancerTelemetryLatestControllersRequest(c.Server, environmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoadBalancerTelemetryReport(ctx context.Context, environmentId string, params *GetLoadBalancerTelemetryReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoadBalancerTelemetryReportRequest(c.Server, environmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSchedulerServiceJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSchedulerServiceJobRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSchedulerServiceJob(ctx context.Context, environmentId string, body CreateSchedulerServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSchedulerServiceJobRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVPNService(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVPNServiceRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVPNLogins(ctx context.Context, environmentId string, params *GetVPNLoginsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVPNLoginsRequest(c.Server, environmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVPNServiceJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVPNServiceJobRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVPNServiceJob(ctx context.Context, environmentId string, body CreateVPNServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVPNServiceJobRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVPNUsers(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVPNUsersRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVPNUserWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVPNUserRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVPNUser(ctx context.Context, environmentId string, body CreateVPNUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVPNUserRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVPNUser(ctx context.Context, environmentId string, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVPNUserRequest(c.Server, environmentId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironmentSummary(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentSummaryRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvironmentJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvironmentJobRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvironmentJob(ctx context.Context, environmentId string, body CreateEnvironmentJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvironmentJobRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubs(ctx context.Context, params *GetHubsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHubWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHubRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHub(ctx context.Context, body CreateHubJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHubRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubCapabilities(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubCapabilitiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHubWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHubRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHub(ctx context.Context, body DeleteHubJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHubRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHub(ctx context.Context, params *GetHubParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateHubWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateHubRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateHub(ctx context.Context, body UpdateHubJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateHubRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubActivity(ctx context.Context, params *GetHubActivityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubActivityRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiKeys(ctx context.Context, params *GetApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKey(ctx context.Context, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAPIKey(ctx context.Context, apikeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAPIKeyRequest(c.Server, apikeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAPIKey(ctx context.Context, apikeyId string, params *GetAPIKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAPIKeyRequest(c.Server, apikeyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAPIKeyWithBody(ctx context.Context, apikeyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAPIKeyRequestWithBody(c.Server, apikeyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAPIKey(ctx context.Context, apikeyId string, body UpdateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAPIKeyRequest(c.Server, apikeyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegrations(ctx context.Context, params *GetIntegrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationWithBody(ctx context.Context, params *CreateIntegrationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegration(ctx context.Context, params *CreateIntegrationParams, body CreateIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableIntegrations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableIntegrationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIntegration(ctx context.Context, integrationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIntegrationRequest(c.Server, integrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIntegration(ctx context.Context, integrationId string, params *GetIntegrationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIntegrationRequest(c.Server, integrationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIntegrationWithBody(ctx context.Context, integrationId string, params *UpdateIntegrationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIntegrationRequestWithBody(c.Server, integrationId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIntegration(ctx context.Context, integrationId string, params *UpdateIntegrationParams, body UpdateIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIntegrationRequest(c.Server, integrationId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationJobWithBody(ctx context.Context, integrationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationJobRequestWithBody(c.Server, integrationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIntegrationJob(ctx context.Context, integrationId string, body CreateIntegrationJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIntegrationJobRequest(c.Server, integrationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubInvites(ctx context.Context, params *GetHubInvitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubInvitesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHubInviteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHubInviteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHubInvite(ctx context.Context, body CreateHubInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHubInviteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHubInvite(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHubInviteRequest(c.Server, inviteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubMembers(ctx context.Context, params *GetHubMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubMembersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubMemberAccount(ctx context.Context, accountId string, params *GetHubMemberAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubMemberAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHubMember(ctx context.Context, memberId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHubMemberRequest(c.Server, memberId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubMember(ctx context.Context, memberId string, params *GetHubMemberParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubMemberRequest(c.Server, memberId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateHubMemberWithBody(ctx context.Context, memberId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateHubMemberRequestWithBody(c.Server, memberId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateHubMember(ctx context.Context, memberId string, body UpdateHubMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateHubMemberRequest(c.Server, memberId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubMembership(ctx context.Context, params *GetHubMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubMembershipRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubNotificationSocketAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubNotificationSocketAuthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoles(ctx context.Context, params *GetRolesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRole(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultHubRoles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultHubRolesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRole(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleRequest(c.Server, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRole(ctx context.Context, roleId string, params *GetRoleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleRequest(c.Server, roleId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleWithBody(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRole(ctx context.Context, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleRequest(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHubUsage(ctx context.Context, params *GetHubUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHubUsageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImages(ctx context.Context, params *GetImagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImage(ctx context.Context, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImageSources(ctx context.Context, params *GetImageSourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImageSourcesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImageSourceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageSourceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImageSource(ctx context.Context, body CreateImageSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageSourceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImageSource(ctx context.Context, sourceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageSourceRequest(c.Server, sourceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImageSource(ctx context.Context, sourceId string, params *GetImageSourceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImageSourceRequest(c.Server, sourceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImageSourceWithBody(ctx context.Context, sourceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageSourceRequestWithBody(c.Server, sourceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImageSource(ctx context.Context, sourceId string, body UpdateImageSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageSourceRequest(c.Server, sourceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImageSourceAccessWithBody(ctx context.Context, sourceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageSourceAccessRequestWithBody(c.Server, sourceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImageSourceAccess(ctx context.Context, sourceId string, body UpdateImageSourceAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageSourceAccessRequest(c.Server, sourceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImagesJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImagesJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImagesJob(ctx context.Context, body CreateImagesJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImagesJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImage(ctx context.Context, imageId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImageRequest(c.Server, imageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImage(ctx context.Context, imageId string, params *GetImageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImageRequest(c.Server, imageId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImageWithBody(ctx context.Context, imageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageRequestWithBody(c.Server, imageId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImage(ctx context.Context, imageId string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImageRequest(c.Server, imageId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImageBuildLog(ctx context.Context, imageId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImageBuildLogRequest(c.Server, imageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImageJobWithBody(ctx context.Context, imageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageJobRequestWithBody(c.Server, imageId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImageJob(ctx context.Context, imageId string, body CreateImageJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImageJobRequest(c.Server, imageId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutoScaleGroups(ctx context.Context, params *GetAutoScaleGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutoScaleGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAutoScaleGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAutoScaleGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAutoScaleGroup(ctx context.Context, body CreateAutoScaleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAutoScaleGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAutoScaleGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAutoScaleGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutoScaleGroup(ctx context.Context, groupId string, params *GetAutoScaleGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutoScaleGroupRequest(c.Server, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutoScaleGroupWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutoScaleGroupRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutoScaleGroup(ctx context.Context, groupId string, body UpdateAutoScaleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutoScaleGroupRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutoScaleGroupAccessWithBody(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutoScaleGroupAccessRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutoScaleGroupAccess(ctx context.Context, groupId string, body UpdateAutoScaleGroupAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutoScaleGroupAccessRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusters(ctx context.Context, params *GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCluster(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCluster(ctx context.Context, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequest(c.Server, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterAccessWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterAccessRequestWithBody(c.Server, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterAccess(ctx context.Context, clusterId string, body UpdateClusterAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterAccessRequest(c.Server, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterJobWithBody(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterJobRequestWithBody(c.Server, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterJob(ctx context.Context, clusterId string, body CreateClusterJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterJobRequest(c.Server, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeploymentStrategies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeploymentStrategiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExternalVolumes(ctx context.Context, params *GetExternalVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExternalVolumesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExternalVolumeWithBody(ctx context.Context, params *CreateExternalVolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExternalVolumeRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExternalVolume(ctx context.Context, params *CreateExternalVolumeParams, body CreateExternalVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExternalVolumeRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExternalVolumeSources(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExternalVolumeSourcesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExternalVolumeWithBody(ctx context.Context, externalVolumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExternalVolumeRequestWithBody(c.Server, externalVolumeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteExternalVolume(ctx context.Context, externalVolumeId string, body DeleteExternalVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteExternalVolumeRequest(c.Server, externalVolumeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExternalVolume(ctx context.Context, externalVolumeId string, params *GetExternalVolumeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExternalVolumeRequest(c.Server, externalVolumeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExternalVolumeWithBody(ctx context.Context, externalVolumeId string, params *UpdateExternalVolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExternalVolumeRequestWithBody(c.Server, externalVolumeId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExternalVolume(ctx context.Context, externalVolumeId string, params *UpdateExternalVolumeParams, body UpdateExternalVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExternalVolumeRequest(c.Server, externalVolumeId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExternalVolumeAccessWithBody(ctx context.Context, externalVolumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExternalVolumeAccessRequestWithBody(c.Server, externalVolumeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExternalVolumeAccess(ctx context.Context, externalVolumeId string, body UpdateExternalVolumeAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExternalVolumeAccessRequest(c.Server, externalVolumeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExternalVolumeJobWithBody(ctx context.Context, externalVolumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExternalVolumeJobRequestWithBody(c.Server, externalVolumeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExternalVolumeJob(ctx context.Context, externalVolumeId string, body CreateExternalVolumeJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExternalVolumeJobRequest(c.Server, externalVolumeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIpPools(ctx context.Context, params *GetIpPoolsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIpPoolsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIpPoolWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIpPoolRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIpPool(ctx context.Context, body CreateIpPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIpPoolRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIPPool(ctx context.Context, poolId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIPPoolRequest(c.Server, poolId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIPPool(ctx context.Context, poolId string, params *GetIPPoolParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIPPoolRequest(c.Server, poolId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPoolIPs(ctx context.Context, poolId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPoolIPsRequest(c.Server, poolId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIpPoolJobWithBody(ctx context.Context, poolId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIpPoolJobRequestWithBody(c.Server, poolId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIpPoolJob(ctx context.Context, poolId string, body CreateIpPoolJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIpPoolJobRequest(c.Server, poolId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterMonitoringTiers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterMonitoringTiersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProviderLocations(ctx context.Context, providerVendor string, params *GetProviderLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProviderLocationsRequest(c.Server, providerVendor, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProviderServers(ctx context.Context, providerVendor string, params *GetProviderServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProviderServersRequest(c.Server, providerVendor, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServers(ctx context.Context, params *GetServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServer(ctx context.Context, body CreateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerTags(ctx context.Context, params *GetServerTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerWithBody(ctx context.Context, serverId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerRequestWithBody(c.Server, serverId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServer(ctx context.Context, serverId string, body DeleteServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerRequest(c.Server, serverId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServer(ctx context.Context, serverId string, params *GetServerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerRequest(c.Server, serverId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServerWithBody(ctx context.Context, serverId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServerRequestWithBody(c.Server, serverId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServer(ctx context.Context, serverId string, body UpdateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServerRequest(c.Server, serverId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerConsole(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerConsoleRequest(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerInstances(ctx context.Context, serverId string, params *GetServerInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerInstancesRequest(c.Server, serverId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerJobWithBody(ctx context.Context, serverId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerJobRequestWithBody(c.Server, serverId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerJob(ctx context.Context, serverId string, body CreateServerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerJobRequest(c.Server, serverId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerTelemetry(ctx context.Context, serverId string, params *GetServerTelemetryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerTelemetryRequest(c.Server, serverId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerUsage(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerUsageRequest(c.Server, serverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInfrastructureSummary(ctx context.Context, params *GetInfrastructureSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInfrastructureSummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualProviderIsos(ctx context.Context, integrationId string, params *GetVirtualProviderIsosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualProviderIsosRequest(c.Server, integrationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualProviderIsoWithBody(ctx context.Context, integrationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualProviderIsoRequestWithBody(c.Server, integrationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualProviderIso(ctx context.Context, integrationId string, body CreateVirtualProviderIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualProviderIsoRequest(c.Server, integrationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualProviderIso(ctx context.Context, integrationId string, isoId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualProviderIsoRequest(c.Server, integrationId, isoId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualProviderIso(ctx context.Context, integrationId string, isoId string, params *GetVirtualProviderIsoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualProviderIsoRequest(c.Server, integrationId, isoId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVirtualProviderIsoWithBody(ctx context.Context, integrationId string, isoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVirtualProviderIsoRequestWithBody(c.Server, integrationId, isoId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVirtualProviderIso(ctx context.Context, integrationId string, isoId string, body UpdateVirtualProviderIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVirtualProviderIsoRequest(c.Server, integrationId, isoId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualProviderIsoDownloadUrl(ctx context.Context, integrationId string, isoId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualProviderIsoDownloadUrlRequest(c.Server, integrationId, isoId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualProviderIsoJobWithBody(ctx context.Context, integrationId string, isoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualProviderIsoJobRequestWithBody(c.Server, integrationId, isoId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualProviderIsoJob(ctx context.Context, integrationId string, isoId string, body CreateVirtualProviderIsoJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualProviderIsoJobRequest(c.Server, integrationId, isoId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobs(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestJobsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEvents(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateAggregatedEventsWithBody(ctx context.Context, params *GenerateAggregatedEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateAggregatedEventsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateAggregatedEvents(ctx context.Context, params *GenerateAggregatedEventsParams, body GenerateAggregatedEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateAggregatedEventsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AggregateLogsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAggregateLogsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AggregateLogs(ctx context.Context, body AggregateLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAggregateLogsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetrics(ctx context.Context, params *GetMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMetricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateAggregatedMetricsWithBody(ctx context.Context, params *GenerateAggregatedMetricsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateAggregatedMetricsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateAggregatedMetrics(ctx context.Context, params *GenerateAggregatedMetricsParams, body GenerateAggregatedMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateAggregatedMetricsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMonitoringMonitors(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMonitoringMonitorsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelines(ctx context.Context, params *GetPipelinesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelinesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePipelineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePipelineRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePipeline(ctx context.Context, body CreatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePipelineRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClonePipelineWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClonePipelineRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClonePipeline(ctx context.Context, body ClonePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClonePipelineRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePipeline(ctx context.Context, pipelineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePipelineRequest(c.Server, pipelineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipeline(ctx context.Context, pipelineId string, params *GetPipelineParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineRequest(c.Server, pipelineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePipelineWithBody(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePipelineRequestWithBody(c.Server, pipelineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePipeline(ctx context.Context, pipelineId string, body UpdatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePipelineRequest(c.Server, pipelineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePipelineAccessWithBody(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePipelineAccessRequestWithBody(c.Server, pipelineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePipelineAccess(ctx context.Context, pipelineId string, body UpdatePipelineAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePipelineAccessRequest(c.Server, pipelineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelineTriggerKeys(ctx context.Context, pipelineId string, params *GetPipelineTriggerKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineTriggerKeysRequest(c.Server, pipelineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePipelineTriggerKeyWithBody(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePipelineTriggerKeyRequestWithBody(c.Server, pipelineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePipelineTriggerKey(ctx context.Context, pipelineId string, body CreatePipelineTriggerKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePipelineTriggerKeyRequest(c.Server, pipelineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePipelineTriggerKey(ctx context.Context, pipelineId string, triggerKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePipelineTriggerKeyRequest(c.Server, pipelineId, triggerKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelineTriggerKey(ctx context.Context, pipelineId string, triggerKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineTriggerKeyRequest(c.Server, pipelineId, triggerKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePipelineTriggerKeyWithBody(ctx context.Context, pipelineId string, triggerKeyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePipelineTriggerKeyRequestWithBody(c.Server, pipelineId, triggerKeyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePipelineTriggerKey(ctx context.Context, pipelineId string, triggerKeyId string, body UpdatePipelineTriggerKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePipelineTriggerKeyRequest(c.Server, pipelineId, triggerKeyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelineRuns(ctx context.Context, pipelineId string, params *GetPipelineRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineRunsRequest(c.Server, pipelineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPipelineRun(ctx context.Context, pipelineId string, runId string, params *GetPipelineRunParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPipelineRunRequest(c.Server, pipelineId, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePipelineJobWithBody(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePipelineJobRequestWithBody(c.Server, pipelineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePipelineJob(ctx context.Context, pipelineId string, body CreatePipelineJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePipelineJobRequest(c.Server, pipelineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerPipelineWithBody(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerPipelineRequestWithBody(c.Server, pipelineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerPipeline(ctx context.Context, pipelineId string, body TriggerPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerPipelineRequest(c.Server, pipelineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworks(ctx context.Context, params *GetNetworksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetworkWithBody(ctx context.Context, params *CreateNetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNetworkRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetwork(ctx context.Context, params *CreateNetworkParams, body CreateNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNetworkRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNetwork(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNetworkRequest(c.Server, networkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetwork(ctx context.Context, networkId string, params *GetNetworkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkRequest(c.Server, networkId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNetworkWithBody(ctx context.Context, networkId string, params *UpdateNetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNetworkRequestWithBody(c.Server, networkId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNetwork(ctx context.Context, networkId string, params *UpdateNetworkParams, body UpdateNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNetworkRequest(c.Server, networkId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNetworkAccessWithBody(ctx context.Context, networkId string, params *UpdateNetworkAccessParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNetworkAccessRequestWithBody(c.Server, networkId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNetworkAccess(ctx context.Context, networkId string, params *UpdateNetworkAccessParams, body UpdateNetworkAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNetworkAccessRequest(c.Server, networkId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetworkJobWithBody(ctx context.Context, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNetworkJobRequestWithBody(c.Server, networkId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNetworkJob(ctx context.Context, networkId string, body CreateNetworkJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNetworkJobRequest(c.Server, networkId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchIndex(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchIndexRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStacks(ctx context.Context, params *GetStacksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStacksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStack(ctx context.Context, body CreateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStackRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LookupStackBuild(ctx context.Context, buildId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLookupStackBuildRequest(c.Server, buildId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStack(ctx context.Context, stackId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStackRequest(c.Server, stackId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStack(ctx context.Context, stackId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStackRequest(c.Server, stackId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStackWithBody(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStackRequestWithBody(c.Server, stackId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStack(ctx context.Context, stackId string, body UpdateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStackRequest(c.Server, stackId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStackAccessWithBody(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStackAccessRequestWithBody(c.Server, stackId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStackAccess(ctx context.Context, stackId string, body UpdateStackAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStackAccessRequest(c.Server, stackId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStackBuilds(ctx context.Context, stackId string, params *GetStackBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStackBuildsRequest(c.Server, stackId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStackBuildWithBody(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStackBuildRequestWithBody(c.Server, stackId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStackBuild(ctx context.Context, stackId string, body CreateStackBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStackBuildRequest(c.Server, stackId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStackBuild(ctx context.Context, stackId string, buildId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStackBuildRequest(c.Server, stackId, buildId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStackBuild(ctx context.Context, stackId string, buildId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStackBuildRequest(c.Server, stackId, buildId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStackBuildLog(ctx context.Context, stackId string, buildId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStackBuildLogRequest(c.Server, stackId, buildId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStackBuildJobWithBody(ctx context.Context, stackId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStackBuildJobRequestWithBody(c.Server, stackId, buildId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStackBuildJob(ctx context.Context, stackId string, buildId string, body CreateStackBuildJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStackBuildJobRequest(c.Server, stackId, buildId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStackJobWithBody(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStackJobRequestWithBody(c.Server, stackId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStackJob(ctx context.Context, stackId string, body CreateStackJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStackJobRequest(c.Server, stackId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LookupComponentsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLookupComponentsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LookupComponents(ctx context.Context, body LookupComponentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLookupComponentsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LookupIdentifier(ctx context.Context, params *LookupIdentifierParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLookupIdentifierRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualMachines(ctx context.Context, params *GetVirtualMachinesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualMachinesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualMachineWithBody(ctx context.Context, params *CreateVirtualMachineParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualMachineRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualMachine(ctx context.Context, params *CreateVirtualMachineParams, body CreateVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualMachineRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualMachineBaseImages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualMachineBaseImagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualMachineSshKeys(ctx context.Context, params *GetVirtualMachineSshKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualMachineSshKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualMachineSshKeyWithBody(ctx context.Context, params *CreateVirtualMachineSshKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualMachineSshKeyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualMachineSshKey(ctx context.Context, params *CreateVirtualMachineSshKeyParams, body CreateVirtualMachineSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualMachineSshKeyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualMachineSshKey(ctx context.Context, sshKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualMachineSshKeyRequest(c.Server, sshKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualMachineSshKey(ctx context.Context, sshKeyId string, params *GetVirtualMachineSshKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualMachineSshKeyRequest(c.Server, sshKeyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVirtualMachineSshKeyWithBody(ctx context.Context, sshKeyId string, params *UpdateVirtualMachineSshKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVirtualMachineSshKeyRequestWithBody(c.Server, sshKeyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVirtualMachineSshKey(ctx context.Context, sshKeyId string, params *UpdateVirtualMachineSshKeyParams, body UpdateVirtualMachineSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVirtualMachineSshKeyRequest(c.Server, sshKeyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVirtualMachine(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVirtualMachineRequest(c.Server, virtualMachineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVirtualMachine(ctx context.Context, virtualMachineId string, params *GetVirtualMachineParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVirtualMachineRequest(c.Server, virtualMachineId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVirtualMachineWithBody(ctx context.Context, virtualMachineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVirtualMachineRequestWithBody(c.Server, virtualMachineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVirtualMachine(ctx context.Context, virtualMachineId string, body UpdateVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVirtualMachineRequest(c.Server, virtualMachineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAvailableIps(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAvailableIpsRequest(c.Server, virtualMachineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExpireVirtualMachineSosCredentials(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExpireVirtualMachineSosCredentialsRequest(c.Server, virtualMachineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateVirtualMachineSosCredentials(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateVirtualMachineSosCredentialsRequest(c.Server, virtualMachineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualMachineJobWithBody(ctx context.Context, virtualMachineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualMachineJobRequestWithBody(c.Server, virtualMachineId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVirtualMachineJob(ctx context.Context, virtualMachineId string, body CreateVirtualMachineJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVirtualMachineJobRequest(c.Server, virtualMachineId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteAccountRequest generates requests for DeleteAccount
func NewDeleteAccountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountRequest generates requests for GetAccount
func NewGetAccountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccountRequest calls the generic UpdateAccount builder with application/json body
func NewUpdateAccountRequest(server string, body UpdateAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccountRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateAccountRequestWithBody generates requests for UpdateAccount with any type of body
func NewUpdateAccountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisableTwoFactorAuthRequest calls the generic DisableTwoFactorAuth builder with application/json body
func NewDisableTwoFactorAuthRequest(server string, body DisableTwoFactorAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDisableTwoFactorAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewDisableTwoFactorAuthRequestWithBody generates requests for DisableTwoFactorAuth with any type of body
func NewDisableTwoFactorAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account/2fa/disable")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecoverTwoFactorAuthRequest calls the generic RecoverTwoFactorAuth builder with application/json body
func NewRecoverTwoFactorAuthRequest(server string, body RecoverTwoFactorAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRecoverTwoFactorAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewRecoverTwoFactorAuthRequestWithBody generates requests for RecoverTwoFactorAuth with any type of body
func NewRecoverTwoFactorAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account/2fa/recover")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTwoFactorAuthSetupRequest generates requests for GetTwoFactorAuthSetup
func NewGetTwoFactorAuthSetupRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account/2fa/setup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnableTwoFactorAuthRequest calls the generic EnableTwoFactorAuth builder with application/json body
func NewEnableTwoFactorAuthRequest(server string, body EnableTwoFactorAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnableTwoFactorAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewEnableTwoFactorAuthRequestWithBody generates requests for EnableTwoFactorAuth with any type of body
func NewEnableTwoFactorAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account/2fa/setup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAccountInvitesRequest generates requests for GetAccountInvites
func NewGetAccountInvitesRequest(server string, params *GetAccountInvitesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccountInviteRequest calls the generic UpdateAccountInvite builder with application/json body
func NewUpdateAccountInviteRequest(server string, inviteId string, params *UpdateAccountInviteParams, body UpdateAccountInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccountInviteRequestWithBody(server, inviteId, params, "application/json", bodyReader)
}

// NewUpdateAccountInviteRequestWithBody generates requests for UpdateAccountInvite with any type of body
func NewUpdateAccountInviteRequestWithBody(server string, inviteId string, params *UpdateAccountInviteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inviteId", runtime.ParamLocationPath, inviteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account/invites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAccountLoginsRequest generates requests for GetAccountLogins
func NewGetAccountLoginsRequest(server string, params *GetAccountLoginsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account/logins")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountMembershipsRequest generates requests for GetAccountMemberships
func NewGetAccountMembershipsRequest(server string, params *GetAccountMembershipsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account/memberships")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangePasswordRequest calls the generic ChangePassword builder with application/json body
func NewChangePasswordRequest(server string, body ChangePasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangePasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewChangePasswordRequestWithBody generates requests for ChangePassword with any type of body
func NewChangePasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account/password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetPasswordRequest calls the generic ResetPassword builder with application/json body
func NewResetPasswordRequest(server string, body ResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewResetPasswordRequestWithBody generates requests for ResetPassword with any type of body
func NewResetPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/account/reset-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAnnouncementsRequest generates requests for GetAnnouncements
func NewGetAnnouncementsRequest(server string, params *GetAnnouncementsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/announcements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCreditsRequest generates requests for GetCredits
func NewGetCreditsRequest(server string, params *GetCreditsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/credits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCreditRequest generates requests for GetCredit
func NewGetCreditRequest(server string, creditsId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "creditsId", runtime.ParamLocationPath, creditsId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/credits/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoicesRequest generates requests for GetInvoices
func NewGetInvoicesRequest(server string, params *GetInvoicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoiceRequest generates requests for GetInvoice
func NewGetInvoiceRequest(server string, invoiceId string, params *GetInvoiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/invoices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Token != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInvoiceJobRequest calls the generic CreateInvoiceJob builder with application/json body
func NewCreateInvoiceJobRequest(server string, invoiceId string, body CreateInvoiceJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInvoiceJobRequestWithBody(server, invoiceId, "application/json", bodyReader)
}

// NewCreateInvoiceJobRequestWithBody generates requests for CreateInvoiceJob with any type of body
func NewCreateInvoiceJobRequestWithBody(server string, invoiceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invoiceId", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/invoices/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBillingMethodsRequest generates requests for GetBillingMethods
func NewGetBillingMethodsRequest(server string, params *GetBillingMethodsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/methods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBillingMethodRequest calls the generic CreateBillingMethod builder with application/json body
func NewCreateBillingMethodRequest(server string, body CreateBillingMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBillingMethodRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBillingMethodRequestWithBody generates requests for CreateBillingMethod with any type of body
func NewCreateBillingMethodRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/methods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBillingMethodRequest generates requests for DeleteBillingMethod
func NewDeleteBillingMethodRequest(server string, methodId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "methodId", runtime.ParamLocationPath, methodId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/methods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillingMethodRequest generates requests for GetBillingMethod
func NewGetBillingMethodRequest(server string, methodId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "methodId", runtime.ParamLocationPath, methodId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/methods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBillingMethodRequest calls the generic UpdateBillingMethod builder with application/json body
func NewUpdateBillingMethodRequest(server string, methodId string, body UpdateBillingMethodJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBillingMethodRequestWithBody(server, methodId, "application/json", bodyReader)
}

// NewUpdateBillingMethodRequestWithBody generates requests for UpdateBillingMethod with any type of body
func NewUpdateBillingMethodRequestWithBody(server string, methodId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "methodId", runtime.ParamLocationPath, methodId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/methods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBillingMethodJobRequest calls the generic CreateBillingMethodJob builder with application/json body
func NewCreateBillingMethodJobRequest(server string, methodId string, body CreateBillingMethodJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBillingMethodJobRequestWithBody(server, methodId, "application/json", bodyReader)
}

// NewCreateBillingMethodJobRequestWithBody generates requests for CreateBillingMethodJob with any type of body
func NewCreateBillingMethodJobRequestWithBody(server string, methodId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "methodId", runtime.ParamLocationPath, methodId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/methods/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrdersRequest generates requests for GetOrders
func NewGetOrdersRequest(server string, params *GetOrdersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrderRequest calls the generic CreateOrder builder with application/json body
func NewCreateOrderRequest(server string, params *CreateOrderParams, body CreateOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateOrderRequestWithBody generates requests for CreateOrder with any type of body
func NewCreateOrderRequestWithBody(server string, params *CreateOrderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBillingOrderRequest generates requests for GetBillingOrder
func NewGetBillingOrderRequest(server string, orderId string, params *GetBillingOrderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBillingOrderRequest calls the generic UpdateBillingOrder builder with application/json body
func NewUpdateBillingOrderRequest(server string, orderId string, params *UpdateBillingOrderParams, body UpdateBillingOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBillingOrderRequestWithBody(server, orderId, params, "application/json", bodyReader)
}

// NewUpdateBillingOrderRequestWithBody generates requests for UpdateBillingOrder with any type of body
func NewUpdateBillingOrderRequestWithBody(server string, orderId string, params *UpdateBillingOrderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/orders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateOrderJobRequest calls the generic CreateOrderJob builder with application/json body
func NewCreateOrderJobRequest(server string, orderId string, body CreateOrderJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrderJobRequestWithBody(server, orderId, "application/json", bodyReader)
}

// NewCreateOrderJobRequestWithBody generates requests for CreateOrderJob with any type of body
func NewCreateOrderJobRequestWithBody(server string, orderId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orderId", runtime.ParamLocationPath, orderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/orders/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBillingSupportPlansRequest generates requests for GetBillingSupportPlans
func NewGetBillingSupportPlansRequest(server string, params *GetBillingSupportPlansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/plans/support")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillingTiersRequest generates requests for GetBillingTiers
func NewGetBillingTiersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/plans/tiers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillingServicesRequest generates requests for GetBillingServices
func NewGetBillingServicesRequest(server string, params *GetBillingServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillingOveragesRequest generates requests for GetBillingOverages
func NewGetBillingOveragesRequest(server string, params *GetBillingOveragesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/services/overages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillingServiceRequest generates requests for GetBillingService
func NewGetBillingServiceRequest(server string, servicesId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "servicesId", runtime.ParamLocationPath, servicesId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillingStatusRequest generates requests for GetBillingStatus
func NewGetBillingStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/billing/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChangelogRequest generates requests for GetChangelog
func NewGetChangelogRequest(server string, params *GetChangelogParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/changelog")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContainersRequest generates requests for GetContainers
func NewGetContainersRequest(server string, params *GetContainersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateContainerRequest calls the generic CreateContainer builder with application/json body
func NewCreateContainerRequest(server string, body CreateContainerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateContainerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateContainerRequestWithBody generates requests for CreateContainer with any type of body
func NewCreateContainerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteContainerRequest generates requests for DeleteContainer
func NewDeleteContainerRequest(server string, containerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContainerRequest generates requests for GetContainer
func NewGetContainerRequest(server string, containerId string, params *GetContainerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateContainerRequest calls the generic UpdateContainer builder with application/json body
func NewUpdateContainerRequest(server string, containerId string, body UpdateContainerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateContainerRequestWithBody(server, containerId, "application/json", bodyReader)
}

// NewUpdateContainerRequestWithBody generates requests for UpdateContainer with any type of body
func NewUpdateContainerRequestWithBody(server string, containerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetContainerBackupsRequest generates requests for GetContainerBackups
func NewGetContainerBackupsRequest(server string, containerId string, params *GetContainerBackupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/backups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteContainerBackupRequest generates requests for DeleteContainerBackup
func NewDeleteContainerBackupRequest(server string, containerId string, backupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/backups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContainerBackupRequest generates requests for GetContainerBackup
func NewGetContainerBackupRequest(server string, containerId string, backupId string, params *GetContainerBackupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/backups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContainerBackupLogsRequest generates requests for GetContainerBackupLogs
func NewGetContainerBackupLogsRequest(server string, containerId string, backupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/backups/%s/logs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateContainerBackupJobRequest calls the generic CreateContainerBackupJob builder with application/json body
func NewCreateContainerBackupJobRequest(server string, containerId string, backupId string, body CreateContainerBackupJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateContainerBackupJobRequestWithBody(server, containerId, backupId, "application/json", bodyReader)
}

// NewCreateContainerBackupJobRequestWithBody generates requests for CreateContainerBackupJob with any type of body
func NewCreateContainerBackupJobRequestWithBody(server string, containerId string, backupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "backupId", runtime.ParamLocationPath, backupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/backups/%s/tasks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCompatibleImagesRequest generates requests for GetCompatibleImages
func NewGetCompatibleImagesRequest(server string, containerId string, params *GetCompatibleImagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/compatible-images", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFunctionJobRequest calls the generic CreateFunctionJob builder with application/json body
func NewCreateFunctionJobRequest(server string, containerId string, body CreateFunctionJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFunctionJobRequestWithBody(server, containerId, "application/json", bodyReader)
}

// NewCreateFunctionJobRequestWithBody generates requests for CreateFunctionJob with any type of body
func NewCreateFunctionJobRequestWithBody(server string, containerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/functions/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteContainerInstancesRequest generates requests for DeleteContainerInstances
func NewDeleteContainerInstancesRequest(server string, containerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/instances", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstancesRequest generates requests for GetInstances
func NewGetInstancesRequest(server string, containerId string, params *GetInstancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/instances", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInstancesRequest calls the generic CreateInstances builder with application/json body
func NewCreateInstancesRequest(server string, containerId string, body CreateInstancesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInstancesRequestWithBody(server, containerId, "application/json", bodyReader)
}

// NewCreateInstancesRequestWithBody generates requests for CreateInstances with any type of body
func NewCreateInstancesRequestWithBody(server string, containerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/instances", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInstanceRequest generates requests for DeleteInstance
func NewDeleteInstanceRequest(server string, containerId string, instanceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/instances/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstanceRequest generates requests for GetInstance
func NewGetInstanceRequest(server string, containerId string, instanceId string, params *GetInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/instances/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstanceConsoleStreamAuthRequest generates requests for GetInstanceConsoleStreamAuth
func NewGetInstanceConsoleStreamAuthRequest(server string, containerId string, instanceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/instances/%s/console", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExpireInstanceSSHCredentialsRequest generates requests for ExpireInstanceSSHCredentials
func NewExpireInstanceSSHCredentialsRequest(server string, containerId string, instanceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/instances/%s/ssh", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateInstanceSSHCredentialsRequest generates requests for GenerateInstanceSSHCredentials
func NewGenerateInstanceSSHCredentialsRequest(server string, containerId string, instanceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/instances/%s/ssh", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInstanceJobRequest calls the generic CreateInstanceJob builder with application/json body
func NewCreateInstanceJobRequest(server string, containerId string, instanceId string, body CreateInstanceJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInstanceJobRequestWithBody(server, containerId, instanceId, "application/json", bodyReader)
}

// NewCreateInstanceJobRequestWithBody generates requests for CreateInstanceJob with any type of body
func NewCreateInstanceJobRequestWithBody(server string, containerId string, instanceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/instances/%s/tasks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetInstanceTelemetryReportRequest generates requests for GetInstanceTelemetryReport
func NewGetInstanceTelemetryReportRequest(server string, containerId string, instanceId string, params *GetInstanceTelemetryReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/instances/%s/telemetry/resources/report", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstanceTelemetryStreamAuthRequest generates requests for GetInstanceTelemetryStreamAuth
func NewGetInstanceTelemetryStreamAuthRequest(server string, containerId string, instanceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/instances/%s/telemetry/resources/stream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInstanceVolumesRequest generates requests for GetInstanceVolumes
func NewGetInstanceVolumesRequest(server string, containerId string, instanceId string, params *GetInstanceVolumesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "instanceId", runtime.ParamLocationPath, instanceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/instances/%s/volumes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContainerServersRequest generates requests for GetContainerServers
func NewGetContainerServersRequest(server string, containerId string, params *GetContainerServersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCompatibleServersRequest generates requests for GetCompatibleServers
func NewGetCompatibleServersRequest(server string, containerId string, params *GetCompatibleServersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/servers/usable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContainerSummaryRequest generates requests for GetContainerSummary
func NewGetContainerSummaryRequest(server string, containerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateContainerJobRequest calls the generic CreateContainerJob builder with application/json body
func NewCreateContainerJobRequest(server string, containerId string, body CreateContainerJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateContainerJobRequestWithBody(server, containerId, "application/json", bodyReader)
}

// NewCreateContainerJobRequestWithBody generates requests for CreateContainerJob with any type of body
func NewCreateContainerJobRequestWithBody(server string, containerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "containerId", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/containers/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTLSGenerationAttemptsRequest generates requests for GetTLSGenerationAttempts
func NewGetTLSGenerationAttemptsRequest(server string, params *GetTLSGenerationAttemptsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/tls/attempts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLookupTLSCertificateRequest generates requests for LookupTLSCertificate
func NewLookupTLSCertificateRequest(server string, params *LookupTLSCertificateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/tls/certificates/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "domain", runtime.ParamLocationQuery, params.Domain); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Private != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "private", runtime.ParamLocationQuery, *params.Private); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserSuppliedCertificatesRequest generates requests for GetUserSuppliedCertificates
func NewGetUserSuppliedCertificatesRequest(server string, params *GetUserSuppliedCertificatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/tls/certificates/user-supplied")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadUserSuppliedCertificateRequest calls the generic UploadUserSuppliedCertificate builder with application/json body
func NewUploadUserSuppliedCertificateRequest(server string, body UploadUserSuppliedCertificateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadUserSuppliedCertificateRequestWithBody(server, "application/json", bodyReader)
}

// NewUploadUserSuppliedCertificateRequestWithBody generates requests for UploadUserSuppliedCertificate with any type of body
func NewUploadUserSuppliedCertificateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/tls/certificates/user-supplied")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserSuppliedCertificateRequest generates requests for GetUserSuppliedCertificate
func NewGetUserSuppliedCertificateRequest(server string, certificateId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificateId", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/tls/certificates/user-supplied/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserSuppliedCertificateJobRequest calls the generic CreateUserSuppliedCertificateJob builder with application/json body
func NewCreateUserSuppliedCertificateJobRequest(server string, certificateId string, body CreateUserSuppliedCertificateJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserSuppliedCertificateJobRequestWithBody(server, certificateId, "application/json", bodyReader)
}

// NewCreateUserSuppliedCertificateJobRequestWithBody generates requests for CreateUserSuppliedCertificateJob with any type of body
func NewCreateUserSuppliedCertificateJobRequestWithBody(server string, certificateId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificateId", runtime.ParamLocationPath, certificateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/tls/certificates/user-supplied/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDNSZonesRequest generates requests for GetDNSZones
func NewGetDNSZonesRequest(server string, params *GetDNSZonesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDNSZoneRequest calls the generic CreateDNSZone builder with application/json body
func NewCreateDNSZoneRequest(server string, body CreateDNSZoneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDNSZoneRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDNSZoneRequestWithBody generates requests for CreateDNSZone with any type of body
func NewCreateDNSZoneRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDNSZoneRequest generates requests for DeleteDNSZone
func NewDeleteDNSZoneRequest(server string, zoneId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDNSZoneRequest generates requests for GetDNSZone
func NewGetDNSZoneRequest(server string, zoneId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDNSZoneRequest calls the generic UpdateDNSZone builder with application/json body
func NewUpdateDNSZoneRequest(server string, zoneId string, params *UpdateDNSZoneParams, body UpdateDNSZoneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDNSZoneRequestWithBody(server, zoneId, params, "application/json", bodyReader)
}

// NewUpdateDNSZoneRequestWithBody generates requests for UpdateDNSZone with any type of body
func NewUpdateDNSZoneRequestWithBody(server string, zoneId string, params *UpdateDNSZoneParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateDNSZoneAccessRequest calls the generic UpdateDNSZoneAccess builder with application/json body
func NewUpdateDNSZoneAccessRequest(server string, zoneId string, params *UpdateDNSZoneAccessParams, body UpdateDNSZoneAccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDNSZoneAccessRequestWithBody(server, zoneId, params, "application/json", bodyReader)
}

// NewUpdateDNSZoneAccessRequestWithBody generates requests for UpdateDNSZoneAccess with any type of body
func NewUpdateDNSZoneAccessRequestWithBody(server string, zoneId string, params *UpdateDNSZoneAccessParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s/access", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDNSZoneRecordsRequest generates requests for GetDNSZoneRecords
func NewGetDNSZoneRecordsRequest(server string, zoneId string, params *GetDNSZoneRecordsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s/records", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDNSZoneRecordRequest calls the generic CreateDNSZoneRecord builder with application/json body
func NewCreateDNSZoneRecordRequest(server string, zoneId string, params *CreateDNSZoneRecordParams, body CreateDNSZoneRecordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDNSZoneRecordRequestWithBody(server, zoneId, params, "application/json", bodyReader)
}

// NewCreateDNSZoneRecordRequestWithBody generates requests for CreateDNSZoneRecord with any type of body
func NewCreateDNSZoneRecordRequestWithBody(server string, zoneId string, params *CreateDNSZoneRecordParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s/records", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDNSZoneRecordRequest generates requests for DeleteDNSZoneRecord
func NewDeleteDNSZoneRecordRequest(server string, zoneId string, recordId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recordId", runtime.ParamLocationPath, recordId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s/records/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDNSZoneRecordRequest calls the generic UpdateDNSZoneRecord builder with application/json body
func NewUpdateDNSZoneRecordRequest(server string, zoneId string, recordId string, params *UpdateDNSZoneRecordParams, body UpdateDNSZoneRecordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDNSZoneRecordRequestWithBody(server, zoneId, recordId, params, "application/json", bodyReader)
}

// NewUpdateDNSZoneRecordRequestWithBody generates requests for UpdateDNSZoneRecord with any type of body
func NewUpdateDNSZoneRecordRequestWithBody(server string, zoneId string, recordId string, params *UpdateDNSZoneRecordParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recordId", runtime.ParamLocationPath, recordId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s/records/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDNSZoneRecordJobRequest calls the generic CreateDNSZoneRecordJob builder with application/json body
func NewCreateDNSZoneRecordJobRequest(server string, zoneId string, recordId string, body CreateDNSZoneRecordJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDNSZoneRecordJobRequestWithBody(server, zoneId, recordId, "application/json", bodyReader)
}

// NewCreateDNSZoneRecordJobRequestWithBody generates requests for CreateDNSZoneRecordJob with any type of body
func NewCreateDNSZoneRecordJobRequestWithBody(server string, zoneId string, recordId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recordId", runtime.ParamLocationPath, recordId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s/records/%s/tasks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDNSZoneJobRequest calls the generic CreateDNSZoneJob builder with application/json body
func NewCreateDNSZoneJobRequest(server string, zoneId string, body CreateDNSZoneJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDNSZoneJobRequestWithBody(server, zoneId, "application/json", bodyReader)
}

// NewCreateDNSZoneJobRequestWithBody generates requests for CreateDNSZoneJob with any type of body
func NewCreateDNSZoneJobRequestWithBody(server string, zoneId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnvironmentsRequest generates requests for GetEnvironments
func NewGetEnvironmentsRequest(server string, params *GetEnvironmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEnvironmentRequest calls the generic CreateEnvironment builder with application/json body
func NewCreateEnvironmentRequest(server string, body CreateEnvironmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEnvironmentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEnvironmentRequestWithBody generates requests for CreateEnvironment with any type of body
func NewCreateEnvironmentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEnvironmentRequest generates requests for DeleteEnvironment
func NewDeleteEnvironmentRequest(server string, environmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvironmentRequest generates requests for GetEnvironment
func NewGetEnvironmentRequest(server string, environmentId string, params *GetEnvironmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEnvironmentRequest calls the generic UpdateEnvironment builder with application/json body
func NewUpdateEnvironmentRequest(server string, environmentId string, body UpdateEnvironmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEnvironmentRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewUpdateEnvironmentRequestWithBody generates requests for UpdateEnvironment with any type of body
func NewUpdateEnvironmentRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateEnvironmentAccessRequest calls the generic UpdateEnvironmentAccess builder with application/json body
func NewUpdateEnvironmentAccessRequest(server string, environmentId string, body UpdateEnvironmentAccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEnvironmentAccessRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewUpdateEnvironmentAccessRequestWithBody generates requests for UpdateEnvironmentAccess with any type of body
func NewUpdateEnvironmentAccessRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/access", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnvironmentDeploymentsRequest generates requests for GetEnvironmentDeployments
func NewGetEnvironmentDeploymentsRequest(server string, environmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/deployments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportStackRequest calls the generic ExportStack builder with application/json body
func NewExportStackRequest(server string, environmentId string, body ExportStackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportStackRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewExportStackRequestWithBody generates requests for ExportStack with any type of body
func NewExportStackRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/export/stack", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetScopedVariablesRequest generates requests for GetScopedVariables
func NewGetScopedVariablesRequest(server string, environmentId string, params *GetScopedVariablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/scoped-variables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateScopedVariableRequest calls the generic CreateScopedVariable builder with application/json body
func NewCreateScopedVariableRequest(server string, environmentId string, body CreateScopedVariableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateScopedVariableRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewCreateScopedVariableRequestWithBody generates requests for CreateScopedVariable with any type of body
func NewCreateScopedVariableRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/scoped-variables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteScopedVariableRequest generates requests for DeleteScopedVariable
func NewDeleteScopedVariableRequest(server string, environmentId string, scopedVariableId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scopedVariableId", runtime.ParamLocationPath, scopedVariableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/scoped-variables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScopedVariableRequest generates requests for GetScopedVariable
func NewGetScopedVariableRequest(server string, environmentId string, scopedVariableId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scopedVariableId", runtime.ParamLocationPath, scopedVariableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/scoped-variables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateScopedVariableRequest calls the generic UpdateScopedVariable builder with application/json body
func NewUpdateScopedVariableRequest(server string, environmentId string, scopedVariableId string, body UpdateScopedVariableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateScopedVariableRequestWithBody(server, environmentId, scopedVariableId, "application/json", bodyReader)
}

// NewUpdateScopedVariableRequestWithBody generates requests for UpdateScopedVariable with any type of body
func NewUpdateScopedVariableRequestWithBody(server string, environmentId string, scopedVariableId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scopedVariableId", runtime.ParamLocationPath, scopedVariableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/scoped-variables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDiscoveryServiceJobRequest calls the generic CreateDiscoveryServiceJob builder with application/json body
func NewCreateDiscoveryServiceJobRequest(server string, environmentId string, body CreateDiscoveryServiceJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDiscoveryServiceJobRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewCreateDiscoveryServiceJobRequestWithBody generates requests for CreateDiscoveryServiceJob with any type of body
func NewCreateDiscoveryServiceJobRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/discovery/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateGatewayServiceJobRequest calls the generic CreateGatewayServiceJob builder with application/json body
func NewCreateGatewayServiceJobRequest(server string, environmentId string, body CreateGatewayServiceJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGatewayServiceJobRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewCreateGatewayServiceJobRequestWithBody generates requests for CreateGatewayServiceJob with any type of body
func NewCreateGatewayServiceJobRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/gateway/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLoadBalancerServiceRequest generates requests for GetLoadBalancerService
func NewGetLoadBalancerServiceRequest(server string, environmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/lb", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLoadBalancerServiceJobRequest calls the generic CreateLoadBalancerServiceJob builder with application/json body
func NewCreateLoadBalancerServiceJobRequest(server string, environmentId string, body CreateLoadBalancerServiceJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLoadBalancerServiceJobRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewCreateLoadBalancerServiceJobRequestWithBody generates requests for CreateLoadBalancerServiceJob with any type of body
func NewCreateLoadBalancerServiceJobRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/lb/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLoadBalancerLatestTelemetryReportRequest generates requests for GetLoadBalancerLatestTelemetryReport
func NewGetLoadBalancerLatestTelemetryReportRequest(server string, environmentId string, params *GetLoadBalancerLatestTelemetryReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/lb/telemetry/latest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoadBalancerTelemetryLatestControllersRequest generates requests for GetLoadBalancerTelemetryLatestControllers
func NewGetLoadBalancerTelemetryLatestControllersRequest(server string, environmentId string, params *GetLoadBalancerTelemetryLatestControllersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/lb/telemetry/latest-controllers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoadBalancerTelemetryReportRequest generates requests for GetLoadBalancerTelemetryReport
func NewGetLoadBalancerTelemetryReportRequest(server string, environmentId string, params *GetLoadBalancerTelemetryReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/lb/telemetry/report", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSchedulerServiceJobRequest calls the generic CreateSchedulerServiceJob builder with application/json body
func NewCreateSchedulerServiceJobRequest(server string, environmentId string, body CreateSchedulerServiceJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSchedulerServiceJobRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewCreateSchedulerServiceJobRequestWithBody generates requests for CreateSchedulerServiceJob with any type of body
func NewCreateSchedulerServiceJobRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/scheduler/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVPNServiceRequest generates requests for GetVPNService
func NewGetVPNServiceRequest(server string, environmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/vpn", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVPNLoginsRequest generates requests for GetVPNLogins
func NewGetVPNLoginsRequest(server string, environmentId string, params *GetVPNLoginsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/vpn/logins", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVPNServiceJobRequest calls the generic CreateVPNServiceJob builder with application/json body
func NewCreateVPNServiceJobRequest(server string, environmentId string, body CreateVPNServiceJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVPNServiceJobRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewCreateVPNServiceJobRequestWithBody generates requests for CreateVPNServiceJob with any type of body
func NewCreateVPNServiceJobRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/vpn/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVPNUsersRequest generates requests for GetVPNUsers
func NewGetVPNUsersRequest(server string, environmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/vpn/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVPNUserRequest calls the generic CreateVPNUser builder with application/json body
func NewCreateVPNUserRequest(server string, environmentId string, body CreateVPNUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVPNUserRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewCreateVPNUserRequestWithBody generates requests for CreateVPNUser with any type of body
func NewCreateVPNUserRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/vpn/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVPNUserRequest generates requests for DeleteVPNUser
func NewDeleteVPNUserRequest(server string, environmentId string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/services/vpn/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvironmentSummaryRequest generates requests for GetEnvironmentSummary
func NewGetEnvironmentSummaryRequest(server string, environmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEnvironmentJobRequest calls the generic CreateEnvironmentJob builder with application/json body
func NewCreateEnvironmentJobRequest(server string, environmentId string, body CreateEnvironmentJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEnvironmentJobRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewCreateEnvironmentJobRequestWithBody generates requests for CreateEnvironmentJob with any type of body
func NewCreateEnvironmentJobRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHubsRequest generates requests for GetHubs
func NewGetHubsRequest(server string, params *GetHubsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHubRequest calls the generic CreateHub builder with application/json body
func NewCreateHubRequest(server string, body CreateHubJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHubRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateHubRequestWithBody generates requests for CreateHub with any type of body
func NewCreateHubRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHubCapabilitiesRequest generates requests for GetHubCapabilities
func NewGetHubCapabilitiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/capabilities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteHubRequest calls the generic DeleteHub builder with application/json body
func NewDeleteHubRequest(server string, body DeleteHubJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteHubRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteHubRequestWithBody generates requests for DeleteHub with any type of body
func NewDeleteHubRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHubRequest generates requests for GetHub
func NewGetHubRequest(server string, params *GetHubParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateHubRequest calls the generic UpdateHub builder with application/json body
func NewUpdateHubRequest(server string, body UpdateHubJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateHubRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateHubRequestWithBody generates requests for UpdateHub with any type of body
func NewUpdateHubRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHubActivityRequest generates requests for GetHubActivity
func NewGetHubActivityRequest(server string, params *GetHubActivityParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/activity")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiKeysRequest generates requests for GetApiKeys
func NewGetApiKeysRequest(server string, params *GetApiKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApiKeyRequest calls the generic CreateApiKey builder with application/json body
func NewCreateApiKeyRequest(server string, body CreateApiKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApiKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateApiKeyRequestWithBody generates requests for CreateApiKey with any type of body
func NewCreateApiKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/api-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAPIKeyRequest generates requests for DeleteAPIKey
func NewDeleteAPIKeyRequest(server string, apikeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apikeyId", runtime.ParamLocationPath, apikeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAPIKeyRequest generates requests for GetAPIKey
func NewGetAPIKeyRequest(server string, apikeyId string, params *GetAPIKeyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apikeyId", runtime.ParamLocationPath, apikeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAPIKeyRequest calls the generic UpdateAPIKey builder with application/json body
func NewUpdateAPIKeyRequest(server string, apikeyId string, body UpdateAPIKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAPIKeyRequestWithBody(server, apikeyId, "application/json", bodyReader)
}

// NewUpdateAPIKeyRequestWithBody generates requests for UpdateAPIKey with any type of body
func NewUpdateAPIKeyRequestWithBody(server string, apikeyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "apikeyId", runtime.ParamLocationPath, apikeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/api-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIntegrationsRequest generates requests for GetIntegrations
func NewGetIntegrationsRequest(server string, params *GetIntegrationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIntegrationRequest calls the generic CreateIntegration builder with application/json body
func NewCreateIntegrationRequest(server string, params *CreateIntegrationParams, body CreateIntegrationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIntegrationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateIntegrationRequestWithBody generates requests for CreateIntegration with any type of body
func NewCreateIntegrationRequestWithBody(server string, params *CreateIntegrationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAvailableIntegrationsRequest generates requests for GetAvailableIntegrations
func NewGetAvailableIntegrationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/integrations/available")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteIntegrationRequest generates requests for DeleteIntegration
func NewDeleteIntegrationRequest(server string, integrationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIntegrationRequest generates requests for GetIntegration
func NewGetIntegrationRequest(server string, integrationId string, params *GetIntegrationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIntegrationRequest calls the generic UpdateIntegration builder with application/json body
func NewUpdateIntegrationRequest(server string, integrationId string, params *UpdateIntegrationParams, body UpdateIntegrationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIntegrationRequestWithBody(server, integrationId, params, "application/json", bodyReader)
}

// NewUpdateIntegrationRequestWithBody generates requests for UpdateIntegration with any type of body
func NewUpdateIntegrationRequestWithBody(server string, integrationId string, params *UpdateIntegrationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateIntegrationJobRequest calls the generic CreateIntegrationJob builder with application/json body
func NewCreateIntegrationJobRequest(server string, integrationId string, body CreateIntegrationJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIntegrationJobRequestWithBody(server, integrationId, "application/json", bodyReader)
}

// NewCreateIntegrationJobRequestWithBody generates requests for CreateIntegrationJob with any type of body
func NewCreateIntegrationJobRequestWithBody(server string, integrationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/integrations/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHubInvitesRequest generates requests for GetHubInvites
func NewGetHubInvitesRequest(server string, params *GetHubInvitesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHubInviteRequest calls the generic CreateHubInvite builder with application/json body
func NewCreateHubInviteRequest(server string, body CreateHubInviteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHubInviteRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateHubInviteRequestWithBody generates requests for CreateHubInvite with any type of body
func NewCreateHubInviteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHubInviteRequest generates requests for DeleteHubInvite
func NewDeleteHubInviteRequest(server string, inviteId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inviteId", runtime.ParamLocationPath, inviteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/invites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHubMembersRequest generates requests for GetHubMembers
func NewGetHubMembersRequest(server string, params *GetHubMembersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/members")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHubMemberAccountRequest generates requests for GetHubMemberAccount
func NewGetHubMemberAccountRequest(server string, accountId string, params *GetHubMemberAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/members/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteHubMemberRequest generates requests for DeleteHubMember
func NewDeleteHubMemberRequest(server string, memberId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "memberId", runtime.ParamLocationPath, memberId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/members/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHubMemberRequest generates requests for GetHubMember
func NewGetHubMemberRequest(server string, memberId string, params *GetHubMemberParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "memberId", runtime.ParamLocationPath, memberId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/members/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateHubMemberRequest calls the generic UpdateHubMember builder with application/json body
func NewUpdateHubMemberRequest(server string, memberId string, body UpdateHubMemberJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateHubMemberRequestWithBody(server, memberId, "application/json", bodyReader)
}

// NewUpdateHubMemberRequestWithBody generates requests for UpdateHubMember with any type of body
func NewUpdateHubMemberRequestWithBody(server string, memberId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "memberId", runtime.ParamLocationPath, memberId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/members/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHubMembershipRequest generates requests for GetHubMembership
func NewGetHubMembershipRequest(server string, params *GetHubMembershipParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/membership")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHubNotificationSocketAuthRequest generates requests for GetHubNotificationSocketAuth
func NewGetHubNotificationSocketAuthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRolesRequest generates requests for GetRoles
func NewGetRolesRequest(server string, params *GetRolesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRoleRequest calls the generic CreateRole builder with application/json body
func NewCreateRoleRequest(server string, body CreateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRoleRequestWithBody generates requests for CreateRole with any type of body
func NewCreateRoleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultHubRolesRequest generates requests for GetDefaultHubRoles
func NewGetDefaultHubRolesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/roles/defaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRoleRequest generates requests for DeleteRole
func NewDeleteRoleRequest(server string, roleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleRequest generates requests for GetRole
func NewGetRoleRequest(server string, roleId string, params *GetRoleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleRequest calls the generic UpdateRole builder with application/json body
func NewUpdateRoleRequest(server string, roleId string, body UpdateRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleRequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewUpdateRoleRequestWithBody generates requests for UpdateRole with any type of body
func NewUpdateRoleRequestWithBody(server string, roleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHubUsageRequest generates requests for GetHubUsage
func NewGetHubUsageRequest(server string, params *GetHubUsageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/hubs/current/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetImagesRequest generates requests for GetImages
func NewGetImagesRequest(server string, params *GetImagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateImageRequest calls the generic CreateImage builder with application/json body
func NewCreateImageRequest(server string, body CreateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateImageRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateImageRequestWithBody generates requests for CreateImage with any type of body
func NewCreateImageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetImageSourcesRequest generates requests for GetImageSources
func NewGetImageSourcesRequest(server string, params *GetImageSourcesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images/sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateImageSourceRequest calls the generic CreateImageSource builder with application/json body
func NewCreateImageSourceRequest(server string, body CreateImageSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateImageSourceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateImageSourceRequestWithBody generates requests for CreateImageSource with any type of body
func NewCreateImageSourceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images/sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteImageSourceRequest generates requests for DeleteImageSource
func NewDeleteImageSourceRequest(server string, sourceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sourceId", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images/sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetImageSourceRequest generates requests for GetImageSource
func NewGetImageSourceRequest(server string, sourceId string, params *GetImageSourceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sourceId", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images/sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateImageSourceRequest calls the generic UpdateImageSource builder with application/json body
func NewUpdateImageSourceRequest(server string, sourceId string, body UpdateImageSourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateImageSourceRequestWithBody(server, sourceId, "application/json", bodyReader)
}

// NewUpdateImageSourceRequestWithBody generates requests for UpdateImageSource with any type of body
func NewUpdateImageSourceRequestWithBody(server string, sourceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sourceId", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images/sources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateImageSourceAccessRequest calls the generic UpdateImageSourceAccess builder with application/json body
func NewUpdateImageSourceAccessRequest(server string, sourceId string, body UpdateImageSourceAccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateImageSourceAccessRequestWithBody(server, sourceId, "application/json", bodyReader)
}

// NewUpdateImageSourceAccessRequestWithBody generates requests for UpdateImageSourceAccess with any type of body
func NewUpdateImageSourceAccessRequestWithBody(server string, sourceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sourceId", runtime.ParamLocationPath, sourceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images/sources/%s/access", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateImagesJobRequest calls the generic CreateImagesJob builder with application/json body
func NewCreateImagesJobRequest(server string, body CreateImagesJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateImagesJobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateImagesJobRequestWithBody generates requests for CreateImagesJob with any type of body
func NewCreateImagesJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images/tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteImageRequest generates requests for DeleteImage
func NewDeleteImageRequest(server string, imageId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "imageId", runtime.ParamLocationPath, imageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetImageRequest generates requests for GetImage
func NewGetImageRequest(server string, imageId string, params *GetImageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "imageId", runtime.ParamLocationPath, imageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateImageRequest calls the generic UpdateImage builder with application/json body
func NewUpdateImageRequest(server string, imageId string, body UpdateImageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateImageRequestWithBody(server, imageId, "application/json", bodyReader)
}

// NewUpdateImageRequestWithBody generates requests for UpdateImage with any type of body
func NewUpdateImageRequestWithBody(server string, imageId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "imageId", runtime.ParamLocationPath, imageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetImageBuildLogRequest generates requests for GetImageBuildLog
func NewGetImageBuildLogRequest(server string, imageId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "imageId", runtime.ParamLocationPath, imageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images/%s/build-log", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateImageJobRequest calls the generic CreateImageJob builder with application/json body
func NewCreateImageJobRequest(server string, imageId string, body CreateImageJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateImageJobRequestWithBody(server, imageId, "application/json", bodyReader)
}

// NewCreateImageJobRequestWithBody generates requests for CreateImageJob with any type of body
func NewCreateImageJobRequestWithBody(server string, imageId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "imageId", runtime.ParamLocationPath, imageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/images/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAutoScaleGroupsRequest generates requests for GetAutoScaleGroups
func NewGetAutoScaleGroupsRequest(server string, params *GetAutoScaleGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/auto-scale/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAutoScaleGroupRequest calls the generic CreateAutoScaleGroup builder with application/json body
func NewCreateAutoScaleGroupRequest(server string, body CreateAutoScaleGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAutoScaleGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAutoScaleGroupRequestWithBody generates requests for CreateAutoScaleGroup with any type of body
func NewCreateAutoScaleGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/auto-scale/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAutoScaleGroupRequest generates requests for DeleteAutoScaleGroup
func NewDeleteAutoScaleGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/auto-scale/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAutoScaleGroupRequest generates requests for GetAutoScaleGroup
func NewGetAutoScaleGroupRequest(server string, groupId string, params *GetAutoScaleGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/auto-scale/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAutoScaleGroupRequest calls the generic UpdateAutoScaleGroup builder with application/json body
func NewUpdateAutoScaleGroupRequest(server string, groupId string, body UpdateAutoScaleGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAutoScaleGroupRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewUpdateAutoScaleGroupRequestWithBody generates requests for UpdateAutoScaleGroup with any type of body
func NewUpdateAutoScaleGroupRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/auto-scale/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateAutoScaleGroupAccessRequest calls the generic UpdateAutoScaleGroupAccess builder with application/json body
func NewUpdateAutoScaleGroupAccessRequest(server string, groupId string, body UpdateAutoScaleGroupAccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAutoScaleGroupAccessRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewUpdateAutoScaleGroupAccessRequestWithBody generates requests for UpdateAutoScaleGroupAccess with any type of body
func NewUpdateAutoScaleGroupAccessRequestWithBody(server string, groupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/auto-scale/groups/%s/access", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClustersRequest generates requests for GetClusters
func NewGetClustersRequest(server string, params *GetClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, clusterId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequest calls the generic UpdateCluster builder with application/json body
func NewUpdateClusterRequest(server string, clusterId string, body UpdateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterRequestWithBody(server, clusterId, "application/json", bodyReader)
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateClusterAccessRequest calls the generic UpdateClusterAccess builder with application/json body
func NewUpdateClusterAccessRequest(server string, clusterId string, body UpdateClusterAccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterAccessRequestWithBody(server, clusterId, "application/json", bodyReader)
}

// NewUpdateClusterAccessRequestWithBody generates requests for UpdateClusterAccess with any type of body
func NewUpdateClusterAccessRequestWithBody(server string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/clusters/%s/access", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateClusterJobRequest calls the generic CreateClusterJob builder with application/json body
func NewCreateClusterJobRequest(server string, clusterId string, body CreateClusterJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterJobRequestWithBody(server, clusterId, "application/json", bodyReader)
}

// NewCreateClusterJobRequestWithBody generates requests for CreateClusterJob with any type of body
func NewCreateClusterJobRequestWithBody(server string, clusterId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterId", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/clusters/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDeploymentStrategiesRequest generates requests for GetDeploymentStrategies
func NewGetDeploymentStrategiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/deployment-strategies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExternalVolumesRequest generates requests for GetExternalVolumes
func NewGetExternalVolumesRequest(server string, params *GetExternalVolumesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/external-volumes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateExternalVolumeRequest calls the generic CreateExternalVolume builder with application/json body
func NewCreateExternalVolumeRequest(server string, params *CreateExternalVolumeParams, body CreateExternalVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateExternalVolumeRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateExternalVolumeRequestWithBody generates requests for CreateExternalVolume with any type of body
func NewCreateExternalVolumeRequestWithBody(server string, params *CreateExternalVolumeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/external-volumes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExternalVolumeSourcesRequest generates requests for GetExternalVolumeSources
func NewGetExternalVolumeSourcesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/external-volumes/sources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteExternalVolumeRequest calls the generic DeleteExternalVolume builder with application/json body
func NewDeleteExternalVolumeRequest(server string, externalVolumeId string, body DeleteExternalVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteExternalVolumeRequestWithBody(server, externalVolumeId, "application/json", bodyReader)
}

// NewDeleteExternalVolumeRequestWithBody generates requests for DeleteExternalVolume with any type of body
func NewDeleteExternalVolumeRequestWithBody(server string, externalVolumeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "externalVolumeId", runtime.ParamLocationPath, externalVolumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/external-volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExternalVolumeRequest generates requests for GetExternalVolume
func NewGetExternalVolumeRequest(server string, externalVolumeId string, params *GetExternalVolumeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "externalVolumeId", runtime.ParamLocationPath, externalVolumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/external-volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateExternalVolumeRequest calls the generic UpdateExternalVolume builder with application/json body
func NewUpdateExternalVolumeRequest(server string, externalVolumeId string, params *UpdateExternalVolumeParams, body UpdateExternalVolumeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateExternalVolumeRequestWithBody(server, externalVolumeId, params, "application/json", bodyReader)
}

// NewUpdateExternalVolumeRequestWithBody generates requests for UpdateExternalVolume with any type of body
func NewUpdateExternalVolumeRequestWithBody(server string, externalVolumeId string, params *UpdateExternalVolumeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "externalVolumeId", runtime.ParamLocationPath, externalVolumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/external-volumes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateExternalVolumeAccessRequest calls the generic UpdateExternalVolumeAccess builder with application/json body
func NewUpdateExternalVolumeAccessRequest(server string, externalVolumeId string, body UpdateExternalVolumeAccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateExternalVolumeAccessRequestWithBody(server, externalVolumeId, "application/json", bodyReader)
}

// NewUpdateExternalVolumeAccessRequestWithBody generates requests for UpdateExternalVolumeAccess with any type of body
func NewUpdateExternalVolumeAccessRequestWithBody(server string, externalVolumeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "externalVolumeId", runtime.ParamLocationPath, externalVolumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/external-volumes/%s/access", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateExternalVolumeJobRequest calls the generic CreateExternalVolumeJob builder with application/json body
func NewCreateExternalVolumeJobRequest(server string, externalVolumeId string, body CreateExternalVolumeJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateExternalVolumeJobRequestWithBody(server, externalVolumeId, "application/json", bodyReader)
}

// NewCreateExternalVolumeJobRequestWithBody generates requests for CreateExternalVolumeJob with any type of body
func NewCreateExternalVolumeJobRequestWithBody(server string, externalVolumeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "externalVolumeId", runtime.ParamLocationPath, externalVolumeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/external-volumes/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIpPoolsRequest generates requests for GetIpPools
func NewGetIpPoolsRequest(server string, params *GetIpPoolsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/ips/pools")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIpPoolRequest calls the generic CreateIpPool builder with application/json body
func NewCreateIpPoolRequest(server string, body CreateIpPoolJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIpPoolRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIpPoolRequestWithBody generates requests for CreateIpPool with any type of body
func NewCreateIpPoolRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/ips/pools")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIPPoolRequest generates requests for DeleteIPPool
func NewDeleteIPPoolRequest(server string, poolId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "poolId", runtime.ParamLocationPath, poolId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/ips/pools/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIPPoolRequest generates requests for GetIPPool
func NewGetIPPoolRequest(server string, poolId string, params *GetIPPoolParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "poolId", runtime.ParamLocationPath, poolId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/ips/pools/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPoolIPsRequest generates requests for GetPoolIPs
func NewGetPoolIPsRequest(server string, poolId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "poolId", runtime.ParamLocationPath, poolId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/ips/pools/%s/ips", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIpPoolJobRequest calls the generic CreateIpPoolJob builder with application/json body
func NewCreateIpPoolJobRequest(server string, poolId string, body CreateIpPoolJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIpPoolJobRequestWithBody(server, poolId, "application/json", bodyReader)
}

// NewCreateIpPoolJobRequestWithBody generates requests for CreateIpPoolJob with any type of body
func NewCreateIpPoolJobRequestWithBody(server string, poolId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "poolId", runtime.ParamLocationPath, poolId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/ips/pools/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterMonitoringTiersRequest generates requests for GetClusterMonitoringTiers
func NewGetClusterMonitoringTiersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/monitoring-tiers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProviderLocationsRequest generates requests for GetProviderLocations
func NewGetProviderLocationsRequest(server string, providerVendor string, params *GetProviderLocationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "providerVendor", runtime.ParamLocationPath, providerVendor)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/providers/%s/locations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProviderServersRequest generates requests for GetProviderServers
func NewGetProviderServersRequest(server string, providerVendor string, params *GetProviderServersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "providerVendor", runtime.ParamLocationPath, providerVendor)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/providers/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServersRequest generates requests for GetServers
func NewGetServersRequest(server string, params *GetServersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerRequest calls the generic CreateServer builder with application/json body
func NewCreateServerRequest(server string, body CreateServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateServerRequestWithBody generates requests for CreateServer with any type of body
func NewCreateServerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerTagsRequest generates requests for GetServerTags
func NewGetServerTagsRequest(server string, params *GetServerTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/servers/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteServerRequest calls the generic DeleteServer builder with application/json body
func NewDeleteServerRequest(server string, serverId string, body DeleteServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteServerRequestWithBody(server, serverId, "application/json", bodyReader)
}

// NewDeleteServerRequestWithBody generates requests for DeleteServer with any type of body
func NewDeleteServerRequestWithBody(server string, serverId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/servers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerRequest generates requests for GetServer
func NewGetServerRequest(server string, serverId string, params *GetServerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/servers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServerRequest calls the generic UpdateServer builder with application/json body
func NewUpdateServerRequest(server string, serverId string, body UpdateServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServerRequestWithBody(server, serverId, "application/json", bodyReader)
}

// NewUpdateServerRequestWithBody generates requests for UpdateServer with any type of body
func NewUpdateServerRequestWithBody(server string, serverId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/servers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerConsoleRequest generates requests for GetServerConsole
func NewGetServerConsoleRequest(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/servers/%s/console", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerInstancesRequest generates requests for GetServerInstances
func NewGetServerInstancesRequest(server string, serverId string, params *GetServerInstancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/servers/%s/instances", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerJobRequest calls the generic CreateServerJob builder with application/json body
func NewCreateServerJobRequest(server string, serverId string, body CreateServerJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerJobRequestWithBody(server, serverId, "application/json", bodyReader)
}

// NewCreateServerJobRequestWithBody generates requests for CreateServerJob with any type of body
func NewCreateServerJobRequestWithBody(server string, serverId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/servers/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerTelemetryRequest generates requests for GetServerTelemetry
func NewGetServerTelemetryRequest(server string, serverId string, params *GetServerTelemetryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/servers/%s/telemetry", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerUsageRequest generates requests for GetServerUsage
func NewGetServerUsageRequest(server string, serverId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serverId", runtime.ParamLocationPath, serverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/servers/%s/usage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInfrastructureSummaryRequest generates requests for GetInfrastructureSummary
func NewGetInfrastructureSummaryRequest(server string, params *GetInfrastructureSummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualProviderIsosRequest generates requests for GetVirtualProviderIsos
func NewGetVirtualProviderIsosRequest(server string, integrationId string, params *GetVirtualProviderIsosParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/virtual-providers/%s/isos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVirtualProviderIsoRequest calls the generic CreateVirtualProviderIso builder with application/json body
func NewCreateVirtualProviderIsoRequest(server string, integrationId string, body CreateVirtualProviderIsoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVirtualProviderIsoRequestWithBody(server, integrationId, "application/json", bodyReader)
}

// NewCreateVirtualProviderIsoRequestWithBody generates requests for CreateVirtualProviderIso with any type of body
func NewCreateVirtualProviderIsoRequestWithBody(server string, integrationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/virtual-providers/%s/isos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVirtualProviderIsoRequest generates requests for DeleteVirtualProviderIso
func NewDeleteVirtualProviderIsoRequest(server string, integrationId string, isoId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "isoId", runtime.ParamLocationPath, isoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/virtual-providers/%s/isos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualProviderIsoRequest generates requests for GetVirtualProviderIso
func NewGetVirtualProviderIsoRequest(server string, integrationId string, isoId string, params *GetVirtualProviderIsoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "isoId", runtime.ParamLocationPath, isoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/virtual-providers/%s/isos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVirtualProviderIsoRequest calls the generic UpdateVirtualProviderIso builder with application/json body
func NewUpdateVirtualProviderIsoRequest(server string, integrationId string, isoId string, body UpdateVirtualProviderIsoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVirtualProviderIsoRequestWithBody(server, integrationId, isoId, "application/json", bodyReader)
}

// NewUpdateVirtualProviderIsoRequestWithBody generates requests for UpdateVirtualProviderIso with any type of body
func NewUpdateVirtualProviderIsoRequestWithBody(server string, integrationId string, isoId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "isoId", runtime.ParamLocationPath, isoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/virtual-providers/%s/isos/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVirtualProviderIsoDownloadUrlRequest generates requests for GetVirtualProviderIsoDownloadUrl
func NewGetVirtualProviderIsoDownloadUrlRequest(server string, integrationId string, isoId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "isoId", runtime.ParamLocationPath, isoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/virtual-providers/%s/isos/%s/download", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVirtualProviderIsoJobRequest calls the generic CreateVirtualProviderIsoJob builder with application/json body
func NewCreateVirtualProviderIsoJobRequest(server string, integrationId string, isoId string, body CreateVirtualProviderIsoJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVirtualProviderIsoJobRequestWithBody(server, integrationId, isoId, "application/json", bodyReader)
}

// NewCreateVirtualProviderIsoJobRequestWithBody generates requests for CreateVirtualProviderIsoJob with any type of body
func NewCreateVirtualProviderIsoJobRequestWithBody(server string, integrationId string, isoId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "isoId", runtime.ParamLocationPath, isoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/infrastructure/virtual-providers/%s/isos/%s/tasks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetJobsRequest generates requests for GetJobs
func NewGetJobsRequest(server string, params *GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLatestJobsRequest generates requests for GetLatestJobs
func NewGetLatestJobsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs/latest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventsRequest generates requests for GetEvents
func NewGetEventsRequest(server string, params *GetEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/monitoring/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateAggregatedEventsRequest calls the generic GenerateAggregatedEvents builder with application/json body
func NewGenerateAggregatedEventsRequest(server string, params *GenerateAggregatedEventsParams, body GenerateAggregatedEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateAggregatedEventsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGenerateAggregatedEventsRequestWithBody generates requests for GenerateAggregatedEvents with any type of body
func NewGenerateAggregatedEventsRequestWithBody(server string, params *GenerateAggregatedEventsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/monitoring/events/aggregate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAggregateLogsRequest calls the generic AggregateLogs builder with application/json body
func NewAggregateLogsRequest(server string, body AggregateLogsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAggregateLogsRequestWithBody(server, "application/json", bodyReader)
}

// NewAggregateLogsRequestWithBody generates requests for AggregateLogs with any type of body
func NewAggregateLogsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/monitoring/logs/aggregate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMetricsRequest generates requests for GetMetrics
func NewGetMetricsRequest(server string, params *GetMetricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/monitoring/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateAggregatedMetricsRequest calls the generic GenerateAggregatedMetrics builder with application/json body
func NewGenerateAggregatedMetricsRequest(server string, params *GenerateAggregatedMetricsParams, body GenerateAggregatedMetricsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGenerateAggregatedMetricsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGenerateAggregatedMetricsRequestWithBody generates requests for GenerateAggregatedMetrics with any type of body
func NewGenerateAggregatedMetricsRequestWithBody(server string, params *GenerateAggregatedMetricsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/monitoring/metrics/aggregate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMonitoringMonitorsRequest generates requests for GetMonitoringMonitors
func NewGetMonitoringMonitorsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/monitoring/monitors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelinesRequest generates requests for GetPipelines
func NewGetPipelinesRequest(server string, params *GetPipelinesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePipelineRequest calls the generic CreatePipeline builder with application/json body
func NewCreatePipelineRequest(server string, body CreatePipelineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePipelineRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePipelineRequestWithBody generates requests for CreatePipeline with any type of body
func NewCreatePipelineRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClonePipelineRequest calls the generic ClonePipeline builder with application/json body
func NewClonePipelineRequest(server string, body ClonePipelineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClonePipelineRequestWithBody(server, "application/json", bodyReader)
}

// NewClonePipelineRequestWithBody generates requests for ClonePipeline with any type of body
func NewClonePipelineRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/clone")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePipelineRequest generates requests for DeletePipeline
func NewDeletePipelineRequest(server string, pipelineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineRequest generates requests for GetPipeline
func NewGetPipelineRequest(server string, pipelineId string, params *GetPipelineParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePipelineRequest calls the generic UpdatePipeline builder with application/json body
func NewUpdatePipelineRequest(server string, pipelineId string, body UpdatePipelineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePipelineRequestWithBody(server, pipelineId, "application/json", bodyReader)
}

// NewUpdatePipelineRequestWithBody generates requests for UpdatePipeline with any type of body
func NewUpdatePipelineRequestWithBody(server string, pipelineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdatePipelineAccessRequest calls the generic UpdatePipelineAccess builder with application/json body
func NewUpdatePipelineAccessRequest(server string, pipelineId string, body UpdatePipelineAccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePipelineAccessRequestWithBody(server, pipelineId, "application/json", bodyReader)
}

// NewUpdatePipelineAccessRequestWithBody generates requests for UpdatePipelineAccess with any type of body
func NewUpdatePipelineAccessRequestWithBody(server string, pipelineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s/access", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPipelineTriggerKeysRequest generates requests for GetPipelineTriggerKeys
func NewGetPipelineTriggerKeysRequest(server string, pipelineId string, params *GetPipelineTriggerKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s/keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePipelineTriggerKeyRequest calls the generic CreatePipelineTriggerKey builder with application/json body
func NewCreatePipelineTriggerKeyRequest(server string, pipelineId string, body CreatePipelineTriggerKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePipelineTriggerKeyRequestWithBody(server, pipelineId, "application/json", bodyReader)
}

// NewCreatePipelineTriggerKeyRequestWithBody generates requests for CreatePipelineTriggerKey with any type of body
func NewCreatePipelineTriggerKeyRequestWithBody(server string, pipelineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s/keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePipelineTriggerKeyRequest generates requests for DeletePipelineTriggerKey
func NewDeletePipelineTriggerKeyRequest(server string, pipelineId string, triggerKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "triggerKeyId", runtime.ParamLocationPath, triggerKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s/keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineTriggerKeyRequest generates requests for GetPipelineTriggerKey
func NewGetPipelineTriggerKeyRequest(server string, pipelineId string, triggerKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "triggerKeyId", runtime.ParamLocationPath, triggerKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s/keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePipelineTriggerKeyRequest calls the generic UpdatePipelineTriggerKey builder with application/json body
func NewUpdatePipelineTriggerKeyRequest(server string, pipelineId string, triggerKeyId string, body UpdatePipelineTriggerKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePipelineTriggerKeyRequestWithBody(server, pipelineId, triggerKeyId, "application/json", bodyReader)
}

// NewUpdatePipelineTriggerKeyRequestWithBody generates requests for UpdatePipelineTriggerKey with any type of body
func NewUpdatePipelineTriggerKeyRequestWithBody(server string, pipelineId string, triggerKeyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "triggerKeyId", runtime.ParamLocationPath, triggerKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s/keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPipelineRunsRequest generates requests for GetPipelineRuns
func NewGetPipelineRunsRequest(server string, pipelineId string, params *GetPipelineRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s/runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPipelineRunRequest generates requests for GetPipelineRun
func NewGetPipelineRunRequest(server string, pipelineId string, runId string, params *GetPipelineRunParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runId", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s/runs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePipelineJobRequest calls the generic CreatePipelineJob builder with application/json body
func NewCreatePipelineJobRequest(server string, pipelineId string, body CreatePipelineJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePipelineJobRequestWithBody(server, pipelineId, "application/json", bodyReader)
}

// NewCreatePipelineJobRequestWithBody generates requests for CreatePipelineJob with any type of body
func NewCreatePipelineJobRequestWithBody(server string, pipelineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTriggerPipelineRequest calls the generic TriggerPipeline builder with application/json body
func NewTriggerPipelineRequest(server string, pipelineId string, body TriggerPipelineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTriggerPipelineRequestWithBody(server, pipelineId, "application/json", bodyReader)
}

// NewTriggerPipelineRequestWithBody generates requests for TriggerPipeline with any type of body
func NewTriggerPipelineRequestWithBody(server string, pipelineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pipelineId", runtime.ParamLocationPath, pipelineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/pipelines/%s/trigger", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNetworksRequest generates requests for GetNetworks
func NewGetNetworksRequest(server string, params *GetNetworksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sdn/networks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNetworkRequest calls the generic CreateNetwork builder with application/json body
func NewCreateNetworkRequest(server string, params *CreateNetworkParams, body CreateNetworkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNetworkRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateNetworkRequestWithBody generates requests for CreateNetwork with any type of body
func NewCreateNetworkRequestWithBody(server string, params *CreateNetworkParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sdn/networks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNetworkRequest generates requests for DeleteNetwork
func NewDeleteNetworkRequest(server string, networkId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "networkId", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sdn/networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkRequest generates requests for GetNetwork
func NewGetNetworkRequest(server string, networkId string, params *GetNetworkParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "networkId", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sdn/networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNetworkRequest calls the generic UpdateNetwork builder with application/json body
func NewUpdateNetworkRequest(server string, networkId string, params *UpdateNetworkParams, body UpdateNetworkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNetworkRequestWithBody(server, networkId, params, "application/json", bodyReader)
}

// NewUpdateNetworkRequestWithBody generates requests for UpdateNetwork with any type of body
func NewUpdateNetworkRequestWithBody(server string, networkId string, params *UpdateNetworkParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "networkId", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sdn/networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateNetworkAccessRequest calls the generic UpdateNetworkAccess builder with application/json body
func NewUpdateNetworkAccessRequest(server string, networkId string, params *UpdateNetworkAccessParams, body UpdateNetworkAccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNetworkAccessRequestWithBody(server, networkId, params, "application/json", bodyReader)
}

// NewUpdateNetworkAccessRequestWithBody generates requests for UpdateNetworkAccess with any type of body
func NewUpdateNetworkAccessRequestWithBody(server string, networkId string, params *UpdateNetworkAccessParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "networkId", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sdn/networks/%s/access", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateNetworkJobRequest calls the generic CreateNetworkJob builder with application/json body
func NewCreateNetworkJobRequest(server string, networkId string, body CreateNetworkJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNetworkJobRequestWithBody(server, networkId, "application/json", bodyReader)
}

// NewCreateNetworkJobRequestWithBody generates requests for CreateNetworkJob with any type of body
func NewCreateNetworkJobRequestWithBody(server string, networkId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "networkId", runtime.ParamLocationPath, networkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/sdn/networks/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchIndexRequest generates requests for GetSearchIndex
func NewGetSearchIndexRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/search/index")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStacksRequest generates requests for GetStacks
func NewGetStacksRequest(server string, params *GetStacksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStackRequest calls the generic CreateStack builder with application/json body
func NewCreateStackRequest(server string, body CreateStackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStackRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateStackRequestWithBody generates requests for CreateStack with any type of body
func NewCreateStackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLookupStackBuildRequest generates requests for LookupStackBuild
func NewLookupStackBuildRequest(server string, buildId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "buildId", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks/builds/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStackRequest generates requests for DeleteStack
func NewDeleteStackRequest(server string, stackId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stackId", runtime.ParamLocationPath, stackId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStackRequest generates requests for GetStack
func NewGetStackRequest(server string, stackId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stackId", runtime.ParamLocationPath, stackId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateStackRequest calls the generic UpdateStack builder with application/json body
func NewUpdateStackRequest(server string, stackId string, body UpdateStackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateStackRequestWithBody(server, stackId, "application/json", bodyReader)
}

// NewUpdateStackRequestWithBody generates requests for UpdateStack with any type of body
func NewUpdateStackRequestWithBody(server string, stackId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stackId", runtime.ParamLocationPath, stackId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateStackAccessRequest calls the generic UpdateStackAccess builder with application/json body
func NewUpdateStackAccessRequest(server string, stackId string, body UpdateStackAccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateStackAccessRequestWithBody(server, stackId, "application/json", bodyReader)
}

// NewUpdateStackAccessRequestWithBody generates requests for UpdateStackAccess with any type of body
func NewUpdateStackAccessRequestWithBody(server string, stackId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stackId", runtime.ParamLocationPath, stackId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks/%s/access", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStackBuildsRequest generates requests for GetStackBuilds
func NewGetStackBuildsRequest(server string, stackId string, params *GetStackBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stackId", runtime.ParamLocationPath, stackId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStackBuildRequest calls the generic CreateStackBuild builder with application/json body
func NewCreateStackBuildRequest(server string, stackId string, body CreateStackBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStackBuildRequestWithBody(server, stackId, "application/json", bodyReader)
}

// NewCreateStackBuildRequestWithBody generates requests for CreateStackBuild with any type of body
func NewCreateStackBuildRequestWithBody(server string, stackId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stackId", runtime.ParamLocationPath, stackId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStackBuildRequest generates requests for DeleteStackBuild
func NewDeleteStackBuildRequest(server string, stackId string, buildId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stackId", runtime.ParamLocationPath, stackId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildId", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStackBuildRequest generates requests for GetStackBuild
func NewGetStackBuildRequest(server string, stackId string, buildId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stackId", runtime.ParamLocationPath, stackId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildId", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStackBuildLogRequest generates requests for GetStackBuildLog
func NewGetStackBuildLogRequest(server string, stackId string, buildId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stackId", runtime.ParamLocationPath, stackId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildId", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks/%s/builds/%s/build-log", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStackBuildJobRequest calls the generic CreateStackBuildJob builder with application/json body
func NewCreateStackBuildJobRequest(server string, stackId string, buildId string, body CreateStackBuildJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStackBuildJobRequestWithBody(server, stackId, buildId, "application/json", bodyReader)
}

// NewCreateStackBuildJobRequestWithBody generates requests for CreateStackBuildJob with any type of body
func NewCreateStackBuildJobRequestWithBody(server string, stackId string, buildId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stackId", runtime.ParamLocationPath, stackId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "buildId", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks/%s/builds/%s/tasks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateStackJobRequest calls the generic CreateStackJob builder with application/json body
func NewCreateStackJobRequest(server string, stackId string, body CreateStackJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStackJobRequestWithBody(server, stackId, "application/json", bodyReader)
}

// NewCreateStackJobRequestWithBody generates requests for CreateStackJob with any type of body
func NewCreateStackJobRequestWithBody(server string, stackId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stackId", runtime.ParamLocationPath, stackId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/stacks/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLookupComponentsRequest calls the generic LookupComponents builder with application/json body
func NewLookupComponentsRequest(server string, body LookupComponentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLookupComponentsRequestWithBody(server, "application/json", bodyReader)
}

// NewLookupComponentsRequestWithBody generates requests for LookupComponents with any type of body
func NewLookupComponentsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/utils/components/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLookupIdentifierRequest generates requests for LookupIdentifier
func NewLookupIdentifierRequest(server string, params *LookupIdentifierParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/utils/resource/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "identifier", runtime.ParamLocationQuery, params.Identifier); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "desired-component", runtime.ParamLocationQuery, params.DesiredComponent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualMachinesRequest generates requests for GetVirtualMachines
func NewGetVirtualMachinesRequest(server string, params *GetVirtualMachinesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVirtualMachineRequest calls the generic CreateVirtualMachine builder with application/json body
func NewCreateVirtualMachineRequest(server string, params *CreateVirtualMachineParams, body CreateVirtualMachineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVirtualMachineRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateVirtualMachineRequestWithBody generates requests for CreateVirtualMachine with any type of body
func NewCreateVirtualMachineRequestWithBody(server string, params *CreateVirtualMachineParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVirtualMachineBaseImagesRequest generates requests for GetVirtualMachineBaseImages
func NewGetVirtualMachineBaseImagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/images/base")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualMachineSshKeysRequest generates requests for GetVirtualMachineSshKeys
func NewGetVirtualMachineSshKeysRequest(server string, params *GetVirtualMachineSshKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/ssh-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVirtualMachineSshKeyRequest calls the generic CreateVirtualMachineSshKey builder with application/json body
func NewCreateVirtualMachineSshKeyRequest(server string, params *CreateVirtualMachineSshKeyParams, body CreateVirtualMachineSshKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVirtualMachineSshKeyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateVirtualMachineSshKeyRequestWithBody generates requests for CreateVirtualMachineSshKey with any type of body
func NewCreateVirtualMachineSshKeyRequestWithBody(server string, params *CreateVirtualMachineSshKeyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/ssh-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVirtualMachineSshKeyRequest generates requests for DeleteVirtualMachineSshKey
func NewDeleteVirtualMachineSshKeyRequest(server string, sshKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sshKeyId", runtime.ParamLocationPath, sshKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/ssh-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualMachineSshKeyRequest generates requests for GetVirtualMachineSshKey
func NewGetVirtualMachineSshKeyRequest(server string, sshKeyId string, params *GetVirtualMachineSshKeyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sshKeyId", runtime.ParamLocationPath, sshKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/ssh-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVirtualMachineSshKeyRequest calls the generic UpdateVirtualMachineSshKey builder with application/json body
func NewUpdateVirtualMachineSshKeyRequest(server string, sshKeyId string, params *UpdateVirtualMachineSshKeyParams, body UpdateVirtualMachineSshKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVirtualMachineSshKeyRequestWithBody(server, sshKeyId, params, "application/json", bodyReader)
}

// NewUpdateVirtualMachineSshKeyRequestWithBody generates requests for UpdateVirtualMachineSshKey with any type of body
func NewUpdateVirtualMachineSshKeyRequestWithBody(server string, sshKeyId string, params *UpdateVirtualMachineSshKeyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "sshKeyId", runtime.ParamLocationPath, sshKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/ssh-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVirtualMachineRequest generates requests for DeleteVirtualMachine
func NewDeleteVirtualMachineRequest(server string, virtualMachineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtualMachineId", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVirtualMachineRequest generates requests for GetVirtualMachine
func NewGetVirtualMachineRequest(server string, virtualMachineId string, params *GetVirtualMachineParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtualMachineId", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVirtualMachineRequest calls the generic UpdateVirtualMachine builder with application/json body
func NewUpdateVirtualMachineRequest(server string, virtualMachineId string, body UpdateVirtualMachineJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVirtualMachineRequestWithBody(server, virtualMachineId, "application/json", bodyReader)
}

// NewUpdateVirtualMachineRequestWithBody generates requests for UpdateVirtualMachine with any type of body
func NewUpdateVirtualMachineRequestWithBody(server string, virtualMachineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtualMachineId", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAvailableIpsRequest generates requests for GetAvailableIps
func NewGetAvailableIpsRequest(server string, virtualMachineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtualMachineId", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/%s/available-ips", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExpireVirtualMachineSosCredentialsRequest generates requests for ExpireVirtualMachineSosCredentials
func NewExpireVirtualMachineSosCredentialsRequest(server string, virtualMachineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtualMachineId", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/%s/sos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateVirtualMachineSosCredentialsRequest generates requests for GenerateVirtualMachineSosCredentials
func NewGenerateVirtualMachineSosCredentialsRequest(server string, virtualMachineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtualMachineId", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/%s/sos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVirtualMachineJobRequest calls the generic CreateVirtualMachineJob builder with application/json body
func NewCreateVirtualMachineJobRequest(server string, virtualMachineId string, body CreateVirtualMachineJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVirtualMachineJobRequestWithBody(server, virtualMachineId, "application/json", bodyReader)
}

// NewCreateVirtualMachineJobRequestWithBody generates requests for CreateVirtualMachineJob with any type of body
func NewCreateVirtualMachineJobRequestWithBody(server string, virtualMachineId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "virtualMachineId", runtime.ParamLocationPath, virtualMachineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/virtual-machines/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteAccountWithResponse request
	DeleteAccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteAccountResponse, error)

	// GetAccountWithResponse request
	GetAccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccountResponse, error)

	// UpdateAccountWithBodyWithResponse request with any body
	UpdateAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error)

	UpdateAccountWithResponse(ctx context.Context, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error)

	// DisableTwoFactorAuthWithBodyWithResponse request with any body
	DisableTwoFactorAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableTwoFactorAuthResponse, error)

	DisableTwoFactorAuthWithResponse(ctx context.Context, body DisableTwoFactorAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableTwoFactorAuthResponse, error)

	// RecoverTwoFactorAuthWithBodyWithResponse request with any body
	RecoverTwoFactorAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecoverTwoFactorAuthResponse, error)

	RecoverTwoFactorAuthWithResponse(ctx context.Context, body RecoverTwoFactorAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*RecoverTwoFactorAuthResponse, error)

	// GetTwoFactorAuthSetupWithResponse request
	GetTwoFactorAuthSetupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTwoFactorAuthSetupResponse, error)

	// EnableTwoFactorAuthWithBodyWithResponse request with any body
	EnableTwoFactorAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableTwoFactorAuthResponse, error)

	EnableTwoFactorAuthWithResponse(ctx context.Context, body EnableTwoFactorAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableTwoFactorAuthResponse, error)

	// GetAccountInvitesWithResponse request
	GetAccountInvitesWithResponse(ctx context.Context, params *GetAccountInvitesParams, reqEditors ...RequestEditorFn) (*GetAccountInvitesResponse, error)

	// UpdateAccountInviteWithBodyWithResponse request with any body
	UpdateAccountInviteWithBodyWithResponse(ctx context.Context, inviteId string, params *UpdateAccountInviteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountInviteResponse, error)

	UpdateAccountInviteWithResponse(ctx context.Context, inviteId string, params *UpdateAccountInviteParams, body UpdateAccountInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountInviteResponse, error)

	// GetAccountLoginsWithResponse request
	GetAccountLoginsWithResponse(ctx context.Context, params *GetAccountLoginsParams, reqEditors ...RequestEditorFn) (*GetAccountLoginsResponse, error)

	// GetAccountMembershipsWithResponse request
	GetAccountMembershipsWithResponse(ctx context.Context, params *GetAccountMembershipsParams, reqEditors ...RequestEditorFn) (*GetAccountMembershipsResponse, error)

	// ChangePasswordWithBodyWithResponse request with any body
	ChangePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePasswordResponse, error)

	ChangePasswordWithResponse(ctx context.Context, body ChangePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePasswordResponse, error)

	// ResetPasswordWithBodyWithResponse request with any body
	ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	ResetPasswordWithResponse(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// GetAnnouncementsWithResponse request
	GetAnnouncementsWithResponse(ctx context.Context, params *GetAnnouncementsParams, reqEditors ...RequestEditorFn) (*GetAnnouncementsResponse, error)

	// GetCreditsWithResponse request
	GetCreditsWithResponse(ctx context.Context, params *GetCreditsParams, reqEditors ...RequestEditorFn) (*GetCreditsResponse, error)

	// GetCreditWithResponse request
	GetCreditWithResponse(ctx context.Context, creditsId string, reqEditors ...RequestEditorFn) (*GetCreditResponse, error)

	// GetInvoicesWithResponse request
	GetInvoicesWithResponse(ctx context.Context, params *GetInvoicesParams, reqEditors ...RequestEditorFn) (*GetInvoicesResponse, error)

	// GetInvoiceWithResponse request
	GetInvoiceWithResponse(ctx context.Context, invoiceId string, params *GetInvoiceParams, reqEditors ...RequestEditorFn) (*GetInvoiceResponse, error)

	// CreateInvoiceJobWithBodyWithResponse request with any body
	CreateInvoiceJobWithBodyWithResponse(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInvoiceJobResponse, error)

	CreateInvoiceJobWithResponse(ctx context.Context, invoiceId string, body CreateInvoiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInvoiceJobResponse, error)

	// GetBillingMethodsWithResponse request
	GetBillingMethodsWithResponse(ctx context.Context, params *GetBillingMethodsParams, reqEditors ...RequestEditorFn) (*GetBillingMethodsResponse, error)

	// CreateBillingMethodWithBodyWithResponse request with any body
	CreateBillingMethodWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBillingMethodResponse, error)

	CreateBillingMethodWithResponse(ctx context.Context, body CreateBillingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBillingMethodResponse, error)

	// DeleteBillingMethodWithResponse request
	DeleteBillingMethodWithResponse(ctx context.Context, methodId string, reqEditors ...RequestEditorFn) (*DeleteBillingMethodResponse, error)

	// GetBillingMethodWithResponse request
	GetBillingMethodWithResponse(ctx context.Context, methodId string, reqEditors ...RequestEditorFn) (*GetBillingMethodResponse, error)

	// UpdateBillingMethodWithBodyWithResponse request with any body
	UpdateBillingMethodWithBodyWithResponse(ctx context.Context, methodId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBillingMethodResponse, error)

	UpdateBillingMethodWithResponse(ctx context.Context, methodId string, body UpdateBillingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBillingMethodResponse, error)

	// CreateBillingMethodJobWithBodyWithResponse request with any body
	CreateBillingMethodJobWithBodyWithResponse(ctx context.Context, methodId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBillingMethodJobResponse, error)

	CreateBillingMethodJobWithResponse(ctx context.Context, methodId string, body CreateBillingMethodJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBillingMethodJobResponse, error)

	// GetOrdersWithResponse request
	GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*GetOrdersResponse, error)

	// CreateOrderWithBodyWithResponse request with any body
	CreateOrderWithBodyWithResponse(ctx context.Context, params *CreateOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrderResponse, error)

	CreateOrderWithResponse(ctx context.Context, params *CreateOrderParams, body CreateOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrderResponse, error)

	// GetBillingOrderWithResponse request
	GetBillingOrderWithResponse(ctx context.Context, orderId string, params *GetBillingOrderParams, reqEditors ...RequestEditorFn) (*GetBillingOrderResponse, error)

	// UpdateBillingOrderWithBodyWithResponse request with any body
	UpdateBillingOrderWithBodyWithResponse(ctx context.Context, orderId string, params *UpdateBillingOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBillingOrderResponse, error)

	UpdateBillingOrderWithResponse(ctx context.Context, orderId string, params *UpdateBillingOrderParams, body UpdateBillingOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBillingOrderResponse, error)

	// CreateOrderJobWithBodyWithResponse request with any body
	CreateOrderJobWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrderJobResponse, error)

	CreateOrderJobWithResponse(ctx context.Context, orderId string, body CreateOrderJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrderJobResponse, error)

	// GetBillingSupportPlansWithResponse request
	GetBillingSupportPlansWithResponse(ctx context.Context, params *GetBillingSupportPlansParams, reqEditors ...RequestEditorFn) (*GetBillingSupportPlansResponse, error)

	// GetBillingTiersWithResponse request
	GetBillingTiersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBillingTiersResponse, error)

	// GetBillingServicesWithResponse request
	GetBillingServicesWithResponse(ctx context.Context, params *GetBillingServicesParams, reqEditors ...RequestEditorFn) (*GetBillingServicesResponse, error)

	// GetBillingOveragesWithResponse request
	GetBillingOveragesWithResponse(ctx context.Context, params *GetBillingOveragesParams, reqEditors ...RequestEditorFn) (*GetBillingOveragesResponse, error)

	// GetBillingServiceWithResponse request
	GetBillingServiceWithResponse(ctx context.Context, servicesId string, reqEditors ...RequestEditorFn) (*GetBillingServiceResponse, error)

	// GetBillingStatusWithResponse request
	GetBillingStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBillingStatusResponse, error)

	// GetChangelogWithResponse request
	GetChangelogWithResponse(ctx context.Context, params *GetChangelogParams, reqEditors ...RequestEditorFn) (*GetChangelogResponse, error)

	// GetContainersWithResponse request
	GetContainersWithResponse(ctx context.Context, params *GetContainersParams, reqEditors ...RequestEditorFn) (*GetContainersResponse, error)

	// CreateContainerWithBodyWithResponse request with any body
	CreateContainerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContainerResponse, error)

	CreateContainerWithResponse(ctx context.Context, body CreateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContainerResponse, error)

	// DeleteContainerWithResponse request
	DeleteContainerWithResponse(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*DeleteContainerResponse, error)

	// GetContainerWithResponse request
	GetContainerWithResponse(ctx context.Context, containerId string, params *GetContainerParams, reqEditors ...RequestEditorFn) (*GetContainerResponse, error)

	// UpdateContainerWithBodyWithResponse request with any body
	UpdateContainerWithBodyWithResponse(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContainerResponse, error)

	UpdateContainerWithResponse(ctx context.Context, containerId string, body UpdateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContainerResponse, error)

	// GetContainerBackupsWithResponse request
	GetContainerBackupsWithResponse(ctx context.Context, containerId string, params *GetContainerBackupsParams, reqEditors ...RequestEditorFn) (*GetContainerBackupsResponse, error)

	// DeleteContainerBackupWithResponse request
	DeleteContainerBackupWithResponse(ctx context.Context, containerId string, backupId string, reqEditors ...RequestEditorFn) (*DeleteContainerBackupResponse, error)

	// GetContainerBackupWithResponse request
	GetContainerBackupWithResponse(ctx context.Context, containerId string, backupId string, params *GetContainerBackupParams, reqEditors ...RequestEditorFn) (*GetContainerBackupResponse, error)

	// GetContainerBackupLogsWithResponse request
	GetContainerBackupLogsWithResponse(ctx context.Context, containerId string, backupId string, reqEditors ...RequestEditorFn) (*GetContainerBackupLogsResponse, error)

	// CreateContainerBackupJobWithBodyWithResponse request with any body
	CreateContainerBackupJobWithBodyWithResponse(ctx context.Context, containerId string, backupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContainerBackupJobResponse, error)

	CreateContainerBackupJobWithResponse(ctx context.Context, containerId string, backupId string, body CreateContainerBackupJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContainerBackupJobResponse, error)

	// GetCompatibleImagesWithResponse request
	GetCompatibleImagesWithResponse(ctx context.Context, containerId string, params *GetCompatibleImagesParams, reqEditors ...RequestEditorFn) (*GetCompatibleImagesResponse, error)

	// CreateFunctionJobWithBodyWithResponse request with any body
	CreateFunctionJobWithBodyWithResponse(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFunctionJobResponse, error)

	CreateFunctionJobWithResponse(ctx context.Context, containerId string, body CreateFunctionJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFunctionJobResponse, error)

	// DeleteContainerInstancesWithResponse request
	DeleteContainerInstancesWithResponse(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*DeleteContainerInstancesResponse, error)

	// GetInstancesWithResponse request
	GetInstancesWithResponse(ctx context.Context, containerId string, params *GetInstancesParams, reqEditors ...RequestEditorFn) (*GetInstancesResponse, error)

	// CreateInstancesWithBodyWithResponse request with any body
	CreateInstancesWithBodyWithResponse(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInstancesResponse, error)

	CreateInstancesWithResponse(ctx context.Context, containerId string, body CreateInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInstancesResponse, error)

	// DeleteInstanceWithResponse request
	DeleteInstanceWithResponse(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*DeleteInstanceResponse, error)

	// GetInstanceWithResponse request
	GetInstanceWithResponse(ctx context.Context, containerId string, instanceId string, params *GetInstanceParams, reqEditors ...RequestEditorFn) (*GetInstanceResponse, error)

	// GetInstanceConsoleStreamAuthWithResponse request
	GetInstanceConsoleStreamAuthWithResponse(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*GetInstanceConsoleStreamAuthResponse, error)

	// ExpireInstanceSSHCredentialsWithResponse request
	ExpireInstanceSSHCredentialsWithResponse(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*ExpireInstanceSSHCredentialsResponse, error)

	// GenerateInstanceSSHCredentialsWithResponse request
	GenerateInstanceSSHCredentialsWithResponse(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*GenerateInstanceSSHCredentialsResponse, error)

	// CreateInstanceJobWithBodyWithResponse request with any body
	CreateInstanceJobWithBodyWithResponse(ctx context.Context, containerId string, instanceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInstanceJobResponse, error)

	CreateInstanceJobWithResponse(ctx context.Context, containerId string, instanceId string, body CreateInstanceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInstanceJobResponse, error)

	// GetInstanceTelemetryReportWithResponse request
	GetInstanceTelemetryReportWithResponse(ctx context.Context, containerId string, instanceId string, params *GetInstanceTelemetryReportParams, reqEditors ...RequestEditorFn) (*GetInstanceTelemetryReportResponse, error)

	// GetInstanceTelemetryStreamAuthWithResponse request
	GetInstanceTelemetryStreamAuthWithResponse(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*GetInstanceTelemetryStreamAuthResponse, error)

	// GetInstanceVolumesWithResponse request
	GetInstanceVolumesWithResponse(ctx context.Context, containerId string, instanceId string, params *GetInstanceVolumesParams, reqEditors ...RequestEditorFn) (*GetInstanceVolumesResponse, error)

	// GetContainerServersWithResponse request
	GetContainerServersWithResponse(ctx context.Context, containerId string, params *GetContainerServersParams, reqEditors ...RequestEditorFn) (*GetContainerServersResponse, error)

	// GetCompatibleServersWithResponse request
	GetCompatibleServersWithResponse(ctx context.Context, containerId string, params *GetCompatibleServersParams, reqEditors ...RequestEditorFn) (*GetCompatibleServersResponse, error)

	// GetContainerSummaryWithResponse request
	GetContainerSummaryWithResponse(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*GetContainerSummaryResponse, error)

	// CreateContainerJobWithBodyWithResponse request with any body
	CreateContainerJobWithBodyWithResponse(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContainerJobResponse, error)

	CreateContainerJobWithResponse(ctx context.Context, containerId string, body CreateContainerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContainerJobResponse, error)

	// GetTLSGenerationAttemptsWithResponse request
	GetTLSGenerationAttemptsWithResponse(ctx context.Context, params *GetTLSGenerationAttemptsParams, reqEditors ...RequestEditorFn) (*GetTLSGenerationAttemptsResponse, error)

	// LookupTLSCertificateWithResponse request
	LookupTLSCertificateWithResponse(ctx context.Context, params *LookupTLSCertificateParams, reqEditors ...RequestEditorFn) (*LookupTLSCertificateResponse, error)

	// GetUserSuppliedCertificatesWithResponse request
	GetUserSuppliedCertificatesWithResponse(ctx context.Context, params *GetUserSuppliedCertificatesParams, reqEditors ...RequestEditorFn) (*GetUserSuppliedCertificatesResponse, error)

	// UploadUserSuppliedCertificateWithBodyWithResponse request with any body
	UploadUserSuppliedCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadUserSuppliedCertificateResponse, error)

	UploadUserSuppliedCertificateWithResponse(ctx context.Context, body UploadUserSuppliedCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadUserSuppliedCertificateResponse, error)

	// GetUserSuppliedCertificateWithResponse request
	GetUserSuppliedCertificateWithResponse(ctx context.Context, certificateId string, reqEditors ...RequestEditorFn) (*GetUserSuppliedCertificateResponse, error)

	// CreateUserSuppliedCertificateJobWithBodyWithResponse request with any body
	CreateUserSuppliedCertificateJobWithBodyWithResponse(ctx context.Context, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserSuppliedCertificateJobResponse, error)

	CreateUserSuppliedCertificateJobWithResponse(ctx context.Context, certificateId string, body CreateUserSuppliedCertificateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserSuppliedCertificateJobResponse, error)

	// GetDNSZonesWithResponse request
	GetDNSZonesWithResponse(ctx context.Context, params *GetDNSZonesParams, reqEditors ...RequestEditorFn) (*GetDNSZonesResponse, error)

	// CreateDNSZoneWithBodyWithResponse request with any body
	CreateDNSZoneWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNSZoneResponse, error)

	CreateDNSZoneWithResponse(ctx context.Context, body CreateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNSZoneResponse, error)

	// DeleteDNSZoneWithResponse request
	DeleteDNSZoneWithResponse(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*DeleteDNSZoneResponse, error)

	// GetDNSZoneWithResponse request
	GetDNSZoneWithResponse(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*GetDNSZoneResponse, error)

	// UpdateDNSZoneWithBodyWithResponse request with any body
	UpdateDNSZoneWithBodyWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNSZoneResponse, error)

	UpdateDNSZoneWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, body UpdateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNSZoneResponse, error)

	// UpdateDNSZoneAccessWithBodyWithResponse request with any body
	UpdateDNSZoneAccessWithBodyWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNSZoneAccessResponse, error)

	UpdateDNSZoneAccessWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, body UpdateDNSZoneAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNSZoneAccessResponse, error)

	// GetDNSZoneRecordsWithResponse request
	GetDNSZoneRecordsWithResponse(ctx context.Context, zoneId string, params *GetDNSZoneRecordsParams, reqEditors ...RequestEditorFn) (*GetDNSZoneRecordsResponse, error)

	// CreateDNSZoneRecordWithBodyWithResponse request with any body
	CreateDNSZoneRecordWithBodyWithResponse(ctx context.Context, zoneId string, params *CreateDNSZoneRecordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNSZoneRecordResponse, error)

	CreateDNSZoneRecordWithResponse(ctx context.Context, zoneId string, params *CreateDNSZoneRecordParams, body CreateDNSZoneRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNSZoneRecordResponse, error)

	// DeleteDNSZoneRecordWithResponse request
	DeleteDNSZoneRecordWithResponse(ctx context.Context, zoneId string, recordId string, reqEditors ...RequestEditorFn) (*DeleteDNSZoneRecordResponse, error)

	// UpdateDNSZoneRecordWithBodyWithResponse request with any body
	UpdateDNSZoneRecordWithBodyWithResponse(ctx context.Context, zoneId string, recordId string, params *UpdateDNSZoneRecordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNSZoneRecordResponse, error)

	UpdateDNSZoneRecordWithResponse(ctx context.Context, zoneId string, recordId string, params *UpdateDNSZoneRecordParams, body UpdateDNSZoneRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNSZoneRecordResponse, error)

	// CreateDNSZoneRecordJobWithBodyWithResponse request with any body
	CreateDNSZoneRecordJobWithBodyWithResponse(ctx context.Context, zoneId string, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNSZoneRecordJobResponse, error)

	CreateDNSZoneRecordJobWithResponse(ctx context.Context, zoneId string, recordId string, body CreateDNSZoneRecordJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNSZoneRecordJobResponse, error)

	// CreateDNSZoneJobWithBodyWithResponse request with any body
	CreateDNSZoneJobWithBodyWithResponse(ctx context.Context, zoneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNSZoneJobResponse, error)

	CreateDNSZoneJobWithResponse(ctx context.Context, zoneId string, body CreateDNSZoneJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNSZoneJobResponse, error)

	// GetEnvironmentsWithResponse request
	GetEnvironmentsWithResponse(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*GetEnvironmentsResponse, error)

	// CreateEnvironmentWithBodyWithResponse request with any body
	CreateEnvironmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvironmentResponse, error)

	CreateEnvironmentWithResponse(ctx context.Context, body CreateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvironmentResponse, error)

	// DeleteEnvironmentWithResponse request
	DeleteEnvironmentWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*DeleteEnvironmentResponse, error)

	// GetEnvironmentWithResponse request
	GetEnvironmentWithResponse(ctx context.Context, environmentId string, params *GetEnvironmentParams, reqEditors ...RequestEditorFn) (*GetEnvironmentResponse, error)

	// UpdateEnvironmentWithBodyWithResponse request with any body
	UpdateEnvironmentWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvironmentResponse, error)

	UpdateEnvironmentWithResponse(ctx context.Context, environmentId string, body UpdateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvironmentResponse, error)

	// UpdateEnvironmentAccessWithBodyWithResponse request with any body
	UpdateEnvironmentAccessWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvironmentAccessResponse, error)

	UpdateEnvironmentAccessWithResponse(ctx context.Context, environmentId string, body UpdateEnvironmentAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvironmentAccessResponse, error)

	// GetEnvironmentDeploymentsWithResponse request
	GetEnvironmentDeploymentsWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*GetEnvironmentDeploymentsResponse, error)

	// ExportStackWithBodyWithResponse request with any body
	ExportStackWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportStackResponse, error)

	ExportStackWithResponse(ctx context.Context, environmentId string, body ExportStackJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportStackResponse, error)

	// GetScopedVariablesWithResponse request
	GetScopedVariablesWithResponse(ctx context.Context, environmentId string, params *GetScopedVariablesParams, reqEditors ...RequestEditorFn) (*GetScopedVariablesResponse, error)

	// CreateScopedVariableWithBodyWithResponse request with any body
	CreateScopedVariableWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScopedVariableResponse, error)

	CreateScopedVariableWithResponse(ctx context.Context, environmentId string, body CreateScopedVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScopedVariableResponse, error)

	// DeleteScopedVariableWithResponse request
	DeleteScopedVariableWithResponse(ctx context.Context, environmentId string, scopedVariableId string, reqEditors ...RequestEditorFn) (*DeleteScopedVariableResponse, error)

	// GetScopedVariableWithResponse request
	GetScopedVariableWithResponse(ctx context.Context, environmentId string, scopedVariableId string, reqEditors ...RequestEditorFn) (*GetScopedVariableResponse, error)

	// UpdateScopedVariableWithBodyWithResponse request with any body
	UpdateScopedVariableWithBodyWithResponse(ctx context.Context, environmentId string, scopedVariableId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScopedVariableResponse, error)

	UpdateScopedVariableWithResponse(ctx context.Context, environmentId string, scopedVariableId string, body UpdateScopedVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScopedVariableResponse, error)

	// CreateDiscoveryServiceJobWithBodyWithResponse request with any body
	CreateDiscoveryServiceJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDiscoveryServiceJobResponse, error)

	CreateDiscoveryServiceJobWithResponse(ctx context.Context, environmentId string, body CreateDiscoveryServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDiscoveryServiceJobResponse, error)

	// CreateGatewayServiceJobWithBodyWithResponse request with any body
	CreateGatewayServiceJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGatewayServiceJobResponse, error)

	CreateGatewayServiceJobWithResponse(ctx context.Context, environmentId string, body CreateGatewayServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGatewayServiceJobResponse, error)

	// GetLoadBalancerServiceWithResponse request
	GetLoadBalancerServiceWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*GetLoadBalancerServiceResponse, error)

	// CreateLoadBalancerServiceJobWithBodyWithResponse request with any body
	CreateLoadBalancerServiceJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerServiceJobResponse, error)

	CreateLoadBalancerServiceJobWithResponse(ctx context.Context, environmentId string, body CreateLoadBalancerServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerServiceJobResponse, error)

	// GetLoadBalancerLatestTelemetryReportWithResponse request
	GetLoadBalancerLatestTelemetryReportWithResponse(ctx context.Context, environmentId string, params *GetLoadBalancerLatestTelemetryReportParams, reqEditors ...RequestEditorFn) (*GetLoadBalancerLatestTelemetryReportResponse, error)

	// GetLoadBalancerTelemetryLatestControllersWithResponse request
	GetLoadBalancerTelemetryLatestControllersWithResponse(ctx context.Context, environmentId string, params *GetLoadBalancerTelemetryLatestControllersParams, reqEditors ...RequestEditorFn) (*GetLoadBalancerTelemetryLatestControllersResponse, error)

	// GetLoadBalancerTelemetryReportWithResponse request
	GetLoadBalancerTelemetryReportWithResponse(ctx context.Context, environmentId string, params *GetLoadBalancerTelemetryReportParams, reqEditors ...RequestEditorFn) (*GetLoadBalancerTelemetryReportResponse, error)

	// CreateSchedulerServiceJobWithBodyWithResponse request with any body
	CreateSchedulerServiceJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSchedulerServiceJobResponse, error)

	CreateSchedulerServiceJobWithResponse(ctx context.Context, environmentId string, body CreateSchedulerServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSchedulerServiceJobResponse, error)

	// GetVPNServiceWithResponse request
	GetVPNServiceWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*GetVPNServiceResponse, error)

	// GetVPNLoginsWithResponse request
	GetVPNLoginsWithResponse(ctx context.Context, environmentId string, params *GetVPNLoginsParams, reqEditors ...RequestEditorFn) (*GetVPNLoginsResponse, error)

	// CreateVPNServiceJobWithBodyWithResponse request with any body
	CreateVPNServiceJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVPNServiceJobResponse, error)

	CreateVPNServiceJobWithResponse(ctx context.Context, environmentId string, body CreateVPNServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVPNServiceJobResponse, error)

	// GetVPNUsersWithResponse request
	GetVPNUsersWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*GetVPNUsersResponse, error)

	// CreateVPNUserWithBodyWithResponse request with any body
	CreateVPNUserWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVPNUserResponse, error)

	CreateVPNUserWithResponse(ctx context.Context, environmentId string, body CreateVPNUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVPNUserResponse, error)

	// DeleteVPNUserWithResponse request
	DeleteVPNUserWithResponse(ctx context.Context, environmentId string, userId string, reqEditors ...RequestEditorFn) (*DeleteVPNUserResponse, error)

	// GetEnvironmentSummaryWithResponse request
	GetEnvironmentSummaryWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*GetEnvironmentSummaryResponse, error)

	// CreateEnvironmentJobWithBodyWithResponse request with any body
	CreateEnvironmentJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvironmentJobResponse, error)

	CreateEnvironmentJobWithResponse(ctx context.Context, environmentId string, body CreateEnvironmentJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvironmentJobResponse, error)

	// GetHubsWithResponse request
	GetHubsWithResponse(ctx context.Context, params *GetHubsParams, reqEditors ...RequestEditorFn) (*GetHubsResponse, error)

	// CreateHubWithBodyWithResponse request with any body
	CreateHubWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHubResponse, error)

	CreateHubWithResponse(ctx context.Context, body CreateHubJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHubResponse, error)

	// GetHubCapabilitiesWithResponse request
	GetHubCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHubCapabilitiesResponse, error)

	// DeleteHubWithBodyWithResponse request with any body
	DeleteHubWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteHubResponse, error)

	DeleteHubWithResponse(ctx context.Context, body DeleteHubJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteHubResponse, error)

	// GetHubWithResponse request
	GetHubWithResponse(ctx context.Context, params *GetHubParams, reqEditors ...RequestEditorFn) (*GetHubResponse, error)

	// UpdateHubWithBodyWithResponse request with any body
	UpdateHubWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateHubResponse, error)

	UpdateHubWithResponse(ctx context.Context, body UpdateHubJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateHubResponse, error)

	// GetHubActivityWithResponse request
	GetHubActivityWithResponse(ctx context.Context, params *GetHubActivityParams, reqEditors ...RequestEditorFn) (*GetHubActivityResponse, error)

	// GetApiKeysWithResponse request
	GetApiKeysWithResponse(ctx context.Context, params *GetApiKeysParams, reqEditors ...RequestEditorFn) (*GetApiKeysResponse, error)

	// CreateApiKeyWithBodyWithResponse request with any body
	CreateApiKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error)

	CreateApiKeyWithResponse(ctx context.Context, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error)

	// DeleteAPIKeyWithResponse request
	DeleteAPIKeyWithResponse(ctx context.Context, apikeyId string, reqEditors ...RequestEditorFn) (*DeleteAPIKeyResponse, error)

	// GetAPIKeyWithResponse request
	GetAPIKeyWithResponse(ctx context.Context, apikeyId string, params *GetAPIKeyParams, reqEditors ...RequestEditorFn) (*GetAPIKeyResponse, error)

	// UpdateAPIKeyWithBodyWithResponse request with any body
	UpdateAPIKeyWithBodyWithResponse(ctx context.Context, apikeyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAPIKeyResponse, error)

	UpdateAPIKeyWithResponse(ctx context.Context, apikeyId string, body UpdateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAPIKeyResponse, error)

	// GetIntegrationsWithResponse request
	GetIntegrationsWithResponse(ctx context.Context, params *GetIntegrationsParams, reqEditors ...RequestEditorFn) (*GetIntegrationsResponse, error)

	// CreateIntegrationWithBodyWithResponse request with any body
	CreateIntegrationWithBodyWithResponse(ctx context.Context, params *CreateIntegrationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationResponse, error)

	CreateIntegrationWithResponse(ctx context.Context, params *CreateIntegrationParams, body CreateIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationResponse, error)

	// GetAvailableIntegrationsWithResponse request
	GetAvailableIntegrationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAvailableIntegrationsResponse, error)

	// DeleteIntegrationWithResponse request
	DeleteIntegrationWithResponse(ctx context.Context, integrationId string, reqEditors ...RequestEditorFn) (*DeleteIntegrationResponse, error)

	// GetIntegrationWithResponse request
	GetIntegrationWithResponse(ctx context.Context, integrationId string, params *GetIntegrationParams, reqEditors ...RequestEditorFn) (*GetIntegrationResponse, error)

	// UpdateIntegrationWithBodyWithResponse request with any body
	UpdateIntegrationWithBodyWithResponse(ctx context.Context, integrationId string, params *UpdateIntegrationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIntegrationResponse, error)

	UpdateIntegrationWithResponse(ctx context.Context, integrationId string, params *UpdateIntegrationParams, body UpdateIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIntegrationResponse, error)

	// CreateIntegrationJobWithBodyWithResponse request with any body
	CreateIntegrationJobWithBodyWithResponse(ctx context.Context, integrationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationJobResponse, error)

	CreateIntegrationJobWithResponse(ctx context.Context, integrationId string, body CreateIntegrationJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationJobResponse, error)

	// GetHubInvitesWithResponse request
	GetHubInvitesWithResponse(ctx context.Context, params *GetHubInvitesParams, reqEditors ...RequestEditorFn) (*GetHubInvitesResponse, error)

	// CreateHubInviteWithBodyWithResponse request with any body
	CreateHubInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHubInviteResponse, error)

	CreateHubInviteWithResponse(ctx context.Context, body CreateHubInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHubInviteResponse, error)

	// DeleteHubInviteWithResponse request
	DeleteHubInviteWithResponse(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*DeleteHubInviteResponse, error)

	// GetHubMembersWithResponse request
	GetHubMembersWithResponse(ctx context.Context, params *GetHubMembersParams, reqEditors ...RequestEditorFn) (*GetHubMembersResponse, error)

	// GetHubMemberAccountWithResponse request
	GetHubMemberAccountWithResponse(ctx context.Context, accountId string, params *GetHubMemberAccountParams, reqEditors ...RequestEditorFn) (*GetHubMemberAccountResponse, error)

	// DeleteHubMemberWithResponse request
	DeleteHubMemberWithResponse(ctx context.Context, memberId string, reqEditors ...RequestEditorFn) (*DeleteHubMemberResponse, error)

	// GetHubMemberWithResponse request
	GetHubMemberWithResponse(ctx context.Context, memberId string, params *GetHubMemberParams, reqEditors ...RequestEditorFn) (*GetHubMemberResponse, error)

	// UpdateHubMemberWithBodyWithResponse request with any body
	UpdateHubMemberWithBodyWithResponse(ctx context.Context, memberId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateHubMemberResponse, error)

	UpdateHubMemberWithResponse(ctx context.Context, memberId string, body UpdateHubMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateHubMemberResponse, error)

	// GetHubMembershipWithResponse request
	GetHubMembershipWithResponse(ctx context.Context, params *GetHubMembershipParams, reqEditors ...RequestEditorFn) (*GetHubMembershipResponse, error)

	// GetHubNotificationSocketAuthWithResponse request
	GetHubNotificationSocketAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHubNotificationSocketAuthResponse, error)

	// GetRolesWithResponse request
	GetRolesWithResponse(ctx context.Context, params *GetRolesParams, reqEditors ...RequestEditorFn) (*GetRolesResponse, error)

	// CreateRoleWithBodyWithResponse request with any body
	CreateRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	CreateRoleWithResponse(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error)

	// GetDefaultHubRolesWithResponse request
	GetDefaultHubRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultHubRolesResponse, error)

	// DeleteRoleWithResponse request
	DeleteRoleWithResponse(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error)

	// GetRoleWithResponse request
	GetRoleWithResponse(ctx context.Context, roleId string, params *GetRoleParams, reqEditors ...RequestEditorFn) (*GetRoleResponse, error)

	// UpdateRoleWithBodyWithResponse request with any body
	UpdateRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	UpdateRoleWithResponse(ctx context.Context, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error)

	// GetHubUsageWithResponse request
	GetHubUsageWithResponse(ctx context.Context, params *GetHubUsageParams, reqEditors ...RequestEditorFn) (*GetHubUsageResponse, error)

	// GetImagesWithResponse request
	GetImagesWithResponse(ctx context.Context, params *GetImagesParams, reqEditors ...RequestEditorFn) (*GetImagesResponse, error)

	// CreateImageWithBodyWithResponse request with any body
	CreateImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageResponse, error)

	CreateImageWithResponse(ctx context.Context, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageResponse, error)

	// GetImageSourcesWithResponse request
	GetImageSourcesWithResponse(ctx context.Context, params *GetImageSourcesParams, reqEditors ...RequestEditorFn) (*GetImageSourcesResponse, error)

	// CreateImageSourceWithBodyWithResponse request with any body
	CreateImageSourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageSourceResponse, error)

	CreateImageSourceWithResponse(ctx context.Context, body CreateImageSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageSourceResponse, error)

	// DeleteImageSourceWithResponse request
	DeleteImageSourceWithResponse(ctx context.Context, sourceId string, reqEditors ...RequestEditorFn) (*DeleteImageSourceResponse, error)

	// GetImageSourceWithResponse request
	GetImageSourceWithResponse(ctx context.Context, sourceId string, params *GetImageSourceParams, reqEditors ...RequestEditorFn) (*GetImageSourceResponse, error)

	// UpdateImageSourceWithBodyWithResponse request with any body
	UpdateImageSourceWithBodyWithResponse(ctx context.Context, sourceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageSourceResponse, error)

	UpdateImageSourceWithResponse(ctx context.Context, sourceId string, body UpdateImageSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageSourceResponse, error)

	// UpdateImageSourceAccessWithBodyWithResponse request with any body
	UpdateImageSourceAccessWithBodyWithResponse(ctx context.Context, sourceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageSourceAccessResponse, error)

	UpdateImageSourceAccessWithResponse(ctx context.Context, sourceId string, body UpdateImageSourceAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageSourceAccessResponse, error)

	// CreateImagesJobWithBodyWithResponse request with any body
	CreateImagesJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImagesJobResponse, error)

	CreateImagesJobWithResponse(ctx context.Context, body CreateImagesJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImagesJobResponse, error)

	// DeleteImageWithResponse request
	DeleteImageWithResponse(ctx context.Context, imageId string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error)

	// GetImageWithResponse request
	GetImageWithResponse(ctx context.Context, imageId string, params *GetImageParams, reqEditors ...RequestEditorFn) (*GetImageResponse, error)

	// UpdateImageWithBodyWithResponse request with any body
	UpdateImageWithBodyWithResponse(ctx context.Context, imageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error)

	UpdateImageWithResponse(ctx context.Context, imageId string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error)

	// GetImageBuildLogWithResponse request
	GetImageBuildLogWithResponse(ctx context.Context, imageId string, reqEditors ...RequestEditorFn) (*GetImageBuildLogResponse, error)

	// CreateImageJobWithBodyWithResponse request with any body
	CreateImageJobWithBodyWithResponse(ctx context.Context, imageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageJobResponse, error)

	CreateImageJobWithResponse(ctx context.Context, imageId string, body CreateImageJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageJobResponse, error)

	// GetAutoScaleGroupsWithResponse request
	GetAutoScaleGroupsWithResponse(ctx context.Context, params *GetAutoScaleGroupsParams, reqEditors ...RequestEditorFn) (*GetAutoScaleGroupsResponse, error)

	// CreateAutoScaleGroupWithBodyWithResponse request with any body
	CreateAutoScaleGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAutoScaleGroupResponse, error)

	CreateAutoScaleGroupWithResponse(ctx context.Context, body CreateAutoScaleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAutoScaleGroupResponse, error)

	// DeleteAutoScaleGroupWithResponse request
	DeleteAutoScaleGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteAutoScaleGroupResponse, error)

	// GetAutoScaleGroupWithResponse request
	GetAutoScaleGroupWithResponse(ctx context.Context, groupId string, params *GetAutoScaleGroupParams, reqEditors ...RequestEditorFn) (*GetAutoScaleGroupResponse, error)

	// UpdateAutoScaleGroupWithBodyWithResponse request with any body
	UpdateAutoScaleGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutoScaleGroupResponse, error)

	UpdateAutoScaleGroupWithResponse(ctx context.Context, groupId string, body UpdateAutoScaleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutoScaleGroupResponse, error)

	// UpdateAutoScaleGroupAccessWithBodyWithResponse request with any body
	UpdateAutoScaleGroupAccessWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutoScaleGroupAccessResponse, error)

	UpdateAutoScaleGroupAccessWithResponse(ctx context.Context, groupId string, body UpdateAutoScaleGroupAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutoScaleGroupAccessResponse, error)

	// GetClustersWithResponse request
	GetClustersWithResponse(ctx context.Context, params *GetClustersParams, reqEditors ...RequestEditorFn) (*GetClustersResponse, error)

	// CreateClusterWithBodyWithResponse request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateClusterWithBodyWithResponse request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	UpdateClusterWithResponse(ctx context.Context, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// UpdateClusterAccessWithBodyWithResponse request with any body
	UpdateClusterAccessWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterAccessResponse, error)

	UpdateClusterAccessWithResponse(ctx context.Context, clusterId string, body UpdateClusterAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterAccessResponse, error)

	// CreateClusterJobWithBodyWithResponse request with any body
	CreateClusterJobWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterJobResponse, error)

	CreateClusterJobWithResponse(ctx context.Context, clusterId string, body CreateClusterJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterJobResponse, error)

	// GetDeploymentStrategiesWithResponse request
	GetDeploymentStrategiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDeploymentStrategiesResponse, error)

	// GetExternalVolumesWithResponse request
	GetExternalVolumesWithResponse(ctx context.Context, params *GetExternalVolumesParams, reqEditors ...RequestEditorFn) (*GetExternalVolumesResponse, error)

	// CreateExternalVolumeWithBodyWithResponse request with any body
	CreateExternalVolumeWithBodyWithResponse(ctx context.Context, params *CreateExternalVolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExternalVolumeResponse, error)

	CreateExternalVolumeWithResponse(ctx context.Context, params *CreateExternalVolumeParams, body CreateExternalVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExternalVolumeResponse, error)

	// GetExternalVolumeSourcesWithResponse request
	GetExternalVolumeSourcesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetExternalVolumeSourcesResponse, error)

	// DeleteExternalVolumeWithBodyWithResponse request with any body
	DeleteExternalVolumeWithBodyWithResponse(ctx context.Context, externalVolumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteExternalVolumeResponse, error)

	DeleteExternalVolumeWithResponse(ctx context.Context, externalVolumeId string, body DeleteExternalVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteExternalVolumeResponse, error)

	// GetExternalVolumeWithResponse request
	GetExternalVolumeWithResponse(ctx context.Context, externalVolumeId string, params *GetExternalVolumeParams, reqEditors ...RequestEditorFn) (*GetExternalVolumeResponse, error)

	// UpdateExternalVolumeWithBodyWithResponse request with any body
	UpdateExternalVolumeWithBodyWithResponse(ctx context.Context, externalVolumeId string, params *UpdateExternalVolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExternalVolumeResponse, error)

	UpdateExternalVolumeWithResponse(ctx context.Context, externalVolumeId string, params *UpdateExternalVolumeParams, body UpdateExternalVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExternalVolumeResponse, error)

	// UpdateExternalVolumeAccessWithBodyWithResponse request with any body
	UpdateExternalVolumeAccessWithBodyWithResponse(ctx context.Context, externalVolumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExternalVolumeAccessResponse, error)

	UpdateExternalVolumeAccessWithResponse(ctx context.Context, externalVolumeId string, body UpdateExternalVolumeAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExternalVolumeAccessResponse, error)

	// CreateExternalVolumeJobWithBodyWithResponse request with any body
	CreateExternalVolumeJobWithBodyWithResponse(ctx context.Context, externalVolumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExternalVolumeJobResponse, error)

	CreateExternalVolumeJobWithResponse(ctx context.Context, externalVolumeId string, body CreateExternalVolumeJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExternalVolumeJobResponse, error)

	// GetIpPoolsWithResponse request
	GetIpPoolsWithResponse(ctx context.Context, params *GetIpPoolsParams, reqEditors ...RequestEditorFn) (*GetIpPoolsResponse, error)

	// CreateIpPoolWithBodyWithResponse request with any body
	CreateIpPoolWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIpPoolResponse, error)

	CreateIpPoolWithResponse(ctx context.Context, body CreateIpPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIpPoolResponse, error)

	// DeleteIPPoolWithResponse request
	DeleteIPPoolWithResponse(ctx context.Context, poolId string, reqEditors ...RequestEditorFn) (*DeleteIPPoolResponse, error)

	// GetIPPoolWithResponse request
	GetIPPoolWithResponse(ctx context.Context, poolId string, params *GetIPPoolParams, reqEditors ...RequestEditorFn) (*GetIPPoolResponse, error)

	// GetPoolIPsWithResponse request
	GetPoolIPsWithResponse(ctx context.Context, poolId string, reqEditors ...RequestEditorFn) (*GetPoolIPsResponse, error)

	// CreateIpPoolJobWithBodyWithResponse request with any body
	CreateIpPoolJobWithBodyWithResponse(ctx context.Context, poolId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIpPoolJobResponse, error)

	CreateIpPoolJobWithResponse(ctx context.Context, poolId string, body CreateIpPoolJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIpPoolJobResponse, error)

	// GetClusterMonitoringTiersWithResponse request
	GetClusterMonitoringTiersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterMonitoringTiersResponse, error)

	// GetProviderLocationsWithResponse request
	GetProviderLocationsWithResponse(ctx context.Context, providerVendor string, params *GetProviderLocationsParams, reqEditors ...RequestEditorFn) (*GetProviderLocationsResponse, error)

	// GetProviderServersWithResponse request
	GetProviderServersWithResponse(ctx context.Context, providerVendor string, params *GetProviderServersParams, reqEditors ...RequestEditorFn) (*GetProviderServersResponse, error)

	// GetServersWithResponse request
	GetServersWithResponse(ctx context.Context, params *GetServersParams, reqEditors ...RequestEditorFn) (*GetServersResponse, error)

	// CreateServerWithBodyWithResponse request with any body
	CreateServerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerResponse, error)

	CreateServerWithResponse(ctx context.Context, body CreateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerResponse, error)

	// GetServerTagsWithResponse request
	GetServerTagsWithResponse(ctx context.Context, params *GetServerTagsParams, reqEditors ...RequestEditorFn) (*GetServerTagsResponse, error)

	// DeleteServerWithBodyWithResponse request with any body
	DeleteServerWithBodyWithResponse(ctx context.Context, serverId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteServerResponse, error)

	DeleteServerWithResponse(ctx context.Context, serverId string, body DeleteServerJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteServerResponse, error)

	// GetServerWithResponse request
	GetServerWithResponse(ctx context.Context, serverId string, params *GetServerParams, reqEditors ...RequestEditorFn) (*GetServerResponse, error)

	// UpdateServerWithBodyWithResponse request with any body
	UpdateServerWithBodyWithResponse(ctx context.Context, serverId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServerResponse, error)

	UpdateServerWithResponse(ctx context.Context, serverId string, body UpdateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServerResponse, error)

	// GetServerConsoleWithResponse request
	GetServerConsoleWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetServerConsoleResponse, error)

	// GetServerInstancesWithResponse request
	GetServerInstancesWithResponse(ctx context.Context, serverId string, params *GetServerInstancesParams, reqEditors ...RequestEditorFn) (*GetServerInstancesResponse, error)

	// CreateServerJobWithBodyWithResponse request with any body
	CreateServerJobWithBodyWithResponse(ctx context.Context, serverId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerJobResponse, error)

	CreateServerJobWithResponse(ctx context.Context, serverId string, body CreateServerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerJobResponse, error)

	// GetServerTelemetryWithResponse request
	GetServerTelemetryWithResponse(ctx context.Context, serverId string, params *GetServerTelemetryParams, reqEditors ...RequestEditorFn) (*GetServerTelemetryResponse, error)

	// GetServerUsageWithResponse request
	GetServerUsageWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetServerUsageResponse, error)

	// GetInfrastructureSummaryWithResponse request
	GetInfrastructureSummaryWithResponse(ctx context.Context, params *GetInfrastructureSummaryParams, reqEditors ...RequestEditorFn) (*GetInfrastructureSummaryResponse, error)

	// GetVirtualProviderIsosWithResponse request
	GetVirtualProviderIsosWithResponse(ctx context.Context, integrationId string, params *GetVirtualProviderIsosParams, reqEditors ...RequestEditorFn) (*GetVirtualProviderIsosResponse, error)

	// CreateVirtualProviderIsoWithBodyWithResponse request with any body
	CreateVirtualProviderIsoWithBodyWithResponse(ctx context.Context, integrationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualProviderIsoResponse, error)

	CreateVirtualProviderIsoWithResponse(ctx context.Context, integrationId string, body CreateVirtualProviderIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualProviderIsoResponse, error)

	// DeleteVirtualProviderIsoWithResponse request
	DeleteVirtualProviderIsoWithResponse(ctx context.Context, integrationId string, isoId string, reqEditors ...RequestEditorFn) (*DeleteVirtualProviderIsoResponse, error)

	// GetVirtualProviderIsoWithResponse request
	GetVirtualProviderIsoWithResponse(ctx context.Context, integrationId string, isoId string, params *GetVirtualProviderIsoParams, reqEditors ...RequestEditorFn) (*GetVirtualProviderIsoResponse, error)

	// UpdateVirtualProviderIsoWithBodyWithResponse request with any body
	UpdateVirtualProviderIsoWithBodyWithResponse(ctx context.Context, integrationId string, isoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVirtualProviderIsoResponse, error)

	UpdateVirtualProviderIsoWithResponse(ctx context.Context, integrationId string, isoId string, body UpdateVirtualProviderIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVirtualProviderIsoResponse, error)

	// GetVirtualProviderIsoDownloadUrlWithResponse request
	GetVirtualProviderIsoDownloadUrlWithResponse(ctx context.Context, integrationId string, isoId string, reqEditors ...RequestEditorFn) (*GetVirtualProviderIsoDownloadUrlResponse, error)

	// CreateVirtualProviderIsoJobWithBodyWithResponse request with any body
	CreateVirtualProviderIsoJobWithBodyWithResponse(ctx context.Context, integrationId string, isoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualProviderIsoJobResponse, error)

	CreateVirtualProviderIsoJobWithResponse(ctx context.Context, integrationId string, isoId string, body CreateVirtualProviderIsoJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualProviderIsoJobResponse, error)

	// GetJobsWithResponse request
	GetJobsWithResponse(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*GetJobsResponse, error)

	// GetLatestJobsWithResponse request
	GetLatestJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLatestJobsResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetJobResponse, error)

	// GetEventsWithResponse request
	GetEventsWithResponse(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*GetEventsResponse, error)

	// GenerateAggregatedEventsWithBodyWithResponse request with any body
	GenerateAggregatedEventsWithBodyWithResponse(ctx context.Context, params *GenerateAggregatedEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateAggregatedEventsResponse, error)

	GenerateAggregatedEventsWithResponse(ctx context.Context, params *GenerateAggregatedEventsParams, body GenerateAggregatedEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateAggregatedEventsResponse, error)

	// AggregateLogsWithBodyWithResponse request with any body
	AggregateLogsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AggregateLogsResponse, error)

	AggregateLogsWithResponse(ctx context.Context, body AggregateLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*AggregateLogsResponse, error)

	// GetMetricsWithResponse request
	GetMetricsWithResponse(ctx context.Context, params *GetMetricsParams, reqEditors ...RequestEditorFn) (*GetMetricsResponse, error)

	// GenerateAggregatedMetricsWithBodyWithResponse request with any body
	GenerateAggregatedMetricsWithBodyWithResponse(ctx context.Context, params *GenerateAggregatedMetricsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateAggregatedMetricsResponse, error)

	GenerateAggregatedMetricsWithResponse(ctx context.Context, params *GenerateAggregatedMetricsParams, body GenerateAggregatedMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateAggregatedMetricsResponse, error)

	// GetMonitoringMonitorsWithResponse request
	GetMonitoringMonitorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMonitoringMonitorsResponse, error)

	// GetPipelinesWithResponse request
	GetPipelinesWithResponse(ctx context.Context, params *GetPipelinesParams, reqEditors ...RequestEditorFn) (*GetPipelinesResponse, error)

	// CreatePipelineWithBodyWithResponse request with any body
	CreatePipelineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePipelineResponse, error)

	CreatePipelineWithResponse(ctx context.Context, body CreatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePipelineResponse, error)

	// ClonePipelineWithBodyWithResponse request with any body
	ClonePipelineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClonePipelineResponse, error)

	ClonePipelineWithResponse(ctx context.Context, body ClonePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*ClonePipelineResponse, error)

	// DeletePipelineWithResponse request
	DeletePipelineWithResponse(ctx context.Context, pipelineId string, reqEditors ...RequestEditorFn) (*DeletePipelineResponse, error)

	// GetPipelineWithResponse request
	GetPipelineWithResponse(ctx context.Context, pipelineId string, params *GetPipelineParams, reqEditors ...RequestEditorFn) (*GetPipelineResponse, error)

	// UpdatePipelineWithBodyWithResponse request with any body
	UpdatePipelineWithBodyWithResponse(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePipelineResponse, error)

	UpdatePipelineWithResponse(ctx context.Context, pipelineId string, body UpdatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePipelineResponse, error)

	// UpdatePipelineAccessWithBodyWithResponse request with any body
	UpdatePipelineAccessWithBodyWithResponse(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePipelineAccessResponse, error)

	UpdatePipelineAccessWithResponse(ctx context.Context, pipelineId string, body UpdatePipelineAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePipelineAccessResponse, error)

	// GetPipelineTriggerKeysWithResponse request
	GetPipelineTriggerKeysWithResponse(ctx context.Context, pipelineId string, params *GetPipelineTriggerKeysParams, reqEditors ...RequestEditorFn) (*GetPipelineTriggerKeysResponse, error)

	// CreatePipelineTriggerKeyWithBodyWithResponse request with any body
	CreatePipelineTriggerKeyWithBodyWithResponse(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePipelineTriggerKeyResponse, error)

	CreatePipelineTriggerKeyWithResponse(ctx context.Context, pipelineId string, body CreatePipelineTriggerKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePipelineTriggerKeyResponse, error)

	// DeletePipelineTriggerKeyWithResponse request
	DeletePipelineTriggerKeyWithResponse(ctx context.Context, pipelineId string, triggerKeyId string, reqEditors ...RequestEditorFn) (*DeletePipelineTriggerKeyResponse, error)

	// GetPipelineTriggerKeyWithResponse request
	GetPipelineTriggerKeyWithResponse(ctx context.Context, pipelineId string, triggerKeyId string, reqEditors ...RequestEditorFn) (*GetPipelineTriggerKeyResponse, error)

	// UpdatePipelineTriggerKeyWithBodyWithResponse request with any body
	UpdatePipelineTriggerKeyWithBodyWithResponse(ctx context.Context, pipelineId string, triggerKeyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePipelineTriggerKeyResponse, error)

	UpdatePipelineTriggerKeyWithResponse(ctx context.Context, pipelineId string, triggerKeyId string, body UpdatePipelineTriggerKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePipelineTriggerKeyResponse, error)

	// GetPipelineRunsWithResponse request
	GetPipelineRunsWithResponse(ctx context.Context, pipelineId string, params *GetPipelineRunsParams, reqEditors ...RequestEditorFn) (*GetPipelineRunsResponse, error)

	// GetPipelineRunWithResponse request
	GetPipelineRunWithResponse(ctx context.Context, pipelineId string, runId string, params *GetPipelineRunParams, reqEditors ...RequestEditorFn) (*GetPipelineRunResponse, error)

	// CreatePipelineJobWithBodyWithResponse request with any body
	CreatePipelineJobWithBodyWithResponse(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePipelineJobResponse, error)

	CreatePipelineJobWithResponse(ctx context.Context, pipelineId string, body CreatePipelineJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePipelineJobResponse, error)

	// TriggerPipelineWithBodyWithResponse request with any body
	TriggerPipelineWithBodyWithResponse(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerPipelineResponse, error)

	TriggerPipelineWithResponse(ctx context.Context, pipelineId string, body TriggerPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerPipelineResponse, error)

	// GetNetworksWithResponse request
	GetNetworksWithResponse(ctx context.Context, params *GetNetworksParams, reqEditors ...RequestEditorFn) (*GetNetworksResponse, error)

	// CreateNetworkWithBodyWithResponse request with any body
	CreateNetworkWithBodyWithResponse(ctx context.Context, params *CreateNetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNetworkResponse, error)

	CreateNetworkWithResponse(ctx context.Context, params *CreateNetworkParams, body CreateNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNetworkResponse, error)

	// DeleteNetworkWithResponse request
	DeleteNetworkWithResponse(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*DeleteNetworkResponse, error)

	// GetNetworkWithResponse request
	GetNetworkWithResponse(ctx context.Context, networkId string, params *GetNetworkParams, reqEditors ...RequestEditorFn) (*GetNetworkResponse, error)

	// UpdateNetworkWithBodyWithResponse request with any body
	UpdateNetworkWithBodyWithResponse(ctx context.Context, networkId string, params *UpdateNetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNetworkResponse, error)

	UpdateNetworkWithResponse(ctx context.Context, networkId string, params *UpdateNetworkParams, body UpdateNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNetworkResponse, error)

	// UpdateNetworkAccessWithBodyWithResponse request with any body
	UpdateNetworkAccessWithBodyWithResponse(ctx context.Context, networkId string, params *UpdateNetworkAccessParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNetworkAccessResponse, error)

	UpdateNetworkAccessWithResponse(ctx context.Context, networkId string, params *UpdateNetworkAccessParams, body UpdateNetworkAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNetworkAccessResponse, error)

	// CreateNetworkJobWithBodyWithResponse request with any body
	CreateNetworkJobWithBodyWithResponse(ctx context.Context, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNetworkJobResponse, error)

	CreateNetworkJobWithResponse(ctx context.Context, networkId string, body CreateNetworkJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNetworkJobResponse, error)

	// GetSearchIndexWithResponse request
	GetSearchIndexWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchIndexResponse, error)

	// GetStacksWithResponse request
	GetStacksWithResponse(ctx context.Context, params *GetStacksParams, reqEditors ...RequestEditorFn) (*GetStacksResponse, error)

	// CreateStackWithBodyWithResponse request with any body
	CreateStackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStackResponse, error)

	CreateStackWithResponse(ctx context.Context, body CreateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStackResponse, error)

	// LookupStackBuildWithResponse request
	LookupStackBuildWithResponse(ctx context.Context, buildId string, reqEditors ...RequestEditorFn) (*LookupStackBuildResponse, error)

	// DeleteStackWithResponse request
	DeleteStackWithResponse(ctx context.Context, stackId string, reqEditors ...RequestEditorFn) (*DeleteStackResponse, error)

	// GetStackWithResponse request
	GetStackWithResponse(ctx context.Context, stackId string, reqEditors ...RequestEditorFn) (*GetStackResponse, error)

	// UpdateStackWithBodyWithResponse request with any body
	UpdateStackWithBodyWithResponse(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStackResponse, error)

	UpdateStackWithResponse(ctx context.Context, stackId string, body UpdateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStackResponse, error)

	// UpdateStackAccessWithBodyWithResponse request with any body
	UpdateStackAccessWithBodyWithResponse(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStackAccessResponse, error)

	UpdateStackAccessWithResponse(ctx context.Context, stackId string, body UpdateStackAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStackAccessResponse, error)

	// GetStackBuildsWithResponse request
	GetStackBuildsWithResponse(ctx context.Context, stackId string, params *GetStackBuildsParams, reqEditors ...RequestEditorFn) (*GetStackBuildsResponse, error)

	// CreateStackBuildWithBodyWithResponse request with any body
	CreateStackBuildWithBodyWithResponse(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStackBuildResponse, error)

	CreateStackBuildWithResponse(ctx context.Context, stackId string, body CreateStackBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStackBuildResponse, error)

	// DeleteStackBuildWithResponse request
	DeleteStackBuildWithResponse(ctx context.Context, stackId string, buildId string, reqEditors ...RequestEditorFn) (*DeleteStackBuildResponse, error)

	// GetStackBuildWithResponse request
	GetStackBuildWithResponse(ctx context.Context, stackId string, buildId string, reqEditors ...RequestEditorFn) (*GetStackBuildResponse, error)

	// GetStackBuildLogWithResponse request
	GetStackBuildLogWithResponse(ctx context.Context, stackId string, buildId string, reqEditors ...RequestEditorFn) (*GetStackBuildLogResponse, error)

	// CreateStackBuildJobWithBodyWithResponse request with any body
	CreateStackBuildJobWithBodyWithResponse(ctx context.Context, stackId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStackBuildJobResponse, error)

	CreateStackBuildJobWithResponse(ctx context.Context, stackId string, buildId string, body CreateStackBuildJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStackBuildJobResponse, error)

	// CreateStackJobWithBodyWithResponse request with any body
	CreateStackJobWithBodyWithResponse(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStackJobResponse, error)

	CreateStackJobWithResponse(ctx context.Context, stackId string, body CreateStackJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStackJobResponse, error)

	// LookupComponentsWithBodyWithResponse request with any body
	LookupComponentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LookupComponentsResponse, error)

	LookupComponentsWithResponse(ctx context.Context, body LookupComponentsJSONRequestBody, reqEditors ...RequestEditorFn) (*LookupComponentsResponse, error)

	// LookupIdentifierWithResponse request
	LookupIdentifierWithResponse(ctx context.Context, params *LookupIdentifierParams, reqEditors ...RequestEditorFn) (*LookupIdentifierResponse, error)

	// GetVirtualMachinesWithResponse request
	GetVirtualMachinesWithResponse(ctx context.Context, params *GetVirtualMachinesParams, reqEditors ...RequestEditorFn) (*GetVirtualMachinesResponse, error)

	// CreateVirtualMachineWithBodyWithResponse request with any body
	CreateVirtualMachineWithBodyWithResponse(ctx context.Context, params *CreateVirtualMachineParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualMachineResponse, error)

	CreateVirtualMachineWithResponse(ctx context.Context, params *CreateVirtualMachineParams, body CreateVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualMachineResponse, error)

	// GetVirtualMachineBaseImagesWithResponse request
	GetVirtualMachineBaseImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVirtualMachineBaseImagesResponse, error)

	// GetVirtualMachineSshKeysWithResponse request
	GetVirtualMachineSshKeysWithResponse(ctx context.Context, params *GetVirtualMachineSshKeysParams, reqEditors ...RequestEditorFn) (*GetVirtualMachineSshKeysResponse, error)

	// CreateVirtualMachineSshKeyWithBodyWithResponse request with any body
	CreateVirtualMachineSshKeyWithBodyWithResponse(ctx context.Context, params *CreateVirtualMachineSshKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualMachineSshKeyResponse, error)

	CreateVirtualMachineSshKeyWithResponse(ctx context.Context, params *CreateVirtualMachineSshKeyParams, body CreateVirtualMachineSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualMachineSshKeyResponse, error)

	// DeleteVirtualMachineSshKeyWithResponse request
	DeleteVirtualMachineSshKeyWithResponse(ctx context.Context, sshKeyId string, reqEditors ...RequestEditorFn) (*DeleteVirtualMachineSshKeyResponse, error)

	// GetVirtualMachineSshKeyWithResponse request
	GetVirtualMachineSshKeyWithResponse(ctx context.Context, sshKeyId string, params *GetVirtualMachineSshKeyParams, reqEditors ...RequestEditorFn) (*GetVirtualMachineSshKeyResponse, error)

	// UpdateVirtualMachineSshKeyWithBodyWithResponse request with any body
	UpdateVirtualMachineSshKeyWithBodyWithResponse(ctx context.Context, sshKeyId string, params *UpdateVirtualMachineSshKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVirtualMachineSshKeyResponse, error)

	UpdateVirtualMachineSshKeyWithResponse(ctx context.Context, sshKeyId string, params *UpdateVirtualMachineSshKeyParams, body UpdateVirtualMachineSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVirtualMachineSshKeyResponse, error)

	// DeleteVirtualMachineWithResponse request
	DeleteVirtualMachineWithResponse(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*DeleteVirtualMachineResponse, error)

	// GetVirtualMachineWithResponse request
	GetVirtualMachineWithResponse(ctx context.Context, virtualMachineId string, params *GetVirtualMachineParams, reqEditors ...RequestEditorFn) (*GetVirtualMachineResponse, error)

	// UpdateVirtualMachineWithBodyWithResponse request with any body
	UpdateVirtualMachineWithBodyWithResponse(ctx context.Context, virtualMachineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVirtualMachineResponse, error)

	UpdateVirtualMachineWithResponse(ctx context.Context, virtualMachineId string, body UpdateVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVirtualMachineResponse, error)

	// GetAvailableIpsWithResponse request
	GetAvailableIpsWithResponse(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*GetAvailableIpsResponse, error)

	// ExpireVirtualMachineSosCredentialsWithResponse request
	ExpireVirtualMachineSosCredentialsWithResponse(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*ExpireVirtualMachineSosCredentialsResponse, error)

	// GenerateVirtualMachineSosCredentialsWithResponse request
	GenerateVirtualMachineSosCredentialsWithResponse(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*GenerateVirtualMachineSosCredentialsResponse, error)

	// CreateVirtualMachineJobWithBodyWithResponse request with any body
	CreateVirtualMachineJobWithBodyWithResponse(ctx context.Context, virtualMachineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualMachineJobResponse, error)

	CreateVirtualMachineJobWithResponse(ctx context.Context, virtualMachineId string, body CreateVirtualMachineJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualMachineJobResponse, error)
}

type DeleteAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An object representing information about the currently logged-in user.
		Data *Account `json:"data,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An object representing information about the currently logged-in user.
		Data Account `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableTwoFactorAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An object representing information about the currently logged-in user.
		Data Account `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DisableTwoFactorAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableTwoFactorAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecoverTwoFactorAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data TwoFactorAuthSetup `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r RecoverTwoFactorAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecoverTwoFactorAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTwoFactorAuthSetupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *TwoFactorAuthSetup `json:"data,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTwoFactorAuthSetupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTwoFactorAuthSetupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableTwoFactorAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data TwoFactorAuthRecovery `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r EnableTwoFactorAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableTwoFactorAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []HubMembership `json:"data"`

		// Includes A resource that is associated with an account's membership.
		Includes *AccountMembershipIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAccountInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccountInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A membership resource that is scoped to an individual hub.
		Data HubMembership `json:"data"`

		// Includes A resource that is associated with an account's membership.
		Includes *AccountMembershipIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateAccountInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccountInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountLoginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []map[string]interface{} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAccountLoginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountLoginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountMembershipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []HubMembership `json:"data"`

		// Includes A resource that is associated with a hub membership.
		Includes *HubMembershipIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAccountMembershipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountMembershipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangePasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An object representing information about the currently logged-in user.
		Data Account `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r ChangePasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangePasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			Success bool `json:"success"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnnouncementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Announcement `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAnnouncementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnnouncementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCreditsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Credit `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCreditsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCreditsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCreditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Information about a billing credit.
		Data Credit `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCreditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCreditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Invoice `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetInvoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Information about a billing invoice.
		Data Invoice `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetInvoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInvoiceJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateInvoiceJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInvoiceJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingMethodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Method `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBillingMethodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingMethodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBillingMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Information about a billing method, usable to pay invoices.
		Data Method `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBillingMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBillingMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBillingMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBillingMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBillingMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Information about a billing method, usable to pay invoices.
		Data Method `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBillingMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBillingMethodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Information about a billing method, usable to pay invoices.
		Data Method `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateBillingMethodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBillingMethodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBillingMethodJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBillingMethodJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBillingMethodJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []Order               `json:"data"`
		Includes *BillingOrderIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Information about an order.
		Data     BillingOrder          `json:"data"`
		Includes *BillingOrderIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An order is a resource that describes a billing order
		Data     Order                 `json:"data"`
		Includes *BillingOrderIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBillingOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBillingOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An order is a resource that describes a billing order
		Data     Order                 `json:"data"`
		Includes *BillingOrderIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateBillingOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBillingOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrderJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateOrderJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrderJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingSupportPlansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []SupportPlan `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBillingSupportPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingSupportPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingTiersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []TierPlan `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBillingTiersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingTiersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []BillingService `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBillingServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingOveragesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Overage `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBillingOveragesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingOveragesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Information about billing service.
		Data BillingService `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBillingServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			// Enabled Whether billing is enabled for this core. Generally, this will only be false for dedicated cores.
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBillingStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChangelogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]ChangelogEntry `json:"data,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetChangelogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChangelogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Container `json:"data"`

		// Includes All includable resources linkable to the given container.
		Includes *ContainerIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Containers are a way to package together your application along with it's dependencies, and run in a resource isolated process. They provide consistency across different hosts, efficiency over traditional hosting methods, and facilitate a micro-service based approach, where each logical piece of your application is split into multiple, easily testable parts (such as API, Backend, Frontend, etc).
		Data Container `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Containers are a way to package together your application along with it's dependencies, and run in a resource isolated process. They provide consistency across different hosts, efficiency over traditional hosting methods, and facilitate a micro-service based approach, where each logical piece of your application is split into multiple, easily testable parts (such as API, Backend, Frontend, etc).
		Data Container `json:"data"`

		// Includes All includable resources linkable to the given container.
		Includes *ContainerIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Containers are a way to package together your application along with it's dependencies, and run in a resource isolated process. They provide consistency across different hosts, efficiency over traditional hosting methods, and facilitate a micro-service based approach, where each logical piece of your application is split into multiple, easily testable parts (such as API, Backend, Frontend, etc).
		Data Container `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerBackupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []ContainerBackup `json:"data"`

		// Includes All includable resources linkable to the given Zone.
		Includes *ContainerBackupIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetContainerBackupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerBackupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteContainerBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteContainerBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteContainerBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerBackupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A Container Backup.
		Data ContainerBackup `json:"data"`

		// Includes All includable resources linkable to the given Zone.
		Includes *ContainerBackupIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetContainerBackupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerBackupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerBackupLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []ContainerBackupLogs `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetContainerBackupLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerBackupLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateContainerBackupJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateContainerBackupJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateContainerBackupJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompatibleImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Image `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCompatibleImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompatibleImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFunctionJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFunctionJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFunctionJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteContainerInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteContainerInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteContainerInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Instance `json:"data"`

		// Includes A resource associated with an instance.
		Includes *InstanceIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An instance of a Container.
		Data Instance `json:"data"`

		// Includes A resource associated with an instance.
		Includes *InstanceIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceConsoleStreamAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			// Address The protocol and url for connecting to the Instance console.
			Address string `json:"address"`

			// Token A token used for connecting to the Instance console.
			Token string `json:"token"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetInstanceConsoleStreamAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceConsoleStreamAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpireInstanceSSHCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The number of tokens expired.
		Data struct {
			// Tokens The number of tokens expired.
			Tokens int `json:"tokens"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r ExpireInstanceSSHCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpireInstanceSSHCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateInstanceSSHCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data SSH connection information for a given container instance.
		Data SSHResponse `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GenerateInstanceSSHCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateInstanceSSHCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInstanceJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateInstanceJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInstanceJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceTelemetryReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An Instance telemetry report.
		Data InstanceTelemetryReport `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetInstanceTelemetryReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceTelemetryReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceTelemetryStreamAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Credentials for connecting to the instance telemetry stream on compute.
		Data struct {
			// Address The URL address to open a websocket to for streaming instance telemetry data.
			Address string `json:"address"`

			// Token The authentication token passed into the address as a URL parameter (?token).
			Token string `json:"token"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetInstanceTelemetryStreamAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceTelemetryStreamAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInstanceVolumesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []InstanceVolume `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetInstanceVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInstanceVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A Server ID and number of Instances of a specific Container it hosts.
		Data ServerInstancesSummary `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetContainerServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCompatibleServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Server `json:"data"`

		// Includes A resource associated with a server.
		Includes *ServerIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCompatibleServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompatibleServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Contains useful and relevant data/statistics for a container that would otherwise be several separate API calls.
		Data struct {
			// Id A 24 character hex string used to identify a unique resource.
			Id    ID                 `json:"id"`
			State ContainerState     `json:"state"`
			Stats *StateCountSummary `json:"stats"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetContainerSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateContainerJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateContainerJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateContainerJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTLSGenerationAttemptsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Attempt `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTLSGenerationAttemptsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTLSGenerationAttemptsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LookupTLSCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			Bundle *string `json:"bundle,omitempty"`
			Csr    *string `json:"csr,omitempty"`

			// Domains A list of domains associated with the certificate.
			Domains []string `json:"domains"`

			// Events A collection of timestamps for each event in the TLS certificate's lifetime.
			Events struct {
				Created   DateTime `json:"created"`
				Deleted   DateTime `json:"deleted"`
				Generated DateTime `json:"generated"`
				Updated   DateTime `json:"updated"`
			} `json:"events"`
			Expires DateTime `json:"expires"`
			HubId   *ID      `json:"hub_id"`

			// Id A 24 character hex string used to identify a unique resource.
			Id         ID      `json:"id"`
			PrivateKey *string `json:"private_key,omitempty"`
			State      struct {
				Changed DateTime `json:"changed"`

				// Current The current state of the TLS certificate.
				Current LookupTLSCertificate200DataStateCurrent `json:"current"`

				// Error An error, if any, that has occurred for this resource.
				Error *struct {
					// Message Details about the error that has occurred.
					Message *string   `json:"message,omitempty"`
					Time    *DateTime `json:"time,omitempty"`
				} `json:"error,omitempty"`
			} `json:"state"`

			// UserSupplied Whether or not this certificate was uploaded instead of generated by the platform.
			UserSupplied bool `json:"user_supplied"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}
type LookupTLSCertificate200DataStateCurrent string

// Status returns HTTPResponse.Status
func (r LookupTLSCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LookupTLSCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserSuppliedCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []TlsCertificate `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUserSuppliedCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserSuppliedCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadUserSuppliedCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data A TLS certificate.
		Data TlsCertificate `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UploadUserSuppliedCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadUserSuppliedCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserSuppliedCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A TLS certificate.
		Data TlsCertificate `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUserSuppliedCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserSuppliedCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserSuppliedCertificateJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateUserSuppliedCertificateJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserSuppliedCertificateJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDNSZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []DnsZone `json:"data"`

		// Includes All includable resources linkable to the given Zone.
		Includes *DnsZoneIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDNSZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDNSZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDNSZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
		Data DnsZone `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDNSZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDNSZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDNSZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDNSZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDNSZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDNSZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
		Data DnsZone `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDNSZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDNSZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDNSZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
		Data DnsZone `json:"data"`

		// Includes All includable resources linkable to the given Zone.
		Includes *DnsZoneIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateDNSZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDNSZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDNSZoneAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
		Data DnsZone `json:"data"`

		// Includes All includable resources linkable to the given Zone.
		Includes *DnsZoneIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateDNSZoneAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDNSZoneAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDNSZoneRecordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []DnsRecord `json:"data"`

		// Includes All includable resources linkable to the given records.
		Includes *RecordIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDNSZoneRecordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDNSZoneRecordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDNSZoneRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data A DNS record.
		Data DnsRecord `json:"data"`

		// Includes All includable resources linkable to the given records.
		Includes *RecordIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDNSZoneRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDNSZoneRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDNSZoneRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data *JobDescriptor `json:"data,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDNSZoneRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDNSZoneRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDNSZoneRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A DNS record.
		Data DnsRecord `json:"data"`

		// Includes All includable resources linkable to the given records.
		Includes *RecordIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateDNSZoneRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDNSZoneRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDNSZoneRecordJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDNSZoneRecordJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDNSZoneRecordJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDNSZoneJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDNSZoneJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDNSZoneJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []Environment `json:"data"`
		Includes *struct {
			// Creators An identity that created a resource.
			Creators *CreatorInclude `json:"creators,omitempty"`
		} `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://cycle.io/docs/platform/introduction-to-environments).
		Data Environment `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://cycle.io/docs/platform/introduction-to-environments).
		Data     Environment `json:"data"`
		Includes *struct {
			// Clusters A resource associated with a cluster.
			Clusters *ClusterIncludes `json:"clusters,omitempty"`

			// Creators An identity that created a resource.
			Creators *CreatorInclude `json:"creators,omitempty"`
		} `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://cycle.io/docs/platform/introduction-to-environments).
		Data Environment `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEnvironmentAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://cycle.io/docs/platform/introduction-to-environments).
		Data Environment `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateEnvironmentAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEnvironmentAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentDeploymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			// Versions A map where the key is the version property of a deployment.
			Versions map[string]struct {
				// Containers The number of containers utilizing this version of this deployment.
				Containers int `json:"containers"`

				// Tags An array of all tags on this environment that point to this version.
				Tags []Identifier `json:"tags"`
			} `json:"versions"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentDeploymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentDeploymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A Cycle stack file is an "environment as code". This allows an environment to be generated consistently based on a fixed specification.
		// Stack files can describe multiple containers and their configurations, environment service settings, scoped variables, and important metadata.
		Data StackSpec `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r ExportStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScopedVariablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []ScopedVariable `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetScopedVariablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScopedVariablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateScopedVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Scoped variables are a way for users to dynamically allocate runtime specific environment variables across any number of containers in an environment.
		Data ScopedVariable `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateScopedVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateScopedVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteScopedVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteScopedVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteScopedVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScopedVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Scoped variables are a way for users to dynamically allocate runtime specific environment variables across any number of containers in an environment.
		Data ScopedVariable `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetScopedVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScopedVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateScopedVariableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Scoped variables are a way for users to dynamically allocate runtime specific environment variables across any number of containers in an environment.
		Data ScopedVariable `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateScopedVariableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateScopedVariableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDiscoveryServiceJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDiscoveryServiceJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDiscoveryServiceJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGatewayServiceJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateGatewayServiceJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGatewayServiceJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoadBalancerServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Information about an environments load balancer configuration, state, and availability settings.
		Data struct {
			BaseConfigs *struct {
				// Haproxy Describes settings that are passed to HAProxy within the load balancer.
				Haproxy HaProxyConfig `json:"haproxy"`
				V1      V1LbConfig    `json:"v1"`
			} `json:"base_configs,omitempty"`
			CurrentType GetLoadBalancerService200DataCurrentType `json:"current_type"`

			// DefaultConfig The config object for the loadbalancer service.
			DefaultConfig LoadBalancerConfig                       `json:"default_config"`
			DefaultType   GetLoadBalancerService200DataDefaultType `json:"default_type"`
			Service       *LoadBalancerEnvironmentService          `json:"service"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}
type GetLoadBalancerService200DataCurrentType string
type GetLoadBalancerService200DataDefaultType string

// Status returns HTTPResponse.Status
func (r GetLoadBalancerServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoadBalancerServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLoadBalancerServiceJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLoadBalancerServiceJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLoadBalancerServiceJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoadBalancerLatestTelemetryReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Snapshots of the latest load balancer telemetry
		Data LoadBalancerLatestTelemetry `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLoadBalancerLatestTelemetryReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoadBalancerLatestTelemetryReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoadBalancerTelemetryLatestControllersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Information about the latest controllers that generated traffic.
		Data LoadBalancerLatestControllers `json:"data"`

		// Includes Optionally included resources for load balancer controllers
		Includes *Controllers `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLoadBalancerTelemetryLatestControllersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoadBalancerTelemetryLatestControllersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoadBalancerTelemetryReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Aggregated load balancer telemetry across all instances for a given range.
		Data LoadBalancerTelemetryReport `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLoadBalancerTelemetryReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoadBalancerTelemetryReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSchedulerServiceJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSchedulerServiceJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSchedulerServiceJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVPNServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A summary of a VPN service for a given environment.
		Data VPNInfoReturn `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVPNServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVPNServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVPNLoginsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []VPNLogin `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVPNLoginsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVPNLoginsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVPNServiceJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateVPNServiceJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVPNServiceJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVPNUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []VPNUsers `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVPNUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVPNUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVPNUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data A VPN user for a given VPN.
		Data VPNUsers `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateVPNUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVPNUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVPNUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data string `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteVPNUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVPNUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Contains useful and relevant data/statistics for an environment that would otherwise be several separate API calls.
		Data EnvironmentSummary `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEnvironmentJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateEnvironmentJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEnvironmentJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Hub `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHubsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHubResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A hub resource.
		Data Hub `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHubResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHubResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubCapabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Capability `json:"data"`
		Meta struct {
			// Captions Human-readable captions keyed by the platform level capability it describes.
			Captions map[string]string `json:"captions"`
		} `json:"meta"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHubCapabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubCapabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHubResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHubResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHubResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A hub resource.
		Data *Hub `json:"data,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHubResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateHubResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A hub resource.
		Data Hub `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateHubResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateHubResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Activity `json:"data"`

		// Includes All includable resources linkable to the given records.
		Includes *ActivityIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHubActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []ApiKey `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data An API key resource
		Data ApiKey `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An API key resource
		Data ApiKey `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An API key resource
		Data *ApiKey `json:"data,omitempty"`

		// Includes A resource that is associated with an API key.
		Includes *ApiKeyIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAPIKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An API key resource
		Data ApiKey `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateAPIKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAPIKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Integration `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetIntegrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIntegrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data Integration `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateIntegrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIntegrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableIntegrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			Billing                  *[]IntegrationDefinition `json:"billing"`
			ImageBuilders            *[]IntegrationDefinition `json:"image-builders"`
			InfrastructureProvider   *[]IntegrationDefinition `json:"infrastructure-provider"`
			ObjectStorage            *[]IntegrationDefinition `json:"object-storage"`
			TlsCertificateGeneration *[]IntegrationDefinition `json:"tls-certificate-generation"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAvailableIntegrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableIntegrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIntegrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteIntegrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIntegrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIntegrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data Integration `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetIntegrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIntegrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIntegrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data Integration `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateIntegrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIntegrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIntegrationJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateIntegrationJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIntegrationJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []HubMembership `json:"data"`

		// Includes All includable resources for invites.
		Includes *HubInviteIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHubInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHubInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data A membership resource that is scoped to an individual hub.
		Data HubMembership `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHubInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHubInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHubInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A membership resource that is scoped to an individual hub.
		Data HubMembership `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHubInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHubInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []HubMembership `json:"data"`

		// Includes All includable resources for hub memberships.
		Includes *HubMembershipIncludes2 `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHubMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubMemberAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A membership resource that is scoped to an individual hub.
		Data HubMembership `json:"data"`

		// Includes All includable resources for hub memberships.
		Includes *HubMembershipIncludes2 `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHubMemberAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubMemberAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHubMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHubMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHubMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A membership resource that is scoped to an individual hub.
		Data HubMembership `json:"data"`

		// Includes All includable resources for hub memberships.
		Includes *HubMembershipIncludes2 `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHubMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateHubMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A membership resource that is scoped to an individual hub.
		Data HubMembership `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateHubMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateHubMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A membership resource that is scoped to an individual hub.
		Data HubMembership `json:"data"`

		// Includes All includable resources for hub memberships.
		Includes *HubMembershipIncludes2 `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHubMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubNotificationSocketAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			// Token A token used for connecting to the Hub notification pipeline websocket API.
			Token string `json:"token"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHubNotificationSocketAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubNotificationSocketAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Role `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data A Role is a custom combination of platform-level capabilities, allowing for fully customizable role-based access controls across the platform.
		Data Role `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultHubRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []struct {
			Capabilities struct {
				// All If true, the role has all capabilities.
				All      bool         `json:"all"`
				Specific []Capability `json:"specific"`
			} `json:"capabilities"`

			// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
			// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
			// have the identifier of `my-container` and is automatically created by the platform.
			//
			// The identifier does not have to be unique.
			Identifier Identifier `json:"identifier"`
			Name       string     `json:"name"`

			// Root The role marked as root has full moderation control over all roles.
			Root bool `json:"root"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDefaultHubRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultHubRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A Role is a custom combination of platform-level capabilities, allowing for fully customizable role-based access controls across the platform.
		Data *Role `json:"data,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A Role is a custom combination of platform-level capabilities, allowing for fully customizable role-based access controls across the platform.
		Data Role `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHubUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []HubUsageDatum `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHubUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHubUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Image `json:"data"`

		// Includes All includable resources linkable to the given image.
		Includes *ImageIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data An image is a point in time build on a given image source, and what is distributed by Cycle to run containers.
		Data Image `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImageSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []ImageSource `json:"data"`

		// Includes A resource associate with an image source.
		Includes *SourceIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetImageSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImageSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImageSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data An image source is a set of resources that direct the platform on where it can find the resources needed to build an image resource.
		Data ImageSource `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateImageSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImageSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteImageSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImageSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An image source is a set of resources that direct the platform on where it can find the resources needed to build an image resource.
		Data ImageSource `json:"data"`

		// Includes A resource associate with an image source.
		Includes *SourceIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetImageSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImageSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateImageSourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An image source is a set of resources that direct the platform on where it can find the resources needed to build an image resource.
		Data ImageSource `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateImageSourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateImageSourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateImageSourceAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An image source is a set of resources that direct the platform on where it can find the resources needed to build an image resource.
		Data ImageSource `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateImageSourceAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateImageSourceAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImagesJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateImagesJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImagesJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An image is a point in time build on a given image source, and what is distributed by Cycle to run containers.
		Data Image `json:"data"`

		// Includes All includable resources linkable to the given image.
		Includes *ImageIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateImageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An image is a point in time build on a given image source, and what is distributed by Cycle to run containers.
		Data Image `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateImageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateImageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImageBuildLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A build log for a given image.
		Data BuildLog `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetImageBuildLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImageBuildLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImageJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateImageJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImageJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutoScaleGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []AutoScaleGroup `json:"data"`

		// Includes All includable resource linkable to the given auto-scale group.
		Includes *AutoScaleGroupIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAutoScaleGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutoScaleGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAutoScaleGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data AutoScaleGroup `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAutoScaleGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAutoScaleGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAutoScaleGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAutoScaleGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAutoScaleGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutoScaleGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data AutoScaleGroup `json:"data"`

		// Includes All includable resource linkable to the given auto-scale group.
		Includes *AutoScaleGroupIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAutoScaleGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutoScaleGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAutoScaleGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data AutoScaleGroup `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateAutoScaleGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAutoScaleGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAutoScaleGroupAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data AutoScaleGroup `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateAutoScaleGroupAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAutoScaleGroupAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Cluster `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Clusters are groups of servers that allow physical separation of resources.
		Data Cluster `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Clusters are groups of servers that allow physical separation of resources.
		Data Cluster `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Clusters are groups of servers that allow physical separation of resources.
		Data Cluster `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Clusters are groups of servers that allow physical separation of resources.
		Data Cluster `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateClusterAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateClusterJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeploymentStrategiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			// Distributed Information about supported container deployment strategies.
			Distributed *DeploymentStrategy `json:"distributed,omitempty"`

			// Edge Information about supported container deployment strategies.
			Edge *DeploymentStrategy `json:"edge,omitempty"`

			// FirstAvailable Information about supported container deployment strategies.
			FirstAvailable *DeploymentStrategy `json:"first-available,omitempty"`

			// Function Information about supported container deployment strategies.
			Function *DeploymentStrategy `json:"function,omitempty"`

			// HighAvailability Information about supported container deployment strategies.
			HighAvailability *DeploymentStrategy `json:"high-availability,omitempty"`

			// Manual Information about supported container deployment strategies.
			Manual *DeploymentStrategy `json:"manual,omitempty"`

			// Node Information about supported container deployment strategies.
			Node *DeploymentStrategy `json:"node,omitempty"`

			// ResourceDensity Information about supported container deployment strategies.
			ResourceDensity *DeploymentStrategy `json:"resource-density,omitempty"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDeploymentStrategiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeploymentStrategiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExternalVolumesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []ExternalVolume `json:"data"`

		// Includes All includable resources linked to the given external volume.
		Includes *ExternalVolumeIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetExternalVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExternalVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateExternalVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data A persistent storage volume within a cluster. Volumes may be attached to containers or VMs and can originate from different storage sources.
		Data ExternalVolume `json:"data"`

		// Includes All includable resources linked to the given external volume.
		Includes *ExternalVolumeIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateExternalVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExternalVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExternalVolumeSourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data map[string]struct {
			// Capabilities Map where keys are attachment types and values are arrays of supported modes.
			Capabilities map[string][]string `json:"capabilities"`

			// Creatable Whether volumes of this source type can be created via the API.
			Creatable bool `json:"creatable"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetExternalVolumeSourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExternalVolumeSourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteExternalVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteExternalVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExternalVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExternalVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A persistent storage volume within a cluster. Volumes may be attached to containers or VMs and can originate from different storage sources.
		Data ExternalVolume `json:"data"`

		// Includes All includable resources linked to the given external volume.
		Includes *ExternalVolumeIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetExternalVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExternalVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateExternalVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A persistent storage volume within a cluster. Volumes may be attached to containers or VMs and can originate from different storage sources.
		Data ExternalVolume `json:"data"`

		// Includes All includable resources linked to the given external volume.
		Includes *ExternalVolumeIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateExternalVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateExternalVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateExternalVolumeAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A persistent storage volume within a cluster. Volumes may be attached to containers or VMs and can originate from different storage sources.
		Data ExternalVolume `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateExternalVolumeAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateExternalVolumeAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateExternalVolumeJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateExternalVolumeJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExternalVolumeJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIpPoolsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []IpPool `json:"data"`

		// Includes Resources associated with an IP Pool.
		Includes *IpPoolIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetIpPoolsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIpPoolsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIpPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data An IP Pool
		Data IpPool `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateIpPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIpPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIPPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteIPPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIPPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIPPoolResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An IP Pool
		Data IpPool `json:"data"`

		// Includes Resources associated with an IP Pool.
		Includes *IpPoolIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetIPPoolResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIPPoolResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPoolIPsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Ip `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPoolIPsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPoolIPsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIpPoolJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateIpPoolJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIpPoolJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterMonitoringTiersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data map[string]MonitoringTierDetails `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetClusterMonitoringTiersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterMonitoringTiersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProviderLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []ProviderLocation `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetProviderLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProviderLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProviderServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []ProviderServerModel `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetProviderServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProviderServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Server `json:"data"`

		// Includes A resource associated with a server.
		Includes *ServerIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerTags
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The server resource, referring to servers that have been deployed to a Cycle hub.
		Data Server `json:"data"`

		// Includes A resource associated with a server.
		Includes *ServerIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The server resource, referring to servers that have been deployed to a Cycle hub.
		Data Server `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerConsoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			// Address The websocket target URL.
			Address string `json:"address"`

			// Token The authentication token for the console socket. It should be appended as the URL parameter "token" to the address.
			Token string `json:"token"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerConsoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerConsoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Instance `json:"data"`

		// Includes A resource associated with an instance.
		Includes *InstanceIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerTelemetryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []ServerStatsTelemetry `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerTelemetryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerTelemetryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Server usage data.
		Data UsageDatum `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInfrastructureSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An infrastructure summary resource.
		Data InfrastructureSummary `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetInfrastructureSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInfrastructureSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualProviderIsosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []VirtualProviderIso `json:"data"`

		// Includes A resource that is associated with an ISO.
		Includes *VirtualProviderIsoIncludes `json:"includes,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetVirtualProviderIsosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualProviderIsosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVirtualProviderIsoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data The ISO image for a virtual provider.
		Data VirtualProviderIso `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateVirtualProviderIsoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVirtualProviderIsoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualProviderIsoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualProviderIsoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualProviderIsoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualProviderIsoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data The ISO image for a virtual provider.
		Data VirtualProviderIso `json:"data"`

		// Includes A resource that is associated with an ISO.
		Includes *VirtualProviderIsoIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVirtualProviderIsoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualProviderIsoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVirtualProviderIsoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data The ISO image for a virtual provider.
		Data VirtualProviderIso `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateVirtualProviderIsoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVirtualProviderIsoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualProviderIsoDownloadUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		Data struct {
			Url string `json:"url"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVirtualProviderIsoDownloadUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualProviderIsoDownloadUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVirtualProviderIsoJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateVirtualProviderIsoJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVirtualProviderIsoJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []Job        `json:"data"`
		Includes *JobIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Job `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLatestJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A job resource.
		Data Job `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Event `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateAggregatedEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []map[string]interface{} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GenerateAggregatedEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateAggregatedEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AggregateLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []LogLine `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r AggregateLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AggregateLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Metric `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateAggregatedMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []map[string]interface{} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GenerateAggregatedMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateAggregatedMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMonitoringMonitorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Monitor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMonitoringMonitorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMonitoringMonitorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Pipeline `json:"data"`

		// Includes All includable resources linkable to the given pipeline.
		Includes *PipelineIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPipelinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data A pipeline resource.
		Data Pipeline `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreatePipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClonePipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data A pipeline resource.
		Data Pipeline `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r ClonePipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClonePipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeletePipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A pipeline resource.
		Data Pipeline `json:"data"`

		// Includes All includable resources linkable to the given pipeline.
		Includes *PipelineIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A pipeline resource.
		Data Pipeline `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdatePipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePipelineAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A pipeline resource.
		Data Pipeline `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdatePipelineAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePipelineAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineTriggerKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []TriggerKey `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPipelineTriggerKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineTriggerKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePipelineTriggerKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data A pipeline trigger key resource.
		Data TriggerKey `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreatePipelineTriggerKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePipelineTriggerKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePipelineTriggerKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeletePipelineTriggerKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePipelineTriggerKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineTriggerKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A pipeline trigger key resource.
		Data *TriggerKey `json:"data,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPipelineTriggerKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineTriggerKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePipelineTriggerKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A pipeline trigger key resource.
		Data TriggerKey `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdatePipelineTriggerKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePipelineTriggerKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []PipelineRun `json:"data"`
		Includes *struct {
			// Creators An identity that created a resource.
			Creators *CreatorInclude `json:"creators,omitempty"`
		} `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPipelineRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPipelineRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A pipeline run resource.
		Data     PipelineRun `json:"data"`
		Includes *struct {
			// Creators An identity that created a resource.
			Creators *CreatorInclude `json:"creators,omitempty"`
		} `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPipelineRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPipelineRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePipelineJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreatePipelineJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePipelineJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerPipelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r TriggerPipelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerPipelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Network `json:"data"`

		// Includes All includable resource linkable to the given network.
		Includes *NetworkIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetNetworksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data SDN Network resource.
		Data Network `json:"data"`

		// Includes All includable resource linkable to the given network.
		Includes *NetworkIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data SDN Network resource.
		Data Network `json:"data"`

		// Includes All includable resource linkable to the given network.
		Includes *NetworkIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data SDN Network resource.
		Data Network `json:"data"`

		// Includes All includable resource linkable to the given network.
		Includes *NetworkIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNetworkAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data SDN Network resource.
		Data Network `json:"data"`

		// Includes All includable resource linkable to the given network.
		Includes *NetworkIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateNetworkAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNetworkAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNetworkJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateNetworkJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNetworkJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An index that enables search in the portal
		Data Index `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSearchIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStacksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Stack `json:"data"`

		// Includes All includable resources linkable to the given stack.
		Includes *StackInclude `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStacksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStacksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Stacks are a way to orchestrate multiple containers atomically and automatically.
		Data Stack `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LookupStackBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A stack build resource.
		Data StackBuild `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r LookupStackBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LookupStackBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Stacks are a way to orchestrate multiple containers atomically and automatically.
		Data Stack `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Stacks are a way to orchestrate multiple containers atomically and automatically.
		Data Stack `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateStackAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Stacks are a way to orchestrate multiple containers atomically and automatically.
		Data Stack `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateStackAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateStackAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStackBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []StackBuild `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStackBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStackBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStackBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data A stack build resource.
		Data StackBuild `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStackBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStackBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStackBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStackBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStackBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStackBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A stack build resource.
		Data StackBuild `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStackBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStackBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStackBuildLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A build log for a given stack build.
		Data StackBuildLog `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStackBuildLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStackBuildLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStackBuildJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStackBuildJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStackBuildJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStackJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStackJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStackJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LookupComponentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A resource that is associated with activity.
		Data ComponentsIncludes `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r LookupComponentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LookupComponentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LookupIdentifierResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			Id string `json:"id"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r LookupIdentifierResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LookupIdentifierResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualMachinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []VirtualMachine `json:"data"`

		// Includes All includable resources linkable to the given virtual machine.
		Includes *VirtualMachineIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVirtualMachinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualMachinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Describes a virtual machine running on the Cycle Platform.
		Data VirtualMachine `json:"data"`

		// Includes All includable resources linkable to the given virtual machine.
		Includes *VirtualMachineIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualMachineBaseImagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data map[string]VirtualMachineBaseImage `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVirtualMachineBaseImagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualMachineBaseImagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualMachineSshKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []VirtualMachineSshKey `json:"data"`

		// Includes All includable resources linkable to the given virtual machine SSH key.
		Includes *VirtualMachineSshIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVirtualMachineSshKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualMachineSshKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVirtualMachineSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Describes an SSH key used to access a virtual machine.
		Data VirtualMachineSshKey `json:"data"`

		// Includes All includable resources linkable to the given virtual machine SSH key.
		Includes *VirtualMachineSshIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateVirtualMachineSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVirtualMachineSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualMachineSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualMachineSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualMachineSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualMachineSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Describes an SSH key used to access a virtual machine.
		Data VirtualMachineSshKey `json:"data"`

		// Includes All includable resources linkable to the given virtual machine SSH key.
		Includes *VirtualMachineSshIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVirtualMachineSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualMachineSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVirtualMachineSshKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Describes an SSH key used to access a virtual machine.
		Data VirtualMachineSshKey `json:"data"`

		// Includes All includable resources linkable to the given virtual machine SSH key.
		Includes *VirtualMachineSshIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateVirtualMachineSshKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVirtualMachineSshKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Describes a virtual machine running on the Cycle Platform.
		Data VirtualMachine `json:"data"`

		// Includes All includable resources linkable to the given virtual machine.
		Includes *VirtualMachineIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVirtualMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Describes a virtual machine running on the Cycle Platform.
		Data VirtualMachine `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateVirtualMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVirtualMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAvailableIpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Ip `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAvailableIpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAvailableIpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExpireVirtualMachineSosCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The number of tokens expired.
		Data struct {
			// Tokens The number of tokens expired.
			Tokens int `json:"tokens"`
		} `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r ExpireVirtualMachineSosCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExpireVirtualMachineSosCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateVirtualMachineSosCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Connection details for connecting to a virtual machine using serial-over-SSH.
		Data VirtualMachineSosConnection `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GenerateVirtualMachineSosCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateVirtualMachineSosCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVirtualMachineJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateVirtualMachineJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVirtualMachineJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteAccountWithResponse request returning *DeleteAccountResponse
func (c *ClientWithResponses) DeleteAccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteAccountResponse, error) {
	rsp, err := c.DeleteAccount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccountResponse(rsp)
}

// GetAccountWithResponse request returning *GetAccountResponse
func (c *ClientWithResponses) GetAccountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAccountResponse, error) {
	rsp, err := c.GetAccount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountResponse(rsp)
}

// UpdateAccountWithBodyWithResponse request with arbitrary body returning *UpdateAccountResponse
func (c *ClientWithResponses) UpdateAccountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error) {
	rsp, err := c.UpdateAccountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountResponse(rsp)
}

func (c *ClientWithResponses) UpdateAccountWithResponse(ctx context.Context, body UpdateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountResponse, error) {
	rsp, err := c.UpdateAccount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountResponse(rsp)
}

// DisableTwoFactorAuthWithBodyWithResponse request with arbitrary body returning *DisableTwoFactorAuthResponse
func (c *ClientWithResponses) DisableTwoFactorAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableTwoFactorAuthResponse, error) {
	rsp, err := c.DisableTwoFactorAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableTwoFactorAuthResponse(rsp)
}

func (c *ClientWithResponses) DisableTwoFactorAuthWithResponse(ctx context.Context, body DisableTwoFactorAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableTwoFactorAuthResponse, error) {
	rsp, err := c.DisableTwoFactorAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableTwoFactorAuthResponse(rsp)
}

// RecoverTwoFactorAuthWithBodyWithResponse request with arbitrary body returning *RecoverTwoFactorAuthResponse
func (c *ClientWithResponses) RecoverTwoFactorAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecoverTwoFactorAuthResponse, error) {
	rsp, err := c.RecoverTwoFactorAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverTwoFactorAuthResponse(rsp)
}

func (c *ClientWithResponses) RecoverTwoFactorAuthWithResponse(ctx context.Context, body RecoverTwoFactorAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*RecoverTwoFactorAuthResponse, error) {
	rsp, err := c.RecoverTwoFactorAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecoverTwoFactorAuthResponse(rsp)
}

// GetTwoFactorAuthSetupWithResponse request returning *GetTwoFactorAuthSetupResponse
func (c *ClientWithResponses) GetTwoFactorAuthSetupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTwoFactorAuthSetupResponse, error) {
	rsp, err := c.GetTwoFactorAuthSetup(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTwoFactorAuthSetupResponse(rsp)
}

// EnableTwoFactorAuthWithBodyWithResponse request with arbitrary body returning *EnableTwoFactorAuthResponse
func (c *ClientWithResponses) EnableTwoFactorAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableTwoFactorAuthResponse, error) {
	rsp, err := c.EnableTwoFactorAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableTwoFactorAuthResponse(rsp)
}

func (c *ClientWithResponses) EnableTwoFactorAuthWithResponse(ctx context.Context, body EnableTwoFactorAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableTwoFactorAuthResponse, error) {
	rsp, err := c.EnableTwoFactorAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableTwoFactorAuthResponse(rsp)
}

// GetAccountInvitesWithResponse request returning *GetAccountInvitesResponse
func (c *ClientWithResponses) GetAccountInvitesWithResponse(ctx context.Context, params *GetAccountInvitesParams, reqEditors ...RequestEditorFn) (*GetAccountInvitesResponse, error) {
	rsp, err := c.GetAccountInvites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountInvitesResponse(rsp)
}

// UpdateAccountInviteWithBodyWithResponse request with arbitrary body returning *UpdateAccountInviteResponse
func (c *ClientWithResponses) UpdateAccountInviteWithBodyWithResponse(ctx context.Context, inviteId string, params *UpdateAccountInviteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccountInviteResponse, error) {
	rsp, err := c.UpdateAccountInviteWithBody(ctx, inviteId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountInviteResponse(rsp)
}

func (c *ClientWithResponses) UpdateAccountInviteWithResponse(ctx context.Context, inviteId string, params *UpdateAccountInviteParams, body UpdateAccountInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccountInviteResponse, error) {
	rsp, err := c.UpdateAccountInvite(ctx, inviteId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccountInviteResponse(rsp)
}

// GetAccountLoginsWithResponse request returning *GetAccountLoginsResponse
func (c *ClientWithResponses) GetAccountLoginsWithResponse(ctx context.Context, params *GetAccountLoginsParams, reqEditors ...RequestEditorFn) (*GetAccountLoginsResponse, error) {
	rsp, err := c.GetAccountLogins(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountLoginsResponse(rsp)
}

// GetAccountMembershipsWithResponse request returning *GetAccountMembershipsResponse
func (c *ClientWithResponses) GetAccountMembershipsWithResponse(ctx context.Context, params *GetAccountMembershipsParams, reqEditors ...RequestEditorFn) (*GetAccountMembershipsResponse, error) {
	rsp, err := c.GetAccountMemberships(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountMembershipsResponse(rsp)
}

// ChangePasswordWithBodyWithResponse request with arbitrary body returning *ChangePasswordResponse
func (c *ClientWithResponses) ChangePasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePasswordResponse, error) {
	rsp, err := c.ChangePasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePasswordResponse(rsp)
}

func (c *ClientWithResponses) ChangePasswordWithResponse(ctx context.Context, body ChangePasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePasswordResponse, error) {
	rsp, err := c.ChangePassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePasswordResponse(rsp)
}

// ResetPasswordWithBodyWithResponse request with arbitrary body returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// GetAnnouncementsWithResponse request returning *GetAnnouncementsResponse
func (c *ClientWithResponses) GetAnnouncementsWithResponse(ctx context.Context, params *GetAnnouncementsParams, reqEditors ...RequestEditorFn) (*GetAnnouncementsResponse, error) {
	rsp, err := c.GetAnnouncements(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnnouncementsResponse(rsp)
}

// GetCreditsWithResponse request returning *GetCreditsResponse
func (c *ClientWithResponses) GetCreditsWithResponse(ctx context.Context, params *GetCreditsParams, reqEditors ...RequestEditorFn) (*GetCreditsResponse, error) {
	rsp, err := c.GetCredits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCreditsResponse(rsp)
}

// GetCreditWithResponse request returning *GetCreditResponse
func (c *ClientWithResponses) GetCreditWithResponse(ctx context.Context, creditsId string, reqEditors ...RequestEditorFn) (*GetCreditResponse, error) {
	rsp, err := c.GetCredit(ctx, creditsId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCreditResponse(rsp)
}

// GetInvoicesWithResponse request returning *GetInvoicesResponse
func (c *ClientWithResponses) GetInvoicesWithResponse(ctx context.Context, params *GetInvoicesParams, reqEditors ...RequestEditorFn) (*GetInvoicesResponse, error) {
	rsp, err := c.GetInvoices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesResponse(rsp)
}

// GetInvoiceWithResponse request returning *GetInvoiceResponse
func (c *ClientWithResponses) GetInvoiceWithResponse(ctx context.Context, invoiceId string, params *GetInvoiceParams, reqEditors ...RequestEditorFn) (*GetInvoiceResponse, error) {
	rsp, err := c.GetInvoice(ctx, invoiceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoiceResponse(rsp)
}

// CreateInvoiceJobWithBodyWithResponse request with arbitrary body returning *CreateInvoiceJobResponse
func (c *ClientWithResponses) CreateInvoiceJobWithBodyWithResponse(ctx context.Context, invoiceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInvoiceJobResponse, error) {
	rsp, err := c.CreateInvoiceJobWithBody(ctx, invoiceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInvoiceJobResponse(rsp)
}

func (c *ClientWithResponses) CreateInvoiceJobWithResponse(ctx context.Context, invoiceId string, body CreateInvoiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInvoiceJobResponse, error) {
	rsp, err := c.CreateInvoiceJob(ctx, invoiceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInvoiceJobResponse(rsp)
}

// GetBillingMethodsWithResponse request returning *GetBillingMethodsResponse
func (c *ClientWithResponses) GetBillingMethodsWithResponse(ctx context.Context, params *GetBillingMethodsParams, reqEditors ...RequestEditorFn) (*GetBillingMethodsResponse, error) {
	rsp, err := c.GetBillingMethods(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingMethodsResponse(rsp)
}

// CreateBillingMethodWithBodyWithResponse request with arbitrary body returning *CreateBillingMethodResponse
func (c *ClientWithResponses) CreateBillingMethodWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBillingMethodResponse, error) {
	rsp, err := c.CreateBillingMethodWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBillingMethodResponse(rsp)
}

func (c *ClientWithResponses) CreateBillingMethodWithResponse(ctx context.Context, body CreateBillingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBillingMethodResponse, error) {
	rsp, err := c.CreateBillingMethod(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBillingMethodResponse(rsp)
}

// DeleteBillingMethodWithResponse request returning *DeleteBillingMethodResponse
func (c *ClientWithResponses) DeleteBillingMethodWithResponse(ctx context.Context, methodId string, reqEditors ...RequestEditorFn) (*DeleteBillingMethodResponse, error) {
	rsp, err := c.DeleteBillingMethod(ctx, methodId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBillingMethodResponse(rsp)
}

// GetBillingMethodWithResponse request returning *GetBillingMethodResponse
func (c *ClientWithResponses) GetBillingMethodWithResponse(ctx context.Context, methodId string, reqEditors ...RequestEditorFn) (*GetBillingMethodResponse, error) {
	rsp, err := c.GetBillingMethod(ctx, methodId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingMethodResponse(rsp)
}

// UpdateBillingMethodWithBodyWithResponse request with arbitrary body returning *UpdateBillingMethodResponse
func (c *ClientWithResponses) UpdateBillingMethodWithBodyWithResponse(ctx context.Context, methodId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBillingMethodResponse, error) {
	rsp, err := c.UpdateBillingMethodWithBody(ctx, methodId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBillingMethodResponse(rsp)
}

func (c *ClientWithResponses) UpdateBillingMethodWithResponse(ctx context.Context, methodId string, body UpdateBillingMethodJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBillingMethodResponse, error) {
	rsp, err := c.UpdateBillingMethod(ctx, methodId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBillingMethodResponse(rsp)
}

// CreateBillingMethodJobWithBodyWithResponse request with arbitrary body returning *CreateBillingMethodJobResponse
func (c *ClientWithResponses) CreateBillingMethodJobWithBodyWithResponse(ctx context.Context, methodId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBillingMethodJobResponse, error) {
	rsp, err := c.CreateBillingMethodJobWithBody(ctx, methodId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBillingMethodJobResponse(rsp)
}

func (c *ClientWithResponses) CreateBillingMethodJobWithResponse(ctx context.Context, methodId string, body CreateBillingMethodJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBillingMethodJobResponse, error) {
	rsp, err := c.CreateBillingMethodJob(ctx, methodId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBillingMethodJobResponse(rsp)
}

// GetOrdersWithResponse request returning *GetOrdersResponse
func (c *ClientWithResponses) GetOrdersWithResponse(ctx context.Context, params *GetOrdersParams, reqEditors ...RequestEditorFn) (*GetOrdersResponse, error) {
	rsp, err := c.GetOrders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrdersResponse(rsp)
}

// CreateOrderWithBodyWithResponse request with arbitrary body returning *CreateOrderResponse
func (c *ClientWithResponses) CreateOrderWithBodyWithResponse(ctx context.Context, params *CreateOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrderResponse, error) {
	rsp, err := c.CreateOrderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrderResponse(rsp)
}

func (c *ClientWithResponses) CreateOrderWithResponse(ctx context.Context, params *CreateOrderParams, body CreateOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrderResponse, error) {
	rsp, err := c.CreateOrder(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrderResponse(rsp)
}

// GetBillingOrderWithResponse request returning *GetBillingOrderResponse
func (c *ClientWithResponses) GetBillingOrderWithResponse(ctx context.Context, orderId string, params *GetBillingOrderParams, reqEditors ...RequestEditorFn) (*GetBillingOrderResponse, error) {
	rsp, err := c.GetBillingOrder(ctx, orderId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingOrderResponse(rsp)
}

// UpdateBillingOrderWithBodyWithResponse request with arbitrary body returning *UpdateBillingOrderResponse
func (c *ClientWithResponses) UpdateBillingOrderWithBodyWithResponse(ctx context.Context, orderId string, params *UpdateBillingOrderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBillingOrderResponse, error) {
	rsp, err := c.UpdateBillingOrderWithBody(ctx, orderId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBillingOrderResponse(rsp)
}

func (c *ClientWithResponses) UpdateBillingOrderWithResponse(ctx context.Context, orderId string, params *UpdateBillingOrderParams, body UpdateBillingOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBillingOrderResponse, error) {
	rsp, err := c.UpdateBillingOrder(ctx, orderId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBillingOrderResponse(rsp)
}

// CreateOrderJobWithBodyWithResponse request with arbitrary body returning *CreateOrderJobResponse
func (c *ClientWithResponses) CreateOrderJobWithBodyWithResponse(ctx context.Context, orderId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrderJobResponse, error) {
	rsp, err := c.CreateOrderJobWithBody(ctx, orderId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrderJobResponse(rsp)
}

func (c *ClientWithResponses) CreateOrderJobWithResponse(ctx context.Context, orderId string, body CreateOrderJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrderJobResponse, error) {
	rsp, err := c.CreateOrderJob(ctx, orderId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrderJobResponse(rsp)
}

// GetBillingSupportPlansWithResponse request returning *GetBillingSupportPlansResponse
func (c *ClientWithResponses) GetBillingSupportPlansWithResponse(ctx context.Context, params *GetBillingSupportPlansParams, reqEditors ...RequestEditorFn) (*GetBillingSupportPlansResponse, error) {
	rsp, err := c.GetBillingSupportPlans(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingSupportPlansResponse(rsp)
}

// GetBillingTiersWithResponse request returning *GetBillingTiersResponse
func (c *ClientWithResponses) GetBillingTiersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBillingTiersResponse, error) {
	rsp, err := c.GetBillingTiers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingTiersResponse(rsp)
}

// GetBillingServicesWithResponse request returning *GetBillingServicesResponse
func (c *ClientWithResponses) GetBillingServicesWithResponse(ctx context.Context, params *GetBillingServicesParams, reqEditors ...RequestEditorFn) (*GetBillingServicesResponse, error) {
	rsp, err := c.GetBillingServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingServicesResponse(rsp)
}

// GetBillingOveragesWithResponse request returning *GetBillingOveragesResponse
func (c *ClientWithResponses) GetBillingOveragesWithResponse(ctx context.Context, params *GetBillingOveragesParams, reqEditors ...RequestEditorFn) (*GetBillingOveragesResponse, error) {
	rsp, err := c.GetBillingOverages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingOveragesResponse(rsp)
}

// GetBillingServiceWithResponse request returning *GetBillingServiceResponse
func (c *ClientWithResponses) GetBillingServiceWithResponse(ctx context.Context, servicesId string, reqEditors ...RequestEditorFn) (*GetBillingServiceResponse, error) {
	rsp, err := c.GetBillingService(ctx, servicesId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingServiceResponse(rsp)
}

// GetBillingStatusWithResponse request returning *GetBillingStatusResponse
func (c *ClientWithResponses) GetBillingStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBillingStatusResponse, error) {
	rsp, err := c.GetBillingStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingStatusResponse(rsp)
}

// GetChangelogWithResponse request returning *GetChangelogResponse
func (c *ClientWithResponses) GetChangelogWithResponse(ctx context.Context, params *GetChangelogParams, reqEditors ...RequestEditorFn) (*GetChangelogResponse, error) {
	rsp, err := c.GetChangelog(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChangelogResponse(rsp)
}

// GetContainersWithResponse request returning *GetContainersResponse
func (c *ClientWithResponses) GetContainersWithResponse(ctx context.Context, params *GetContainersParams, reqEditors ...RequestEditorFn) (*GetContainersResponse, error) {
	rsp, err := c.GetContainers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainersResponse(rsp)
}

// CreateContainerWithBodyWithResponse request with arbitrary body returning *CreateContainerResponse
func (c *ClientWithResponses) CreateContainerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContainerResponse, error) {
	rsp, err := c.CreateContainerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContainerResponse(rsp)
}

func (c *ClientWithResponses) CreateContainerWithResponse(ctx context.Context, body CreateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContainerResponse, error) {
	rsp, err := c.CreateContainer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContainerResponse(rsp)
}

// DeleteContainerWithResponse request returning *DeleteContainerResponse
func (c *ClientWithResponses) DeleteContainerWithResponse(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*DeleteContainerResponse, error) {
	rsp, err := c.DeleteContainer(ctx, containerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteContainerResponse(rsp)
}

// GetContainerWithResponse request returning *GetContainerResponse
func (c *ClientWithResponses) GetContainerWithResponse(ctx context.Context, containerId string, params *GetContainerParams, reqEditors ...RequestEditorFn) (*GetContainerResponse, error) {
	rsp, err := c.GetContainer(ctx, containerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerResponse(rsp)
}

// UpdateContainerWithBodyWithResponse request with arbitrary body returning *UpdateContainerResponse
func (c *ClientWithResponses) UpdateContainerWithBodyWithResponse(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContainerResponse, error) {
	rsp, err := c.UpdateContainerWithBody(ctx, containerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContainerResponse(rsp)
}

func (c *ClientWithResponses) UpdateContainerWithResponse(ctx context.Context, containerId string, body UpdateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContainerResponse, error) {
	rsp, err := c.UpdateContainer(ctx, containerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContainerResponse(rsp)
}

// GetContainerBackupsWithResponse request returning *GetContainerBackupsResponse
func (c *ClientWithResponses) GetContainerBackupsWithResponse(ctx context.Context, containerId string, params *GetContainerBackupsParams, reqEditors ...RequestEditorFn) (*GetContainerBackupsResponse, error) {
	rsp, err := c.GetContainerBackups(ctx, containerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerBackupsResponse(rsp)
}

// DeleteContainerBackupWithResponse request returning *DeleteContainerBackupResponse
func (c *ClientWithResponses) DeleteContainerBackupWithResponse(ctx context.Context, containerId string, backupId string, reqEditors ...RequestEditorFn) (*DeleteContainerBackupResponse, error) {
	rsp, err := c.DeleteContainerBackup(ctx, containerId, backupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteContainerBackupResponse(rsp)
}

// GetContainerBackupWithResponse request returning *GetContainerBackupResponse
func (c *ClientWithResponses) GetContainerBackupWithResponse(ctx context.Context, containerId string, backupId string, params *GetContainerBackupParams, reqEditors ...RequestEditorFn) (*GetContainerBackupResponse, error) {
	rsp, err := c.GetContainerBackup(ctx, containerId, backupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerBackupResponse(rsp)
}

// GetContainerBackupLogsWithResponse request returning *GetContainerBackupLogsResponse
func (c *ClientWithResponses) GetContainerBackupLogsWithResponse(ctx context.Context, containerId string, backupId string, reqEditors ...RequestEditorFn) (*GetContainerBackupLogsResponse, error) {
	rsp, err := c.GetContainerBackupLogs(ctx, containerId, backupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerBackupLogsResponse(rsp)
}

// CreateContainerBackupJobWithBodyWithResponse request with arbitrary body returning *CreateContainerBackupJobResponse
func (c *ClientWithResponses) CreateContainerBackupJobWithBodyWithResponse(ctx context.Context, containerId string, backupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContainerBackupJobResponse, error) {
	rsp, err := c.CreateContainerBackupJobWithBody(ctx, containerId, backupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContainerBackupJobResponse(rsp)
}

func (c *ClientWithResponses) CreateContainerBackupJobWithResponse(ctx context.Context, containerId string, backupId string, body CreateContainerBackupJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContainerBackupJobResponse, error) {
	rsp, err := c.CreateContainerBackupJob(ctx, containerId, backupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContainerBackupJobResponse(rsp)
}

// GetCompatibleImagesWithResponse request returning *GetCompatibleImagesResponse
func (c *ClientWithResponses) GetCompatibleImagesWithResponse(ctx context.Context, containerId string, params *GetCompatibleImagesParams, reqEditors ...RequestEditorFn) (*GetCompatibleImagesResponse, error) {
	rsp, err := c.GetCompatibleImages(ctx, containerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompatibleImagesResponse(rsp)
}

// CreateFunctionJobWithBodyWithResponse request with arbitrary body returning *CreateFunctionJobResponse
func (c *ClientWithResponses) CreateFunctionJobWithBodyWithResponse(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFunctionJobResponse, error) {
	rsp, err := c.CreateFunctionJobWithBody(ctx, containerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFunctionJobResponse(rsp)
}

func (c *ClientWithResponses) CreateFunctionJobWithResponse(ctx context.Context, containerId string, body CreateFunctionJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFunctionJobResponse, error) {
	rsp, err := c.CreateFunctionJob(ctx, containerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFunctionJobResponse(rsp)
}

// DeleteContainerInstancesWithResponse request returning *DeleteContainerInstancesResponse
func (c *ClientWithResponses) DeleteContainerInstancesWithResponse(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*DeleteContainerInstancesResponse, error) {
	rsp, err := c.DeleteContainerInstances(ctx, containerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteContainerInstancesResponse(rsp)
}

// GetInstancesWithResponse request returning *GetInstancesResponse
func (c *ClientWithResponses) GetInstancesWithResponse(ctx context.Context, containerId string, params *GetInstancesParams, reqEditors ...RequestEditorFn) (*GetInstancesResponse, error) {
	rsp, err := c.GetInstances(ctx, containerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstancesResponse(rsp)
}

// CreateInstancesWithBodyWithResponse request with arbitrary body returning *CreateInstancesResponse
func (c *ClientWithResponses) CreateInstancesWithBodyWithResponse(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInstancesResponse, error) {
	rsp, err := c.CreateInstancesWithBody(ctx, containerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInstancesResponse(rsp)
}

func (c *ClientWithResponses) CreateInstancesWithResponse(ctx context.Context, containerId string, body CreateInstancesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInstancesResponse, error) {
	rsp, err := c.CreateInstances(ctx, containerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInstancesResponse(rsp)
}

// DeleteInstanceWithResponse request returning *DeleteInstanceResponse
func (c *ClientWithResponses) DeleteInstanceWithResponse(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*DeleteInstanceResponse, error) {
	rsp, err := c.DeleteInstance(ctx, containerId, instanceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInstanceResponse(rsp)
}

// GetInstanceWithResponse request returning *GetInstanceResponse
func (c *ClientWithResponses) GetInstanceWithResponse(ctx context.Context, containerId string, instanceId string, params *GetInstanceParams, reqEditors ...RequestEditorFn) (*GetInstanceResponse, error) {
	rsp, err := c.GetInstance(ctx, containerId, instanceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceResponse(rsp)
}

// GetInstanceConsoleStreamAuthWithResponse request returning *GetInstanceConsoleStreamAuthResponse
func (c *ClientWithResponses) GetInstanceConsoleStreamAuthWithResponse(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*GetInstanceConsoleStreamAuthResponse, error) {
	rsp, err := c.GetInstanceConsoleStreamAuth(ctx, containerId, instanceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceConsoleStreamAuthResponse(rsp)
}

// ExpireInstanceSSHCredentialsWithResponse request returning *ExpireInstanceSSHCredentialsResponse
func (c *ClientWithResponses) ExpireInstanceSSHCredentialsWithResponse(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*ExpireInstanceSSHCredentialsResponse, error) {
	rsp, err := c.ExpireInstanceSSHCredentials(ctx, containerId, instanceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpireInstanceSSHCredentialsResponse(rsp)
}

// GenerateInstanceSSHCredentialsWithResponse request returning *GenerateInstanceSSHCredentialsResponse
func (c *ClientWithResponses) GenerateInstanceSSHCredentialsWithResponse(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*GenerateInstanceSSHCredentialsResponse, error) {
	rsp, err := c.GenerateInstanceSSHCredentials(ctx, containerId, instanceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateInstanceSSHCredentialsResponse(rsp)
}

// CreateInstanceJobWithBodyWithResponse request with arbitrary body returning *CreateInstanceJobResponse
func (c *ClientWithResponses) CreateInstanceJobWithBodyWithResponse(ctx context.Context, containerId string, instanceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInstanceJobResponse, error) {
	rsp, err := c.CreateInstanceJobWithBody(ctx, containerId, instanceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInstanceJobResponse(rsp)
}

func (c *ClientWithResponses) CreateInstanceJobWithResponse(ctx context.Context, containerId string, instanceId string, body CreateInstanceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInstanceJobResponse, error) {
	rsp, err := c.CreateInstanceJob(ctx, containerId, instanceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInstanceJobResponse(rsp)
}

// GetInstanceTelemetryReportWithResponse request returning *GetInstanceTelemetryReportResponse
func (c *ClientWithResponses) GetInstanceTelemetryReportWithResponse(ctx context.Context, containerId string, instanceId string, params *GetInstanceTelemetryReportParams, reqEditors ...RequestEditorFn) (*GetInstanceTelemetryReportResponse, error) {
	rsp, err := c.GetInstanceTelemetryReport(ctx, containerId, instanceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceTelemetryReportResponse(rsp)
}

// GetInstanceTelemetryStreamAuthWithResponse request returning *GetInstanceTelemetryStreamAuthResponse
func (c *ClientWithResponses) GetInstanceTelemetryStreamAuthWithResponse(ctx context.Context, containerId string, instanceId string, reqEditors ...RequestEditorFn) (*GetInstanceTelemetryStreamAuthResponse, error) {
	rsp, err := c.GetInstanceTelemetryStreamAuth(ctx, containerId, instanceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceTelemetryStreamAuthResponse(rsp)
}

// GetInstanceVolumesWithResponse request returning *GetInstanceVolumesResponse
func (c *ClientWithResponses) GetInstanceVolumesWithResponse(ctx context.Context, containerId string, instanceId string, params *GetInstanceVolumesParams, reqEditors ...RequestEditorFn) (*GetInstanceVolumesResponse, error) {
	rsp, err := c.GetInstanceVolumes(ctx, containerId, instanceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInstanceVolumesResponse(rsp)
}

// GetContainerServersWithResponse request returning *GetContainerServersResponse
func (c *ClientWithResponses) GetContainerServersWithResponse(ctx context.Context, containerId string, params *GetContainerServersParams, reqEditors ...RequestEditorFn) (*GetContainerServersResponse, error) {
	rsp, err := c.GetContainerServers(ctx, containerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerServersResponse(rsp)
}

// GetCompatibleServersWithResponse request returning *GetCompatibleServersResponse
func (c *ClientWithResponses) GetCompatibleServersWithResponse(ctx context.Context, containerId string, params *GetCompatibleServersParams, reqEditors ...RequestEditorFn) (*GetCompatibleServersResponse, error) {
	rsp, err := c.GetCompatibleServers(ctx, containerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCompatibleServersResponse(rsp)
}

// GetContainerSummaryWithResponse request returning *GetContainerSummaryResponse
func (c *ClientWithResponses) GetContainerSummaryWithResponse(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*GetContainerSummaryResponse, error) {
	rsp, err := c.GetContainerSummary(ctx, containerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerSummaryResponse(rsp)
}

// CreateContainerJobWithBodyWithResponse request with arbitrary body returning *CreateContainerJobResponse
func (c *ClientWithResponses) CreateContainerJobWithBodyWithResponse(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContainerJobResponse, error) {
	rsp, err := c.CreateContainerJobWithBody(ctx, containerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContainerJobResponse(rsp)
}

func (c *ClientWithResponses) CreateContainerJobWithResponse(ctx context.Context, containerId string, body CreateContainerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContainerJobResponse, error) {
	rsp, err := c.CreateContainerJob(ctx, containerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContainerJobResponse(rsp)
}

// GetTLSGenerationAttemptsWithResponse request returning *GetTLSGenerationAttemptsResponse
func (c *ClientWithResponses) GetTLSGenerationAttemptsWithResponse(ctx context.Context, params *GetTLSGenerationAttemptsParams, reqEditors ...RequestEditorFn) (*GetTLSGenerationAttemptsResponse, error) {
	rsp, err := c.GetTLSGenerationAttempts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTLSGenerationAttemptsResponse(rsp)
}

// LookupTLSCertificateWithResponse request returning *LookupTLSCertificateResponse
func (c *ClientWithResponses) LookupTLSCertificateWithResponse(ctx context.Context, params *LookupTLSCertificateParams, reqEditors ...RequestEditorFn) (*LookupTLSCertificateResponse, error) {
	rsp, err := c.LookupTLSCertificate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLookupTLSCertificateResponse(rsp)
}

// GetUserSuppliedCertificatesWithResponse request returning *GetUserSuppliedCertificatesResponse
func (c *ClientWithResponses) GetUserSuppliedCertificatesWithResponse(ctx context.Context, params *GetUserSuppliedCertificatesParams, reqEditors ...RequestEditorFn) (*GetUserSuppliedCertificatesResponse, error) {
	rsp, err := c.GetUserSuppliedCertificates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserSuppliedCertificatesResponse(rsp)
}

// UploadUserSuppliedCertificateWithBodyWithResponse request with arbitrary body returning *UploadUserSuppliedCertificateResponse
func (c *ClientWithResponses) UploadUserSuppliedCertificateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadUserSuppliedCertificateResponse, error) {
	rsp, err := c.UploadUserSuppliedCertificateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadUserSuppliedCertificateResponse(rsp)
}

func (c *ClientWithResponses) UploadUserSuppliedCertificateWithResponse(ctx context.Context, body UploadUserSuppliedCertificateJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadUserSuppliedCertificateResponse, error) {
	rsp, err := c.UploadUserSuppliedCertificate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadUserSuppliedCertificateResponse(rsp)
}

// GetUserSuppliedCertificateWithResponse request returning *GetUserSuppliedCertificateResponse
func (c *ClientWithResponses) GetUserSuppliedCertificateWithResponse(ctx context.Context, certificateId string, reqEditors ...RequestEditorFn) (*GetUserSuppliedCertificateResponse, error) {
	rsp, err := c.GetUserSuppliedCertificate(ctx, certificateId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserSuppliedCertificateResponse(rsp)
}

// CreateUserSuppliedCertificateJobWithBodyWithResponse request with arbitrary body returning *CreateUserSuppliedCertificateJobResponse
func (c *ClientWithResponses) CreateUserSuppliedCertificateJobWithBodyWithResponse(ctx context.Context, certificateId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserSuppliedCertificateJobResponse, error) {
	rsp, err := c.CreateUserSuppliedCertificateJobWithBody(ctx, certificateId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserSuppliedCertificateJobResponse(rsp)
}

func (c *ClientWithResponses) CreateUserSuppliedCertificateJobWithResponse(ctx context.Context, certificateId string, body CreateUserSuppliedCertificateJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserSuppliedCertificateJobResponse, error) {
	rsp, err := c.CreateUserSuppliedCertificateJob(ctx, certificateId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserSuppliedCertificateJobResponse(rsp)
}

// GetDNSZonesWithResponse request returning *GetDNSZonesResponse
func (c *ClientWithResponses) GetDNSZonesWithResponse(ctx context.Context, params *GetDNSZonesParams, reqEditors ...RequestEditorFn) (*GetDNSZonesResponse, error) {
	rsp, err := c.GetDNSZones(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDNSZonesResponse(rsp)
}

// CreateDNSZoneWithBodyWithResponse request with arbitrary body returning *CreateDNSZoneResponse
func (c *ClientWithResponses) CreateDNSZoneWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNSZoneResponse, error) {
	rsp, err := c.CreateDNSZoneWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNSZoneResponse(rsp)
}

func (c *ClientWithResponses) CreateDNSZoneWithResponse(ctx context.Context, body CreateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNSZoneResponse, error) {
	rsp, err := c.CreateDNSZone(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNSZoneResponse(rsp)
}

// DeleteDNSZoneWithResponse request returning *DeleteDNSZoneResponse
func (c *ClientWithResponses) DeleteDNSZoneWithResponse(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*DeleteDNSZoneResponse, error) {
	rsp, err := c.DeleteDNSZone(ctx, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDNSZoneResponse(rsp)
}

// GetDNSZoneWithResponse request returning *GetDNSZoneResponse
func (c *ClientWithResponses) GetDNSZoneWithResponse(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*GetDNSZoneResponse, error) {
	rsp, err := c.GetDNSZone(ctx, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDNSZoneResponse(rsp)
}

// UpdateDNSZoneWithBodyWithResponse request with arbitrary body returning *UpdateDNSZoneResponse
func (c *ClientWithResponses) UpdateDNSZoneWithBodyWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNSZoneResponse, error) {
	rsp, err := c.UpdateDNSZoneWithBody(ctx, zoneId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNSZoneResponse(rsp)
}

func (c *ClientWithResponses) UpdateDNSZoneWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, body UpdateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNSZoneResponse, error) {
	rsp, err := c.UpdateDNSZone(ctx, zoneId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNSZoneResponse(rsp)
}

// UpdateDNSZoneAccessWithBodyWithResponse request with arbitrary body returning *UpdateDNSZoneAccessResponse
func (c *ClientWithResponses) UpdateDNSZoneAccessWithBodyWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNSZoneAccessResponse, error) {
	rsp, err := c.UpdateDNSZoneAccessWithBody(ctx, zoneId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNSZoneAccessResponse(rsp)
}

func (c *ClientWithResponses) UpdateDNSZoneAccessWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, body UpdateDNSZoneAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNSZoneAccessResponse, error) {
	rsp, err := c.UpdateDNSZoneAccess(ctx, zoneId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNSZoneAccessResponse(rsp)
}

// GetDNSZoneRecordsWithResponse request returning *GetDNSZoneRecordsResponse
func (c *ClientWithResponses) GetDNSZoneRecordsWithResponse(ctx context.Context, zoneId string, params *GetDNSZoneRecordsParams, reqEditors ...RequestEditorFn) (*GetDNSZoneRecordsResponse, error) {
	rsp, err := c.GetDNSZoneRecords(ctx, zoneId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDNSZoneRecordsResponse(rsp)
}

// CreateDNSZoneRecordWithBodyWithResponse request with arbitrary body returning *CreateDNSZoneRecordResponse
func (c *ClientWithResponses) CreateDNSZoneRecordWithBodyWithResponse(ctx context.Context, zoneId string, params *CreateDNSZoneRecordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNSZoneRecordResponse, error) {
	rsp, err := c.CreateDNSZoneRecordWithBody(ctx, zoneId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNSZoneRecordResponse(rsp)
}

func (c *ClientWithResponses) CreateDNSZoneRecordWithResponse(ctx context.Context, zoneId string, params *CreateDNSZoneRecordParams, body CreateDNSZoneRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNSZoneRecordResponse, error) {
	rsp, err := c.CreateDNSZoneRecord(ctx, zoneId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNSZoneRecordResponse(rsp)
}

// DeleteDNSZoneRecordWithResponse request returning *DeleteDNSZoneRecordResponse
func (c *ClientWithResponses) DeleteDNSZoneRecordWithResponse(ctx context.Context, zoneId string, recordId string, reqEditors ...RequestEditorFn) (*DeleteDNSZoneRecordResponse, error) {
	rsp, err := c.DeleteDNSZoneRecord(ctx, zoneId, recordId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDNSZoneRecordResponse(rsp)
}

// UpdateDNSZoneRecordWithBodyWithResponse request with arbitrary body returning *UpdateDNSZoneRecordResponse
func (c *ClientWithResponses) UpdateDNSZoneRecordWithBodyWithResponse(ctx context.Context, zoneId string, recordId string, params *UpdateDNSZoneRecordParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNSZoneRecordResponse, error) {
	rsp, err := c.UpdateDNSZoneRecordWithBody(ctx, zoneId, recordId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNSZoneRecordResponse(rsp)
}

func (c *ClientWithResponses) UpdateDNSZoneRecordWithResponse(ctx context.Context, zoneId string, recordId string, params *UpdateDNSZoneRecordParams, body UpdateDNSZoneRecordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNSZoneRecordResponse, error) {
	rsp, err := c.UpdateDNSZoneRecord(ctx, zoneId, recordId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNSZoneRecordResponse(rsp)
}

// CreateDNSZoneRecordJobWithBodyWithResponse request with arbitrary body returning *CreateDNSZoneRecordJobResponse
func (c *ClientWithResponses) CreateDNSZoneRecordJobWithBodyWithResponse(ctx context.Context, zoneId string, recordId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNSZoneRecordJobResponse, error) {
	rsp, err := c.CreateDNSZoneRecordJobWithBody(ctx, zoneId, recordId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNSZoneRecordJobResponse(rsp)
}

func (c *ClientWithResponses) CreateDNSZoneRecordJobWithResponse(ctx context.Context, zoneId string, recordId string, body CreateDNSZoneRecordJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNSZoneRecordJobResponse, error) {
	rsp, err := c.CreateDNSZoneRecordJob(ctx, zoneId, recordId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNSZoneRecordJobResponse(rsp)
}

// CreateDNSZoneJobWithBodyWithResponse request with arbitrary body returning *CreateDNSZoneJobResponse
func (c *ClientWithResponses) CreateDNSZoneJobWithBodyWithResponse(ctx context.Context, zoneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNSZoneJobResponse, error) {
	rsp, err := c.CreateDNSZoneJobWithBody(ctx, zoneId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNSZoneJobResponse(rsp)
}

func (c *ClientWithResponses) CreateDNSZoneJobWithResponse(ctx context.Context, zoneId string, body CreateDNSZoneJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNSZoneJobResponse, error) {
	rsp, err := c.CreateDNSZoneJob(ctx, zoneId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNSZoneJobResponse(rsp)
}

// GetEnvironmentsWithResponse request returning *GetEnvironmentsResponse
func (c *ClientWithResponses) GetEnvironmentsWithResponse(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*GetEnvironmentsResponse, error) {
	rsp, err := c.GetEnvironments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentsResponse(rsp)
}

// CreateEnvironmentWithBodyWithResponse request with arbitrary body returning *CreateEnvironmentResponse
func (c *ClientWithResponses) CreateEnvironmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvironmentResponse, error) {
	rsp, err := c.CreateEnvironmentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvironmentResponse(rsp)
}

func (c *ClientWithResponses) CreateEnvironmentWithResponse(ctx context.Context, body CreateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvironmentResponse, error) {
	rsp, err := c.CreateEnvironment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvironmentResponse(rsp)
}

// DeleteEnvironmentWithResponse request returning *DeleteEnvironmentResponse
func (c *ClientWithResponses) DeleteEnvironmentWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*DeleteEnvironmentResponse, error) {
	rsp, err := c.DeleteEnvironment(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEnvironmentResponse(rsp)
}

// GetEnvironmentWithResponse request returning *GetEnvironmentResponse
func (c *ClientWithResponses) GetEnvironmentWithResponse(ctx context.Context, environmentId string, params *GetEnvironmentParams, reqEditors ...RequestEditorFn) (*GetEnvironmentResponse, error) {
	rsp, err := c.GetEnvironment(ctx, environmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentResponse(rsp)
}

// UpdateEnvironmentWithBodyWithResponse request with arbitrary body returning *UpdateEnvironmentResponse
func (c *ClientWithResponses) UpdateEnvironmentWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvironmentResponse, error) {
	rsp, err := c.UpdateEnvironmentWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvironmentResponse(rsp)
}

func (c *ClientWithResponses) UpdateEnvironmentWithResponse(ctx context.Context, environmentId string, body UpdateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvironmentResponse, error) {
	rsp, err := c.UpdateEnvironment(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvironmentResponse(rsp)
}

// UpdateEnvironmentAccessWithBodyWithResponse request with arbitrary body returning *UpdateEnvironmentAccessResponse
func (c *ClientWithResponses) UpdateEnvironmentAccessWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvironmentAccessResponse, error) {
	rsp, err := c.UpdateEnvironmentAccessWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvironmentAccessResponse(rsp)
}

func (c *ClientWithResponses) UpdateEnvironmentAccessWithResponse(ctx context.Context, environmentId string, body UpdateEnvironmentAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvironmentAccessResponse, error) {
	rsp, err := c.UpdateEnvironmentAccess(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvironmentAccessResponse(rsp)
}

// GetEnvironmentDeploymentsWithResponse request returning *GetEnvironmentDeploymentsResponse
func (c *ClientWithResponses) GetEnvironmentDeploymentsWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*GetEnvironmentDeploymentsResponse, error) {
	rsp, err := c.GetEnvironmentDeployments(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentDeploymentsResponse(rsp)
}

// ExportStackWithBodyWithResponse request with arbitrary body returning *ExportStackResponse
func (c *ClientWithResponses) ExportStackWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportStackResponse, error) {
	rsp, err := c.ExportStackWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportStackResponse(rsp)
}

func (c *ClientWithResponses) ExportStackWithResponse(ctx context.Context, environmentId string, body ExportStackJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportStackResponse, error) {
	rsp, err := c.ExportStack(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportStackResponse(rsp)
}

// GetScopedVariablesWithResponse request returning *GetScopedVariablesResponse
func (c *ClientWithResponses) GetScopedVariablesWithResponse(ctx context.Context, environmentId string, params *GetScopedVariablesParams, reqEditors ...RequestEditorFn) (*GetScopedVariablesResponse, error) {
	rsp, err := c.GetScopedVariables(ctx, environmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScopedVariablesResponse(rsp)
}

// CreateScopedVariableWithBodyWithResponse request with arbitrary body returning *CreateScopedVariableResponse
func (c *ClientWithResponses) CreateScopedVariableWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateScopedVariableResponse, error) {
	rsp, err := c.CreateScopedVariableWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScopedVariableResponse(rsp)
}

func (c *ClientWithResponses) CreateScopedVariableWithResponse(ctx context.Context, environmentId string, body CreateScopedVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateScopedVariableResponse, error) {
	rsp, err := c.CreateScopedVariable(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateScopedVariableResponse(rsp)
}

// DeleteScopedVariableWithResponse request returning *DeleteScopedVariableResponse
func (c *ClientWithResponses) DeleteScopedVariableWithResponse(ctx context.Context, environmentId string, scopedVariableId string, reqEditors ...RequestEditorFn) (*DeleteScopedVariableResponse, error) {
	rsp, err := c.DeleteScopedVariable(ctx, environmentId, scopedVariableId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteScopedVariableResponse(rsp)
}

// GetScopedVariableWithResponse request returning *GetScopedVariableResponse
func (c *ClientWithResponses) GetScopedVariableWithResponse(ctx context.Context, environmentId string, scopedVariableId string, reqEditors ...RequestEditorFn) (*GetScopedVariableResponse, error) {
	rsp, err := c.GetScopedVariable(ctx, environmentId, scopedVariableId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScopedVariableResponse(rsp)
}

// UpdateScopedVariableWithBodyWithResponse request with arbitrary body returning *UpdateScopedVariableResponse
func (c *ClientWithResponses) UpdateScopedVariableWithBodyWithResponse(ctx context.Context, environmentId string, scopedVariableId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScopedVariableResponse, error) {
	rsp, err := c.UpdateScopedVariableWithBody(ctx, environmentId, scopedVariableId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScopedVariableResponse(rsp)
}

func (c *ClientWithResponses) UpdateScopedVariableWithResponse(ctx context.Context, environmentId string, scopedVariableId string, body UpdateScopedVariableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScopedVariableResponse, error) {
	rsp, err := c.UpdateScopedVariable(ctx, environmentId, scopedVariableId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScopedVariableResponse(rsp)
}

// CreateDiscoveryServiceJobWithBodyWithResponse request with arbitrary body returning *CreateDiscoveryServiceJobResponse
func (c *ClientWithResponses) CreateDiscoveryServiceJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDiscoveryServiceJobResponse, error) {
	rsp, err := c.CreateDiscoveryServiceJobWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDiscoveryServiceJobResponse(rsp)
}

func (c *ClientWithResponses) CreateDiscoveryServiceJobWithResponse(ctx context.Context, environmentId string, body CreateDiscoveryServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDiscoveryServiceJobResponse, error) {
	rsp, err := c.CreateDiscoveryServiceJob(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDiscoveryServiceJobResponse(rsp)
}

// CreateGatewayServiceJobWithBodyWithResponse request with arbitrary body returning *CreateGatewayServiceJobResponse
func (c *ClientWithResponses) CreateGatewayServiceJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGatewayServiceJobResponse, error) {
	rsp, err := c.CreateGatewayServiceJobWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGatewayServiceJobResponse(rsp)
}

func (c *ClientWithResponses) CreateGatewayServiceJobWithResponse(ctx context.Context, environmentId string, body CreateGatewayServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGatewayServiceJobResponse, error) {
	rsp, err := c.CreateGatewayServiceJob(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGatewayServiceJobResponse(rsp)
}

// GetLoadBalancerServiceWithResponse request returning *GetLoadBalancerServiceResponse
func (c *ClientWithResponses) GetLoadBalancerServiceWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*GetLoadBalancerServiceResponse, error) {
	rsp, err := c.GetLoadBalancerService(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoadBalancerServiceResponse(rsp)
}

// CreateLoadBalancerServiceJobWithBodyWithResponse request with arbitrary body returning *CreateLoadBalancerServiceJobResponse
func (c *ClientWithResponses) CreateLoadBalancerServiceJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLoadBalancerServiceJobResponse, error) {
	rsp, err := c.CreateLoadBalancerServiceJobWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerServiceJobResponse(rsp)
}

func (c *ClientWithResponses) CreateLoadBalancerServiceJobWithResponse(ctx context.Context, environmentId string, body CreateLoadBalancerServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLoadBalancerServiceJobResponse, error) {
	rsp, err := c.CreateLoadBalancerServiceJob(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLoadBalancerServiceJobResponse(rsp)
}

// GetLoadBalancerLatestTelemetryReportWithResponse request returning *GetLoadBalancerLatestTelemetryReportResponse
func (c *ClientWithResponses) GetLoadBalancerLatestTelemetryReportWithResponse(ctx context.Context, environmentId string, params *GetLoadBalancerLatestTelemetryReportParams, reqEditors ...RequestEditorFn) (*GetLoadBalancerLatestTelemetryReportResponse, error) {
	rsp, err := c.GetLoadBalancerLatestTelemetryReport(ctx, environmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoadBalancerLatestTelemetryReportResponse(rsp)
}

// GetLoadBalancerTelemetryLatestControllersWithResponse request returning *GetLoadBalancerTelemetryLatestControllersResponse
func (c *ClientWithResponses) GetLoadBalancerTelemetryLatestControllersWithResponse(ctx context.Context, environmentId string, params *GetLoadBalancerTelemetryLatestControllersParams, reqEditors ...RequestEditorFn) (*GetLoadBalancerTelemetryLatestControllersResponse, error) {
	rsp, err := c.GetLoadBalancerTelemetryLatestControllers(ctx, environmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoadBalancerTelemetryLatestControllersResponse(rsp)
}

// GetLoadBalancerTelemetryReportWithResponse request returning *GetLoadBalancerTelemetryReportResponse
func (c *ClientWithResponses) GetLoadBalancerTelemetryReportWithResponse(ctx context.Context, environmentId string, params *GetLoadBalancerTelemetryReportParams, reqEditors ...RequestEditorFn) (*GetLoadBalancerTelemetryReportResponse, error) {
	rsp, err := c.GetLoadBalancerTelemetryReport(ctx, environmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoadBalancerTelemetryReportResponse(rsp)
}

// CreateSchedulerServiceJobWithBodyWithResponse request with arbitrary body returning *CreateSchedulerServiceJobResponse
func (c *ClientWithResponses) CreateSchedulerServiceJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSchedulerServiceJobResponse, error) {
	rsp, err := c.CreateSchedulerServiceJobWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSchedulerServiceJobResponse(rsp)
}

func (c *ClientWithResponses) CreateSchedulerServiceJobWithResponse(ctx context.Context, environmentId string, body CreateSchedulerServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSchedulerServiceJobResponse, error) {
	rsp, err := c.CreateSchedulerServiceJob(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSchedulerServiceJobResponse(rsp)
}

// GetVPNServiceWithResponse request returning *GetVPNServiceResponse
func (c *ClientWithResponses) GetVPNServiceWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*GetVPNServiceResponse, error) {
	rsp, err := c.GetVPNService(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVPNServiceResponse(rsp)
}

// GetVPNLoginsWithResponse request returning *GetVPNLoginsResponse
func (c *ClientWithResponses) GetVPNLoginsWithResponse(ctx context.Context, environmentId string, params *GetVPNLoginsParams, reqEditors ...RequestEditorFn) (*GetVPNLoginsResponse, error) {
	rsp, err := c.GetVPNLogins(ctx, environmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVPNLoginsResponse(rsp)
}

// CreateVPNServiceJobWithBodyWithResponse request with arbitrary body returning *CreateVPNServiceJobResponse
func (c *ClientWithResponses) CreateVPNServiceJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVPNServiceJobResponse, error) {
	rsp, err := c.CreateVPNServiceJobWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVPNServiceJobResponse(rsp)
}

func (c *ClientWithResponses) CreateVPNServiceJobWithResponse(ctx context.Context, environmentId string, body CreateVPNServiceJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVPNServiceJobResponse, error) {
	rsp, err := c.CreateVPNServiceJob(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVPNServiceJobResponse(rsp)
}

// GetVPNUsersWithResponse request returning *GetVPNUsersResponse
func (c *ClientWithResponses) GetVPNUsersWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*GetVPNUsersResponse, error) {
	rsp, err := c.GetVPNUsers(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVPNUsersResponse(rsp)
}

// CreateVPNUserWithBodyWithResponse request with arbitrary body returning *CreateVPNUserResponse
func (c *ClientWithResponses) CreateVPNUserWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVPNUserResponse, error) {
	rsp, err := c.CreateVPNUserWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVPNUserResponse(rsp)
}

func (c *ClientWithResponses) CreateVPNUserWithResponse(ctx context.Context, environmentId string, body CreateVPNUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVPNUserResponse, error) {
	rsp, err := c.CreateVPNUser(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVPNUserResponse(rsp)
}

// DeleteVPNUserWithResponse request returning *DeleteVPNUserResponse
func (c *ClientWithResponses) DeleteVPNUserWithResponse(ctx context.Context, environmentId string, userId string, reqEditors ...RequestEditorFn) (*DeleteVPNUserResponse, error) {
	rsp, err := c.DeleteVPNUser(ctx, environmentId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVPNUserResponse(rsp)
}

// GetEnvironmentSummaryWithResponse request returning *GetEnvironmentSummaryResponse
func (c *ClientWithResponses) GetEnvironmentSummaryWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*GetEnvironmentSummaryResponse, error) {
	rsp, err := c.GetEnvironmentSummary(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentSummaryResponse(rsp)
}

// CreateEnvironmentJobWithBodyWithResponse request with arbitrary body returning *CreateEnvironmentJobResponse
func (c *ClientWithResponses) CreateEnvironmentJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvironmentJobResponse, error) {
	rsp, err := c.CreateEnvironmentJobWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvironmentJobResponse(rsp)
}

func (c *ClientWithResponses) CreateEnvironmentJobWithResponse(ctx context.Context, environmentId string, body CreateEnvironmentJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvironmentJobResponse, error) {
	rsp, err := c.CreateEnvironmentJob(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvironmentJobResponse(rsp)
}

// GetHubsWithResponse request returning *GetHubsResponse
func (c *ClientWithResponses) GetHubsWithResponse(ctx context.Context, params *GetHubsParams, reqEditors ...RequestEditorFn) (*GetHubsResponse, error) {
	rsp, err := c.GetHubs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubsResponse(rsp)
}

// CreateHubWithBodyWithResponse request with arbitrary body returning *CreateHubResponse
func (c *ClientWithResponses) CreateHubWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHubResponse, error) {
	rsp, err := c.CreateHubWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHubResponse(rsp)
}

func (c *ClientWithResponses) CreateHubWithResponse(ctx context.Context, body CreateHubJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHubResponse, error) {
	rsp, err := c.CreateHub(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHubResponse(rsp)
}

// GetHubCapabilitiesWithResponse request returning *GetHubCapabilitiesResponse
func (c *ClientWithResponses) GetHubCapabilitiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHubCapabilitiesResponse, error) {
	rsp, err := c.GetHubCapabilities(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubCapabilitiesResponse(rsp)
}

// DeleteHubWithBodyWithResponse request with arbitrary body returning *DeleteHubResponse
func (c *ClientWithResponses) DeleteHubWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteHubResponse, error) {
	rsp, err := c.DeleteHubWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHubResponse(rsp)
}

func (c *ClientWithResponses) DeleteHubWithResponse(ctx context.Context, body DeleteHubJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteHubResponse, error) {
	rsp, err := c.DeleteHub(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHubResponse(rsp)
}

// GetHubWithResponse request returning *GetHubResponse
func (c *ClientWithResponses) GetHubWithResponse(ctx context.Context, params *GetHubParams, reqEditors ...RequestEditorFn) (*GetHubResponse, error) {
	rsp, err := c.GetHub(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubResponse(rsp)
}

// UpdateHubWithBodyWithResponse request with arbitrary body returning *UpdateHubResponse
func (c *ClientWithResponses) UpdateHubWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateHubResponse, error) {
	rsp, err := c.UpdateHubWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateHubResponse(rsp)
}

func (c *ClientWithResponses) UpdateHubWithResponse(ctx context.Context, body UpdateHubJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateHubResponse, error) {
	rsp, err := c.UpdateHub(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateHubResponse(rsp)
}

// GetHubActivityWithResponse request returning *GetHubActivityResponse
func (c *ClientWithResponses) GetHubActivityWithResponse(ctx context.Context, params *GetHubActivityParams, reqEditors ...RequestEditorFn) (*GetHubActivityResponse, error) {
	rsp, err := c.GetHubActivity(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubActivityResponse(rsp)
}

// GetApiKeysWithResponse request returning *GetApiKeysResponse
func (c *ClientWithResponses) GetApiKeysWithResponse(ctx context.Context, params *GetApiKeysParams, reqEditors ...RequestEditorFn) (*GetApiKeysResponse, error) {
	rsp, err := c.GetApiKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiKeysResponse(rsp)
}

// CreateApiKeyWithBodyWithResponse request with arbitrary body returning *CreateApiKeyResponse
func (c *ClientWithResponses) CreateApiKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error) {
	rsp, err := c.CreateApiKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateApiKeyWithResponse(ctx context.Context, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error) {
	rsp, err := c.CreateApiKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyResponse(rsp)
}

// DeleteAPIKeyWithResponse request returning *DeleteAPIKeyResponse
func (c *ClientWithResponses) DeleteAPIKeyWithResponse(ctx context.Context, apikeyId string, reqEditors ...RequestEditorFn) (*DeleteAPIKeyResponse, error) {
	rsp, err := c.DeleteAPIKey(ctx, apikeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAPIKeyResponse(rsp)
}

// GetAPIKeyWithResponse request returning *GetAPIKeyResponse
func (c *ClientWithResponses) GetAPIKeyWithResponse(ctx context.Context, apikeyId string, params *GetAPIKeyParams, reqEditors ...RequestEditorFn) (*GetAPIKeyResponse, error) {
	rsp, err := c.GetAPIKey(ctx, apikeyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAPIKeyResponse(rsp)
}

// UpdateAPIKeyWithBodyWithResponse request with arbitrary body returning *UpdateAPIKeyResponse
func (c *ClientWithResponses) UpdateAPIKeyWithBodyWithResponse(ctx context.Context, apikeyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAPIKeyResponse, error) {
	rsp, err := c.UpdateAPIKeyWithBody(ctx, apikeyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAPIKeyResponse(rsp)
}

func (c *ClientWithResponses) UpdateAPIKeyWithResponse(ctx context.Context, apikeyId string, body UpdateAPIKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAPIKeyResponse, error) {
	rsp, err := c.UpdateAPIKey(ctx, apikeyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAPIKeyResponse(rsp)
}

// GetIntegrationsWithResponse request returning *GetIntegrationsResponse
func (c *ClientWithResponses) GetIntegrationsWithResponse(ctx context.Context, params *GetIntegrationsParams, reqEditors ...RequestEditorFn) (*GetIntegrationsResponse, error) {
	rsp, err := c.GetIntegrations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationsResponse(rsp)
}

// CreateIntegrationWithBodyWithResponse request with arbitrary body returning *CreateIntegrationResponse
func (c *ClientWithResponses) CreateIntegrationWithBodyWithResponse(ctx context.Context, params *CreateIntegrationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationResponse, error) {
	rsp, err := c.CreateIntegrationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationResponse(rsp)
}

func (c *ClientWithResponses) CreateIntegrationWithResponse(ctx context.Context, params *CreateIntegrationParams, body CreateIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationResponse, error) {
	rsp, err := c.CreateIntegration(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationResponse(rsp)
}

// GetAvailableIntegrationsWithResponse request returning *GetAvailableIntegrationsResponse
func (c *ClientWithResponses) GetAvailableIntegrationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAvailableIntegrationsResponse, error) {
	rsp, err := c.GetAvailableIntegrations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableIntegrationsResponse(rsp)
}

// DeleteIntegrationWithResponse request returning *DeleteIntegrationResponse
func (c *ClientWithResponses) DeleteIntegrationWithResponse(ctx context.Context, integrationId string, reqEditors ...RequestEditorFn) (*DeleteIntegrationResponse, error) {
	rsp, err := c.DeleteIntegration(ctx, integrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIntegrationResponse(rsp)
}

// GetIntegrationWithResponse request returning *GetIntegrationResponse
func (c *ClientWithResponses) GetIntegrationWithResponse(ctx context.Context, integrationId string, params *GetIntegrationParams, reqEditors ...RequestEditorFn) (*GetIntegrationResponse, error) {
	rsp, err := c.GetIntegration(ctx, integrationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIntegrationResponse(rsp)
}

// UpdateIntegrationWithBodyWithResponse request with arbitrary body returning *UpdateIntegrationResponse
func (c *ClientWithResponses) UpdateIntegrationWithBodyWithResponse(ctx context.Context, integrationId string, params *UpdateIntegrationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIntegrationResponse, error) {
	rsp, err := c.UpdateIntegrationWithBody(ctx, integrationId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIntegrationResponse(rsp)
}

func (c *ClientWithResponses) UpdateIntegrationWithResponse(ctx context.Context, integrationId string, params *UpdateIntegrationParams, body UpdateIntegrationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIntegrationResponse, error) {
	rsp, err := c.UpdateIntegration(ctx, integrationId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIntegrationResponse(rsp)
}

// CreateIntegrationJobWithBodyWithResponse request with arbitrary body returning *CreateIntegrationJobResponse
func (c *ClientWithResponses) CreateIntegrationJobWithBodyWithResponse(ctx context.Context, integrationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIntegrationJobResponse, error) {
	rsp, err := c.CreateIntegrationJobWithBody(ctx, integrationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationJobResponse(rsp)
}

func (c *ClientWithResponses) CreateIntegrationJobWithResponse(ctx context.Context, integrationId string, body CreateIntegrationJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIntegrationJobResponse, error) {
	rsp, err := c.CreateIntegrationJob(ctx, integrationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIntegrationJobResponse(rsp)
}

// GetHubInvitesWithResponse request returning *GetHubInvitesResponse
func (c *ClientWithResponses) GetHubInvitesWithResponse(ctx context.Context, params *GetHubInvitesParams, reqEditors ...RequestEditorFn) (*GetHubInvitesResponse, error) {
	rsp, err := c.GetHubInvites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubInvitesResponse(rsp)
}

// CreateHubInviteWithBodyWithResponse request with arbitrary body returning *CreateHubInviteResponse
func (c *ClientWithResponses) CreateHubInviteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHubInviteResponse, error) {
	rsp, err := c.CreateHubInviteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHubInviteResponse(rsp)
}

func (c *ClientWithResponses) CreateHubInviteWithResponse(ctx context.Context, body CreateHubInviteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHubInviteResponse, error) {
	rsp, err := c.CreateHubInvite(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHubInviteResponse(rsp)
}

// DeleteHubInviteWithResponse request returning *DeleteHubInviteResponse
func (c *ClientWithResponses) DeleteHubInviteWithResponse(ctx context.Context, inviteId string, reqEditors ...RequestEditorFn) (*DeleteHubInviteResponse, error) {
	rsp, err := c.DeleteHubInvite(ctx, inviteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHubInviteResponse(rsp)
}

// GetHubMembersWithResponse request returning *GetHubMembersResponse
func (c *ClientWithResponses) GetHubMembersWithResponse(ctx context.Context, params *GetHubMembersParams, reqEditors ...RequestEditorFn) (*GetHubMembersResponse, error) {
	rsp, err := c.GetHubMembers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubMembersResponse(rsp)
}

// GetHubMemberAccountWithResponse request returning *GetHubMemberAccountResponse
func (c *ClientWithResponses) GetHubMemberAccountWithResponse(ctx context.Context, accountId string, params *GetHubMemberAccountParams, reqEditors ...RequestEditorFn) (*GetHubMemberAccountResponse, error) {
	rsp, err := c.GetHubMemberAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubMemberAccountResponse(rsp)
}

// DeleteHubMemberWithResponse request returning *DeleteHubMemberResponse
func (c *ClientWithResponses) DeleteHubMemberWithResponse(ctx context.Context, memberId string, reqEditors ...RequestEditorFn) (*DeleteHubMemberResponse, error) {
	rsp, err := c.DeleteHubMember(ctx, memberId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHubMemberResponse(rsp)
}

// GetHubMemberWithResponse request returning *GetHubMemberResponse
func (c *ClientWithResponses) GetHubMemberWithResponse(ctx context.Context, memberId string, params *GetHubMemberParams, reqEditors ...RequestEditorFn) (*GetHubMemberResponse, error) {
	rsp, err := c.GetHubMember(ctx, memberId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubMemberResponse(rsp)
}

// UpdateHubMemberWithBodyWithResponse request with arbitrary body returning *UpdateHubMemberResponse
func (c *ClientWithResponses) UpdateHubMemberWithBodyWithResponse(ctx context.Context, memberId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateHubMemberResponse, error) {
	rsp, err := c.UpdateHubMemberWithBody(ctx, memberId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateHubMemberResponse(rsp)
}

func (c *ClientWithResponses) UpdateHubMemberWithResponse(ctx context.Context, memberId string, body UpdateHubMemberJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateHubMemberResponse, error) {
	rsp, err := c.UpdateHubMember(ctx, memberId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateHubMemberResponse(rsp)
}

// GetHubMembershipWithResponse request returning *GetHubMembershipResponse
func (c *ClientWithResponses) GetHubMembershipWithResponse(ctx context.Context, params *GetHubMembershipParams, reqEditors ...RequestEditorFn) (*GetHubMembershipResponse, error) {
	rsp, err := c.GetHubMembership(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubMembershipResponse(rsp)
}

// GetHubNotificationSocketAuthWithResponse request returning *GetHubNotificationSocketAuthResponse
func (c *ClientWithResponses) GetHubNotificationSocketAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHubNotificationSocketAuthResponse, error) {
	rsp, err := c.GetHubNotificationSocketAuth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubNotificationSocketAuthResponse(rsp)
}

// GetRolesWithResponse request returning *GetRolesResponse
func (c *ClientWithResponses) GetRolesWithResponse(ctx context.Context, params *GetRolesParams, reqEditors ...RequestEditorFn) (*GetRolesResponse, error) {
	rsp, err := c.GetRoles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolesResponse(rsp)
}

// CreateRoleWithBodyWithResponse request with arbitrary body returning *CreateRoleResponse
func (c *ClientWithResponses) CreateRoleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRoleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateRoleWithResponse(ctx context.Context, body CreateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleResponse, error) {
	rsp, err := c.CreateRole(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleResponse(rsp)
}

// GetDefaultHubRolesWithResponse request returning *GetDefaultHubRolesResponse
func (c *ClientWithResponses) GetDefaultHubRolesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDefaultHubRolesResponse, error) {
	rsp, err := c.GetDefaultHubRoles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultHubRolesResponse(rsp)
}

// DeleteRoleWithResponse request returning *DeleteRoleResponse
func (c *ClientWithResponses) DeleteRoleWithResponse(ctx context.Context, roleId string, reqEditors ...RequestEditorFn) (*DeleteRoleResponse, error) {
	rsp, err := c.DeleteRole(ctx, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleResponse(rsp)
}

// GetRoleWithResponse request returning *GetRoleResponse
func (c *ClientWithResponses) GetRoleWithResponse(ctx context.Context, roleId string, params *GetRoleParams, reqEditors ...RequestEditorFn) (*GetRoleResponse, error) {
	rsp, err := c.GetRole(ctx, roleId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleResponse(rsp)
}

// UpdateRoleWithBodyWithResponse request with arbitrary body returning *UpdateRoleResponse
func (c *ClientWithResponses) UpdateRoleWithBodyWithResponse(ctx context.Context, roleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRoleWithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRoleWithResponse(ctx context.Context, roleId string, body UpdateRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleResponse, error) {
	rsp, err := c.UpdateRole(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleResponse(rsp)
}

// GetHubUsageWithResponse request returning *GetHubUsageResponse
func (c *ClientWithResponses) GetHubUsageWithResponse(ctx context.Context, params *GetHubUsageParams, reqEditors ...RequestEditorFn) (*GetHubUsageResponse, error) {
	rsp, err := c.GetHubUsage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHubUsageResponse(rsp)
}

// GetImagesWithResponse request returning *GetImagesResponse
func (c *ClientWithResponses) GetImagesWithResponse(ctx context.Context, params *GetImagesParams, reqEditors ...RequestEditorFn) (*GetImagesResponse, error) {
	rsp, err := c.GetImages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImagesResponse(rsp)
}

// CreateImageWithBodyWithResponse request with arbitrary body returning *CreateImageResponse
func (c *ClientWithResponses) CreateImageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageResponse, error) {
	rsp, err := c.CreateImageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageResponse(rsp)
}

func (c *ClientWithResponses) CreateImageWithResponse(ctx context.Context, body CreateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageResponse, error) {
	rsp, err := c.CreateImage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageResponse(rsp)
}

// GetImageSourcesWithResponse request returning *GetImageSourcesResponse
func (c *ClientWithResponses) GetImageSourcesWithResponse(ctx context.Context, params *GetImageSourcesParams, reqEditors ...RequestEditorFn) (*GetImageSourcesResponse, error) {
	rsp, err := c.GetImageSources(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImageSourcesResponse(rsp)
}

// CreateImageSourceWithBodyWithResponse request with arbitrary body returning *CreateImageSourceResponse
func (c *ClientWithResponses) CreateImageSourceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageSourceResponse, error) {
	rsp, err := c.CreateImageSourceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageSourceResponse(rsp)
}

func (c *ClientWithResponses) CreateImageSourceWithResponse(ctx context.Context, body CreateImageSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageSourceResponse, error) {
	rsp, err := c.CreateImageSource(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageSourceResponse(rsp)
}

// DeleteImageSourceWithResponse request returning *DeleteImageSourceResponse
func (c *ClientWithResponses) DeleteImageSourceWithResponse(ctx context.Context, sourceId string, reqEditors ...RequestEditorFn) (*DeleteImageSourceResponse, error) {
	rsp, err := c.DeleteImageSource(ctx, sourceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageSourceResponse(rsp)
}

// GetImageSourceWithResponse request returning *GetImageSourceResponse
func (c *ClientWithResponses) GetImageSourceWithResponse(ctx context.Context, sourceId string, params *GetImageSourceParams, reqEditors ...RequestEditorFn) (*GetImageSourceResponse, error) {
	rsp, err := c.GetImageSource(ctx, sourceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImageSourceResponse(rsp)
}

// UpdateImageSourceWithBodyWithResponse request with arbitrary body returning *UpdateImageSourceResponse
func (c *ClientWithResponses) UpdateImageSourceWithBodyWithResponse(ctx context.Context, sourceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageSourceResponse, error) {
	rsp, err := c.UpdateImageSourceWithBody(ctx, sourceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageSourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateImageSourceWithResponse(ctx context.Context, sourceId string, body UpdateImageSourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageSourceResponse, error) {
	rsp, err := c.UpdateImageSource(ctx, sourceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageSourceResponse(rsp)
}

// UpdateImageSourceAccessWithBodyWithResponse request with arbitrary body returning *UpdateImageSourceAccessResponse
func (c *ClientWithResponses) UpdateImageSourceAccessWithBodyWithResponse(ctx context.Context, sourceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageSourceAccessResponse, error) {
	rsp, err := c.UpdateImageSourceAccessWithBody(ctx, sourceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageSourceAccessResponse(rsp)
}

func (c *ClientWithResponses) UpdateImageSourceAccessWithResponse(ctx context.Context, sourceId string, body UpdateImageSourceAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageSourceAccessResponse, error) {
	rsp, err := c.UpdateImageSourceAccess(ctx, sourceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageSourceAccessResponse(rsp)
}

// CreateImagesJobWithBodyWithResponse request with arbitrary body returning *CreateImagesJobResponse
func (c *ClientWithResponses) CreateImagesJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImagesJobResponse, error) {
	rsp, err := c.CreateImagesJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImagesJobResponse(rsp)
}

func (c *ClientWithResponses) CreateImagesJobWithResponse(ctx context.Context, body CreateImagesJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImagesJobResponse, error) {
	rsp, err := c.CreateImagesJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImagesJobResponse(rsp)
}

// DeleteImageWithResponse request returning *DeleteImageResponse
func (c *ClientWithResponses) DeleteImageWithResponse(ctx context.Context, imageId string, reqEditors ...RequestEditorFn) (*DeleteImageResponse, error) {
	rsp, err := c.DeleteImage(ctx, imageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImageResponse(rsp)
}

// GetImageWithResponse request returning *GetImageResponse
func (c *ClientWithResponses) GetImageWithResponse(ctx context.Context, imageId string, params *GetImageParams, reqEditors ...RequestEditorFn) (*GetImageResponse, error) {
	rsp, err := c.GetImage(ctx, imageId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImageResponse(rsp)
}

// UpdateImageWithBodyWithResponse request with arbitrary body returning *UpdateImageResponse
func (c *ClientWithResponses) UpdateImageWithBodyWithResponse(ctx context.Context, imageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error) {
	rsp, err := c.UpdateImageWithBody(ctx, imageId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageResponse(rsp)
}

func (c *ClientWithResponses) UpdateImageWithResponse(ctx context.Context, imageId string, body UpdateImageJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImageResponse, error) {
	rsp, err := c.UpdateImage(ctx, imageId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImageResponse(rsp)
}

// GetImageBuildLogWithResponse request returning *GetImageBuildLogResponse
func (c *ClientWithResponses) GetImageBuildLogWithResponse(ctx context.Context, imageId string, reqEditors ...RequestEditorFn) (*GetImageBuildLogResponse, error) {
	rsp, err := c.GetImageBuildLog(ctx, imageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImageBuildLogResponse(rsp)
}

// CreateImageJobWithBodyWithResponse request with arbitrary body returning *CreateImageJobResponse
func (c *ClientWithResponses) CreateImageJobWithBodyWithResponse(ctx context.Context, imageId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImageJobResponse, error) {
	rsp, err := c.CreateImageJobWithBody(ctx, imageId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageJobResponse(rsp)
}

func (c *ClientWithResponses) CreateImageJobWithResponse(ctx context.Context, imageId string, body CreateImageJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImageJobResponse, error) {
	rsp, err := c.CreateImageJob(ctx, imageId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImageJobResponse(rsp)
}

// GetAutoScaleGroupsWithResponse request returning *GetAutoScaleGroupsResponse
func (c *ClientWithResponses) GetAutoScaleGroupsWithResponse(ctx context.Context, params *GetAutoScaleGroupsParams, reqEditors ...RequestEditorFn) (*GetAutoScaleGroupsResponse, error) {
	rsp, err := c.GetAutoScaleGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutoScaleGroupsResponse(rsp)
}

// CreateAutoScaleGroupWithBodyWithResponse request with arbitrary body returning *CreateAutoScaleGroupResponse
func (c *ClientWithResponses) CreateAutoScaleGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAutoScaleGroupResponse, error) {
	rsp, err := c.CreateAutoScaleGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAutoScaleGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateAutoScaleGroupWithResponse(ctx context.Context, body CreateAutoScaleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAutoScaleGroupResponse, error) {
	rsp, err := c.CreateAutoScaleGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAutoScaleGroupResponse(rsp)
}

// DeleteAutoScaleGroupWithResponse request returning *DeleteAutoScaleGroupResponse
func (c *ClientWithResponses) DeleteAutoScaleGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*DeleteAutoScaleGroupResponse, error) {
	rsp, err := c.DeleteAutoScaleGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAutoScaleGroupResponse(rsp)
}

// GetAutoScaleGroupWithResponse request returning *GetAutoScaleGroupResponse
func (c *ClientWithResponses) GetAutoScaleGroupWithResponse(ctx context.Context, groupId string, params *GetAutoScaleGroupParams, reqEditors ...RequestEditorFn) (*GetAutoScaleGroupResponse, error) {
	rsp, err := c.GetAutoScaleGroup(ctx, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutoScaleGroupResponse(rsp)
}

// UpdateAutoScaleGroupWithBodyWithResponse request with arbitrary body returning *UpdateAutoScaleGroupResponse
func (c *ClientWithResponses) UpdateAutoScaleGroupWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutoScaleGroupResponse, error) {
	rsp, err := c.UpdateAutoScaleGroupWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutoScaleGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateAutoScaleGroupWithResponse(ctx context.Context, groupId string, body UpdateAutoScaleGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutoScaleGroupResponse, error) {
	rsp, err := c.UpdateAutoScaleGroup(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutoScaleGroupResponse(rsp)
}

// UpdateAutoScaleGroupAccessWithBodyWithResponse request with arbitrary body returning *UpdateAutoScaleGroupAccessResponse
func (c *ClientWithResponses) UpdateAutoScaleGroupAccessWithBodyWithResponse(ctx context.Context, groupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutoScaleGroupAccessResponse, error) {
	rsp, err := c.UpdateAutoScaleGroupAccessWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutoScaleGroupAccessResponse(rsp)
}

func (c *ClientWithResponses) UpdateAutoScaleGroupAccessWithResponse(ctx context.Context, groupId string, body UpdateAutoScaleGroupAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutoScaleGroupAccessResponse, error) {
	rsp, err := c.UpdateAutoScaleGroupAccess(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutoScaleGroupAccessResponse(rsp)
}

// GetClustersWithResponse request returning *GetClustersResponse
func (c *ClientWithResponses) GetClustersWithResponse(ctx context.Context, params *GetClustersParams, reqEditors ...RequestEditorFn) (*GetClustersResponse, error) {
	rsp, err := c.GetClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClustersResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, clusterId string, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWithResponse(ctx context.Context, clusterId string, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateCluster(ctx, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// UpdateClusterAccessWithBodyWithResponse request with arbitrary body returning *UpdateClusterAccessResponse
func (c *ClientWithResponses) UpdateClusterAccessWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterAccessResponse, error) {
	rsp, err := c.UpdateClusterAccessWithBody(ctx, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterAccessResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterAccessWithResponse(ctx context.Context, clusterId string, body UpdateClusterAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterAccessResponse, error) {
	rsp, err := c.UpdateClusterAccess(ctx, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterAccessResponse(rsp)
}

// CreateClusterJobWithBodyWithResponse request with arbitrary body returning *CreateClusterJobResponse
func (c *ClientWithResponses) CreateClusterJobWithBodyWithResponse(ctx context.Context, clusterId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterJobResponse, error) {
	rsp, err := c.CreateClusterJobWithBody(ctx, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterJobResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterJobWithResponse(ctx context.Context, clusterId string, body CreateClusterJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterJobResponse, error) {
	rsp, err := c.CreateClusterJob(ctx, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterJobResponse(rsp)
}

// GetDeploymentStrategiesWithResponse request returning *GetDeploymentStrategiesResponse
func (c *ClientWithResponses) GetDeploymentStrategiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDeploymentStrategiesResponse, error) {
	rsp, err := c.GetDeploymentStrategies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeploymentStrategiesResponse(rsp)
}

// GetExternalVolumesWithResponse request returning *GetExternalVolumesResponse
func (c *ClientWithResponses) GetExternalVolumesWithResponse(ctx context.Context, params *GetExternalVolumesParams, reqEditors ...RequestEditorFn) (*GetExternalVolumesResponse, error) {
	rsp, err := c.GetExternalVolumes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExternalVolumesResponse(rsp)
}

// CreateExternalVolumeWithBodyWithResponse request with arbitrary body returning *CreateExternalVolumeResponse
func (c *ClientWithResponses) CreateExternalVolumeWithBodyWithResponse(ctx context.Context, params *CreateExternalVolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExternalVolumeResponse, error) {
	rsp, err := c.CreateExternalVolumeWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExternalVolumeResponse(rsp)
}

func (c *ClientWithResponses) CreateExternalVolumeWithResponse(ctx context.Context, params *CreateExternalVolumeParams, body CreateExternalVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExternalVolumeResponse, error) {
	rsp, err := c.CreateExternalVolume(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExternalVolumeResponse(rsp)
}

// GetExternalVolumeSourcesWithResponse request returning *GetExternalVolumeSourcesResponse
func (c *ClientWithResponses) GetExternalVolumeSourcesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetExternalVolumeSourcesResponse, error) {
	rsp, err := c.GetExternalVolumeSources(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExternalVolumeSourcesResponse(rsp)
}

// DeleteExternalVolumeWithBodyWithResponse request with arbitrary body returning *DeleteExternalVolumeResponse
func (c *ClientWithResponses) DeleteExternalVolumeWithBodyWithResponse(ctx context.Context, externalVolumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteExternalVolumeResponse, error) {
	rsp, err := c.DeleteExternalVolumeWithBody(ctx, externalVolumeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExternalVolumeResponse(rsp)
}

func (c *ClientWithResponses) DeleteExternalVolumeWithResponse(ctx context.Context, externalVolumeId string, body DeleteExternalVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteExternalVolumeResponse, error) {
	rsp, err := c.DeleteExternalVolume(ctx, externalVolumeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteExternalVolumeResponse(rsp)
}

// GetExternalVolumeWithResponse request returning *GetExternalVolumeResponse
func (c *ClientWithResponses) GetExternalVolumeWithResponse(ctx context.Context, externalVolumeId string, params *GetExternalVolumeParams, reqEditors ...RequestEditorFn) (*GetExternalVolumeResponse, error) {
	rsp, err := c.GetExternalVolume(ctx, externalVolumeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExternalVolumeResponse(rsp)
}

// UpdateExternalVolumeWithBodyWithResponse request with arbitrary body returning *UpdateExternalVolumeResponse
func (c *ClientWithResponses) UpdateExternalVolumeWithBodyWithResponse(ctx context.Context, externalVolumeId string, params *UpdateExternalVolumeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExternalVolumeResponse, error) {
	rsp, err := c.UpdateExternalVolumeWithBody(ctx, externalVolumeId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExternalVolumeResponse(rsp)
}

func (c *ClientWithResponses) UpdateExternalVolumeWithResponse(ctx context.Context, externalVolumeId string, params *UpdateExternalVolumeParams, body UpdateExternalVolumeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExternalVolumeResponse, error) {
	rsp, err := c.UpdateExternalVolume(ctx, externalVolumeId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExternalVolumeResponse(rsp)
}

// UpdateExternalVolumeAccessWithBodyWithResponse request with arbitrary body returning *UpdateExternalVolumeAccessResponse
func (c *ClientWithResponses) UpdateExternalVolumeAccessWithBodyWithResponse(ctx context.Context, externalVolumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExternalVolumeAccessResponse, error) {
	rsp, err := c.UpdateExternalVolumeAccessWithBody(ctx, externalVolumeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExternalVolumeAccessResponse(rsp)
}

func (c *ClientWithResponses) UpdateExternalVolumeAccessWithResponse(ctx context.Context, externalVolumeId string, body UpdateExternalVolumeAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExternalVolumeAccessResponse, error) {
	rsp, err := c.UpdateExternalVolumeAccess(ctx, externalVolumeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateExternalVolumeAccessResponse(rsp)
}

// CreateExternalVolumeJobWithBodyWithResponse request with arbitrary body returning *CreateExternalVolumeJobResponse
func (c *ClientWithResponses) CreateExternalVolumeJobWithBodyWithResponse(ctx context.Context, externalVolumeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateExternalVolumeJobResponse, error) {
	rsp, err := c.CreateExternalVolumeJobWithBody(ctx, externalVolumeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExternalVolumeJobResponse(rsp)
}

func (c *ClientWithResponses) CreateExternalVolumeJobWithResponse(ctx context.Context, externalVolumeId string, body CreateExternalVolumeJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateExternalVolumeJobResponse, error) {
	rsp, err := c.CreateExternalVolumeJob(ctx, externalVolumeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateExternalVolumeJobResponse(rsp)
}

// GetIpPoolsWithResponse request returning *GetIpPoolsResponse
func (c *ClientWithResponses) GetIpPoolsWithResponse(ctx context.Context, params *GetIpPoolsParams, reqEditors ...RequestEditorFn) (*GetIpPoolsResponse, error) {
	rsp, err := c.GetIpPools(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIpPoolsResponse(rsp)
}

// CreateIpPoolWithBodyWithResponse request with arbitrary body returning *CreateIpPoolResponse
func (c *ClientWithResponses) CreateIpPoolWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIpPoolResponse, error) {
	rsp, err := c.CreateIpPoolWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIpPoolResponse(rsp)
}

func (c *ClientWithResponses) CreateIpPoolWithResponse(ctx context.Context, body CreateIpPoolJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIpPoolResponse, error) {
	rsp, err := c.CreateIpPool(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIpPoolResponse(rsp)
}

// DeleteIPPoolWithResponse request returning *DeleteIPPoolResponse
func (c *ClientWithResponses) DeleteIPPoolWithResponse(ctx context.Context, poolId string, reqEditors ...RequestEditorFn) (*DeleteIPPoolResponse, error) {
	rsp, err := c.DeleteIPPool(ctx, poolId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIPPoolResponse(rsp)
}

// GetIPPoolWithResponse request returning *GetIPPoolResponse
func (c *ClientWithResponses) GetIPPoolWithResponse(ctx context.Context, poolId string, params *GetIPPoolParams, reqEditors ...RequestEditorFn) (*GetIPPoolResponse, error) {
	rsp, err := c.GetIPPool(ctx, poolId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIPPoolResponse(rsp)
}

// GetPoolIPsWithResponse request returning *GetPoolIPsResponse
func (c *ClientWithResponses) GetPoolIPsWithResponse(ctx context.Context, poolId string, reqEditors ...RequestEditorFn) (*GetPoolIPsResponse, error) {
	rsp, err := c.GetPoolIPs(ctx, poolId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPoolIPsResponse(rsp)
}

// CreateIpPoolJobWithBodyWithResponse request with arbitrary body returning *CreateIpPoolJobResponse
func (c *ClientWithResponses) CreateIpPoolJobWithBodyWithResponse(ctx context.Context, poolId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIpPoolJobResponse, error) {
	rsp, err := c.CreateIpPoolJobWithBody(ctx, poolId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIpPoolJobResponse(rsp)
}

func (c *ClientWithResponses) CreateIpPoolJobWithResponse(ctx context.Context, poolId string, body CreateIpPoolJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIpPoolJobResponse, error) {
	rsp, err := c.CreateIpPoolJob(ctx, poolId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIpPoolJobResponse(rsp)
}

// GetClusterMonitoringTiersWithResponse request returning *GetClusterMonitoringTiersResponse
func (c *ClientWithResponses) GetClusterMonitoringTiersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterMonitoringTiersResponse, error) {
	rsp, err := c.GetClusterMonitoringTiers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterMonitoringTiersResponse(rsp)
}

// GetProviderLocationsWithResponse request returning *GetProviderLocationsResponse
func (c *ClientWithResponses) GetProviderLocationsWithResponse(ctx context.Context, providerVendor string, params *GetProviderLocationsParams, reqEditors ...RequestEditorFn) (*GetProviderLocationsResponse, error) {
	rsp, err := c.GetProviderLocations(ctx, providerVendor, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProviderLocationsResponse(rsp)
}

// GetProviderServersWithResponse request returning *GetProviderServersResponse
func (c *ClientWithResponses) GetProviderServersWithResponse(ctx context.Context, providerVendor string, params *GetProviderServersParams, reqEditors ...RequestEditorFn) (*GetProviderServersResponse, error) {
	rsp, err := c.GetProviderServers(ctx, providerVendor, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProviderServersResponse(rsp)
}

// GetServersWithResponse request returning *GetServersResponse
func (c *ClientWithResponses) GetServersWithResponse(ctx context.Context, params *GetServersParams, reqEditors ...RequestEditorFn) (*GetServersResponse, error) {
	rsp, err := c.GetServers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServersResponse(rsp)
}

// CreateServerWithBodyWithResponse request with arbitrary body returning *CreateServerResponse
func (c *ClientWithResponses) CreateServerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerResponse, error) {
	rsp, err := c.CreateServerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerResponse(rsp)
}

func (c *ClientWithResponses) CreateServerWithResponse(ctx context.Context, body CreateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerResponse, error) {
	rsp, err := c.CreateServer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerResponse(rsp)
}

// GetServerTagsWithResponse request returning *GetServerTagsResponse
func (c *ClientWithResponses) GetServerTagsWithResponse(ctx context.Context, params *GetServerTagsParams, reqEditors ...RequestEditorFn) (*GetServerTagsResponse, error) {
	rsp, err := c.GetServerTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerTagsResponse(rsp)
}

// DeleteServerWithBodyWithResponse request with arbitrary body returning *DeleteServerResponse
func (c *ClientWithResponses) DeleteServerWithBodyWithResponse(ctx context.Context, serverId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteServerResponse, error) {
	rsp, err := c.DeleteServerWithBody(ctx, serverId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerResponse(rsp)
}

func (c *ClientWithResponses) DeleteServerWithResponse(ctx context.Context, serverId string, body DeleteServerJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteServerResponse, error) {
	rsp, err := c.DeleteServer(ctx, serverId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerResponse(rsp)
}

// GetServerWithResponse request returning *GetServerResponse
func (c *ClientWithResponses) GetServerWithResponse(ctx context.Context, serverId string, params *GetServerParams, reqEditors ...RequestEditorFn) (*GetServerResponse, error) {
	rsp, err := c.GetServer(ctx, serverId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerResponse(rsp)
}

// UpdateServerWithBodyWithResponse request with arbitrary body returning *UpdateServerResponse
func (c *ClientWithResponses) UpdateServerWithBodyWithResponse(ctx context.Context, serverId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServerResponse, error) {
	rsp, err := c.UpdateServerWithBody(ctx, serverId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServerResponse(rsp)
}

func (c *ClientWithResponses) UpdateServerWithResponse(ctx context.Context, serverId string, body UpdateServerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServerResponse, error) {
	rsp, err := c.UpdateServer(ctx, serverId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServerResponse(rsp)
}

// GetServerConsoleWithResponse request returning *GetServerConsoleResponse
func (c *ClientWithResponses) GetServerConsoleWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetServerConsoleResponse, error) {
	rsp, err := c.GetServerConsole(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerConsoleResponse(rsp)
}

// GetServerInstancesWithResponse request returning *GetServerInstancesResponse
func (c *ClientWithResponses) GetServerInstancesWithResponse(ctx context.Context, serverId string, params *GetServerInstancesParams, reqEditors ...RequestEditorFn) (*GetServerInstancesResponse, error) {
	rsp, err := c.GetServerInstances(ctx, serverId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerInstancesResponse(rsp)
}

// CreateServerJobWithBodyWithResponse request with arbitrary body returning *CreateServerJobResponse
func (c *ClientWithResponses) CreateServerJobWithBodyWithResponse(ctx context.Context, serverId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerJobResponse, error) {
	rsp, err := c.CreateServerJobWithBody(ctx, serverId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerJobResponse(rsp)
}

func (c *ClientWithResponses) CreateServerJobWithResponse(ctx context.Context, serverId string, body CreateServerJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerJobResponse, error) {
	rsp, err := c.CreateServerJob(ctx, serverId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerJobResponse(rsp)
}

// GetServerTelemetryWithResponse request returning *GetServerTelemetryResponse
func (c *ClientWithResponses) GetServerTelemetryWithResponse(ctx context.Context, serverId string, params *GetServerTelemetryParams, reqEditors ...RequestEditorFn) (*GetServerTelemetryResponse, error) {
	rsp, err := c.GetServerTelemetry(ctx, serverId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerTelemetryResponse(rsp)
}

// GetServerUsageWithResponse request returning *GetServerUsageResponse
func (c *ClientWithResponses) GetServerUsageWithResponse(ctx context.Context, serverId string, reqEditors ...RequestEditorFn) (*GetServerUsageResponse, error) {
	rsp, err := c.GetServerUsage(ctx, serverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerUsageResponse(rsp)
}

// GetInfrastructureSummaryWithResponse request returning *GetInfrastructureSummaryResponse
func (c *ClientWithResponses) GetInfrastructureSummaryWithResponse(ctx context.Context, params *GetInfrastructureSummaryParams, reqEditors ...RequestEditorFn) (*GetInfrastructureSummaryResponse, error) {
	rsp, err := c.GetInfrastructureSummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInfrastructureSummaryResponse(rsp)
}

// GetVirtualProviderIsosWithResponse request returning *GetVirtualProviderIsosResponse
func (c *ClientWithResponses) GetVirtualProviderIsosWithResponse(ctx context.Context, integrationId string, params *GetVirtualProviderIsosParams, reqEditors ...RequestEditorFn) (*GetVirtualProviderIsosResponse, error) {
	rsp, err := c.GetVirtualProviderIsos(ctx, integrationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualProviderIsosResponse(rsp)
}

// CreateVirtualProviderIsoWithBodyWithResponse request with arbitrary body returning *CreateVirtualProviderIsoResponse
func (c *ClientWithResponses) CreateVirtualProviderIsoWithBodyWithResponse(ctx context.Context, integrationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualProviderIsoResponse, error) {
	rsp, err := c.CreateVirtualProviderIsoWithBody(ctx, integrationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualProviderIsoResponse(rsp)
}

func (c *ClientWithResponses) CreateVirtualProviderIsoWithResponse(ctx context.Context, integrationId string, body CreateVirtualProviderIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualProviderIsoResponse, error) {
	rsp, err := c.CreateVirtualProviderIso(ctx, integrationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualProviderIsoResponse(rsp)
}

// DeleteVirtualProviderIsoWithResponse request returning *DeleteVirtualProviderIsoResponse
func (c *ClientWithResponses) DeleteVirtualProviderIsoWithResponse(ctx context.Context, integrationId string, isoId string, reqEditors ...RequestEditorFn) (*DeleteVirtualProviderIsoResponse, error) {
	rsp, err := c.DeleteVirtualProviderIso(ctx, integrationId, isoId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualProviderIsoResponse(rsp)
}

// GetVirtualProviderIsoWithResponse request returning *GetVirtualProviderIsoResponse
func (c *ClientWithResponses) GetVirtualProviderIsoWithResponse(ctx context.Context, integrationId string, isoId string, params *GetVirtualProviderIsoParams, reqEditors ...RequestEditorFn) (*GetVirtualProviderIsoResponse, error) {
	rsp, err := c.GetVirtualProviderIso(ctx, integrationId, isoId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualProviderIsoResponse(rsp)
}

// UpdateVirtualProviderIsoWithBodyWithResponse request with arbitrary body returning *UpdateVirtualProviderIsoResponse
func (c *ClientWithResponses) UpdateVirtualProviderIsoWithBodyWithResponse(ctx context.Context, integrationId string, isoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVirtualProviderIsoResponse, error) {
	rsp, err := c.UpdateVirtualProviderIsoWithBody(ctx, integrationId, isoId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVirtualProviderIsoResponse(rsp)
}

func (c *ClientWithResponses) UpdateVirtualProviderIsoWithResponse(ctx context.Context, integrationId string, isoId string, body UpdateVirtualProviderIsoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVirtualProviderIsoResponse, error) {
	rsp, err := c.UpdateVirtualProviderIso(ctx, integrationId, isoId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVirtualProviderIsoResponse(rsp)
}

// GetVirtualProviderIsoDownloadUrlWithResponse request returning *GetVirtualProviderIsoDownloadUrlResponse
func (c *ClientWithResponses) GetVirtualProviderIsoDownloadUrlWithResponse(ctx context.Context, integrationId string, isoId string, reqEditors ...RequestEditorFn) (*GetVirtualProviderIsoDownloadUrlResponse, error) {
	rsp, err := c.GetVirtualProviderIsoDownloadUrl(ctx, integrationId, isoId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualProviderIsoDownloadUrlResponse(rsp)
}

// CreateVirtualProviderIsoJobWithBodyWithResponse request with arbitrary body returning *CreateVirtualProviderIsoJobResponse
func (c *ClientWithResponses) CreateVirtualProviderIsoJobWithBodyWithResponse(ctx context.Context, integrationId string, isoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualProviderIsoJobResponse, error) {
	rsp, err := c.CreateVirtualProviderIsoJobWithBody(ctx, integrationId, isoId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualProviderIsoJobResponse(rsp)
}

func (c *ClientWithResponses) CreateVirtualProviderIsoJobWithResponse(ctx context.Context, integrationId string, isoId string, body CreateVirtualProviderIsoJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualProviderIsoJobResponse, error) {
	rsp, err := c.CreateVirtualProviderIsoJob(ctx, integrationId, isoId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualProviderIsoJobResponse(rsp)
}

// GetJobsWithResponse request returning *GetJobsResponse
func (c *ClientWithResponses) GetJobsWithResponse(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*GetJobsResponse, error) {
	rsp, err := c.GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobsResponse(rsp)
}

// GetLatestJobsWithResponse request returning *GetLatestJobsResponse
func (c *ClientWithResponses) GetLatestJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLatestJobsResponse, error) {
	rsp, err := c.GetLatestJobs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestJobsResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// GetEventsWithResponse request returning *GetEventsResponse
func (c *ClientWithResponses) GetEventsWithResponse(ctx context.Context, params *GetEventsParams, reqEditors ...RequestEditorFn) (*GetEventsResponse, error) {
	rsp, err := c.GetEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventsResponse(rsp)
}

// GenerateAggregatedEventsWithBodyWithResponse request with arbitrary body returning *GenerateAggregatedEventsResponse
func (c *ClientWithResponses) GenerateAggregatedEventsWithBodyWithResponse(ctx context.Context, params *GenerateAggregatedEventsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateAggregatedEventsResponse, error) {
	rsp, err := c.GenerateAggregatedEventsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateAggregatedEventsResponse(rsp)
}

func (c *ClientWithResponses) GenerateAggregatedEventsWithResponse(ctx context.Context, params *GenerateAggregatedEventsParams, body GenerateAggregatedEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateAggregatedEventsResponse, error) {
	rsp, err := c.GenerateAggregatedEvents(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateAggregatedEventsResponse(rsp)
}

// AggregateLogsWithBodyWithResponse request with arbitrary body returning *AggregateLogsResponse
func (c *ClientWithResponses) AggregateLogsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AggregateLogsResponse, error) {
	rsp, err := c.AggregateLogsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAggregateLogsResponse(rsp)
}

func (c *ClientWithResponses) AggregateLogsWithResponse(ctx context.Context, body AggregateLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*AggregateLogsResponse, error) {
	rsp, err := c.AggregateLogs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAggregateLogsResponse(rsp)
}

// GetMetricsWithResponse request returning *GetMetricsResponse
func (c *ClientWithResponses) GetMetricsWithResponse(ctx context.Context, params *GetMetricsParams, reqEditors ...RequestEditorFn) (*GetMetricsResponse, error) {
	rsp, err := c.GetMetrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsResponse(rsp)
}

// GenerateAggregatedMetricsWithBodyWithResponse request with arbitrary body returning *GenerateAggregatedMetricsResponse
func (c *ClientWithResponses) GenerateAggregatedMetricsWithBodyWithResponse(ctx context.Context, params *GenerateAggregatedMetricsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateAggregatedMetricsResponse, error) {
	rsp, err := c.GenerateAggregatedMetricsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateAggregatedMetricsResponse(rsp)
}

func (c *ClientWithResponses) GenerateAggregatedMetricsWithResponse(ctx context.Context, params *GenerateAggregatedMetricsParams, body GenerateAggregatedMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*GenerateAggregatedMetricsResponse, error) {
	rsp, err := c.GenerateAggregatedMetrics(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateAggregatedMetricsResponse(rsp)
}

// GetMonitoringMonitorsWithResponse request returning *GetMonitoringMonitorsResponse
func (c *ClientWithResponses) GetMonitoringMonitorsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMonitoringMonitorsResponse, error) {
	rsp, err := c.GetMonitoringMonitors(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMonitoringMonitorsResponse(rsp)
}

// GetPipelinesWithResponse request returning *GetPipelinesResponse
func (c *ClientWithResponses) GetPipelinesWithResponse(ctx context.Context, params *GetPipelinesParams, reqEditors ...RequestEditorFn) (*GetPipelinesResponse, error) {
	rsp, err := c.GetPipelines(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelinesResponse(rsp)
}

// CreatePipelineWithBodyWithResponse request with arbitrary body returning *CreatePipelineResponse
func (c *ClientWithResponses) CreatePipelineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePipelineResponse, error) {
	rsp, err := c.CreatePipelineWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePipelineResponse(rsp)
}

func (c *ClientWithResponses) CreatePipelineWithResponse(ctx context.Context, body CreatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePipelineResponse, error) {
	rsp, err := c.CreatePipeline(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePipelineResponse(rsp)
}

// ClonePipelineWithBodyWithResponse request with arbitrary body returning *ClonePipelineResponse
func (c *ClientWithResponses) ClonePipelineWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClonePipelineResponse, error) {
	rsp, err := c.ClonePipelineWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClonePipelineResponse(rsp)
}

func (c *ClientWithResponses) ClonePipelineWithResponse(ctx context.Context, body ClonePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*ClonePipelineResponse, error) {
	rsp, err := c.ClonePipeline(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClonePipelineResponse(rsp)
}

// DeletePipelineWithResponse request returning *DeletePipelineResponse
func (c *ClientWithResponses) DeletePipelineWithResponse(ctx context.Context, pipelineId string, reqEditors ...RequestEditorFn) (*DeletePipelineResponse, error) {
	rsp, err := c.DeletePipeline(ctx, pipelineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePipelineResponse(rsp)
}

// GetPipelineWithResponse request returning *GetPipelineResponse
func (c *ClientWithResponses) GetPipelineWithResponse(ctx context.Context, pipelineId string, params *GetPipelineParams, reqEditors ...RequestEditorFn) (*GetPipelineResponse, error) {
	rsp, err := c.GetPipeline(ctx, pipelineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineResponse(rsp)
}

// UpdatePipelineWithBodyWithResponse request with arbitrary body returning *UpdatePipelineResponse
func (c *ClientWithResponses) UpdatePipelineWithBodyWithResponse(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePipelineResponse, error) {
	rsp, err := c.UpdatePipelineWithBody(ctx, pipelineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePipelineResponse(rsp)
}

func (c *ClientWithResponses) UpdatePipelineWithResponse(ctx context.Context, pipelineId string, body UpdatePipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePipelineResponse, error) {
	rsp, err := c.UpdatePipeline(ctx, pipelineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePipelineResponse(rsp)
}

// UpdatePipelineAccessWithBodyWithResponse request with arbitrary body returning *UpdatePipelineAccessResponse
func (c *ClientWithResponses) UpdatePipelineAccessWithBodyWithResponse(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePipelineAccessResponse, error) {
	rsp, err := c.UpdatePipelineAccessWithBody(ctx, pipelineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePipelineAccessResponse(rsp)
}

func (c *ClientWithResponses) UpdatePipelineAccessWithResponse(ctx context.Context, pipelineId string, body UpdatePipelineAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePipelineAccessResponse, error) {
	rsp, err := c.UpdatePipelineAccess(ctx, pipelineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePipelineAccessResponse(rsp)
}

// GetPipelineTriggerKeysWithResponse request returning *GetPipelineTriggerKeysResponse
func (c *ClientWithResponses) GetPipelineTriggerKeysWithResponse(ctx context.Context, pipelineId string, params *GetPipelineTriggerKeysParams, reqEditors ...RequestEditorFn) (*GetPipelineTriggerKeysResponse, error) {
	rsp, err := c.GetPipelineTriggerKeys(ctx, pipelineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineTriggerKeysResponse(rsp)
}

// CreatePipelineTriggerKeyWithBodyWithResponse request with arbitrary body returning *CreatePipelineTriggerKeyResponse
func (c *ClientWithResponses) CreatePipelineTriggerKeyWithBodyWithResponse(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePipelineTriggerKeyResponse, error) {
	rsp, err := c.CreatePipelineTriggerKeyWithBody(ctx, pipelineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePipelineTriggerKeyResponse(rsp)
}

func (c *ClientWithResponses) CreatePipelineTriggerKeyWithResponse(ctx context.Context, pipelineId string, body CreatePipelineTriggerKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePipelineTriggerKeyResponse, error) {
	rsp, err := c.CreatePipelineTriggerKey(ctx, pipelineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePipelineTriggerKeyResponse(rsp)
}

// DeletePipelineTriggerKeyWithResponse request returning *DeletePipelineTriggerKeyResponse
func (c *ClientWithResponses) DeletePipelineTriggerKeyWithResponse(ctx context.Context, pipelineId string, triggerKeyId string, reqEditors ...RequestEditorFn) (*DeletePipelineTriggerKeyResponse, error) {
	rsp, err := c.DeletePipelineTriggerKey(ctx, pipelineId, triggerKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePipelineTriggerKeyResponse(rsp)
}

// GetPipelineTriggerKeyWithResponse request returning *GetPipelineTriggerKeyResponse
func (c *ClientWithResponses) GetPipelineTriggerKeyWithResponse(ctx context.Context, pipelineId string, triggerKeyId string, reqEditors ...RequestEditorFn) (*GetPipelineTriggerKeyResponse, error) {
	rsp, err := c.GetPipelineTriggerKey(ctx, pipelineId, triggerKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineTriggerKeyResponse(rsp)
}

// UpdatePipelineTriggerKeyWithBodyWithResponse request with arbitrary body returning *UpdatePipelineTriggerKeyResponse
func (c *ClientWithResponses) UpdatePipelineTriggerKeyWithBodyWithResponse(ctx context.Context, pipelineId string, triggerKeyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePipelineTriggerKeyResponse, error) {
	rsp, err := c.UpdatePipelineTriggerKeyWithBody(ctx, pipelineId, triggerKeyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePipelineTriggerKeyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePipelineTriggerKeyWithResponse(ctx context.Context, pipelineId string, triggerKeyId string, body UpdatePipelineTriggerKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePipelineTriggerKeyResponse, error) {
	rsp, err := c.UpdatePipelineTriggerKey(ctx, pipelineId, triggerKeyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePipelineTriggerKeyResponse(rsp)
}

// GetPipelineRunsWithResponse request returning *GetPipelineRunsResponse
func (c *ClientWithResponses) GetPipelineRunsWithResponse(ctx context.Context, pipelineId string, params *GetPipelineRunsParams, reqEditors ...RequestEditorFn) (*GetPipelineRunsResponse, error) {
	rsp, err := c.GetPipelineRuns(ctx, pipelineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineRunsResponse(rsp)
}

// GetPipelineRunWithResponse request returning *GetPipelineRunResponse
func (c *ClientWithResponses) GetPipelineRunWithResponse(ctx context.Context, pipelineId string, runId string, params *GetPipelineRunParams, reqEditors ...RequestEditorFn) (*GetPipelineRunResponse, error) {
	rsp, err := c.GetPipelineRun(ctx, pipelineId, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPipelineRunResponse(rsp)
}

// CreatePipelineJobWithBodyWithResponse request with arbitrary body returning *CreatePipelineJobResponse
func (c *ClientWithResponses) CreatePipelineJobWithBodyWithResponse(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePipelineJobResponse, error) {
	rsp, err := c.CreatePipelineJobWithBody(ctx, pipelineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePipelineJobResponse(rsp)
}

func (c *ClientWithResponses) CreatePipelineJobWithResponse(ctx context.Context, pipelineId string, body CreatePipelineJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePipelineJobResponse, error) {
	rsp, err := c.CreatePipelineJob(ctx, pipelineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePipelineJobResponse(rsp)
}

// TriggerPipelineWithBodyWithResponse request with arbitrary body returning *TriggerPipelineResponse
func (c *ClientWithResponses) TriggerPipelineWithBodyWithResponse(ctx context.Context, pipelineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerPipelineResponse, error) {
	rsp, err := c.TriggerPipelineWithBody(ctx, pipelineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerPipelineResponse(rsp)
}

func (c *ClientWithResponses) TriggerPipelineWithResponse(ctx context.Context, pipelineId string, body TriggerPipelineJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerPipelineResponse, error) {
	rsp, err := c.TriggerPipeline(ctx, pipelineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerPipelineResponse(rsp)
}

// GetNetworksWithResponse request returning *GetNetworksResponse
func (c *ClientWithResponses) GetNetworksWithResponse(ctx context.Context, params *GetNetworksParams, reqEditors ...RequestEditorFn) (*GetNetworksResponse, error) {
	rsp, err := c.GetNetworks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworksResponse(rsp)
}

// CreateNetworkWithBodyWithResponse request with arbitrary body returning *CreateNetworkResponse
func (c *ClientWithResponses) CreateNetworkWithBodyWithResponse(ctx context.Context, params *CreateNetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNetworkResponse, error) {
	rsp, err := c.CreateNetworkWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetworkResponse(rsp)
}

func (c *ClientWithResponses) CreateNetworkWithResponse(ctx context.Context, params *CreateNetworkParams, body CreateNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNetworkResponse, error) {
	rsp, err := c.CreateNetwork(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetworkResponse(rsp)
}

// DeleteNetworkWithResponse request returning *DeleteNetworkResponse
func (c *ClientWithResponses) DeleteNetworkWithResponse(ctx context.Context, networkId string, reqEditors ...RequestEditorFn) (*DeleteNetworkResponse, error) {
	rsp, err := c.DeleteNetwork(ctx, networkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNetworkResponse(rsp)
}

// GetNetworkWithResponse request returning *GetNetworkResponse
func (c *ClientWithResponses) GetNetworkWithResponse(ctx context.Context, networkId string, params *GetNetworkParams, reqEditors ...RequestEditorFn) (*GetNetworkResponse, error) {
	rsp, err := c.GetNetwork(ctx, networkId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkResponse(rsp)
}

// UpdateNetworkWithBodyWithResponse request with arbitrary body returning *UpdateNetworkResponse
func (c *ClientWithResponses) UpdateNetworkWithBodyWithResponse(ctx context.Context, networkId string, params *UpdateNetworkParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNetworkResponse, error) {
	rsp, err := c.UpdateNetworkWithBody(ctx, networkId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNetworkResponse(rsp)
}

func (c *ClientWithResponses) UpdateNetworkWithResponse(ctx context.Context, networkId string, params *UpdateNetworkParams, body UpdateNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNetworkResponse, error) {
	rsp, err := c.UpdateNetwork(ctx, networkId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNetworkResponse(rsp)
}

// UpdateNetworkAccessWithBodyWithResponse request with arbitrary body returning *UpdateNetworkAccessResponse
func (c *ClientWithResponses) UpdateNetworkAccessWithBodyWithResponse(ctx context.Context, networkId string, params *UpdateNetworkAccessParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNetworkAccessResponse, error) {
	rsp, err := c.UpdateNetworkAccessWithBody(ctx, networkId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNetworkAccessResponse(rsp)
}

func (c *ClientWithResponses) UpdateNetworkAccessWithResponse(ctx context.Context, networkId string, params *UpdateNetworkAccessParams, body UpdateNetworkAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNetworkAccessResponse, error) {
	rsp, err := c.UpdateNetworkAccess(ctx, networkId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNetworkAccessResponse(rsp)
}

// CreateNetworkJobWithBodyWithResponse request with arbitrary body returning *CreateNetworkJobResponse
func (c *ClientWithResponses) CreateNetworkJobWithBodyWithResponse(ctx context.Context, networkId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNetworkJobResponse, error) {
	rsp, err := c.CreateNetworkJobWithBody(ctx, networkId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetworkJobResponse(rsp)
}

func (c *ClientWithResponses) CreateNetworkJobWithResponse(ctx context.Context, networkId string, body CreateNetworkJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNetworkJobResponse, error) {
	rsp, err := c.CreateNetworkJob(ctx, networkId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNetworkJobResponse(rsp)
}

// GetSearchIndexWithResponse request returning *GetSearchIndexResponse
func (c *ClientWithResponses) GetSearchIndexWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSearchIndexResponse, error) {
	rsp, err := c.GetSearchIndex(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchIndexResponse(rsp)
}

// GetStacksWithResponse request returning *GetStacksResponse
func (c *ClientWithResponses) GetStacksWithResponse(ctx context.Context, params *GetStacksParams, reqEditors ...RequestEditorFn) (*GetStacksResponse, error) {
	rsp, err := c.GetStacks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStacksResponse(rsp)
}

// CreateStackWithBodyWithResponse request with arbitrary body returning *CreateStackResponse
func (c *ClientWithResponses) CreateStackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStackResponse, error) {
	rsp, err := c.CreateStackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStackResponse(rsp)
}

func (c *ClientWithResponses) CreateStackWithResponse(ctx context.Context, body CreateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStackResponse, error) {
	rsp, err := c.CreateStack(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStackResponse(rsp)
}

// LookupStackBuildWithResponse request returning *LookupStackBuildResponse
func (c *ClientWithResponses) LookupStackBuildWithResponse(ctx context.Context, buildId string, reqEditors ...RequestEditorFn) (*LookupStackBuildResponse, error) {
	rsp, err := c.LookupStackBuild(ctx, buildId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLookupStackBuildResponse(rsp)
}

// DeleteStackWithResponse request returning *DeleteStackResponse
func (c *ClientWithResponses) DeleteStackWithResponse(ctx context.Context, stackId string, reqEditors ...RequestEditorFn) (*DeleteStackResponse, error) {
	rsp, err := c.DeleteStack(ctx, stackId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStackResponse(rsp)
}

// GetStackWithResponse request returning *GetStackResponse
func (c *ClientWithResponses) GetStackWithResponse(ctx context.Context, stackId string, reqEditors ...RequestEditorFn) (*GetStackResponse, error) {
	rsp, err := c.GetStack(ctx, stackId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStackResponse(rsp)
}

// UpdateStackWithBodyWithResponse request with arbitrary body returning *UpdateStackResponse
func (c *ClientWithResponses) UpdateStackWithBodyWithResponse(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStackResponse, error) {
	rsp, err := c.UpdateStackWithBody(ctx, stackId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStackResponse(rsp)
}

func (c *ClientWithResponses) UpdateStackWithResponse(ctx context.Context, stackId string, body UpdateStackJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStackResponse, error) {
	rsp, err := c.UpdateStack(ctx, stackId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStackResponse(rsp)
}

// UpdateStackAccessWithBodyWithResponse request with arbitrary body returning *UpdateStackAccessResponse
func (c *ClientWithResponses) UpdateStackAccessWithBodyWithResponse(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStackAccessResponse, error) {
	rsp, err := c.UpdateStackAccessWithBody(ctx, stackId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStackAccessResponse(rsp)
}

func (c *ClientWithResponses) UpdateStackAccessWithResponse(ctx context.Context, stackId string, body UpdateStackAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStackAccessResponse, error) {
	rsp, err := c.UpdateStackAccess(ctx, stackId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStackAccessResponse(rsp)
}

// GetStackBuildsWithResponse request returning *GetStackBuildsResponse
func (c *ClientWithResponses) GetStackBuildsWithResponse(ctx context.Context, stackId string, params *GetStackBuildsParams, reqEditors ...RequestEditorFn) (*GetStackBuildsResponse, error) {
	rsp, err := c.GetStackBuilds(ctx, stackId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStackBuildsResponse(rsp)
}

// CreateStackBuildWithBodyWithResponse request with arbitrary body returning *CreateStackBuildResponse
func (c *ClientWithResponses) CreateStackBuildWithBodyWithResponse(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStackBuildResponse, error) {
	rsp, err := c.CreateStackBuildWithBody(ctx, stackId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStackBuildResponse(rsp)
}

func (c *ClientWithResponses) CreateStackBuildWithResponse(ctx context.Context, stackId string, body CreateStackBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStackBuildResponse, error) {
	rsp, err := c.CreateStackBuild(ctx, stackId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStackBuildResponse(rsp)
}

// DeleteStackBuildWithResponse request returning *DeleteStackBuildResponse
func (c *ClientWithResponses) DeleteStackBuildWithResponse(ctx context.Context, stackId string, buildId string, reqEditors ...RequestEditorFn) (*DeleteStackBuildResponse, error) {
	rsp, err := c.DeleteStackBuild(ctx, stackId, buildId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStackBuildResponse(rsp)
}

// GetStackBuildWithResponse request returning *GetStackBuildResponse
func (c *ClientWithResponses) GetStackBuildWithResponse(ctx context.Context, stackId string, buildId string, reqEditors ...RequestEditorFn) (*GetStackBuildResponse, error) {
	rsp, err := c.GetStackBuild(ctx, stackId, buildId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStackBuildResponse(rsp)
}

// GetStackBuildLogWithResponse request returning *GetStackBuildLogResponse
func (c *ClientWithResponses) GetStackBuildLogWithResponse(ctx context.Context, stackId string, buildId string, reqEditors ...RequestEditorFn) (*GetStackBuildLogResponse, error) {
	rsp, err := c.GetStackBuildLog(ctx, stackId, buildId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStackBuildLogResponse(rsp)
}

// CreateStackBuildJobWithBodyWithResponse request with arbitrary body returning *CreateStackBuildJobResponse
func (c *ClientWithResponses) CreateStackBuildJobWithBodyWithResponse(ctx context.Context, stackId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStackBuildJobResponse, error) {
	rsp, err := c.CreateStackBuildJobWithBody(ctx, stackId, buildId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStackBuildJobResponse(rsp)
}

func (c *ClientWithResponses) CreateStackBuildJobWithResponse(ctx context.Context, stackId string, buildId string, body CreateStackBuildJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStackBuildJobResponse, error) {
	rsp, err := c.CreateStackBuildJob(ctx, stackId, buildId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStackBuildJobResponse(rsp)
}

// CreateStackJobWithBodyWithResponse request with arbitrary body returning *CreateStackJobResponse
func (c *ClientWithResponses) CreateStackJobWithBodyWithResponse(ctx context.Context, stackId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStackJobResponse, error) {
	rsp, err := c.CreateStackJobWithBody(ctx, stackId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStackJobResponse(rsp)
}

func (c *ClientWithResponses) CreateStackJobWithResponse(ctx context.Context, stackId string, body CreateStackJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStackJobResponse, error) {
	rsp, err := c.CreateStackJob(ctx, stackId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStackJobResponse(rsp)
}

// LookupComponentsWithBodyWithResponse request with arbitrary body returning *LookupComponentsResponse
func (c *ClientWithResponses) LookupComponentsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LookupComponentsResponse, error) {
	rsp, err := c.LookupComponentsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLookupComponentsResponse(rsp)
}

func (c *ClientWithResponses) LookupComponentsWithResponse(ctx context.Context, body LookupComponentsJSONRequestBody, reqEditors ...RequestEditorFn) (*LookupComponentsResponse, error) {
	rsp, err := c.LookupComponents(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLookupComponentsResponse(rsp)
}

// LookupIdentifierWithResponse request returning *LookupIdentifierResponse
func (c *ClientWithResponses) LookupIdentifierWithResponse(ctx context.Context, params *LookupIdentifierParams, reqEditors ...RequestEditorFn) (*LookupIdentifierResponse, error) {
	rsp, err := c.LookupIdentifier(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLookupIdentifierResponse(rsp)
}

// GetVirtualMachinesWithResponse request returning *GetVirtualMachinesResponse
func (c *ClientWithResponses) GetVirtualMachinesWithResponse(ctx context.Context, params *GetVirtualMachinesParams, reqEditors ...RequestEditorFn) (*GetVirtualMachinesResponse, error) {
	rsp, err := c.GetVirtualMachines(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualMachinesResponse(rsp)
}

// CreateVirtualMachineWithBodyWithResponse request with arbitrary body returning *CreateVirtualMachineResponse
func (c *ClientWithResponses) CreateVirtualMachineWithBodyWithResponse(ctx context.Context, params *CreateVirtualMachineParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualMachineResponse, error) {
	rsp, err := c.CreateVirtualMachineWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualMachineResponse(rsp)
}

func (c *ClientWithResponses) CreateVirtualMachineWithResponse(ctx context.Context, params *CreateVirtualMachineParams, body CreateVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualMachineResponse, error) {
	rsp, err := c.CreateVirtualMachine(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualMachineResponse(rsp)
}

// GetVirtualMachineBaseImagesWithResponse request returning *GetVirtualMachineBaseImagesResponse
func (c *ClientWithResponses) GetVirtualMachineBaseImagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVirtualMachineBaseImagesResponse, error) {
	rsp, err := c.GetVirtualMachineBaseImages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualMachineBaseImagesResponse(rsp)
}

// GetVirtualMachineSshKeysWithResponse request returning *GetVirtualMachineSshKeysResponse
func (c *ClientWithResponses) GetVirtualMachineSshKeysWithResponse(ctx context.Context, params *GetVirtualMachineSshKeysParams, reqEditors ...RequestEditorFn) (*GetVirtualMachineSshKeysResponse, error) {
	rsp, err := c.GetVirtualMachineSshKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualMachineSshKeysResponse(rsp)
}

// CreateVirtualMachineSshKeyWithBodyWithResponse request with arbitrary body returning *CreateVirtualMachineSshKeyResponse
func (c *ClientWithResponses) CreateVirtualMachineSshKeyWithBodyWithResponse(ctx context.Context, params *CreateVirtualMachineSshKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualMachineSshKeyResponse, error) {
	rsp, err := c.CreateVirtualMachineSshKeyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualMachineSshKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateVirtualMachineSshKeyWithResponse(ctx context.Context, params *CreateVirtualMachineSshKeyParams, body CreateVirtualMachineSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualMachineSshKeyResponse, error) {
	rsp, err := c.CreateVirtualMachineSshKey(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualMachineSshKeyResponse(rsp)
}

// DeleteVirtualMachineSshKeyWithResponse request returning *DeleteVirtualMachineSshKeyResponse
func (c *ClientWithResponses) DeleteVirtualMachineSshKeyWithResponse(ctx context.Context, sshKeyId string, reqEditors ...RequestEditorFn) (*DeleteVirtualMachineSshKeyResponse, error) {
	rsp, err := c.DeleteVirtualMachineSshKey(ctx, sshKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualMachineSshKeyResponse(rsp)
}

// GetVirtualMachineSshKeyWithResponse request returning *GetVirtualMachineSshKeyResponse
func (c *ClientWithResponses) GetVirtualMachineSshKeyWithResponse(ctx context.Context, sshKeyId string, params *GetVirtualMachineSshKeyParams, reqEditors ...RequestEditorFn) (*GetVirtualMachineSshKeyResponse, error) {
	rsp, err := c.GetVirtualMachineSshKey(ctx, sshKeyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualMachineSshKeyResponse(rsp)
}

// UpdateVirtualMachineSshKeyWithBodyWithResponse request with arbitrary body returning *UpdateVirtualMachineSshKeyResponse
func (c *ClientWithResponses) UpdateVirtualMachineSshKeyWithBodyWithResponse(ctx context.Context, sshKeyId string, params *UpdateVirtualMachineSshKeyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVirtualMachineSshKeyResponse, error) {
	rsp, err := c.UpdateVirtualMachineSshKeyWithBody(ctx, sshKeyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVirtualMachineSshKeyResponse(rsp)
}

func (c *ClientWithResponses) UpdateVirtualMachineSshKeyWithResponse(ctx context.Context, sshKeyId string, params *UpdateVirtualMachineSshKeyParams, body UpdateVirtualMachineSshKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVirtualMachineSshKeyResponse, error) {
	rsp, err := c.UpdateVirtualMachineSshKey(ctx, sshKeyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVirtualMachineSshKeyResponse(rsp)
}

// DeleteVirtualMachineWithResponse request returning *DeleteVirtualMachineResponse
func (c *ClientWithResponses) DeleteVirtualMachineWithResponse(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*DeleteVirtualMachineResponse, error) {
	rsp, err := c.DeleteVirtualMachine(ctx, virtualMachineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVirtualMachineResponse(rsp)
}

// GetVirtualMachineWithResponse request returning *GetVirtualMachineResponse
func (c *ClientWithResponses) GetVirtualMachineWithResponse(ctx context.Context, virtualMachineId string, params *GetVirtualMachineParams, reqEditors ...RequestEditorFn) (*GetVirtualMachineResponse, error) {
	rsp, err := c.GetVirtualMachine(ctx, virtualMachineId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVirtualMachineResponse(rsp)
}

// UpdateVirtualMachineWithBodyWithResponse request with arbitrary body returning *UpdateVirtualMachineResponse
func (c *ClientWithResponses) UpdateVirtualMachineWithBodyWithResponse(ctx context.Context, virtualMachineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVirtualMachineResponse, error) {
	rsp, err := c.UpdateVirtualMachineWithBody(ctx, virtualMachineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVirtualMachineResponse(rsp)
}

func (c *ClientWithResponses) UpdateVirtualMachineWithResponse(ctx context.Context, virtualMachineId string, body UpdateVirtualMachineJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVirtualMachineResponse, error) {
	rsp, err := c.UpdateVirtualMachine(ctx, virtualMachineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVirtualMachineResponse(rsp)
}

// GetAvailableIpsWithResponse request returning *GetAvailableIpsResponse
func (c *ClientWithResponses) GetAvailableIpsWithResponse(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*GetAvailableIpsResponse, error) {
	rsp, err := c.GetAvailableIps(ctx, virtualMachineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAvailableIpsResponse(rsp)
}

// ExpireVirtualMachineSosCredentialsWithResponse request returning *ExpireVirtualMachineSosCredentialsResponse
func (c *ClientWithResponses) ExpireVirtualMachineSosCredentialsWithResponse(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*ExpireVirtualMachineSosCredentialsResponse, error) {
	rsp, err := c.ExpireVirtualMachineSosCredentials(ctx, virtualMachineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExpireVirtualMachineSosCredentialsResponse(rsp)
}

// GenerateVirtualMachineSosCredentialsWithResponse request returning *GenerateVirtualMachineSosCredentialsResponse
func (c *ClientWithResponses) GenerateVirtualMachineSosCredentialsWithResponse(ctx context.Context, virtualMachineId string, reqEditors ...RequestEditorFn) (*GenerateVirtualMachineSosCredentialsResponse, error) {
	rsp, err := c.GenerateVirtualMachineSosCredentials(ctx, virtualMachineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateVirtualMachineSosCredentialsResponse(rsp)
}

// CreateVirtualMachineJobWithBodyWithResponse request with arbitrary body returning *CreateVirtualMachineJobResponse
func (c *ClientWithResponses) CreateVirtualMachineJobWithBodyWithResponse(ctx context.Context, virtualMachineId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVirtualMachineJobResponse, error) {
	rsp, err := c.CreateVirtualMachineJobWithBody(ctx, virtualMachineId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualMachineJobResponse(rsp)
}

func (c *ClientWithResponses) CreateVirtualMachineJobWithResponse(ctx context.Context, virtualMachineId string, body CreateVirtualMachineJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVirtualMachineJobResponse, error) {
	rsp, err := c.CreateVirtualMachineJob(ctx, virtualMachineId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVirtualMachineJobResponse(rsp)
}

// ParseDeleteAccountResponse parses an HTTP response from a DeleteAccountWithResponse call
func ParseDeleteAccountResponse(rsp *http.Response) (*DeleteAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAccountResponse parses an HTTP response from a GetAccountWithResponse call
func ParseGetAccountResponse(rsp *http.Response) (*GetAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An object representing information about the currently logged-in user.
			Data *Account `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateAccountResponse parses an HTTP response from a UpdateAccountWithResponse call
func ParseUpdateAccountResponse(rsp *http.Response) (*UpdateAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An object representing information about the currently logged-in user.
			Data Account `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDisableTwoFactorAuthResponse parses an HTTP response from a DisableTwoFactorAuthWithResponse call
func ParseDisableTwoFactorAuthResponse(rsp *http.Response) (*DisableTwoFactorAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableTwoFactorAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An object representing information about the currently logged-in user.
			Data Account `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRecoverTwoFactorAuthResponse parses an HTTP response from a RecoverTwoFactorAuthWithResponse call
func ParseRecoverTwoFactorAuthResponse(rsp *http.Response) (*RecoverTwoFactorAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecoverTwoFactorAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data TwoFactorAuthSetup `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTwoFactorAuthSetupResponse parses an HTTP response from a GetTwoFactorAuthSetupWithResponse call
func ParseGetTwoFactorAuthSetupResponse(rsp *http.Response) (*GetTwoFactorAuthSetupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTwoFactorAuthSetupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *TwoFactorAuthSetup `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEnableTwoFactorAuthResponse parses an HTTP response from a EnableTwoFactorAuthWithResponse call
func ParseEnableTwoFactorAuthResponse(rsp *http.Response) (*EnableTwoFactorAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableTwoFactorAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data TwoFactorAuthRecovery `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAccountInvitesResponse parses an HTTP response from a GetAccountInvitesWithResponse call
func ParseGetAccountInvitesResponse(rsp *http.Response) (*GetAccountInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []HubMembership `json:"data"`

			// Includes A resource that is associated with an account's membership.
			Includes *AccountMembershipIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateAccountInviteResponse parses an HTTP response from a UpdateAccountInviteWithResponse call
func ParseUpdateAccountInviteResponse(rsp *http.Response) (*UpdateAccountInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccountInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A membership resource that is scoped to an individual hub.
			Data HubMembership `json:"data"`

			// Includes A resource that is associated with an account's membership.
			Includes *AccountMembershipIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAccountLoginsResponse parses an HTTP response from a GetAccountLoginsWithResponse call
func ParseGetAccountLoginsResponse(rsp *http.Response) (*GetAccountLoginsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountLoginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []map[string]interface{} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAccountMembershipsResponse parses an HTTP response from a GetAccountMembershipsWithResponse call
func ParseGetAccountMembershipsResponse(rsp *http.Response) (*GetAccountMembershipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountMembershipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []HubMembership `json:"data"`

			// Includes A resource that is associated with a hub membership.
			Includes *HubMembershipIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseChangePasswordResponse parses an HTTP response from a ChangePasswordWithResponse call
func ParseChangePasswordResponse(rsp *http.Response) (*ChangePasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangePasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An object representing information about the currently logged-in user.
			Data Account `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				Success bool `json:"success"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAnnouncementsResponse parses an HTTP response from a GetAnnouncementsWithResponse call
func ParseGetAnnouncementsResponse(rsp *http.Response) (*GetAnnouncementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnnouncementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Announcement `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCreditsResponse parses an HTTP response from a GetCreditsWithResponse call
func ParseGetCreditsResponse(rsp *http.Response) (*GetCreditsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCreditsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Credit `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCreditResponse parses an HTTP response from a GetCreditWithResponse call
func ParseGetCreditResponse(rsp *http.Response) (*GetCreditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCreditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Information about a billing credit.
			Data Credit `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInvoicesResponse parses an HTTP response from a GetInvoicesWithResponse call
func ParseGetInvoicesResponse(rsp *http.Response) (*GetInvoicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Invoice `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInvoiceResponse parses an HTTP response from a GetInvoiceWithResponse call
func ParseGetInvoiceResponse(rsp *http.Response) (*GetInvoiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Information about a billing invoice.
			Data Invoice `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateInvoiceJobResponse parses an HTTP response from a CreateInvoiceJobWithResponse call
func ParseCreateInvoiceJobResponse(rsp *http.Response) (*CreateInvoiceJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInvoiceJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBillingMethodsResponse parses an HTTP response from a GetBillingMethodsWithResponse call
func ParseGetBillingMethodsResponse(rsp *http.Response) (*GetBillingMethodsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingMethodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Method `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBillingMethodResponse parses an HTTP response from a CreateBillingMethodWithResponse call
func ParseCreateBillingMethodResponse(rsp *http.Response) (*CreateBillingMethodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBillingMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Information about a billing method, usable to pay invoices.
			Data Method `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBillingMethodResponse parses an HTTP response from a DeleteBillingMethodWithResponse call
func ParseDeleteBillingMethodResponse(rsp *http.Response) (*DeleteBillingMethodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBillingMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBillingMethodResponse parses an HTTP response from a GetBillingMethodWithResponse call
func ParseGetBillingMethodResponse(rsp *http.Response) (*GetBillingMethodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Information about a billing method, usable to pay invoices.
			Data Method `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateBillingMethodResponse parses an HTTP response from a UpdateBillingMethodWithResponse call
func ParseUpdateBillingMethodResponse(rsp *http.Response) (*UpdateBillingMethodResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBillingMethodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Information about a billing method, usable to pay invoices.
			Data Method `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBillingMethodJobResponse parses an HTTP response from a CreateBillingMethodJobWithResponse call
func ParseCreateBillingMethodJobResponse(rsp *http.Response) (*CreateBillingMethodJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBillingMethodJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOrdersResponse parses an HTTP response from a GetOrdersWithResponse call
func ParseGetOrdersResponse(rsp *http.Response) (*GetOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []Order               `json:"data"`
			Includes *BillingOrderIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateOrderResponse parses an HTTP response from a CreateOrderWithResponse call
func ParseCreateOrderResponse(rsp *http.Response) (*CreateOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Information about an order.
			Data     BillingOrder          `json:"data"`
			Includes *BillingOrderIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBillingOrderResponse parses an HTTP response from a GetBillingOrderWithResponse call
func ParseGetBillingOrderResponse(rsp *http.Response) (*GetBillingOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An order is a resource that describes a billing order
			Data     Order                 `json:"data"`
			Includes *BillingOrderIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateBillingOrderResponse parses an HTTP response from a UpdateBillingOrderWithResponse call
func ParseUpdateBillingOrderResponse(rsp *http.Response) (*UpdateBillingOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBillingOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An order is a resource that describes a billing order
			Data     Order                 `json:"data"`
			Includes *BillingOrderIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateOrderJobResponse parses an HTTP response from a CreateOrderJobWithResponse call
func ParseCreateOrderJobResponse(rsp *http.Response) (*CreateOrderJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrderJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBillingSupportPlansResponse parses an HTTP response from a GetBillingSupportPlansWithResponse call
func ParseGetBillingSupportPlansResponse(rsp *http.Response) (*GetBillingSupportPlansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingSupportPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []SupportPlan `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBillingTiersResponse parses an HTTP response from a GetBillingTiersWithResponse call
func ParseGetBillingTiersResponse(rsp *http.Response) (*GetBillingTiersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingTiersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []TierPlan `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBillingServicesResponse parses an HTTP response from a GetBillingServicesWithResponse call
func ParseGetBillingServicesResponse(rsp *http.Response) (*GetBillingServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []BillingService `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBillingOveragesResponse parses an HTTP response from a GetBillingOveragesWithResponse call
func ParseGetBillingOveragesResponse(rsp *http.Response) (*GetBillingOveragesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingOveragesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Overage `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBillingServiceResponse parses an HTTP response from a GetBillingServiceWithResponse call
func ParseGetBillingServiceResponse(rsp *http.Response) (*GetBillingServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Information about billing service.
			Data BillingService `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBillingStatusResponse parses an HTTP response from a GetBillingStatusWithResponse call
func ParseGetBillingStatusResponse(rsp *http.Response) (*GetBillingStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				// Enabled Whether billing is enabled for this core. Generally, this will only be false for dedicated cores.
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetChangelogResponse parses an HTTP response from a GetChangelogWithResponse call
func ParseGetChangelogResponse(rsp *http.Response) (*GetChangelogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChangelogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]ChangelogEntry `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetContainersResponse parses an HTTP response from a GetContainersWithResponse call
func ParseGetContainersResponse(rsp *http.Response) (*GetContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Container `json:"data"`

			// Includes All includable resources linkable to the given container.
			Includes *ContainerIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateContainerResponse parses an HTTP response from a CreateContainerWithResponse call
func ParseCreateContainerResponse(rsp *http.Response) (*CreateContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Containers are a way to package together your application along with it's dependencies, and run in a resource isolated process. They provide consistency across different hosts, efficiency over traditional hosting methods, and facilitate a micro-service based approach, where each logical piece of your application is split into multiple, easily testable parts (such as API, Backend, Frontend, etc).
			Data Container `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteContainerResponse parses an HTTP response from a DeleteContainerWithResponse call
func ParseDeleteContainerResponse(rsp *http.Response) (*DeleteContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetContainerResponse parses an HTTP response from a GetContainerWithResponse call
func ParseGetContainerResponse(rsp *http.Response) (*GetContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Containers are a way to package together your application along with it's dependencies, and run in a resource isolated process. They provide consistency across different hosts, efficiency over traditional hosting methods, and facilitate a micro-service based approach, where each logical piece of your application is split into multiple, easily testable parts (such as API, Backend, Frontend, etc).
			Data Container `json:"data"`

			// Includes All includable resources linkable to the given container.
			Includes *ContainerIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateContainerResponse parses an HTTP response from a UpdateContainerWithResponse call
func ParseUpdateContainerResponse(rsp *http.Response) (*UpdateContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Containers are a way to package together your application along with it's dependencies, and run in a resource isolated process. They provide consistency across different hosts, efficiency over traditional hosting methods, and facilitate a micro-service based approach, where each logical piece of your application is split into multiple, easily testable parts (such as API, Backend, Frontend, etc).
			Data Container `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetContainerBackupsResponse parses an HTTP response from a GetContainerBackupsWithResponse call
func ParseGetContainerBackupsResponse(rsp *http.Response) (*GetContainerBackupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerBackupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []ContainerBackup `json:"data"`

			// Includes All includable resources linkable to the given Zone.
			Includes *ContainerBackupIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteContainerBackupResponse parses an HTTP response from a DeleteContainerBackupWithResponse call
func ParseDeleteContainerBackupResponse(rsp *http.Response) (*DeleteContainerBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteContainerBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetContainerBackupResponse parses an HTTP response from a GetContainerBackupWithResponse call
func ParseGetContainerBackupResponse(rsp *http.Response) (*GetContainerBackupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerBackupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A Container Backup.
			Data ContainerBackup `json:"data"`

			// Includes All includable resources linkable to the given Zone.
			Includes *ContainerBackupIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetContainerBackupLogsResponse parses an HTTP response from a GetContainerBackupLogsWithResponse call
func ParseGetContainerBackupLogsResponse(rsp *http.Response) (*GetContainerBackupLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerBackupLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []ContainerBackupLogs `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateContainerBackupJobResponse parses an HTTP response from a CreateContainerBackupJobWithResponse call
func ParseCreateContainerBackupJobResponse(rsp *http.Response) (*CreateContainerBackupJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateContainerBackupJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCompatibleImagesResponse parses an HTTP response from a GetCompatibleImagesWithResponse call
func ParseGetCompatibleImagesResponse(rsp *http.Response) (*GetCompatibleImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompatibleImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Image `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFunctionJobResponse parses an HTTP response from a CreateFunctionJobWithResponse call
func ParseCreateFunctionJobResponse(rsp *http.Response) (*CreateFunctionJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFunctionJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteContainerInstancesResponse parses an HTTP response from a DeleteContainerInstancesWithResponse call
func ParseDeleteContainerInstancesResponse(rsp *http.Response) (*DeleteContainerInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteContainerInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInstancesResponse parses an HTTP response from a GetInstancesWithResponse call
func ParseGetInstancesResponse(rsp *http.Response) (*GetInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Instance `json:"data"`

			// Includes A resource associated with an instance.
			Includes *InstanceIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateInstancesResponse parses an HTTP response from a CreateInstancesWithResponse call
func ParseCreateInstancesResponse(rsp *http.Response) (*CreateInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteInstanceResponse parses an HTTP response from a DeleteInstanceWithResponse call
func ParseDeleteInstanceResponse(rsp *http.Response) (*DeleteInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInstanceResponse parses an HTTP response from a GetInstanceWithResponse call
func ParseGetInstanceResponse(rsp *http.Response) (*GetInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An instance of a Container.
			Data Instance `json:"data"`

			// Includes A resource associated with an instance.
			Includes *InstanceIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInstanceConsoleStreamAuthResponse parses an HTTP response from a GetInstanceConsoleStreamAuthWithResponse call
func ParseGetInstanceConsoleStreamAuthResponse(rsp *http.Response) (*GetInstanceConsoleStreamAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceConsoleStreamAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				// Address The protocol and url for connecting to the Instance console.
				Address string `json:"address"`

				// Token A token used for connecting to the Instance console.
				Token string `json:"token"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExpireInstanceSSHCredentialsResponse parses an HTTP response from a ExpireInstanceSSHCredentialsWithResponse call
func ParseExpireInstanceSSHCredentialsResponse(rsp *http.Response) (*ExpireInstanceSSHCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpireInstanceSSHCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The number of tokens expired.
			Data struct {
				// Tokens The number of tokens expired.
				Tokens int `json:"tokens"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGenerateInstanceSSHCredentialsResponse parses an HTTP response from a GenerateInstanceSSHCredentialsWithResponse call
func ParseGenerateInstanceSSHCredentialsResponse(rsp *http.Response) (*GenerateInstanceSSHCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateInstanceSSHCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data SSH connection information for a given container instance.
			Data SSHResponse `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateInstanceJobResponse parses an HTTP response from a CreateInstanceJobWithResponse call
func ParseCreateInstanceJobResponse(rsp *http.Response) (*CreateInstanceJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInstanceJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInstanceTelemetryReportResponse parses an HTTP response from a GetInstanceTelemetryReportWithResponse call
func ParseGetInstanceTelemetryReportResponse(rsp *http.Response) (*GetInstanceTelemetryReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceTelemetryReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An Instance telemetry report.
			Data InstanceTelemetryReport `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInstanceTelemetryStreamAuthResponse parses an HTTP response from a GetInstanceTelemetryStreamAuthWithResponse call
func ParseGetInstanceTelemetryStreamAuthResponse(rsp *http.Response) (*GetInstanceTelemetryStreamAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceTelemetryStreamAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Credentials for connecting to the instance telemetry stream on compute.
			Data struct {
				// Address The URL address to open a websocket to for streaming instance telemetry data.
				Address string `json:"address"`

				// Token The authentication token passed into the address as a URL parameter (?token).
				Token string `json:"token"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInstanceVolumesResponse parses an HTTP response from a GetInstanceVolumesWithResponse call
func ParseGetInstanceVolumesResponse(rsp *http.Response) (*GetInstanceVolumesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInstanceVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []InstanceVolume `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetContainerServersResponse parses an HTTP response from a GetContainerServersWithResponse call
func ParseGetContainerServersResponse(rsp *http.Response) (*GetContainerServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A Server ID and number of Instances of a specific Container it hosts.
			Data ServerInstancesSummary `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCompatibleServersResponse parses an HTTP response from a GetCompatibleServersWithResponse call
func ParseGetCompatibleServersResponse(rsp *http.Response) (*GetCompatibleServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCompatibleServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Server `json:"data"`

			// Includes A resource associated with a server.
			Includes *ServerIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetContainerSummaryResponse parses an HTTP response from a GetContainerSummaryWithResponse call
func ParseGetContainerSummaryResponse(rsp *http.Response) (*GetContainerSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Contains useful and relevant data/statistics for a container that would otherwise be several separate API calls.
			Data struct {
				// Id A 24 character hex string used to identify a unique resource.
				Id    ID                 `json:"id"`
				State ContainerState     `json:"state"`
				Stats *StateCountSummary `json:"stats"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateContainerJobResponse parses an HTTP response from a CreateContainerJobWithResponse call
func ParseCreateContainerJobResponse(rsp *http.Response) (*CreateContainerJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateContainerJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTLSGenerationAttemptsResponse parses an HTTP response from a GetTLSGenerationAttemptsWithResponse call
func ParseGetTLSGenerationAttemptsResponse(rsp *http.Response) (*GetTLSGenerationAttemptsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTLSGenerationAttemptsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Attempt `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLookupTLSCertificateResponse parses an HTTP response from a LookupTLSCertificateWithResponse call
func ParseLookupTLSCertificateResponse(rsp *http.Response) (*LookupTLSCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LookupTLSCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				Bundle *string `json:"bundle,omitempty"`
				Csr    *string `json:"csr,omitempty"`

				// Domains A list of domains associated with the certificate.
				Domains []string `json:"domains"`

				// Events A collection of timestamps for each event in the TLS certificate's lifetime.
				Events struct {
					Created   DateTime `json:"created"`
					Deleted   DateTime `json:"deleted"`
					Generated DateTime `json:"generated"`
					Updated   DateTime `json:"updated"`
				} `json:"events"`
				Expires DateTime `json:"expires"`
				HubId   *ID      `json:"hub_id"`

				// Id A 24 character hex string used to identify a unique resource.
				Id         ID      `json:"id"`
				PrivateKey *string `json:"private_key,omitempty"`
				State      struct {
					Changed DateTime `json:"changed"`

					// Current The current state of the TLS certificate.
					Current LookupTLSCertificate200DataStateCurrent `json:"current"`

					// Error An error, if any, that has occurred for this resource.
					Error *struct {
						// Message Details about the error that has occurred.
						Message *string   `json:"message,omitempty"`
						Time    *DateTime `json:"time,omitempty"`
					} `json:"error,omitempty"`
				} `json:"state"`

				// UserSupplied Whether or not this certificate was uploaded instead of generated by the platform.
				UserSupplied bool `json:"user_supplied"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserSuppliedCertificatesResponse parses an HTTP response from a GetUserSuppliedCertificatesWithResponse call
func ParseGetUserSuppliedCertificatesResponse(rsp *http.Response) (*GetUserSuppliedCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserSuppliedCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []TlsCertificate `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUploadUserSuppliedCertificateResponse parses an HTTP response from a UploadUserSuppliedCertificateWithResponse call
func ParseUploadUserSuppliedCertificateResponse(rsp *http.Response) (*UploadUserSuppliedCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadUserSuppliedCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data A TLS certificate.
			Data TlsCertificate `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserSuppliedCertificateResponse parses an HTTP response from a GetUserSuppliedCertificateWithResponse call
func ParseGetUserSuppliedCertificateResponse(rsp *http.Response) (*GetUserSuppliedCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserSuppliedCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A TLS certificate.
			Data TlsCertificate `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserSuppliedCertificateJobResponse parses an HTTP response from a CreateUserSuppliedCertificateJobWithResponse call
func ParseCreateUserSuppliedCertificateJobResponse(rsp *http.Response) (*CreateUserSuppliedCertificateJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserSuppliedCertificateJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDNSZonesResponse parses an HTTP response from a GetDNSZonesWithResponse call
func ParseGetDNSZonesResponse(rsp *http.Response) (*GetDNSZonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDNSZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []DnsZone `json:"data"`

			// Includes All includable resources linkable to the given Zone.
			Includes *DnsZoneIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDNSZoneResponse parses an HTTP response from a CreateDNSZoneWithResponse call
func ParseCreateDNSZoneResponse(rsp *http.Response) (*CreateDNSZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDNSZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
			Data DnsZone `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDNSZoneResponse parses an HTTP response from a DeleteDNSZoneWithResponse call
func ParseDeleteDNSZoneResponse(rsp *http.Response) (*DeleteDNSZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDNSZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDNSZoneResponse parses an HTTP response from a GetDNSZoneWithResponse call
func ParseGetDNSZoneResponse(rsp *http.Response) (*GetDNSZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDNSZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
			Data DnsZone `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateDNSZoneResponse parses an HTTP response from a UpdateDNSZoneWithResponse call
func ParseUpdateDNSZoneResponse(rsp *http.Response) (*UpdateDNSZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDNSZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
			Data DnsZone `json:"data"`

			// Includes All includable resources linkable to the given Zone.
			Includes *DnsZoneIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateDNSZoneAccessResponse parses an HTTP response from a UpdateDNSZoneAccessWithResponse call
func ParseUpdateDNSZoneAccessResponse(rsp *http.Response) (*UpdateDNSZoneAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDNSZoneAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
			Data DnsZone `json:"data"`

			// Includes All includable resources linkable to the given Zone.
			Includes *DnsZoneIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDNSZoneRecordsResponse parses an HTTP response from a GetDNSZoneRecordsWithResponse call
func ParseGetDNSZoneRecordsResponse(rsp *http.Response) (*GetDNSZoneRecordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDNSZoneRecordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []DnsRecord `json:"data"`

			// Includes All includable resources linkable to the given records.
			Includes *RecordIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDNSZoneRecordResponse parses an HTTP response from a CreateDNSZoneRecordWithResponse call
func ParseCreateDNSZoneRecordResponse(rsp *http.Response) (*CreateDNSZoneRecordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDNSZoneRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data A DNS record.
			Data DnsRecord `json:"data"`

			// Includes All includable resources linkable to the given records.
			Includes *RecordIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDNSZoneRecordResponse parses an HTTP response from a DeleteDNSZoneRecordWithResponse call
func ParseDeleteDNSZoneRecordResponse(rsp *http.Response) (*DeleteDNSZoneRecordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDNSZoneRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data *JobDescriptor `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateDNSZoneRecordResponse parses an HTTP response from a UpdateDNSZoneRecordWithResponse call
func ParseUpdateDNSZoneRecordResponse(rsp *http.Response) (*UpdateDNSZoneRecordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDNSZoneRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A DNS record.
			Data DnsRecord `json:"data"`

			// Includes All includable resources linkable to the given records.
			Includes *RecordIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDNSZoneRecordJobResponse parses an HTTP response from a CreateDNSZoneRecordJobWithResponse call
func ParseCreateDNSZoneRecordJobResponse(rsp *http.Response) (*CreateDNSZoneRecordJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDNSZoneRecordJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDNSZoneJobResponse parses an HTTP response from a CreateDNSZoneJobWithResponse call
func ParseCreateDNSZoneJobResponse(rsp *http.Response) (*CreateDNSZoneJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDNSZoneJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentsResponse parses an HTTP response from a GetEnvironmentsWithResponse call
func ParseGetEnvironmentsResponse(rsp *http.Response) (*GetEnvironmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []Environment `json:"data"`
			Includes *struct {
				// Creators An identity that created a resource.
				Creators *CreatorInclude `json:"creators,omitempty"`
			} `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateEnvironmentResponse parses an HTTP response from a CreateEnvironmentWithResponse call
func ParseCreateEnvironmentResponse(rsp *http.Response) (*CreateEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://cycle.io/docs/platform/introduction-to-environments).
			Data Environment `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEnvironmentResponse parses an HTTP response from a DeleteEnvironmentWithResponse call
func ParseDeleteEnvironmentResponse(rsp *http.Response) (*DeleteEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentResponse parses an HTTP response from a GetEnvironmentWithResponse call
func ParseGetEnvironmentResponse(rsp *http.Response) (*GetEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://cycle.io/docs/platform/introduction-to-environments).
			Data     Environment `json:"data"`
			Includes *struct {
				// Clusters A resource associated with a cluster.
				Clusters *ClusterIncludes `json:"clusters,omitempty"`

				// Creators An identity that created a resource.
				Creators *CreatorInclude `json:"creators,omitempty"`
			} `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateEnvironmentResponse parses an HTTP response from a UpdateEnvironmentWithResponse call
func ParseUpdateEnvironmentResponse(rsp *http.Response) (*UpdateEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://cycle.io/docs/platform/introduction-to-environments).
			Data Environment `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateEnvironmentAccessResponse parses an HTTP response from a UpdateEnvironmentAccessWithResponse call
func ParseUpdateEnvironmentAccessResponse(rsp *http.Response) (*UpdateEnvironmentAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEnvironmentAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://cycle.io/docs/platform/introduction-to-environments).
			Data Environment `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentDeploymentsResponse parses an HTTP response from a GetEnvironmentDeploymentsWithResponse call
func ParseGetEnvironmentDeploymentsResponse(rsp *http.Response) (*GetEnvironmentDeploymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentDeploymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				// Versions A map where the key is the version property of a deployment.
				Versions map[string]struct {
					// Containers The number of containers utilizing this version of this deployment.
					Containers int `json:"containers"`

					// Tags An array of all tags on this environment that point to this version.
					Tags []Identifier `json:"tags"`
				} `json:"versions"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExportStackResponse parses an HTTP response from a ExportStackWithResponse call
func ParseExportStackResponse(rsp *http.Response) (*ExportStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A Cycle stack file is an "environment as code". This allows an environment to be generated consistently based on a fixed specification.
			// Stack files can describe multiple containers and their configurations, environment service settings, scoped variables, and important metadata.
			Data StackSpec `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetScopedVariablesResponse parses an HTTP response from a GetScopedVariablesWithResponse call
func ParseGetScopedVariablesResponse(rsp *http.Response) (*GetScopedVariablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScopedVariablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []ScopedVariable `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateScopedVariableResponse parses an HTTP response from a CreateScopedVariableWithResponse call
func ParseCreateScopedVariableResponse(rsp *http.Response) (*CreateScopedVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateScopedVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Scoped variables are a way for users to dynamically allocate runtime specific environment variables across any number of containers in an environment.
			Data ScopedVariable `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteScopedVariableResponse parses an HTTP response from a DeleteScopedVariableWithResponse call
func ParseDeleteScopedVariableResponse(rsp *http.Response) (*DeleteScopedVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteScopedVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetScopedVariableResponse parses an HTTP response from a GetScopedVariableWithResponse call
func ParseGetScopedVariableResponse(rsp *http.Response) (*GetScopedVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScopedVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Scoped variables are a way for users to dynamically allocate runtime specific environment variables across any number of containers in an environment.
			Data ScopedVariable `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateScopedVariableResponse parses an HTTP response from a UpdateScopedVariableWithResponse call
func ParseUpdateScopedVariableResponse(rsp *http.Response) (*UpdateScopedVariableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateScopedVariableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Scoped variables are a way for users to dynamically allocate runtime specific environment variables across any number of containers in an environment.
			Data ScopedVariable `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDiscoveryServiceJobResponse parses an HTTP response from a CreateDiscoveryServiceJobWithResponse call
func ParseCreateDiscoveryServiceJobResponse(rsp *http.Response) (*CreateDiscoveryServiceJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDiscoveryServiceJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateGatewayServiceJobResponse parses an HTTP response from a CreateGatewayServiceJobWithResponse call
func ParseCreateGatewayServiceJobResponse(rsp *http.Response) (*CreateGatewayServiceJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGatewayServiceJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoadBalancerServiceResponse parses an HTTP response from a GetLoadBalancerServiceWithResponse call
func ParseGetLoadBalancerServiceResponse(rsp *http.Response) (*GetLoadBalancerServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoadBalancerServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Information about an environments load balancer configuration, state, and availability settings.
			Data struct {
				BaseConfigs *struct {
					// Haproxy Describes settings that are passed to HAProxy within the load balancer.
					Haproxy HaProxyConfig `json:"haproxy"`
					V1      V1LbConfig    `json:"v1"`
				} `json:"base_configs,omitempty"`
				CurrentType GetLoadBalancerService200DataCurrentType `json:"current_type"`

				// DefaultConfig The config object for the loadbalancer service.
				DefaultConfig LoadBalancerConfig                       `json:"default_config"`
				DefaultType   GetLoadBalancerService200DataDefaultType `json:"default_type"`
				Service       *LoadBalancerEnvironmentService          `json:"service"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLoadBalancerServiceJobResponse parses an HTTP response from a CreateLoadBalancerServiceJobWithResponse call
func ParseCreateLoadBalancerServiceJobResponse(rsp *http.Response) (*CreateLoadBalancerServiceJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLoadBalancerServiceJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoadBalancerLatestTelemetryReportResponse parses an HTTP response from a GetLoadBalancerLatestTelemetryReportWithResponse call
func ParseGetLoadBalancerLatestTelemetryReportResponse(rsp *http.Response) (*GetLoadBalancerLatestTelemetryReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoadBalancerLatestTelemetryReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Snapshots of the latest load balancer telemetry
			Data LoadBalancerLatestTelemetry `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoadBalancerTelemetryLatestControllersResponse parses an HTTP response from a GetLoadBalancerTelemetryLatestControllersWithResponse call
func ParseGetLoadBalancerTelemetryLatestControllersResponse(rsp *http.Response) (*GetLoadBalancerTelemetryLatestControllersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoadBalancerTelemetryLatestControllersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Information about the latest controllers that generated traffic.
			Data LoadBalancerLatestControllers `json:"data"`

			// Includes Optionally included resources for load balancer controllers
			Includes *Controllers `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoadBalancerTelemetryReportResponse parses an HTTP response from a GetLoadBalancerTelemetryReportWithResponse call
func ParseGetLoadBalancerTelemetryReportResponse(rsp *http.Response) (*GetLoadBalancerTelemetryReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoadBalancerTelemetryReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Aggregated load balancer telemetry across all instances for a given range.
			Data LoadBalancerTelemetryReport `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSchedulerServiceJobResponse parses an HTTP response from a CreateSchedulerServiceJobWithResponse call
func ParseCreateSchedulerServiceJobResponse(rsp *http.Response) (*CreateSchedulerServiceJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSchedulerServiceJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVPNServiceResponse parses an HTTP response from a GetVPNServiceWithResponse call
func ParseGetVPNServiceResponse(rsp *http.Response) (*GetVPNServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVPNServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A summary of a VPN service for a given environment.
			Data VPNInfoReturn `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVPNLoginsResponse parses an HTTP response from a GetVPNLoginsWithResponse call
func ParseGetVPNLoginsResponse(rsp *http.Response) (*GetVPNLoginsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVPNLoginsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []VPNLogin `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateVPNServiceJobResponse parses an HTTP response from a CreateVPNServiceJobWithResponse call
func ParseCreateVPNServiceJobResponse(rsp *http.Response) (*CreateVPNServiceJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVPNServiceJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVPNUsersResponse parses an HTTP response from a GetVPNUsersWithResponse call
func ParseGetVPNUsersResponse(rsp *http.Response) (*GetVPNUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVPNUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []VPNUsers `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateVPNUserResponse parses an HTTP response from a CreateVPNUserWithResponse call
func ParseCreateVPNUserResponse(rsp *http.Response) (*CreateVPNUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVPNUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data A VPN user for a given VPN.
			Data VPNUsers `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVPNUserResponse parses an HTTP response from a DeleteVPNUserWithResponse call
func ParseDeleteVPNUserResponse(rsp *http.Response) (*DeleteVPNUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVPNUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data string `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentSummaryResponse parses an HTTP response from a GetEnvironmentSummaryWithResponse call
func ParseGetEnvironmentSummaryResponse(rsp *http.Response) (*GetEnvironmentSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Contains useful and relevant data/statistics for an environment that would otherwise be several separate API calls.
			Data EnvironmentSummary `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateEnvironmentJobResponse parses an HTTP response from a CreateEnvironmentJobWithResponse call
func ParseCreateEnvironmentJobResponse(rsp *http.Response) (*CreateEnvironmentJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEnvironmentJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHubsResponse parses an HTTP response from a GetHubsWithResponse call
func ParseGetHubsResponse(rsp *http.Response) (*GetHubsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Hub `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHubResponse parses an HTTP response from a CreateHubWithResponse call
func ParseCreateHubResponse(rsp *http.Response) (*CreateHubResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHubResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A hub resource.
			Data Hub `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHubCapabilitiesResponse parses an HTTP response from a GetHubCapabilitiesWithResponse call
func ParseGetHubCapabilitiesResponse(rsp *http.Response) (*GetHubCapabilitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubCapabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Capability `json:"data"`
			Meta struct {
				// Captions Human-readable captions keyed by the platform level capability it describes.
				Captions map[string]string `json:"captions"`
			} `json:"meta"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHubResponse parses an HTTP response from a DeleteHubWithResponse call
func ParseDeleteHubResponse(rsp *http.Response) (*DeleteHubResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHubResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHubResponse parses an HTTP response from a GetHubWithResponse call
func ParseGetHubResponse(rsp *http.Response) (*GetHubResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A hub resource.
			Data *Hub `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateHubResponse parses an HTTP response from a UpdateHubWithResponse call
func ParseUpdateHubResponse(rsp *http.Response) (*UpdateHubResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateHubResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A hub resource.
			Data Hub `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHubActivityResponse parses an HTTP response from a GetHubActivityWithResponse call
func ParseGetHubActivityResponse(rsp *http.Response) (*GetHubActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Activity `json:"data"`

			// Includes All includable resources linkable to the given records.
			Includes *ActivityIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetApiKeysResponse parses an HTTP response from a GetApiKeysWithResponse call
func ParseGetApiKeysResponse(rsp *http.Response) (*GetApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []ApiKey `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateApiKeyResponse parses an HTTP response from a CreateApiKeyWithResponse call
func ParseCreateApiKeyResponse(rsp *http.Response) (*CreateApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data An API key resource
			Data ApiKey `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAPIKeyResponse parses an HTTP response from a DeleteAPIKeyWithResponse call
func ParseDeleteAPIKeyResponse(rsp *http.Response) (*DeleteAPIKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An API key resource
			Data ApiKey `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAPIKeyResponse parses an HTTP response from a GetAPIKeyWithResponse call
func ParseGetAPIKeyResponse(rsp *http.Response) (*GetAPIKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An API key resource
			Data *ApiKey `json:"data,omitempty"`

			// Includes A resource that is associated with an API key.
			Includes *ApiKeyIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateAPIKeyResponse parses an HTTP response from a UpdateAPIKeyWithResponse call
func ParseUpdateAPIKeyResponse(rsp *http.Response) (*UpdateAPIKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAPIKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An API key resource
			Data ApiKey `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIntegrationsResponse parses an HTTP response from a GetIntegrationsWithResponse call
func ParseGetIntegrationsResponse(rsp *http.Response) (*GetIntegrationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Integration `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateIntegrationResponse parses an HTTP response from a CreateIntegrationWithResponse call
func ParseCreateIntegrationResponse(rsp *http.Response) (*CreateIntegrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIntegrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data Integration `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAvailableIntegrationsResponse parses an HTTP response from a GetAvailableIntegrationsWithResponse call
func ParseGetAvailableIntegrationsResponse(rsp *http.Response) (*GetAvailableIntegrationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableIntegrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				Billing                  *[]IntegrationDefinition `json:"billing"`
				ImageBuilders            *[]IntegrationDefinition `json:"image-builders"`
				InfrastructureProvider   *[]IntegrationDefinition `json:"infrastructure-provider"`
				ObjectStorage            *[]IntegrationDefinition `json:"object-storage"`
				TlsCertificateGeneration *[]IntegrationDefinition `json:"tls-certificate-generation"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteIntegrationResponse parses an HTTP response from a DeleteIntegrationWithResponse call
func ParseDeleteIntegrationResponse(rsp *http.Response) (*DeleteIntegrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIntegrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIntegrationResponse parses an HTTP response from a GetIntegrationWithResponse call
func ParseGetIntegrationResponse(rsp *http.Response) (*GetIntegrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIntegrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data Integration `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateIntegrationResponse parses an HTTP response from a UpdateIntegrationWithResponse call
func ParseUpdateIntegrationResponse(rsp *http.Response) (*UpdateIntegrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateIntegrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data Integration `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateIntegrationJobResponse parses an HTTP response from a CreateIntegrationJobWithResponse call
func ParseCreateIntegrationJobResponse(rsp *http.Response) (*CreateIntegrationJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIntegrationJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHubInvitesResponse parses an HTTP response from a GetHubInvitesWithResponse call
func ParseGetHubInvitesResponse(rsp *http.Response) (*GetHubInvitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []HubMembership `json:"data"`

			// Includes All includable resources for invites.
			Includes *HubInviteIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHubInviteResponse parses an HTTP response from a CreateHubInviteWithResponse call
func ParseCreateHubInviteResponse(rsp *http.Response) (*CreateHubInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHubInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data A membership resource that is scoped to an individual hub.
			Data HubMembership `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHubInviteResponse parses an HTTP response from a DeleteHubInviteWithResponse call
func ParseDeleteHubInviteResponse(rsp *http.Response) (*DeleteHubInviteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHubInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A membership resource that is scoped to an individual hub.
			Data HubMembership `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHubMembersResponse parses an HTTP response from a GetHubMembersWithResponse call
func ParseGetHubMembersResponse(rsp *http.Response) (*GetHubMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []HubMembership `json:"data"`

			// Includes All includable resources for hub memberships.
			Includes *HubMembershipIncludes2 `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHubMemberAccountResponse parses an HTTP response from a GetHubMemberAccountWithResponse call
func ParseGetHubMemberAccountResponse(rsp *http.Response) (*GetHubMemberAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubMemberAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A membership resource that is scoped to an individual hub.
			Data HubMembership `json:"data"`

			// Includes All includable resources for hub memberships.
			Includes *HubMembershipIncludes2 `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHubMemberResponse parses an HTTP response from a DeleteHubMemberWithResponse call
func ParseDeleteHubMemberResponse(rsp *http.Response) (*DeleteHubMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHubMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHubMemberResponse parses an HTTP response from a GetHubMemberWithResponse call
func ParseGetHubMemberResponse(rsp *http.Response) (*GetHubMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A membership resource that is scoped to an individual hub.
			Data HubMembership `json:"data"`

			// Includes All includable resources for hub memberships.
			Includes *HubMembershipIncludes2 `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateHubMemberResponse parses an HTTP response from a UpdateHubMemberWithResponse call
func ParseUpdateHubMemberResponse(rsp *http.Response) (*UpdateHubMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateHubMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A membership resource that is scoped to an individual hub.
			Data HubMembership `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHubMembershipResponse parses an HTTP response from a GetHubMembershipWithResponse call
func ParseGetHubMembershipResponse(rsp *http.Response) (*GetHubMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A membership resource that is scoped to an individual hub.
			Data HubMembership `json:"data"`

			// Includes All includable resources for hub memberships.
			Includes *HubMembershipIncludes2 `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHubNotificationSocketAuthResponse parses an HTTP response from a GetHubNotificationSocketAuthWithResponse call
func ParseGetHubNotificationSocketAuthResponse(rsp *http.Response) (*GetHubNotificationSocketAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubNotificationSocketAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				// Token A token used for connecting to the Hub notification pipeline websocket API.
				Token string `json:"token"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRolesResponse parses an HTTP response from a GetRolesWithResponse call
func ParseGetRolesResponse(rsp *http.Response) (*GetRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Role `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRoleResponse parses an HTTP response from a CreateRoleWithResponse call
func ParseCreateRoleResponse(rsp *http.Response) (*CreateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data A Role is a custom combination of platform-level capabilities, allowing for fully customizable role-based access controls across the platform.
			Data Role `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDefaultHubRolesResponse parses an HTTP response from a GetDefaultHubRolesWithResponse call
func ParseGetDefaultHubRolesResponse(rsp *http.Response) (*GetDefaultHubRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultHubRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []struct {
				Capabilities struct {
					// All If true, the role has all capabilities.
					All      bool         `json:"all"`
					Specific []Capability `json:"specific"`
				} `json:"capabilities"`

				// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
				// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
				// have the identifier of `my-container` and is automatically created by the platform.
				//
				// The identifier does not have to be unique.
				Identifier Identifier `json:"identifier"`
				Name       string     `json:"name"`

				// Root The role marked as root has full moderation control over all roles.
				Root bool `json:"root"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRoleResponse parses an HTTP response from a DeleteRoleWithResponse call
func ParseDeleteRoleResponse(rsp *http.Response) (*DeleteRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRoleResponse parses an HTTP response from a GetRoleWithResponse call
func ParseGetRoleResponse(rsp *http.Response) (*GetRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A Role is a custom combination of platform-level capabilities, allowing for fully customizable role-based access controls across the platform.
			Data *Role `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateRoleResponse parses an HTTP response from a UpdateRoleWithResponse call
func ParseUpdateRoleResponse(rsp *http.Response) (*UpdateRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A Role is a custom combination of platform-level capabilities, allowing for fully customizable role-based access controls across the platform.
			Data Role `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHubUsageResponse parses an HTTP response from a GetHubUsageWithResponse call
func ParseGetHubUsageResponse(rsp *http.Response) (*GetHubUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHubUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []HubUsageDatum `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetImagesResponse parses an HTTP response from a GetImagesWithResponse call
func ParseGetImagesResponse(rsp *http.Response) (*GetImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Image `json:"data"`

			// Includes All includable resources linkable to the given image.
			Includes *ImageIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateImageResponse parses an HTTP response from a CreateImageWithResponse call
func ParseCreateImageResponse(rsp *http.Response) (*CreateImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data An image is a point in time build on a given image source, and what is distributed by Cycle to run containers.
			Data Image `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetImageSourcesResponse parses an HTTP response from a GetImageSourcesWithResponse call
func ParseGetImageSourcesResponse(rsp *http.Response) (*GetImageSourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImageSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []ImageSource `json:"data"`

			// Includes A resource associate with an image source.
			Includes *SourceIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateImageSourceResponse parses an HTTP response from a CreateImageSourceWithResponse call
func ParseCreateImageSourceResponse(rsp *http.Response) (*CreateImageSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImageSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data An image source is a set of resources that direct the platform on where it can find the resources needed to build an image resource.
			Data ImageSource `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteImageSourceResponse parses an HTTP response from a DeleteImageSourceWithResponse call
func ParseDeleteImageSourceResponse(rsp *http.Response) (*DeleteImageSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetImageSourceResponse parses an HTTP response from a GetImageSourceWithResponse call
func ParseGetImageSourceResponse(rsp *http.Response) (*GetImageSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImageSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An image source is a set of resources that direct the platform on where it can find the resources needed to build an image resource.
			Data ImageSource `json:"data"`

			// Includes A resource associate with an image source.
			Includes *SourceIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateImageSourceResponse parses an HTTP response from a UpdateImageSourceWithResponse call
func ParseUpdateImageSourceResponse(rsp *http.Response) (*UpdateImageSourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateImageSourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An image source is a set of resources that direct the platform on where it can find the resources needed to build an image resource.
			Data ImageSource `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateImageSourceAccessResponse parses an HTTP response from a UpdateImageSourceAccessWithResponse call
func ParseUpdateImageSourceAccessResponse(rsp *http.Response) (*UpdateImageSourceAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateImageSourceAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An image source is a set of resources that direct the platform on where it can find the resources needed to build an image resource.
			Data ImageSource `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateImagesJobResponse parses an HTTP response from a CreateImagesJobWithResponse call
func ParseCreateImagesJobResponse(rsp *http.Response) (*CreateImagesJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImagesJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteImageResponse parses an HTTP response from a DeleteImageWithResponse call
func ParseDeleteImageResponse(rsp *http.Response) (*DeleteImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetImageResponse parses an HTTP response from a GetImageWithResponse call
func ParseGetImageResponse(rsp *http.Response) (*GetImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An image is a point in time build on a given image source, and what is distributed by Cycle to run containers.
			Data Image `json:"data"`

			// Includes All includable resources linkable to the given image.
			Includes *ImageIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateImageResponse parses an HTTP response from a UpdateImageWithResponse call
func ParseUpdateImageResponse(rsp *http.Response) (*UpdateImageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateImageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An image is a point in time build on a given image source, and what is distributed by Cycle to run containers.
			Data Image `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetImageBuildLogResponse parses an HTTP response from a GetImageBuildLogWithResponse call
func ParseGetImageBuildLogResponse(rsp *http.Response) (*GetImageBuildLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImageBuildLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A build log for a given image.
			Data BuildLog `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateImageJobResponse parses an HTTP response from a CreateImageJobWithResponse call
func ParseCreateImageJobResponse(rsp *http.Response) (*CreateImageJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImageJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAutoScaleGroupsResponse parses an HTTP response from a GetAutoScaleGroupsWithResponse call
func ParseGetAutoScaleGroupsResponse(rsp *http.Response) (*GetAutoScaleGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutoScaleGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []AutoScaleGroup `json:"data"`

			// Includes All includable resource linkable to the given auto-scale group.
			Includes *AutoScaleGroupIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAutoScaleGroupResponse parses an HTTP response from a CreateAutoScaleGroupWithResponse call
func ParseCreateAutoScaleGroupResponse(rsp *http.Response) (*CreateAutoScaleGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAutoScaleGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data AutoScaleGroup `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAutoScaleGroupResponse parses an HTTP response from a DeleteAutoScaleGroupWithResponse call
func ParseDeleteAutoScaleGroupResponse(rsp *http.Response) (*DeleteAutoScaleGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAutoScaleGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAutoScaleGroupResponse parses an HTTP response from a GetAutoScaleGroupWithResponse call
func ParseGetAutoScaleGroupResponse(rsp *http.Response) (*GetAutoScaleGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutoScaleGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data AutoScaleGroup `json:"data"`

			// Includes All includable resource linkable to the given auto-scale group.
			Includes *AutoScaleGroupIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateAutoScaleGroupResponse parses an HTTP response from a UpdateAutoScaleGroupWithResponse call
func ParseUpdateAutoScaleGroupResponse(rsp *http.Response) (*UpdateAutoScaleGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAutoScaleGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data AutoScaleGroup `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateAutoScaleGroupAccessResponse parses an HTTP response from a UpdateAutoScaleGroupAccessWithResponse call
func ParseUpdateAutoScaleGroupAccessResponse(rsp *http.Response) (*UpdateAutoScaleGroupAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAutoScaleGroupAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data AutoScaleGroup `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClustersResponse parses an HTTP response from a GetClustersWithResponse call
func ParseGetClustersResponse(rsp *http.Response) (*GetClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Cluster `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Clusters are groups of servers that allow physical separation of resources.
			Data Cluster `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Clusters are groups of servers that allow physical separation of resources.
			Data Cluster `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Clusters are groups of servers that allow physical separation of resources.
			Data Cluster `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateClusterAccessResponse parses an HTTP response from a UpdateClusterAccessWithResponse call
func ParseUpdateClusterAccessResponse(rsp *http.Response) (*UpdateClusterAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Clusters are groups of servers that allow physical separation of resources.
			Data Cluster `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateClusterJobResponse parses an HTTP response from a CreateClusterJobWithResponse call
func ParseCreateClusterJobResponse(rsp *http.Response) (*CreateClusterJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDeploymentStrategiesResponse parses an HTTP response from a GetDeploymentStrategiesWithResponse call
func ParseGetDeploymentStrategiesResponse(rsp *http.Response) (*GetDeploymentStrategiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeploymentStrategiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				// Distributed Information about supported container deployment strategies.
				Distributed *DeploymentStrategy `json:"distributed,omitempty"`

				// Edge Information about supported container deployment strategies.
				Edge *DeploymentStrategy `json:"edge,omitempty"`

				// FirstAvailable Information about supported container deployment strategies.
				FirstAvailable *DeploymentStrategy `json:"first-available,omitempty"`

				// Function Information about supported container deployment strategies.
				Function *DeploymentStrategy `json:"function,omitempty"`

				// HighAvailability Information about supported container deployment strategies.
				HighAvailability *DeploymentStrategy `json:"high-availability,omitempty"`

				// Manual Information about supported container deployment strategies.
				Manual *DeploymentStrategy `json:"manual,omitempty"`

				// Node Information about supported container deployment strategies.
				Node *DeploymentStrategy `json:"node,omitempty"`

				// ResourceDensity Information about supported container deployment strategies.
				ResourceDensity *DeploymentStrategy `json:"resource-density,omitempty"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetExternalVolumesResponse parses an HTTP response from a GetExternalVolumesWithResponse call
func ParseGetExternalVolumesResponse(rsp *http.Response) (*GetExternalVolumesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExternalVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []ExternalVolume `json:"data"`

			// Includes All includable resources linked to the given external volume.
			Includes *ExternalVolumeIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateExternalVolumeResponse parses an HTTP response from a CreateExternalVolumeWithResponse call
func ParseCreateExternalVolumeResponse(rsp *http.Response) (*CreateExternalVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateExternalVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data A persistent storage volume within a cluster. Volumes may be attached to containers or VMs and can originate from different storage sources.
			Data ExternalVolume `json:"data"`

			// Includes All includable resources linked to the given external volume.
			Includes *ExternalVolumeIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetExternalVolumeSourcesResponse parses an HTTP response from a GetExternalVolumeSourcesWithResponse call
func ParseGetExternalVolumeSourcesResponse(rsp *http.Response) (*GetExternalVolumeSourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExternalVolumeSourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data map[string]struct {
				// Capabilities Map where keys are attachment types and values are arrays of supported modes.
				Capabilities map[string][]string `json:"capabilities"`

				// Creatable Whether volumes of this source type can be created via the API.
				Creatable bool `json:"creatable"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteExternalVolumeResponse parses an HTTP response from a DeleteExternalVolumeWithResponse call
func ParseDeleteExternalVolumeResponse(rsp *http.Response) (*DeleteExternalVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteExternalVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetExternalVolumeResponse parses an HTTP response from a GetExternalVolumeWithResponse call
func ParseGetExternalVolumeResponse(rsp *http.Response) (*GetExternalVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExternalVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A persistent storage volume within a cluster. Volumes may be attached to containers or VMs and can originate from different storage sources.
			Data ExternalVolume `json:"data"`

			// Includes All includable resources linked to the given external volume.
			Includes *ExternalVolumeIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateExternalVolumeResponse parses an HTTP response from a UpdateExternalVolumeWithResponse call
func ParseUpdateExternalVolumeResponse(rsp *http.Response) (*UpdateExternalVolumeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateExternalVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A persistent storage volume within a cluster. Volumes may be attached to containers or VMs and can originate from different storage sources.
			Data ExternalVolume `json:"data"`

			// Includes All includable resources linked to the given external volume.
			Includes *ExternalVolumeIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateExternalVolumeAccessResponse parses an HTTP response from a UpdateExternalVolumeAccessWithResponse call
func ParseUpdateExternalVolumeAccessResponse(rsp *http.Response) (*UpdateExternalVolumeAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateExternalVolumeAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A persistent storage volume within a cluster. Volumes may be attached to containers or VMs and can originate from different storage sources.
			Data ExternalVolume `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateExternalVolumeJobResponse parses an HTTP response from a CreateExternalVolumeJobWithResponse call
func ParseCreateExternalVolumeJobResponse(rsp *http.Response) (*CreateExternalVolumeJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateExternalVolumeJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIpPoolsResponse parses an HTTP response from a GetIpPoolsWithResponse call
func ParseGetIpPoolsResponse(rsp *http.Response) (*GetIpPoolsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIpPoolsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []IpPool `json:"data"`

			// Includes Resources associated with an IP Pool.
			Includes *IpPoolIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateIpPoolResponse parses an HTTP response from a CreateIpPoolWithResponse call
func ParseCreateIpPoolResponse(rsp *http.Response) (*CreateIpPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIpPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data An IP Pool
			Data IpPool `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteIPPoolResponse parses an HTTP response from a DeleteIPPoolWithResponse call
func ParseDeleteIPPoolResponse(rsp *http.Response) (*DeleteIPPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIPPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIPPoolResponse parses an HTTP response from a GetIPPoolWithResponse call
func ParseGetIPPoolResponse(rsp *http.Response) (*GetIPPoolResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIPPoolResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An IP Pool
			Data IpPool `json:"data"`

			// Includes Resources associated with an IP Pool.
			Includes *IpPoolIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPoolIPsResponse parses an HTTP response from a GetPoolIPsWithResponse call
func ParseGetPoolIPsResponse(rsp *http.Response) (*GetPoolIPsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPoolIPsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Ip `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateIpPoolJobResponse parses an HTTP response from a CreateIpPoolJobWithResponse call
func ParseCreateIpPoolJobResponse(rsp *http.Response) (*CreateIpPoolJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIpPoolJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClusterMonitoringTiersResponse parses an HTTP response from a GetClusterMonitoringTiersWithResponse call
func ParseGetClusterMonitoringTiersResponse(rsp *http.Response) (*GetClusterMonitoringTiersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterMonitoringTiersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data map[string]MonitoringTierDetails `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProviderLocationsResponse parses an HTTP response from a GetProviderLocationsWithResponse call
func ParseGetProviderLocationsResponse(rsp *http.Response) (*GetProviderLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProviderLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []ProviderLocation `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProviderServersResponse parses an HTTP response from a GetProviderServersWithResponse call
func ParseGetProviderServersResponse(rsp *http.Response) (*GetProviderServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProviderServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []ProviderServerModel `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServersResponse parses an HTTP response from a GetServersWithResponse call
func ParseGetServersResponse(rsp *http.Response) (*GetServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Server `json:"data"`

			// Includes A resource associated with a server.
			Includes *ServerIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerResponse parses an HTTP response from a CreateServerWithResponse call
func ParseCreateServerResponse(rsp *http.Response) (*CreateServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerTagsResponse parses an HTTP response from a GetServerTagsWithResponse call
func ParseGetServerTagsResponse(rsp *http.Response) (*GetServerTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerTags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerResponse parses an HTTP response from a DeleteServerWithResponse call
func ParseDeleteServerResponse(rsp *http.Response) (*DeleteServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerResponse parses an HTTP response from a GetServerWithResponse call
func ParseGetServerResponse(rsp *http.Response) (*GetServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The server resource, referring to servers that have been deployed to a Cycle hub.
			Data Server `json:"data"`

			// Includes A resource associated with a server.
			Includes *ServerIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateServerResponse parses an HTTP response from a UpdateServerWithResponse call
func ParseUpdateServerResponse(rsp *http.Response) (*UpdateServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The server resource, referring to servers that have been deployed to a Cycle hub.
			Data Server `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerConsoleResponse parses an HTTP response from a GetServerConsoleWithResponse call
func ParseGetServerConsoleResponse(rsp *http.Response) (*GetServerConsoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerConsoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				// Address The websocket target URL.
				Address string `json:"address"`

				// Token The authentication token for the console socket. It should be appended as the URL parameter "token" to the address.
				Token string `json:"token"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerInstancesResponse parses an HTTP response from a GetServerInstancesWithResponse call
func ParseGetServerInstancesResponse(rsp *http.Response) (*GetServerInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Instance `json:"data"`

			// Includes A resource associated with an instance.
			Includes *InstanceIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerJobResponse parses an HTTP response from a CreateServerJobWithResponse call
func ParseCreateServerJobResponse(rsp *http.Response) (*CreateServerJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerTelemetryResponse parses an HTTP response from a GetServerTelemetryWithResponse call
func ParseGetServerTelemetryResponse(rsp *http.Response) (*GetServerTelemetryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerTelemetryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []ServerStatsTelemetry `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerUsageResponse parses an HTTP response from a GetServerUsageWithResponse call
func ParseGetServerUsageResponse(rsp *http.Response) (*GetServerUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Server usage data.
			Data UsageDatum `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInfrastructureSummaryResponse parses an HTTP response from a GetInfrastructureSummaryWithResponse call
func ParseGetInfrastructureSummaryResponse(rsp *http.Response) (*GetInfrastructureSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInfrastructureSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An infrastructure summary resource.
			Data InfrastructureSummary `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualProviderIsosResponse parses an HTTP response from a GetVirtualProviderIsosWithResponse call
func ParseGetVirtualProviderIsosResponse(rsp *http.Response) (*GetVirtualProviderIsosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualProviderIsosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []VirtualProviderIso `json:"data"`

			// Includes A resource that is associated with an ISO.
			Includes *VirtualProviderIsoIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateVirtualProviderIsoResponse parses an HTTP response from a CreateVirtualProviderIsoWithResponse call
func ParseCreateVirtualProviderIsoResponse(rsp *http.Response) (*CreateVirtualProviderIsoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVirtualProviderIsoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data The ISO image for a virtual provider.
			Data VirtualProviderIso `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVirtualProviderIsoResponse parses an HTTP response from a DeleteVirtualProviderIsoWithResponse call
func ParseDeleteVirtualProviderIsoResponse(rsp *http.Response) (*DeleteVirtualProviderIsoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualProviderIsoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualProviderIsoResponse parses an HTTP response from a GetVirtualProviderIsoWithResponse call
func ParseGetVirtualProviderIsoResponse(rsp *http.Response) (*GetVirtualProviderIsoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualProviderIsoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data The ISO image for a virtual provider.
			Data VirtualProviderIso `json:"data"`

			// Includes A resource that is associated with an ISO.
			Includes *VirtualProviderIsoIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateVirtualProviderIsoResponse parses an HTTP response from a UpdateVirtualProviderIsoWithResponse call
func ParseUpdateVirtualProviderIsoResponse(rsp *http.Response) (*UpdateVirtualProviderIsoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVirtualProviderIsoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data The ISO image for a virtual provider.
			Data VirtualProviderIso `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualProviderIsoDownloadUrlResponse parses an HTTP response from a GetVirtualProviderIsoDownloadUrlWithResponse call
func ParseGetVirtualProviderIsoDownloadUrlResponse(rsp *http.Response) (*GetVirtualProviderIsoDownloadUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualProviderIsoDownloadUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			Data struct {
				Url string `json:"url"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateVirtualProviderIsoJobResponse parses an HTTP response from a CreateVirtualProviderIsoJobWithResponse call
func ParseCreateVirtualProviderIsoJobResponse(rsp *http.Response) (*CreateVirtualProviderIsoJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVirtualProviderIsoJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetJobsResponse parses an HTTP response from a GetJobsWithResponse call
func ParseGetJobsResponse(rsp *http.Response) (*GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []Job        `json:"data"`
			Includes *JobIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLatestJobsResponse parses an HTTP response from a GetLatestJobsWithResponse call
func ParseGetLatestJobsResponse(rsp *http.Response) (*GetLatestJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Job `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A job resource.
			Data Job `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEventsResponse parses an HTTP response from a GetEventsWithResponse call
func ParseGetEventsResponse(rsp *http.Response) (*GetEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Event `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGenerateAggregatedEventsResponse parses an HTTP response from a GenerateAggregatedEventsWithResponse call
func ParseGenerateAggregatedEventsResponse(rsp *http.Response) (*GenerateAggregatedEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateAggregatedEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []map[string]interface{} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAggregateLogsResponse parses an HTTP response from a AggregateLogsWithResponse call
func ParseAggregateLogsResponse(rsp *http.Response) (*AggregateLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AggregateLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []LogLine `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMetricsResponse parses an HTTP response from a GetMetricsWithResponse call
func ParseGetMetricsResponse(rsp *http.Response) (*GetMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Metric `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGenerateAggregatedMetricsResponse parses an HTTP response from a GenerateAggregatedMetricsWithResponse call
func ParseGenerateAggregatedMetricsResponse(rsp *http.Response) (*GenerateAggregatedMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateAggregatedMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []map[string]interface{} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMonitoringMonitorsResponse parses an HTTP response from a GetMonitoringMonitorsWithResponse call
func ParseGetMonitoringMonitorsResponse(rsp *http.Response) (*GetMonitoringMonitorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMonitoringMonitorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Monitor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPipelinesResponse parses an HTTP response from a GetPipelinesWithResponse call
func ParseGetPipelinesResponse(rsp *http.Response) (*GetPipelinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Pipeline `json:"data"`

			// Includes All includable resources linkable to the given pipeline.
			Includes *PipelineIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePipelineResponse parses an HTTP response from a CreatePipelineWithResponse call
func ParseCreatePipelineResponse(rsp *http.Response) (*CreatePipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data A pipeline resource.
			Data Pipeline `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseClonePipelineResponse parses an HTTP response from a ClonePipelineWithResponse call
func ParseClonePipelineResponse(rsp *http.Response) (*ClonePipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClonePipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data A pipeline resource.
			Data Pipeline `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePipelineResponse parses an HTTP response from a DeletePipelineWithResponse call
func ParseDeletePipelineResponse(rsp *http.Response) (*DeletePipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPipelineResponse parses an HTTP response from a GetPipelineWithResponse call
func ParseGetPipelineResponse(rsp *http.Response) (*GetPipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A pipeline resource.
			Data Pipeline `json:"data"`

			// Includes All includable resources linkable to the given pipeline.
			Includes *PipelineIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePipelineResponse parses an HTTP response from a UpdatePipelineWithResponse call
func ParseUpdatePipelineResponse(rsp *http.Response) (*UpdatePipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A pipeline resource.
			Data Pipeline `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePipelineAccessResponse parses an HTTP response from a UpdatePipelineAccessWithResponse call
func ParseUpdatePipelineAccessResponse(rsp *http.Response) (*UpdatePipelineAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePipelineAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A pipeline resource.
			Data Pipeline `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPipelineTriggerKeysResponse parses an HTTP response from a GetPipelineTriggerKeysWithResponse call
func ParseGetPipelineTriggerKeysResponse(rsp *http.Response) (*GetPipelineTriggerKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineTriggerKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []TriggerKey `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePipelineTriggerKeyResponse parses an HTTP response from a CreatePipelineTriggerKeyWithResponse call
func ParseCreatePipelineTriggerKeyResponse(rsp *http.Response) (*CreatePipelineTriggerKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePipelineTriggerKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data A pipeline trigger key resource.
			Data TriggerKey `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePipelineTriggerKeyResponse parses an HTTP response from a DeletePipelineTriggerKeyWithResponse call
func ParseDeletePipelineTriggerKeyResponse(rsp *http.Response) (*DeletePipelineTriggerKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePipelineTriggerKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPipelineTriggerKeyResponse parses an HTTP response from a GetPipelineTriggerKeyWithResponse call
func ParseGetPipelineTriggerKeyResponse(rsp *http.Response) (*GetPipelineTriggerKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineTriggerKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A pipeline trigger key resource.
			Data *TriggerKey `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePipelineTriggerKeyResponse parses an HTTP response from a UpdatePipelineTriggerKeyWithResponse call
func ParseUpdatePipelineTriggerKeyResponse(rsp *http.Response) (*UpdatePipelineTriggerKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePipelineTriggerKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A pipeline trigger key resource.
			Data TriggerKey `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPipelineRunsResponse parses an HTTP response from a GetPipelineRunsWithResponse call
func ParseGetPipelineRunsResponse(rsp *http.Response) (*GetPipelineRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []PipelineRun `json:"data"`
			Includes *struct {
				// Creators An identity that created a resource.
				Creators *CreatorInclude `json:"creators,omitempty"`
			} `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPipelineRunResponse parses an HTTP response from a GetPipelineRunWithResponse call
func ParseGetPipelineRunResponse(rsp *http.Response) (*GetPipelineRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPipelineRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A pipeline run resource.
			Data     PipelineRun `json:"data"`
			Includes *struct {
				// Creators An identity that created a resource.
				Creators *CreatorInclude `json:"creators,omitempty"`
			} `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePipelineJobResponse parses an HTTP response from a CreatePipelineJobWithResponse call
func ParseCreatePipelineJobResponse(rsp *http.Response) (*CreatePipelineJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePipelineJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTriggerPipelineResponse parses an HTTP response from a TriggerPipelineWithResponse call
func ParseTriggerPipelineResponse(rsp *http.Response) (*TriggerPipelineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerPipelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetNetworksResponse parses an HTTP response from a GetNetworksWithResponse call
func ParseGetNetworksResponse(rsp *http.Response) (*GetNetworksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Network `json:"data"`

			// Includes All includable resource linkable to the given network.
			Includes *NetworkIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNetworkResponse parses an HTTP response from a CreateNetworkWithResponse call
func ParseCreateNetworkResponse(rsp *http.Response) (*CreateNetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data SDN Network resource.
			Data Network `json:"data"`

			// Includes All includable resource linkable to the given network.
			Includes *NetworkIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteNetworkResponse parses an HTTP response from a DeleteNetworkWithResponse call
func ParseDeleteNetworkResponse(rsp *http.Response) (*DeleteNetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetNetworkResponse parses an HTTP response from a GetNetworkWithResponse call
func ParseGetNetworkResponse(rsp *http.Response) (*GetNetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data SDN Network resource.
			Data Network `json:"data"`

			// Includes All includable resource linkable to the given network.
			Includes *NetworkIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateNetworkResponse parses an HTTP response from a UpdateNetworkWithResponse call
func ParseUpdateNetworkResponse(rsp *http.Response) (*UpdateNetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data SDN Network resource.
			Data Network `json:"data"`

			// Includes All includable resource linkable to the given network.
			Includes *NetworkIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateNetworkAccessResponse parses an HTTP response from a UpdateNetworkAccessWithResponse call
func ParseUpdateNetworkAccessResponse(rsp *http.Response) (*UpdateNetworkAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNetworkAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data SDN Network resource.
			Data Network `json:"data"`

			// Includes All includable resource linkable to the given network.
			Includes *NetworkIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNetworkJobResponse parses an HTTP response from a CreateNetworkJobWithResponse call
func ParseCreateNetworkJobResponse(rsp *http.Response) (*CreateNetworkJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNetworkJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSearchIndexResponse parses an HTTP response from a GetSearchIndexWithResponse call
func ParseGetSearchIndexResponse(rsp *http.Response) (*GetSearchIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An index that enables search in the portal
			Data Index `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStacksResponse parses an HTTP response from a GetStacksWithResponse call
func ParseGetStacksResponse(rsp *http.Response) (*GetStacksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStacksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Stack `json:"data"`

			// Includes All includable resources linkable to the given stack.
			Includes *StackInclude `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStackResponse parses an HTTP response from a CreateStackWithResponse call
func ParseCreateStackResponse(rsp *http.Response) (*CreateStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Stacks are a way to orchestrate multiple containers atomically and automatically.
			Data Stack `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLookupStackBuildResponse parses an HTTP response from a LookupStackBuildWithResponse call
func ParseLookupStackBuildResponse(rsp *http.Response) (*LookupStackBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LookupStackBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A stack build resource.
			Data StackBuild `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStackResponse parses an HTTP response from a DeleteStackWithResponse call
func ParseDeleteStackResponse(rsp *http.Response) (*DeleteStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStackResponse parses an HTTP response from a GetStackWithResponse call
func ParseGetStackResponse(rsp *http.Response) (*GetStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Stacks are a way to orchestrate multiple containers atomically and automatically.
			Data Stack `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateStackResponse parses an HTTP response from a UpdateStackWithResponse call
func ParseUpdateStackResponse(rsp *http.Response) (*UpdateStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Stacks are a way to orchestrate multiple containers atomically and automatically.
			Data Stack `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateStackAccessResponse parses an HTTP response from a UpdateStackAccessWithResponse call
func ParseUpdateStackAccessResponse(rsp *http.Response) (*UpdateStackAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateStackAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Stacks are a way to orchestrate multiple containers atomically and automatically.
			Data Stack `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStackBuildsResponse parses an HTTP response from a GetStackBuildsWithResponse call
func ParseGetStackBuildsResponse(rsp *http.Response) (*GetStackBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStackBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []StackBuild `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStackBuildResponse parses an HTTP response from a CreateStackBuildWithResponse call
func ParseCreateStackBuildResponse(rsp *http.Response) (*CreateStackBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStackBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data A stack build resource.
			Data StackBuild `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStackBuildResponse parses an HTTP response from a DeleteStackBuildWithResponse call
func ParseDeleteStackBuildResponse(rsp *http.Response) (*DeleteStackBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStackBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStackBuildResponse parses an HTTP response from a GetStackBuildWithResponse call
func ParseGetStackBuildResponse(rsp *http.Response) (*GetStackBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStackBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A stack build resource.
			Data StackBuild `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStackBuildLogResponse parses an HTTP response from a GetStackBuildLogWithResponse call
func ParseGetStackBuildLogResponse(rsp *http.Response) (*GetStackBuildLogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStackBuildLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A build log for a given stack build.
			Data StackBuildLog `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStackBuildJobResponse parses an HTTP response from a CreateStackBuildJobWithResponse call
func ParseCreateStackBuildJobResponse(rsp *http.Response) (*CreateStackBuildJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStackBuildJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStackJobResponse parses an HTTP response from a CreateStackJobWithResponse call
func ParseCreateStackJobResponse(rsp *http.Response) (*CreateStackJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStackJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLookupComponentsResponse parses an HTTP response from a LookupComponentsWithResponse call
func ParseLookupComponentsResponse(rsp *http.Response) (*LookupComponentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LookupComponentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A resource that is associated with activity.
			Data ComponentsIncludes `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLookupIdentifierResponse parses an HTTP response from a LookupIdentifierWithResponse call
func ParseLookupIdentifierResponse(rsp *http.Response) (*LookupIdentifierResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LookupIdentifierResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				Id string `json:"id"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualMachinesResponse parses an HTTP response from a GetVirtualMachinesWithResponse call
func ParseGetVirtualMachinesResponse(rsp *http.Response) (*GetVirtualMachinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualMachinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []VirtualMachine `json:"data"`

			// Includes All includable resources linkable to the given virtual machine.
			Includes *VirtualMachineIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateVirtualMachineResponse parses an HTTP response from a CreateVirtualMachineWithResponse call
func ParseCreateVirtualMachineResponse(rsp *http.Response) (*CreateVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Describes a virtual machine running on the Cycle Platform.
			Data VirtualMachine `json:"data"`

			// Includes All includable resources linkable to the given virtual machine.
			Includes *VirtualMachineIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualMachineBaseImagesResponse parses an HTTP response from a GetVirtualMachineBaseImagesWithResponse call
func ParseGetVirtualMachineBaseImagesResponse(rsp *http.Response) (*GetVirtualMachineBaseImagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualMachineBaseImagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data map[string]VirtualMachineBaseImage `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualMachineSshKeysResponse parses an HTTP response from a GetVirtualMachineSshKeysWithResponse call
func ParseGetVirtualMachineSshKeysResponse(rsp *http.Response) (*GetVirtualMachineSshKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualMachineSshKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []VirtualMachineSshKey `json:"data"`

			// Includes All includable resources linkable to the given virtual machine SSH key.
			Includes *VirtualMachineSshIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateVirtualMachineSshKeyResponse parses an HTTP response from a CreateVirtualMachineSshKeyWithResponse call
func ParseCreateVirtualMachineSshKeyResponse(rsp *http.Response) (*CreateVirtualMachineSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVirtualMachineSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Describes an SSH key used to access a virtual machine.
			Data VirtualMachineSshKey `json:"data"`

			// Includes All includable resources linkable to the given virtual machine SSH key.
			Includes *VirtualMachineSshIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVirtualMachineSshKeyResponse parses an HTTP response from a DeleteVirtualMachineSshKeyWithResponse call
func ParseDeleteVirtualMachineSshKeyResponse(rsp *http.Response) (*DeleteVirtualMachineSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualMachineSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualMachineSshKeyResponse parses an HTTP response from a GetVirtualMachineSshKeyWithResponse call
func ParseGetVirtualMachineSshKeyResponse(rsp *http.Response) (*GetVirtualMachineSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualMachineSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Describes an SSH key used to access a virtual machine.
			Data VirtualMachineSshKey `json:"data"`

			// Includes All includable resources linkable to the given virtual machine SSH key.
			Includes *VirtualMachineSshIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateVirtualMachineSshKeyResponse parses an HTTP response from a UpdateVirtualMachineSshKeyWithResponse call
func ParseUpdateVirtualMachineSshKeyResponse(rsp *http.Response) (*UpdateVirtualMachineSshKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVirtualMachineSshKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Describes an SSH key used to access a virtual machine.
			Data VirtualMachineSshKey `json:"data"`

			// Includes All includable resources linkable to the given virtual machine SSH key.
			Includes *VirtualMachineSshIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVirtualMachineResponse parses an HTTP response from a DeleteVirtualMachineWithResponse call
func ParseDeleteVirtualMachineResponse(rsp *http.Response) (*DeleteVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVirtualMachineResponse parses an HTTP response from a GetVirtualMachineWithResponse call
func ParseGetVirtualMachineResponse(rsp *http.Response) (*GetVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Describes a virtual machine running on the Cycle Platform.
			Data VirtualMachine `json:"data"`

			// Includes All includable resources linkable to the given virtual machine.
			Includes *VirtualMachineIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateVirtualMachineResponse parses an HTTP response from a UpdateVirtualMachineWithResponse call
func ParseUpdateVirtualMachineResponse(rsp *http.Response) (*UpdateVirtualMachineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVirtualMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Describes a virtual machine running on the Cycle Platform.
			Data VirtualMachine `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAvailableIpsResponse parses an HTTP response from a GetAvailableIpsWithResponse call
func ParseGetAvailableIpsResponse(rsp *http.Response) (*GetAvailableIpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAvailableIpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Ip `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExpireVirtualMachineSosCredentialsResponse parses an HTTP response from a ExpireVirtualMachineSosCredentialsWithResponse call
func ParseExpireVirtualMachineSosCredentialsResponse(rsp *http.Response) (*ExpireVirtualMachineSosCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExpireVirtualMachineSosCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The number of tokens expired.
			Data struct {
				// Tokens The number of tokens expired.
				Tokens int `json:"tokens"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGenerateVirtualMachineSosCredentialsResponse parses an HTTP response from a GenerateVirtualMachineSosCredentialsWithResponse call
func ParseGenerateVirtualMachineSosCredentialsResponse(rsp *http.Response) (*GenerateVirtualMachineSosCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateVirtualMachineSosCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Connection details for connecting to a virtual machine using serial-over-SSH.
			Data VirtualMachineSosConnection `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateVirtualMachineJobResponse parses an HTTP response from a CreateVirtualMachineJobWithResponse call
func ParseCreateVirtualMachineJobResponse(rsp *http.Response) (*CreateVirtualMachineJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVirtualMachineJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
