// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	HubAuthScopes    = "hubAuth.Scopes"
)

// Defines values for ApiKeyCreatorStateCurrent.
const (
	ApiKeyCreatorStateCurrentDeleted  ApiKeyCreatorStateCurrent = "deleted"
	ApiKeyCreatorStateCurrentDeleting ApiKeyCreatorStateCurrent = "deleting"
	ApiKeyCreatorStateCurrentLive     ApiKeyCreatorStateCurrent = "live"
)

// Defines values for Capability.
const (
	ApiKeysManage                     Capability = "api-keys-manage"
	ApionlyJobsView                   Capability = "apionly-jobs-view"
	ApionlyNotificationsListen        Capability = "apionly-notifications-listen"
	AutoscaleGroupsManage             Capability = "autoscale-groups-manage"
	AutoscaleGroupsView               Capability = "autoscale-groups-view"
	BillingCreditsView                Capability = "billing-credits-view"
	BillingInvoicesPay                Capability = "billing-invoices-pay"
	BillingInvoicesView               Capability = "billing-invoices-view"
	BillingMethodsManage              Capability = "billing-methods-manage"
	BillingServicesManage             Capability = "billing-services-manage"
	BillingServicesView               Capability = "billing-services-view"
	ClustersManage                    Capability = "clusters-manage"
	ClustersView                      Capability = "clusters-view"
	ContainersBackupsManage           Capability = "containers-backups-manage"
	ContainersBackupsView             Capability = "containers-backups-view"
	ContainersConsole                 Capability = "containers-console"
	ContainersDeploy                  Capability = "containers-deploy"
	ContainersFunctionsTrigger        Capability = "containers-functions-trigger"
	ContainersInstancesMigrate        Capability = "containers-instances-migrate"
	ContainersLock                    Capability = "containers-lock"
	ContainersManage                  Capability = "containers-manage"
	ContainersSsh                     Capability = "containers-ssh"
	ContainersView                    Capability = "containers-view"
	ContainersVolumesManage           Capability = "containers-volumes-manage"
	ContainersVolumesView             Capability = "containers-volumes-view"
	DnsCertsView                      Capability = "dns-certs-view"
	DnsManage                         Capability = "dns-manage"
	DnsView                           Capability = "dns-view"
	EnvironmentsDeploymentsManage     Capability = "environments-deployments-manage"
	EnvironmentsManage                Capability = "environments-manage"
	EnvironmentsScopedvariablesManage Capability = "environments-scopedvariables-manage"
	EnvironmentsScopedvariablesView   Capability = "environments-scopedvariables-view"
	EnvironmentsServicesManage        Capability = "environments-services-manage"
	EnvironmentsView                  Capability = "environments-view"
	EnvironmentsVpn                   Capability = "environments-vpn"
	EnvironmentsVpnManage             Capability = "environments-vpn-manage"
	HubsAuditlogView                  Capability = "hubs-auditlog-view"
	HubsDelete                        Capability = "hubs-delete"
	HubsIntegrationsManage            Capability = "hubs-integrations-manage"
	HubsIntegrationsView              Capability = "hubs-integrations-view"
	HubsInvitesManage                 Capability = "hubs-invites-manage"
	HubsInvitesSend                   Capability = "hubs-invites-send"
	HubsMembersManage                 Capability = "hubs-members-manage"
	HubsMembersView                   Capability = "hubs-members-view"
	HubsRolesManage                   Capability = "hubs-roles-manage"
	HubsRolesView                     Capability = "hubs-roles-view"
	HubsUpdate                        Capability = "hubs-update"
	HubsUsageView                     Capability = "hubs-usage-view"
	ImagesManage                      Capability = "images-manage"
	ImagesSourcesManage               Capability = "images-sources-manage"
	ImagesSourcesView                 Capability = "images-sources-view"
	ImagesView                        Capability = "images-view"
	IpsManage                         Capability = "ips-manage"
	MonitorManage                     Capability = "monitor-manage"
	MonitorView                       Capability = "monitor-view"
	PipelinesManage                   Capability = "pipelines-manage"
	PipelinesTrigger                  Capability = "pipelines-trigger"
	PipelinesView                     Capability = "pipelines-view"
	SdnNetworksManage                 Capability = "sdn-networks-manage"
	SdnNetworksView                   Capability = "sdn-networks-view"
	SecurityManage                    Capability = "security-manage"
	SecurityView                      Capability = "security-view"
	ServersConsole                    Capability = "servers-console"
	ServersDecommission               Capability = "servers-decommission"
	ServersLogin                      Capability = "servers-login"
	ServersManage                     Capability = "servers-manage"
	ServersProvision                  Capability = "servers-provision"
	ServersView                       Capability = "servers-view"
	StacksBuildsDeploy                Capability = "stacks-builds-deploy"
	StacksBuildsManage                Capability = "stacks-builds-manage"
	StacksManage                      Capability = "stacks-manage"
	StacksView                        Capability = "stacks-view"
)

// Defines values for ContainerImageSummaryService0.
const (
	Discovery    ContainerImageSummaryService0 = "discovery"
	Loadbalancer ContainerImageSummaryService0 = "loadbalancer"
	Vpn          ContainerImageSummaryService0 = "vpn"
)

// Defines values for ContainerStateCurrent.
const (
	ContainerStateCurrentDeleted  ContainerStateCurrent = "deleted"
	ContainerStateCurrentDeleting ContainerStateCurrent = "deleting"
	ContainerStateCurrentFunction ContainerStateCurrent = "function"
	ContainerStateCurrentNew      ContainerStateCurrent = "new"
	ContainerStateCurrentRunning  ContainerStateCurrent = "running"
	ContainerStateCurrentStarting ContainerStateCurrent = "starting"
	ContainerStateCurrentStopped  ContainerStateCurrent = "stopped"
	ContainerStateCurrentStopping ContainerStateCurrent = "stopping"
)

// Defines values for ContainerStateDesired.
const (
	ContainerStateDesiredDeleted  ContainerStateDesired = "deleted"
	ContainerStateDesiredDeleting ContainerStateDesired = "deleting"
	ContainerStateDesiredFunction ContainerStateDesired = "function"
	ContainerStateDesiredNew      ContainerStateDesired = "new"
	ContainerStateDesiredRunning  ContainerStateDesired = "running"
	ContainerStateDesiredStarting ContainerStateDesired = "starting"
	ContainerStateDesiredStopped  ContainerStateDesired = "stopped"
	ContainerStateDesiredStopping ContainerStateDesired = "stopping"
)

// Defines values for CreatorScopeType.
const (
	CreatorScopeTypeAccount          CreatorScopeType = "account"
	CreatorScopeTypeApiKey           CreatorScopeType = "api-key"
	CreatorScopeTypeEmployee         CreatorScopeType = "employee"
	CreatorScopeTypeEnvironment      CreatorScopeType = "environment"
	CreatorScopeTypePlatform         CreatorScopeType = "platform"
	CreatorScopeTypePlatformPipeline CreatorScopeType = "platform-pipeline"
	CreatorScopeTypeVisitor          CreatorScopeType = "visitor"
)

// Defines values for CredentialsHTTPType.
const (
	CredentialsHTTPTypeHttp CredentialsHTTPType = "http"
)

// Defines values for CredentialsSSHType.
const (
	Ssh CredentialsSSHType = "ssh"
)

// Defines values for CycleSourceOriginType.
const (
	CycleSource CycleSourceOriginType = "cycle-source"
)

// Defines values for DefaultLbTypeType.
const (
	Default DefaultLbTypeType = "default"
)

// Defines values for DockerFileOriginType.
const (
	DockerFile DockerFileOriginType = "docker-file"
)

// Defines values for DockerHubOriginType.
const (
	DockerHub DockerHubOriginType = "docker-hub"
)

// Defines values for DockerRegistryOriginType.
const (
	DockerRegistry DockerRegistryOriginType = "docker-registry"
)

// Defines values for EnvironmentFeaturesMonitoringTier.
const (
	EnvironmentFeaturesMonitoringTierEnterprise EnvironmentFeaturesMonitoringTier = "enterprise"
	EnvironmentFeaturesMonitoringTierLimited    EnvironmentFeaturesMonitoringTier = "limited"
	EnvironmentFeaturesMonitoringTierPremium    EnvironmentFeaturesMonitoringTier = "premium"
	EnvironmentFeaturesMonitoringTierStandard   EnvironmentFeaturesMonitoringTier = "standard"
)

// Defines values for EnvironmentInitializeActionAction.
const (
	Initialize EnvironmentInitializeActionAction = "initialize"
)

// Defines values for EnvironmentReconfigureDeploymentsActionAction.
const (
	DeploymentsReconfigure EnvironmentReconfigureDeploymentsActionAction = "deployments.reconfigure"
)

// Defines values for EnvironmentStartActionAction.
const (
	Start EnvironmentStartActionAction = "start"
)

// Defines values for EnvironmentStateCurrent.
const (
	EnvironmentStateCurrentCloning  EnvironmentStateCurrent = "cloning"
	EnvironmentStateCurrentDeleted  EnvironmentStateCurrent = "deleted"
	EnvironmentStateCurrentDeleting EnvironmentStateCurrent = "deleting"
	EnvironmentStateCurrentLive     EnvironmentStateCurrent = "live"
	EnvironmentStateCurrentNew      EnvironmentStateCurrent = "new"
)

// Defines values for EnvironmentStopActionAction.
const (
	Stop EnvironmentStopActionAction = "stop"
)

// Defines values for ErrorCode.
const (
	N400InvalidSyntax              ErrorCode = "400.invalid_syntax"
	N401AuthExpired                ErrorCode = "401.auth_expired"
	N401AuthInvalid                ErrorCode = "401.auth_invalid"
	N401NoCookie                   ErrorCode = "401.no_cookie"
	N401UnauthorizedApplication    ErrorCode = "401.unauthorized_application"
	N4032faFailed                  ErrorCode = "403.2fa_failed"
	N4032faRequired                ErrorCode = "403.2fa_required"
	N403Expired                    ErrorCode = "403.expired"
	N403InvalidIp                  ErrorCode = "403.invalid_ip"
	N403InvalidState               ErrorCode = "403.invalid_state"
	N403Mismatch                   ErrorCode = "403.mismatch"
	N403NewApplicationCapabilities ErrorCode = "403.new_application_capabilities"
	N403NotAllowed                 ErrorCode = "403.not_allowed"
	N403NotApproved                ErrorCode = "403.not_approved"
	N403NotReady                   ErrorCode = "403.not_ready"
	N403Permissions                ErrorCode = "403.permissions"
	N403PlatformDisabled           ErrorCode = "403.platform_disabled"
	N403RestrictedPortal           ErrorCode = "403.restricted_portal"
	N403TierRestricted             ErrorCode = "403.tier_restricted"
	N403WrongHub                   ErrorCode = "403.wrong_hub"
	N403WrongScope                 ErrorCode = "403.wrong_scope"
	N404Account                    ErrorCode = "404.account"
	N404Announcement               ErrorCode = "404.announcement"
	N404BillingCredit              ErrorCode = "404.billing.credit"
	N404BillingInvoice             ErrorCode = "404.billing.invoice"
	N404BillingOrder               ErrorCode = "404.billing.order"
	N404BillingPaymentMethod       ErrorCode = "404.billing.payment_method"
	N404BillingPromoCode           ErrorCode = "404.billing.promo_code"
	N404BillingService             ErrorCode = "404.billing.service"
	N404BillingSupport             ErrorCode = "404.billing.support"
	N404BillingTier                ErrorCode = "404.billing.tier"
	N404Cluster                    ErrorCode = "404.cluster"
	N404Container                  ErrorCode = "404.container"
	N404ContainerBackup            ErrorCode = "404.container.backup"
	N404CycleosBuild               ErrorCode = "404.cycleos_build"
	N404DnsRecord                  ErrorCode = "404.dns.record"
	N404DnsZone                    ErrorCode = "404.dns.zone"
	N404EmailVerification          ErrorCode = "404.email_verification"
	N404Environment                ErrorCode = "404.environment"
	N404EnvironmentScopedVariable  ErrorCode = "404.environment.scoped-variable"
	N404HaServiceSession           ErrorCode = "404.ha_service_session"
	N404Hub                        ErrorCode = "404.hub"
	N404HubApiKey                  ErrorCode = "404.hub.api_key"
	N404HubIntegration             ErrorCode = "404.hub.integration"
	N404HubInvitation              ErrorCode = "404.hub.invitation"
	N404HubMembership              ErrorCode = "404.hub.membership"
	N404HubProvider                ErrorCode = "404.hub.provider"
	N404Image                      ErrorCode = "404.image"
	N404ImageBuildLog              ErrorCode = "404.image.build_log"
	N404ImageSource                ErrorCode = "404.image.source"
	N404InfrastructureIpsPool      ErrorCode = "404.infrastructure.ips.pool"
	N404InfrastructureLocation     ErrorCode = "404.infrastructure.location"
	N404InfrastructureModel        ErrorCode = "404.infrastructure.model"
	N404InfrastructureProvider     ErrorCode = "404.infrastructure.provider"
	N404InfrastructureServer       ErrorCode = "404.infrastructure.server"
	N404Instance                   ErrorCode = "404.instance"
	N404Job                        ErrorCode = "404.job"
	N404Node                       ErrorCode = "404.node"
	N404Notification               ErrorCode = "404.notification"
	N404Pipeline                   ErrorCode = "404.pipeline"
	N404PipelineKey                ErrorCode = "404.pipeline.key"
	N404PipelineRun                ErrorCode = "404.pipeline.run"
	N404PlatformBuild              ErrorCode = "404.platform_build"
	N404Provider                   ErrorCode = "404.provider"
	N404SalesLead                  ErrorCode = "404.sales_lead"
	N404SdnNetwork                 ErrorCode = "404.sdn_network"
	N404Stack                      ErrorCode = "404.stack"
	N404StackBuild                 ErrorCode = "404.stack_build"
	N404Survey                     ErrorCode = "404.survey"
	N404SurveyResponse             ErrorCode = "404.survey_response"
	N404Uri                        ErrorCode = "404.uri"
	N404VpnAccount                 ErrorCode = "404.vpn_account"
	N409DuplicateFound             ErrorCode = "409.duplicate_found"
	N415InvalidContentType         ErrorCode = "415.invalid_content_type"
	N422AlreadyExists              ErrorCode = "422.already_exists"
	N422InvalidArgument            ErrorCode = "422.invalid_argument"
	N422InvalidInput               ErrorCode = "422.invalid_input"
	N422MaxExceeded                ErrorCode = "422.max_exceeded"
	N422MissingArgument            ErrorCode = "422.missing_argument"
	N422NotCompatible              ErrorCode = "422.not_compatible"
	N429RateLimiting               ErrorCode = "429.rate_limiting"
	N500Database                   ErrorCode = "500.database"
	N500DatabaseInsert             ErrorCode = "500.database_insert"
	N500DatabaseRemove             ErrorCode = "500.database_remove"
	N500DatabaseUpdate             ErrorCode = "500.database_update"
	N500Dev                        ErrorCode = "500.dev"
	N500Email                      ErrorCode = "500.email"
	N500Jobd                       ErrorCode = "500.jobd"
	N500PaymentGateway             ErrorCode = "500.payment_gateway"
	N500Unknown                    ErrorCode = "500.unknown"
	N503DependencyNotEnabled       ErrorCode = "503.dependency_not_enabled"
	N503NotEnabled                 ErrorCode = "503.not_enabled"
	N503NotReady                   ErrorCode = "503.not_ready"
	N504NotAvailable               ErrorCode = "504.not_available"
)

// Defines values for ErrorStatus.
const (
	N400 ErrorStatus = 400
	N401 ErrorStatus = 401
	N403 ErrorStatus = 403
	N404 ErrorStatus = 404
	N409 ErrorStatus = 409
	N415 ErrorStatus = 415
	N422 ErrorStatus = 422
	N500 ErrorStatus = 500
	N501 ErrorStatus = 501
	N502 ErrorStatus = 502
	N503 ErrorStatus = 503
	N504 ErrorStatus = 504
)

// Defines values for HaProxyConfigSetBackendBalance.
const (
	First      HaProxyConfigSetBackendBalance = "first"
	Leastconn  HaProxyConfigSetBackendBalance = "leastconn"
	Roundrobin HaProxyConfigSetBackendBalance = "roundrobin"
	Source     HaProxyConfigSetBackendBalance = "source"
	StaticRr   HaProxyConfigSetBackendBalance = "static-rr"
)

// Defines values for HaProxyConfigSetFrontendMode.
const (
	HaProxyConfigSetFrontendModeHttp HaProxyConfigSetFrontendMode = "http"
	HaProxyConfigSetFrontendModeTcp  HaProxyConfigSetFrontendMode = "tcp"
)

// Defines values for HaProxyLbTypeType.
const (
	Haproxy HaProxyLbTypeType = "haproxy"
)

// Defines values for HttpRouterConfigType.
const (
	HttpRouterConfigTypeHttp HttpRouterConfigType = "http"
)

// Defines values for HttpTransportConfigType.
const (
	HttpTransportConfigTypeHttp HttpTransportConfigType = "http"
)

// Defines values for JobStateCurrent.
const (
	JobStateCurrentCompleted JobStateCurrent = "completed"
	JobStateCurrentError     JobStateCurrent = "error"
	JobStateCurrentExpired   JobStateCurrent = "expired"
	JobStateCurrentNew       JobStateCurrent = "new"
	JobStateCurrentQueued    JobStateCurrent = "queued"
	JobStateCurrentRunning   JobStateCurrent = "running"
	JobStateCurrentScheduled JobStateCurrent = "scheduled"
)

// Defines values for OciRegistryOriginType.
const (
	OciRegistry OciRegistryOriginType = "oci-registry"
)

// Defines values for RegistryAuthProviderDetailsFlavor.
const (
	Ecr RegistryAuthProviderDetailsFlavor = "ecr"
)

// Defines values for RegistryAuthProviderType.
const (
	Provider RegistryAuthProviderType = "provider"
)

// Defines values for RegistryAuthUserType.
const (
	RegistryAuthUserTypeUser RegistryAuthUserType = "user"
)

// Defines values for RegistryAuthWebhookType.
const (
	Webhook RegistryAuthWebhookType = "webhook"
)

// Defines values for StackContainerRole.
const (
	Conductor StackContainerRole = "conductor"
)

// Defines values for StackContainerConfigDeployRestartCondition.
const (
	Always  StackContainerConfigDeployRestartCondition = "always"
	Failure StackContainerConfigDeployRestartCondition = "failure"
	Never   StackContainerConfigDeployRestartCondition = "never"
)

// Defines values for StackContainerConfigDeployShutdownSignals.
const (
	SIGHUB  StackContainerConfigDeployShutdownSignals = "SIGHUB"
	SIGINT  StackContainerConfigDeployShutdownSignals = "SIGINT"
	SIGKILL StackContainerConfigDeployShutdownSignals = "SIGKILL"
	SIGQUIT StackContainerConfigDeployShutdownSignals = "SIGQUIT"
	SIGTERM StackContainerConfigDeployShutdownSignals = "SIGTERM"
	SIGUSR1 StackContainerConfigDeployShutdownSignals = "SIGUSR1"
	SIGUSR2 StackContainerConfigDeployShutdownSignals = "SIGUSR2"
)

// Defines values for StackContainerConfigDeployStrategy.
const (
	Edge             StackContainerConfigDeployStrategy = "edge"
	FirstAvailable   StackContainerConfigDeployStrategy = "first-available"
	Function         StackContainerConfigDeployStrategy = "function"
	HighAvailability StackContainerConfigDeployStrategy = "high-availability"
	Manual           StackContainerConfigDeployStrategy = "manual"
	Node             StackContainerConfigDeployStrategy = "node"
	ResourceDensity  StackContainerConfigDeployStrategy = "resource-density"
)

// Defines values for StackContainerConfigNetworkPublic.
const (
	Disable    StackContainerConfigNetworkPublic = "disable"
	EgressOnly StackContainerConfigNetworkPublic = "egress-only"
	Enable     StackContainerConfigNetworkPublic = "enable"
)

// Defines values for StackContainerConfigRuntimeCapabilities.
const (
	CAPAUDITCONTROL   StackContainerConfigRuntimeCapabilities = "CAP_AUDIT_CONTROL"
	CAPAUDITREAD      StackContainerConfigRuntimeCapabilities = "CAP_AUDIT_READ"
	CAPAUDITWRITE     StackContainerConfigRuntimeCapabilities = "CAP_AUDIT_WRITE"
	CAPBLOCKSUSPEND   StackContainerConfigRuntimeCapabilities = "CAP_BLOCK_SUSPEND"
	CAPCHOWN          StackContainerConfigRuntimeCapabilities = "CAP_CHOWN"
	CAPDACOVERRIDE    StackContainerConfigRuntimeCapabilities = "CAP_DAC_OVERRIDE"
	CAPDACREADSEARCH  StackContainerConfigRuntimeCapabilities = "CAP_DAC_READ_SEARCH"
	CAPFOWNER         StackContainerConfigRuntimeCapabilities = "CAP_FOWNER"
	CAPFSETID         StackContainerConfigRuntimeCapabilities = "CAP_FSETID"
	CAPIPCLOCK        StackContainerConfigRuntimeCapabilities = "CAP_IPC_LOCK"
	CAPIPCOWNER       StackContainerConfigRuntimeCapabilities = "CAP_IPC_OWNER"
	CAPKILL           StackContainerConfigRuntimeCapabilities = "CAP_KILL"
	CAPLEASE          StackContainerConfigRuntimeCapabilities = "CAP_LEASE"
	CAPLINUXIMMUTABLE StackContainerConfigRuntimeCapabilities = "CAP_LINUX_IMMUTABLE"
	CAPMACADMIN       StackContainerConfigRuntimeCapabilities = "CAP_MAC_ADMIN"
	CAPMACOVERRIDE    StackContainerConfigRuntimeCapabilities = "CAP_MAC_OVERRIDE"
	CAPMKNOD          StackContainerConfigRuntimeCapabilities = "CAP_MKNOD"
	CAPNETADMIN       StackContainerConfigRuntimeCapabilities = "CAP_NET_ADMIN"
	CAPNETBINDSERVICE StackContainerConfigRuntimeCapabilities = "CAP_NET_BIND_SERVICE"
	CAPNETBROADCAST   StackContainerConfigRuntimeCapabilities = "CAP_NET_BROADCAST"
	CAPNETRAW         StackContainerConfigRuntimeCapabilities = "CAP_NET_RAW"
	CAPSETFCAP        StackContainerConfigRuntimeCapabilities = "CAP_SETFCAP"
	CAPSETGID         StackContainerConfigRuntimeCapabilities = "CAP_SETGID"
	CAPSETPCAP        StackContainerConfigRuntimeCapabilities = "CAP_SETPCAP"
	CAPSETUID         StackContainerConfigRuntimeCapabilities = "CAP_SETUID"
	CAPSYSADMIN       StackContainerConfigRuntimeCapabilities = "CAP_SYS_ADMIN"
	CAPSYSBOOT        StackContainerConfigRuntimeCapabilities = "CAP_SYS_BOOT"
	CAPSYSCHROOT      StackContainerConfigRuntimeCapabilities = "CAP_SYS_CHROOT"
	CAPSYSLOG         StackContainerConfigRuntimeCapabilities = "CAP_SYSLOG"
	CAPSYSMODULE      StackContainerConfigRuntimeCapabilities = "CAP_SYS_MODULE"
	CAPSYSNICE        StackContainerConfigRuntimeCapabilities = "CAP_SYS_NICE"
	CAPSYSPACCT       StackContainerConfigRuntimeCapabilities = "CAP_SYS_PACCT"
	CAPSYSPTRACE      StackContainerConfigRuntimeCapabilities = "CAP_SYS_PTRACE"
	CAPSYSRAWIO       StackContainerConfigRuntimeCapabilities = "CAP_SYS_RAWIO"
	CAPSYSRESOURCE    StackContainerConfigRuntimeCapabilities = "CAP_SYS_RESOURCE"
	CAPSYSTIME        StackContainerConfigRuntimeCapabilities = "CAP_SYS_TIME"
	CAPSYSTTYCONFIG   StackContainerConfigRuntimeCapabilities = "CAP_SYS_TTY_CONFIG"
	CAPWAKEALARM      StackContainerConfigRuntimeCapabilities = "CAP_WAKE_ALARM"
)

// Defines values for StackContainerConfigRuntimeNamespaces.
const (
	StackContainerConfigRuntimeNamespacesCgroup  StackContainerConfigRuntimeNamespaces = "cgroup"
	StackContainerConfigRuntimeNamespacesIpc     StackContainerConfigRuntimeNamespaces = "ipc"
	StackContainerConfigRuntimeNamespacesMount   StackContainerConfigRuntimeNamespaces = "mount"
	StackContainerConfigRuntimeNamespacesNetwork StackContainerConfigRuntimeNamespaces = "network"
	StackContainerConfigRuntimeNamespacesPid     StackContainerConfigRuntimeNamespaces = "pid"
	StackContainerConfigRuntimeNamespacesUser    StackContainerConfigRuntimeNamespaces = "user"
	StackContainerConfigRuntimeNamespacesUts     StackContainerConfigRuntimeNamespaces = "uts"
)

// Defines values for StackContainerConfigRuntimeSeccompRulesSyscallAction.
const (
	SCMPACTALLOW       StackContainerConfigRuntimeSeccompRulesSyscallAction = "SCMP_ACT_ALLOW"
	SCMPACTERRNO       StackContainerConfigRuntimeSeccompRulesSyscallAction = "SCMP_ACT_ERRNO"
	SCMPACTKILL        StackContainerConfigRuntimeSeccompRulesSyscallAction = "SCMP_ACT_KILL"
	SCMPACTKILLPROCESS StackContainerConfigRuntimeSeccompRulesSyscallAction = "SCMP_ACT_KILL_PROCESS"
	SCMPACTKILLTHREAD  StackContainerConfigRuntimeSeccompRulesSyscallAction = "SCMP_ACT_KILL_THREAD"
	SCMPACTLOG         StackContainerConfigRuntimeSeccompRulesSyscallAction = "SCMP_ACT_LOG"
	SCMPACTNOTIFY      StackContainerConfigRuntimeSeccompRulesSyscallAction = "SCMP_ACT_NOTIFY"
	SCMPACTTRACE       StackContainerConfigRuntimeSeccompRulesSyscallAction = "SCMP_ACT_TRACE"
	SCMPACTTRAP        StackContainerConfigRuntimeSeccompRulesSyscallAction = "SCMP_ACT_TRAP"
)

// Defines values for StackContainerConfigRuntimeSeccompRulesSyscallArgsOp.
const (
	SCMPCMPEQ       StackContainerConfigRuntimeSeccompRulesSyscallArgsOp = "SCMP_CMP_EQ"
	SCMPCMPGE       StackContainerConfigRuntimeSeccompRulesSyscallArgsOp = "SCMP_CMP_GE"
	SCMPCMPGT       StackContainerConfigRuntimeSeccompRulesSyscallArgsOp = "SCMP_CMP_GT"
	SCMPCMPLE       StackContainerConfigRuntimeSeccompRulesSyscallArgsOp = "SCMP_CMP_LE"
	SCMPCMPLT       StackContainerConfigRuntimeSeccompRulesSyscallArgsOp = "SCMP_CMP_LT"
	SCMPCMPMASKEDEQ StackContainerConfigRuntimeSeccompRulesSyscallArgsOp = "SCMP_CMP_MASKED_EQ"
	SCMPCMPNE       StackContainerConfigRuntimeSeccompRulesSyscallArgsOp = "SCMP_CMP_NE"
)

// Defines values for StackContainerScaleThresholdCpuType.
const (
	Cpu StackContainerScaleThresholdCpuType = "cpu"
)

// Defines values for StackContainerScaleThresholdCustomType.
const (
	Custom StackContainerScaleThresholdCustomType = "custom"
)

// Defines values for StackContainerScaleThresholdNetworkConnectionsType.
const (
	NetworkConnections StackContainerScaleThresholdNetworkConnectionsType = "network-connections"
)

// Defines values for StackContainerScaleThresholdNetworkRequestsType.
const (
	NetworkRequests StackContainerScaleThresholdNetworkRequestsType = "network-requests"
)

// Defines values for StackContainerScaleThresholdNetworkThroughputType.
const (
	NetworkThroughput StackContainerScaleThresholdNetworkThroughputType = "network-throughput"
)

// Defines values for StackContainerScaleThresholdRamType.
const (
	Ram StackContainerScaleThresholdRamType = "ram"
)

// Defines values for StackContainerVolumeRemoteAccessPasswordAlgorithm.
const (
	StackContainerVolumeRemoteAccessPasswordAlgorithmMd5    StackContainerVolumeRemoteAccessPasswordAlgorithm = "md5"
	StackContainerVolumeRemoteAccessPasswordAlgorithmRaw    StackContainerVolumeRemoteAccessPasswordAlgorithm = "raw"
	StackContainerVolumeRemoteAccessPasswordAlgorithmSha512 StackContainerVolumeRemoteAccessPasswordAlgorithm = "sha512"
)

// Defines values for StackSpecVersion.
const (
	N10 StackSpecVersion = "1.0"
)

// Defines values for StackSpecScopedVariableRawSourceType.
const (
	StackSpecScopedVariableRawSourceTypeRaw StackSpecScopedVariableRawSourceType = "raw"
)

// Defines values for StackSpecScopedVariableUrlSourceType.
const (
	Url StackSpecScopedVariableUrlSourceType = "url"
)

// Defines values for TaskStateCurrent.
const (
	TaskStateCurrentCompleted TaskStateCurrent = "completed"
	TaskStateCurrentError     TaskStateCurrent = "error"
	TaskStateCurrentPending   TaskStateCurrent = "pending"
	TaskStateCurrentRunning   TaskStateCurrent = "running"
)

// Defines values for TcpRouterConfigType.
const (
	TcpRouterConfigTypeTcp TcpRouterConfigType = "tcp"
)

// Defines values for TcpTransportConfigType.
const (
	TcpTransportConfigTypeTcp TcpTransportConfigType = "tcp"
)

// Defines values for UdpRouterConfigType.
const (
	UdpRouterConfigTypeUdp UdpRouterConfigType = "udp"
)

// Defines values for UdpTransportConfigType.
const (
	UdpTransportConfigTypeUdp UdpTransportConfigType = "udp"
)

// Defines values for V1LbConfigRouterConfigDestinationPrioritization0.
const (
	V1LbConfigRouterConfigDestinationPrioritization0Latency V1LbConfigRouterConfigDestinationPrioritization0 = "latency"
	V1LbConfigRouterConfigDestinationPrioritization0Random  V1LbConfigRouterConfigDestinationPrioritization0 = "random"
)

// Defines values for V1LbConfigRouterConfigTlsClientAuth0.
const (
	None          V1LbConfigRouterConfigTlsClientAuth0 = "none"
	Request       V1LbConfigRouterConfigTlsClientAuth0 = "request"
	Require       V1LbConfigRouterConfigTlsClientAuth0 = "require"
	RequireVerify V1LbConfigRouterConfigTlsClientAuth0 = "require-verify"
)

// Defines values for V1LbConfigRouterMode.
const (
	V1LbConfigRouterModeRandom     V1LbConfigRouterMode = "random"
	V1LbConfigRouterModeRoundRobin V1LbConfigRouterMode = "round-robin"
)

// Defines values for V1LbControllerTransportConfigVerbosity.
const (
	Debug  V1LbControllerTransportConfigVerbosity = "debug"
	High   V1LbControllerTransportConfigVerbosity = "high"
	Low    V1LbControllerTransportConfigVerbosity = "low"
	Normal V1LbControllerTransportConfigVerbosity = "normal"
)

// Defines values for V1LbControllerTransportMode.
const (
	Http V1LbControllerTransportMode = "http"
	Tcp  V1LbControllerTransportMode = "tcp"
	Udp  V1LbControllerTransportMode = "udp"
)

// Defines values for V1LbTypeType.
const (
	V1 V1LbTypeType = "v1"
)

// Defines values for WafConfigRulesConditionsOperator.
const (
	Empty      WafConfigRulesConditionsOperator = "!="
	EqualEqual WafConfigRulesConditionsOperator = "=="
	N1         WafConfigRulesConditionsOperator = ">"
	N2         WafConfigRulesConditionsOperator = "<"
	N3         WafConfigRulesConditionsOperator = ">="
	N4         WafConfigRulesConditionsOperator = "<="
)

// Defines values for WafConfigRulesConditionsType.
const (
	GeoMatch    WafConfigRulesConditionsType = "geo-match"
	HeaderMatch WafConfigRulesConditionsType = "header-match"
	IpMatch     WafConfigRulesConditionsType = "ip-match"
	MethodMatch WafConfigRulesConditionsType = "method-match"
	UrlMatch    WafConfigRulesConditionsType = "url-match"
)

// Defines values for WafConfigRulesType.
const (
	Allow WafConfigRulesType = "allow"
	Deny  WafConfigRulesType = "deny"
)

// Defines values for ZoneStateCurrent.
const (
	Deleted   ZoneStateCurrent = "deleted"
	Deleting  ZoneStateCurrent = "deleting"
	Disabled  ZoneStateCurrent = "disabled"
	Live      ZoneStateCurrent = "live"
	New       ZoneStateCurrent = "new"
	Pending   ZoneStateCurrent = "pending"
	Verifying ZoneStateCurrent = "verifying"
)

// Defines values for GetDNSZonesParamsInclude.
const (
	GetDNSZonesParamsIncludeCreators GetDNSZonesParamsInclude = "creators"
)

// Defines values for UpdateDNSZoneParamsInclude.
const (
	UpdateDNSZoneParamsIncludeCreators UpdateDNSZoneParamsInclude = "creators"
)

// Defines values for UpdateDNSZoneAccessParamsInclude.
const (
	UpdateDNSZoneAccessParamsIncludeCreators UpdateDNSZoneAccessParamsInclude = "creators"
)

// Defines values for CreateDNSZoneJobJSONBodyAction.
const (
	Verify CreateDNSZoneJobJSONBodyAction = "verify"
)

// Defines values for GetEnvironmentsParamsMeta.
const (
	GetEnvironmentsParamsMetaContainers      GetEnvironmentsParamsMeta = "containers"
	GetEnvironmentsParamsMetaContainersCount GetEnvironmentsParamsMeta = "containers_count"
	GetEnvironmentsParamsMetaInstancesCount  GetEnvironmentsParamsMeta = "instances_count"
)

// Defines values for GetEnvironmentsParamsInclude.
const (
	GetEnvironmentsParamsIncludeCreators GetEnvironmentsParamsInclude = "creators"
	GetEnvironmentsParamsIncludeStacks   GetEnvironmentsParamsInclude = "stacks"
)

// Defines values for GetEnvironmentParamsMeta.
const (
	GetEnvironmentParamsMetaContainers      GetEnvironmentParamsMeta = "containers"
	GetEnvironmentParamsMetaContainersCount GetEnvironmentParamsMeta = "containers_count"
	GetEnvironmentParamsMetaInstancesCount  GetEnvironmentParamsMeta = "instances_count"
)

// Defines values for GetEnvironmentParamsInclude.
const (
	GetEnvironmentParamsIncludeCreators GetEnvironmentParamsInclude = "creators"
	GetEnvironmentParamsIncludeStacks   GetEnvironmentParamsInclude = "stacks"
)

// Defines values for UpdateEnvironmentJSONBodyMonitoringTier.
const (
	UpdateEnvironmentJSONBodyMonitoringTierEnterprise UpdateEnvironmentJSONBodyMonitoringTier = "enterprise"
	UpdateEnvironmentJSONBodyMonitoringTierLimited    UpdateEnvironmentJSONBodyMonitoringTier = "limited"
	UpdateEnvironmentJSONBodyMonitoringTierPremium    UpdateEnvironmentJSONBodyMonitoringTier = "premium"
	UpdateEnvironmentJSONBodyMonitoringTierStandard   UpdateEnvironmentJSONBodyMonitoringTier = "standard"
)

// Defines values for GetJobsParamsInclude.
const (
	GetJobsParamsIncludeCreators GetJobsParamsInclude = "creators"
)

// ACL An access control list. Defines which roles have which permissions on specific resources.
type ACL struct {
	Roles *map[string]struct {
		// Manage Can the user delete / update ACLs for this resource?
		Manage bool `json:"manage"`

		// Modify Can the user edit the state / name / identifier of this resource?
		Modify bool `json:"modify"`

		// View Can the user see / use this resource?
		View bool `json:"view"`
	} `json:"roles,omitempty"`
}

// ApiKeyCreator An extended resource that has information on a Cycle hub API key
type ApiKeyCreator struct {
	// Capabilities The API key capabilities list
	Capabilities struct {
		All      bool     `json:"all"`
		Specific []string `json:"specific"`
	} `json:"capabilities"`

	// Events Describes the date and time at which certain events occurred in the lifetime of this resource.
	Events Events `json:"events"`

	// HubId A 24 character hex string used to identify a unique resource.
	HubId ID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id  ID        `json:"id"`
	Ips *[]string `json:"ips"`

	// Name The name of the API key
	Name string `json:"name"`

	// Permissions Permissions information for an API Key
	Permissions Permissions `json:"permissions"`

	// Secret The API key secret
	Secret *string `json:"secret,omitempty"`
	State  struct {
		Changed DateTime                  `json:"changed"`
		Current ApiKeyCreatorStateCurrent `json:"current"`

		// Error An error, if any, that has occurred for this resource.
		Error *struct {
			// Message Details about the error that has occurred.
			Message *string   `json:"message,omitempty"`
			Time    *DateTime `json:"time,omitempty"`
		} `json:"error,omitempty"`
	} `json:"state"`
}

// ApiKeyCreatorStateCurrent defines model for ApiKeyCreator.State.Current.
type ApiKeyCreatorStateCurrent string

// Capability A capability that a user or API key that represents what an API key or a user can do.
type Capability string

// ContainerEnvironmentSummary A summary of supplemental environment and network information specific to a container.
type ContainerEnvironmentSummary struct {
	// Cluster The cluster this environment is associated with.
	Cluster string `json:"cluster"`

	// ContainerSubnet The private network subnet ID for this container and its instances.
	ContainerSubnet *string `json:"container_subnet"`

	// Id A 24 character hex string used to identify a unique resource.
	Id     ID                                 `json:"id"`
	Ipv6   *ContainerEnvironmentSummary_Ipv6  `json:"ipv6,omitempty"`
	Legacy ContainerEnvironmentSummary_Legacy `json:"legacy"`
}

// ContainerEnvironmentSummaryIpv61 defines model for .
type ContainerEnvironmentSummaryIpv61 = map[string]interface{}

// ContainerEnvironmentSummary_Ipv6 defines model for ContainerEnvironmentSummary.Ipv6.
type ContainerEnvironmentSummary_Ipv6 struct {
	union json.RawMessage
}

// ContainerEnvironmentSummaryLegacy1 defines model for .
type ContainerEnvironmentSummaryLegacy1 = map[string]interface{}

// ContainerEnvironmentSummary_Legacy defines model for ContainerEnvironmentSummary.Legacy.
type ContainerEnvironmentSummary_Legacy struct {
	union json.RawMessage
}

// ContainerImageSummary The Id of the image and information on if it is a service.
type ContainerImageSummary struct {
	// Id A 24 character hex string used to identify a unique resource.
	Id      ID                            `json:"id"`
	Service ContainerImageSummary_Service `json:"service"`
}

// ContainerImageSummaryService0 If this image is a service container this will say either `discovery` | `loadbalancer` | `vpn`.
type ContainerImageSummaryService0 string

// ContainerImageSummaryService1 defines model for .
type ContainerImageSummaryService1 = map[string]interface{}

// ContainerImageSummary_Service defines model for ContainerImageSummary.Service.
type ContainerImageSummary_Service struct {
	union json.RawMessage
}

// ContainerState defines model for ContainerState.
type ContainerState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the container.
	Current ContainerStateCurrent `json:"current"`

	// Desired The desired state of the container.
	Desired *ContainerStateDesired `json:"desired,omitempty"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// ContainerStateCurrent The current state of the container.
type ContainerStateCurrent string

// ContainerStateDesired The desired state of the container.
type ContainerStateDesired string

// CreatorInclude An identity that created a resource.
type CreatorInclude struct {
	// Accounts Included creators that are public accounts, keyed by ID.
	Accounts *map[string]PublicAccount `json:"accounts,omitempty"`

	// ApiKeys Included creators that are Cycle API Keys, keyed by ID.
	ApiKeys *map[string]ApiKeyCreator `json:"api_keys,omitempty"`

	// Employees Included creators that are employees of Cycle, keyed by ID.
	Employees *map[string]PublicAccount `json:"employees,omitempty"`

	// Environments Included creators that are Cycle environments (usually automatically created resources), keyed by ID.
	Environments *map[string]Environment `json:"environments,omitempty"`

	// Visitors Included creators that are not Cycle accounts, keyed by ID.
	Visitors *map[string]PublicAccount `json:"visitors,omitempty"`
}

// CreatorScope The creator scope is embedded in resource objects to describe who created them
type CreatorScope struct {
	// Id A 24 character hex string used to identify a unique resource.
	Id   ID               `json:"id"`
	Type CreatorScopeType `json:"type"`
}

// CreatorScopeType defines model for CreatorScope.Type.
type CreatorScopeType string

// CredentialsHTTP defines model for CredentialsHTTP.
type CredentialsHTTP struct {
	// Credentials Authentication credentails for the Dockerfile image source type when authenticating over HTTP.
	Credentials struct {
		// Password For authentication, the password.
		Password string `json:"password"`

		// Username For authentication, the username.
		Username string `json:"username"`
	} `json:"credentials"`
	Type CredentialsHTTPType `json:"type"`
}

// CredentialsHTTPType defines model for CredentialsHTTP.Type.
type CredentialsHTTPType string

// CredentialsSSH defines model for CredentialsSSH.
type CredentialsSSH struct {
	// Credentials Authentication credentials for the Dockerfile image source type when authenticating with SSH.
	Credentials struct {
		// Passphrase The passphrase used for the key.
		Passphrase string `json:"passphrase"`

		// PrivateKey A pem encoded private key.
		PrivateKey string `json:"private_key"`

		// Username The username for the repo service, that is used to authenticate an ssh key.
		Username string `json:"username"`
	} `json:"credentials"`
	Type CredentialsSSHType `json:"type"`
}

// CredentialsSSHType defines model for CredentialsSSH.Type.
type CredentialsSSHType string

// CycleSourceOrigin An image origin that references an image source on Cycle.
//
// This origin will never be embedded in an image source. It is for use in stacks, describing an image which is already a part of an image source on Cycle.
type CycleSourceOrigin struct {
	Details struct {
		// SourceId A 24 character hex string used to identify a unique resource.
		SourceId ID `json:"source_id"`
	} `json:"details"`
	Type CycleSourceOriginType `json:"type"`
}

// CycleSourceOriginType defines model for CycleSourceOrigin.Type.
type CycleSourceOriginType string

// DateTime defines model for DateTime.
type DateTime = time.Time

// DefaultLbType defines model for DefaultLbType.
type DefaultLbType struct {
	Details DefaultLbType_Details `json:"details"`

	// Ipv4 Allow / disallow traffic to be routed via IPv4.
	Ipv4 bool `json:"ipv4"`

	// Ipv6 Allow / disallow traffic to be routed via IPv6.
	Ipv6 bool              `json:"ipv6"`
	Type DefaultLbTypeType `json:"type"`
}

// DefaultLbTypeDetails2 defines model for .
type DefaultLbTypeDetails2 = map[string]interface{}

// DefaultLbType_Details defines model for DefaultLbType.Details.
type DefaultLbType_Details struct {
	union json.RawMessage
}

// DefaultLbTypeType defines model for DefaultLbType.Type.
type DefaultLbTypeType string

// DiscoveryConfig The config object for the discovery service.
type DiscoveryConfig struct {
	EmptySetDelay *DiscoveryConfig_EmptySetDelay `json:"empty_set_delay,omitempty"`

	// Hosts A mapping of hostnames to IP addresses for custom internal resolutions. Acts as a custom /etc/resolv.conf file that works environment wide.
	Hosts *map[string]struct {
		// Ipv4 The IPv4 address the discovery server should return to any container instance requesting this hostname.
		Ipv4 *[]string `json:"ipv4"`

		// Ipv6 The IPv6 address the discovery server should return to any container instance requesting this hostname.
		Ipv6 *[]string `json:"ipv6"`
	} `json:"hosts"`
}

// DiscoveryConfigEmptySetDelay1 defines model for .
type DiscoveryConfigEmptySetDelay1 = string

// DiscoveryConfig_EmptySetDelay defines model for DiscoveryConfig.EmptySetDelay.
type DiscoveryConfig_EmptySetDelay struct {
	union json.RawMessage
}

// DiscoveryEnvironmentService Information about the environments discovery service(s).
type DiscoveryEnvironmentService struct {
	// AutoUpdate A boolean where `true` represents the desire to automatically update the environment discovery service.
	AutoUpdate *bool `json:"auto_update,omitempty"`

	// Config The config object for the discovery service.
	Config DiscoveryEnvironmentService_Config `json:"config"`

	// ContainerId The ID of the discovery service container
	ContainerId string `json:"container_id"`

	// Enable Whether or not the discovery service is enabled.
	Enable bool `json:"enable"`

	// HighAvailability A boolean representing if this service container is set to high availability mode or not.
	HighAvailability bool `json:"high_availability"`
}

// DiscoveryEnvironmentServiceConfig1 defines model for .
type DiscoveryEnvironmentServiceConfig1 = map[string]interface{}

// DiscoveryEnvironmentService_Config The config object for the discovery service.
type DiscoveryEnvironmentService_Config struct {
	union json.RawMessage
}

// DockerFileOrigin An image origin where the image is built from a Dockerfile located in a git repository.
type DockerFileOrigin struct {
	Details struct {
		// BuildFile The path to the Dockerfile to be used for buiding the image.
		BuildFile *string `json:"build_file"`

		// ContextDir The path to the directory to use as the context when building the image.
		ContextDir  *string                               `json:"context_dir"`
		Credentials *DockerFileOrigin_Details_Credentials `json:"credentials,omitempty"`
		Existing    *DockerFileOrigin_Details_Existing    `json:"existing,omitempty"`
		Repo        *DockerFileOrigin_Details_Repo        `json:"repo,omitempty"`

		// TargzUrl An endpoint that serves the tar file.
		TargzUrl *string `json:"targz_url"`
	} `json:"details"`
	Type DockerFileOriginType `json:"type"`
}

// DockerFileOriginDetailsCredentials1 defines model for .
type DockerFileOriginDetailsCredentials1 = []interface{}

// DockerFileOrigin_Details_Credentials defines model for DockerFileOrigin.Details.Credentials.
type DockerFileOrigin_Details_Credentials struct {
	union json.RawMessage
}

// DockerFileOriginDetailsExisting1 defines model for .
type DockerFileOriginDetailsExisting1 = map[string]interface{}

// DockerFileOrigin_Details_Existing defines model for DockerFileOrigin.Details.Existing.
type DockerFileOrigin_Details_Existing struct {
	union json.RawMessage
}

// DockerFileOriginDetailsRepo1 defines model for .
type DockerFileOriginDetailsRepo1 = map[string]interface{}

// DockerFileOrigin_Details_Repo defines model for DockerFileOrigin.Details.Repo.
type DockerFileOrigin_Details_Repo struct {
	union json.RawMessage
}

// DockerFileOriginType defines model for DockerFileOrigin.Type.
type DockerFileOriginType string

// DockerHubOrigin An image origin where the image is pulled from DockerHub.
type DockerHubOrigin struct {
	Details struct {
		Existing *DockerHubOrigin_Details_Existing `json:"existing,omitempty"`

		// Target The DockerHub target string. ex - `mysql:5.7`
		Target string `json:"target"`

		// Token For authentication, a token.
		Token *string `json:"token,omitempty"`

		// Username For authentication, a username.
		Username *string `json:"username,omitempty"`
	} `json:"details"`
	Type DockerHubOriginType `json:"type"`
}

// DockerHubOriginDetailsExisting1 defines model for .
type DockerHubOriginDetailsExisting1 = map[string]interface{}

// DockerHubOrigin_Details_Existing defines model for DockerHubOrigin.Details.Existing.
type DockerHubOrigin_Details_Existing struct {
	union json.RawMessage
}

// DockerHubOriginType defines model for DockerHubOrigin.Type.
type DockerHubOriginType string

// DockerRegistryOrigin An image origin where the image is pulled from a private Docker registry.
type DockerRegistryOrigin struct {
	Details struct {
		// Existing In a stack, specifies an image source ID from which Cycle will derive any values not specified in the stack file. This is useful for avoiding direct placement of credentials in a stack file, for example.
		Existing *ExistingSource `json:"existing,omitempty"`

		// Password For authentication, a password.
		Password *string `json:"password,omitempty"`

		// Target The image name on the registry.
		Target string `json:"target"`

		// Token For authentication, a token.
		Token *string `json:"token,omitempty"`

		// Url The url of the remote registry.
		Url string `json:"url"`

		// Username For authentication, a username.
		Username *string `json:"username,omitempty"`
	} `json:"details"`
	Type DockerRegistryOriginType `json:"type"`
}

// DockerRegistryOriginType defines model for DockerRegistryOrigin.Type.
type DockerRegistryOriginType string

// DockerfileCredentials An array of credentials objects to be used when authenticating against private images used by the Dockerfile.
type DockerfileCredentials = []struct {
	// Token A token for authentication.
	Token *string `json:"token,omitempty"`

	// Url The url the resource is located at.
	Url *string `json:"url,omitempty"`

	// Username A username for authentication.
	Username *string `json:"username,omitempty"`
}

// Duration A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
type Duration = string

// Environment Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://docs.cycle.io/environments/overview/).
type Environment struct {
	// About Contains details regarding the environment.
	About EnvironmentAbout `json:"about"`
	Acl   *Environment_Acl `json:"acl,omitempty"`

	// Cluster The cluster this environment is associated with.
	Cluster string `json:"cluster"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Deployments A map of custom tags to deployment versions.
	Deployments *struct {
		// Tags A map of custom tags to deployment versions. Allows for defining a custom, persistent tag with a changing version number.
		// For example, `dev -> v1.2.3-dev`. This is useful when dealing with DNS LINKED records, where you always want dev.example.com to point to the
		// `dev` version of your app within an environment, where you can continuously deploy and update it without needing to change the record. It is
		// even more useful when you have multiple LINKED records, and you update i.e. `prod`` tag to point to a new version, all records using the `prod` tag
		// are switched at once.
		Tags EnvironmentDeploymentTags `json:"tags"`
	} `json:"deployments"`

	// Events A collection of timestamps for each event in the environment's lifetime.
	Events struct {
		Created DateTime `json:"created"`
		Deleted DateTime `json:"deleted"`
		Updated DateTime `json:"updated"`
	} `json:"events"`

	// Features An object representing specialized features configured for this environment.
	Features EnvironmentFeatures `json:"features"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`

	// Meta A list of meta fields that can be applied to this environment.
	Meta *EnvironmentMeta `json:"meta,omitempty"`

	// Name A user defined name for the environment resource.
	Name           string                      `json:"name"`
	PrivateNetwork *Environment_PrivateNetwork `json:"private_network,omitempty"`

	// Services Service containers run by this environment and their configurations.
	Services EnvironmentServices `json:"services"`
	State    EnvironmentState    `json:"state"`
}

// EnvironmentAcl1 defines model for .
type EnvironmentAcl1 = map[string]interface{}

// Environment_Acl defines model for Environment.Acl.
type Environment_Acl struct {
	union json.RawMessage
}

// EnvironmentPrivateNetwork1 defines model for .
type EnvironmentPrivateNetwork1 = map[string]interface{}

// Environment_PrivateNetwork defines model for Environment.PrivateNetwork.
type Environment_PrivateNetwork struct {
	union json.RawMessage
}

// EnvironmentAbout Contains details regarding the environment.
type EnvironmentAbout struct {
	// Description A custom description for this environment.
	Description string `json:"description"`

	// Favorite If true, this environment has been marked as a favorite.
	Favorite bool `json:"favorite"`
}

// EnvironmentDeploymentTags A map of custom tags to deployment versions. Allows for defining a custom, persistent tag with a changing version number.
// For example, `dev -> v1.2.3-dev`. This is useful when dealing with DNS LINKED records, where you always want dev.example.com to point to the
// `dev` version of your app within an environment, where you can continuously deploy and update it without needing to change the record. It is
// even more useful when you have multiple LINKED records, and you update i.e. `prodâ tag to point to a new version, all records using the `prod` tag
// are switched at once.
type EnvironmentDeploymentTags map[string]Version

// EnvironmentFeatures An object representing specialized features configured for this environment.
type EnvironmentFeatures struct {
	// LegacyNetworking Whether or not legacy networking mode is enabled on this environment.
	LegacyNetworking bool `json:"legacy_networking"`

	// Monitoring The level of monitoring to enable for this environment. There is a cost associated with higher levels of monitoring.
	Monitoring *struct {
		Tier EnvironmentFeaturesMonitoringTier `json:"tier"`
	} `json:"monitoring"`
}

// EnvironmentFeaturesMonitoringTier defines model for EnvironmentFeatures.Monitoring.Tier.
type EnvironmentFeaturesMonitoringTier string

// EnvironmentInitializeAction A task to initialize an environment.
type EnvironmentInitializeAction struct {
	// Action The name of the action to perform.
	Action EnvironmentInitializeActionAction `json:"action"`
}

// EnvironmentInitializeActionAction The name of the action to perform.
type EnvironmentInitializeActionAction string

// EnvironmentMeta A list of meta fields that can be applied to this environment.
type EnvironmentMeta struct {
	Containers *[]struct {
		// Environment A summary of supplemental environment and network information specific to a container.
		Environment ContainerEnvironmentSummary `json:"environment"`

		// Id A 24 character hex string used to identify a unique resource.
		Id ID `json:"id"`

		// Image The Id of the image and information on if it is a service.
		Image ContainerImageSummary `json:"image"`

		// Name A user defined name for the container resource.
		Name  string         `json:"name"`
		State ContainerState `json:"state"`
	} `json:"containers,omitempty"`

	// ContainersCount A summary of resources by state
	ContainersCount *StateCountSummary `json:"containers_count,omitempty"`

	// InstancesCount A summary of resources by state
	InstancesCount *StateCountSummary `json:"instances_count,omitempty"`
}

// EnvironmentReconfigureDeploymentsAction A task to reconfigure deployment mappings on an environment.
type EnvironmentReconfigureDeploymentsAction struct {
	// Action The action to take.
	Action   EnvironmentReconfigureDeploymentsActionAction `json:"action"`
	Contents struct {
		// Tags A map of custom tags to deployment versions. Allows for defining a custom, persistent tag with a changing version number.
		// For example, `dev -> v1.2.3-dev`. This is useful when dealing with DNS LINKED records, where you always want dev.example.com to point to the
		// `dev` version of your app within an environment, where you can continuously deploy and update it without needing to change the record. It is
		// even more useful when you have multiple LINKED records, and you update i.e. `prod`` tag to point to a new version, all records using the `prod` tag
		// are switched at once.
		Tags EnvironmentDeploymentTags `json:"tags"`
	} `json:"contents"`
}

// EnvironmentReconfigureDeploymentsActionAction The action to take.
type EnvironmentReconfigureDeploymentsActionAction string

// EnvironmentServiceContainerSummary An object containing information about a service container associated with this environment.
type EnvironmentServiceContainerSummary struct {
	// AutoUpdate Whether or not the service will be automatically updated as new versions are released. Otherwise, the service will need to be restarted manually.
	AutoUpdate  *bool                                           `json:"auto_update,omitempty"`
	ContainerId *EnvironmentServiceContainerSummary_ContainerId `json:"container_id,omitempty"`

	// Enable Whether or not the service is enabled.
	Enable bool `json:"enable"`

	// HighAvailability Whether or not the service is deployed in high availability
	HighAvailability bool           `json:"high_availability"`
	State            ContainerState `json:"state"`
}

// EnvironmentServiceContainerSummaryContainerId1 defines model for .
type EnvironmentServiceContainerSummaryContainerId1 = string

// EnvironmentServiceContainerSummary_ContainerId defines model for EnvironmentServiceContainerSummary.ContainerId.
type EnvironmentServiceContainerSummary_ContainerId struct {
	union json.RawMessage
}

// EnvironmentServices Service containers run by this environment and their configurations.
type EnvironmentServices struct {
	Discovery    *EnvironmentServices_Discovery   `json:"discovery,omitempty"`
	Loadbalancer EnvironmentServices_Loadbalancer `json:"loadbalancer"`
	Scheduler    *EnvironmentServices_Scheduler   `json:"scheduler,omitempty"`
	Vpn          *EnvironmentServices_Vpn         `json:"vpn,omitempty"`
}

// EnvironmentServicesDiscovery1 defines model for .
type EnvironmentServicesDiscovery1 = map[string]interface{}

// EnvironmentServices_Discovery defines model for EnvironmentServices.Discovery.
type EnvironmentServices_Discovery struct {
	union json.RawMessage
}

// EnvironmentServicesLoadbalancer1 defines model for .
type EnvironmentServicesLoadbalancer1 = map[string]interface{}

// EnvironmentServices_Loadbalancer defines model for EnvironmentServices.Loadbalancer.
type EnvironmentServices_Loadbalancer struct {
	union json.RawMessage
}

// EnvironmentServicesScheduler1 defines model for .
type EnvironmentServicesScheduler1 = map[string]interface{}

// EnvironmentServices_Scheduler defines model for EnvironmentServices.Scheduler.
type EnvironmentServices_Scheduler struct {
	union json.RawMessage
}

// EnvironmentServicesVpn1 defines model for .
type EnvironmentServicesVpn1 = map[string]interface{}

// EnvironmentServices_Vpn defines model for EnvironmentServices.Vpn.
type EnvironmentServices_Vpn struct {
	union json.RawMessage
}

// EnvironmentStartAction A task to start an environment.
type EnvironmentStartAction struct {
	// Action The name of the action to perform.
	Action EnvironmentStartActionAction `json:"action"`
}

// EnvironmentStartActionAction The name of the action to perform.
type EnvironmentStartActionAction string

// EnvironmentState defines model for EnvironmentState.
type EnvironmentState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the environment.
	Current EnvironmentStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// EnvironmentStateCurrent The current state of the environment.
type EnvironmentStateCurrent string

// EnvironmentStopAction A task to stop an environment.
type EnvironmentStopAction struct {
	// Action The name of the action to perform.
	Action EnvironmentStopActionAction `json:"action"`
}

// EnvironmentStopActionAction The name of the action to perform.
type EnvironmentStopActionAction string

// EnvironmentSummary Contains useful and relevant data/statistics for an environment that would otherwise be several separate API calls.
type EnvironmentSummary struct {
	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Services An object containing information about the service containers associated with this container. Each key is the name of a service, one of `discovery`, `vpn`, or `loadbalancer`.
	Services struct {
		Discovery    *EnvironmentSummary_Services_Discovery    `json:"discovery,omitempty"`
		Loadbalancer *EnvironmentSummary_Services_Loadbalancer `json:"loadbalancer,omitempty"`
		Scheduler    *EnvironmentSummary_Services_Scheduler    `json:"scheduler,omitempty"`
		Vpn          *EnvironmentSummary_Services_Vpn          `json:"vpn,omitempty"`
	} `json:"services"`
	State EnvironmentState `json:"state"`

	// Stats Statistics about the containers and instances associated with this environment.
	Stats struct {
		// Containers A summary of resources by state
		Containers StateCountSummary `json:"containers"`

		// Instances A summary of resources by state
		Instances StateCountSummary `json:"instances"`
	} `json:"stats"`
}

// EnvironmentSummaryServicesDiscovery1 defines model for .
type EnvironmentSummaryServicesDiscovery1 = map[string]interface{}

// EnvironmentSummary_Services_Discovery defines model for EnvironmentSummary.Services.Discovery.
type EnvironmentSummary_Services_Discovery struct {
	union json.RawMessage
}

// EnvironmentSummaryServicesLoadbalancer1 defines model for .
type EnvironmentSummaryServicesLoadbalancer1 = map[string]interface{}

// EnvironmentSummary_Services_Loadbalancer defines model for EnvironmentSummary.Services.Loadbalancer.
type EnvironmentSummary_Services_Loadbalancer struct {
	union json.RawMessage
}

// EnvironmentSummaryServicesScheduler1 defines model for .
type EnvironmentSummaryServicesScheduler1 = map[string]interface{}

// EnvironmentSummary_Services_Scheduler defines model for EnvironmentSummary.Services.Scheduler.
type EnvironmentSummary_Services_Scheduler struct {
	union json.RawMessage
}

// EnvironmentSummaryServicesVpn1 defines model for .
type EnvironmentSummaryServicesVpn1 = map[string]interface{}

// EnvironmentSummary_Services_Vpn defines model for EnvironmentSummary.Services.Vpn.
type EnvironmentSummary_Services_Vpn struct {
	union json.RawMessage
}

// Error The Cycle API uses standard HTTP response codes to indicate the success or failure of an API request. Codes in the `2xx` range indicate success. Codes in the `4xx` range indicate a request that failed due to input, and codes in the `5xx` range indicate an error on Cycle's part (rare).
// There are two types of error response objects. Errors with authentication are formatted to follow the OAuth spec, while all other errors follow the same convention. If you're using one of our API Libraries, they will standardize OAuth errors to fit the general convention.
type Error struct {
	// Code A Cycle standard error code.
	Code *ErrorCode `json:"code,omitempty"`

	// Detail A more detailed description of the error.
	Detail *string `json:"detail,omitempty"`

	// Extra Additional entries on the error object to provide extra details.
	Extra *struct {
		// Capability A capability that a user or API key that represents what an API key or a user can do.
		Capability *Capability `json:"capability,omitempty"`
	} `json:"extra,omitempty"`

	// Source A [JSON pointer](https://tools.ietf.org/html/rfc6901/) describing the source of an error.
	Source *string `json:"source,omitempty"`

	// Status The HTTP response code.
	Status *ErrorStatus `json:"status,omitempty"`

	// Title The main text describing the error.
	Title *string `json:"title,omitempty"`
}

// ErrorCode A Cycle standard error code.
type ErrorCode string

// ErrorStatus The HTTP response code.
type ErrorStatus int

// ErrorEnvelope An error response.
type ErrorEnvelope struct {
	Data *map[string]interface{} `json:"data"`

	// Error The Cycle API uses standard HTTP response codes to indicate the success or failure of an API request. Codes in the `2xx` range indicate success. Codes in the `4xx` range indicate a request that failed due to input, and codes in the `5xx` range indicate an error on Cycle's part (rare).
	// There are two types of error response objects. Errors with authentication are formatted to follow the OAuth spec, while all other errors follow the same convention. If you're using one of our API Libraries, they will standardize OAuth errors to fit the general convention.
	Error Error `json:"error"`
}

// Events Describes the date and time at which certain events occurred in the lifetime of this resource.
type Events map[string]DateTime

// ExistingSource In a stack, specifies an image source ID from which Cycle will derive any values not specified in the stack file. This is useful for avoiding direct placement of credentials in a stack file, for example.
type ExistingSource struct {
	// SourceId A 24 character hex string used to identify a unique resource.
	SourceId *ID `json:"source_id,omitempty"`
}

// HaProxyConfig Describes settings that are passed to HAProxy within the load balancer.
type HaProxyConfig struct {
	Default HaProxyConfigSet `json:"default"`

	// Ports An object that defines how HAProxy will act on a specific port. The key is a custom port, and the value is the same settings object found under `default` above.
	Ports map[string]HaProxyConfigSet `json:"ports"`
}

// HaProxyConfigSet defines model for HaProxyConfigSet.
type HaProxyConfigSet struct {
	// Backend Settings related to how the load balancer routes connections to container instances.
	Backend struct {
		// Balance How connections are balanced across your container instances. Can be one of the following:
		//  - `roundrobin`: Each container instance is used in turns.
		//  - `static-rr`: Each container instance is used in turns, but is faster than Round Robin at the expense of being less dynamic.
		//  - `leastconn`: Routes traffic to the instance with the least number of active connections.
		//  - `first`: Routes traffic to the first available instance.
		//  - `source`: The same client IP always reaches the same container instance as long as no instance goes down or up.
		Balance HaProxyConfigSetBackendBalance `json:"balance"`

		// Timeouts Various options for handling timeouts when communicating with a container instance behind the load balancer.
		Timeouts *struct {
			// ConnectMs The number of milliseconds the load balancer will wait for a successful connection to a container instance. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4-timeout%20connect) for more information.
			ConnectMs *int `json:"connect_ms"`

			// QueueMs The number of milliseconds the load balancer will hold connections in a queue when the maximum number of connections has been reached. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4-timeout%20queue) for more information.
			QueueMs *int `json:"queue_ms"`

			// ServerFinMs The number of milliseconds the load balancer will wait for the server to send data when one direction is already closed. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4-timeout%20server-fin) for more information.
			ServerFinMs *int `json:"server_fin_ms"`

			// ServerSecs The number of seconds the load balancer will wait for a response from the container instance. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4.2-timeout%20server) for more information.
			ServerSecs *int `json:"server_secs"`

			// TunnelSecs The number of milliseconds the load balancer will allow for inactivity on a bidirectional tunnel. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4-timeout%20tunnel) for more information.
			TunnelSecs *int `json:"tunnel_secs"`
		} `json:"timeouts"`
	} `json:"backend"`

	// Frontend Settings that describe how incoming traffic to the load balancer is handled.
	Frontend struct {
		// MaxConnections The number of simultaneous connections that can be processed at a time.
		MaxConnections *int `json:"max_connections"`

		// Mode The type of traffic expected by the load balancer for this port. Can be either:
		//  - tcp: Traffic is forwarded without any parsing or additional manipulation.
		//  - http: Traffic is treated as web traffic. If a LINKED record is configured for a container exposing this port, the domain will be parsed and it will be forwarded to the proper container. This allows multiple services to run on port 80 in the same environment.
		Mode HaProxyConfigSetFrontendMode `json:"mode"`

		// Timeouts Various options for handling timeouts when communicating with the client.
		Timeouts *struct {
			// ClientFinMs The number of milliseconds the load balancer will wait for a client to send it data when one direction is already closed. This is particularly useful to avoid keeping connections in a waiting state for too long when clients do not disconnect cleanly.
			ClientFinMs *int `json:"client_fin_ms"`

			// ClientSecs The number of seconds the load balancer will wait for a response from a client before disconnecting.
			ClientSecs *int `json:"client_secs"`

			// HttpKeepAliveMs The number of milliseconds the load balancer will wait for a new HTTP request to start coming after a response was set. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4.2-timeout%20http-request) for more information. (`http` mode only)
			HttpKeepAliveMs *int `json:"http_keep_alive_ms"`

			// HttpRequestMs The number of milliseconds the load balancer will wait for a complete HTTP request. See the [HAProxy Docs](https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4.2-timeout%20http-request) for more information. (`http` mode only)
			HttpRequestMs *int `json:"http_request_ms"`
		} `json:"timeouts"`
	} `json:"frontend"`
}

// HaProxyConfigSetBackendBalance How connections are balanced across your container instances. Can be one of the following:
//   - `roundrobin`: Each container instance is used in turns.
//   - `static-rr`: Each container instance is used in turns, but is faster than Round Robin at the expense of being less dynamic.
//   - `leastconn`: Routes traffic to the instance with the least number of active connections.
//   - `first`: Routes traffic to the first available instance.
//   - `source`: The same client IP always reaches the same container instance as long as no instance goes down or up.
type HaProxyConfigSetBackendBalance string

// HaProxyConfigSetFrontendMode The type of traffic expected by the load balancer for this port. Can be either:
//   - tcp: Traffic is forwarded without any parsing or additional manipulation.
//   - http: Traffic is treated as web traffic. If a LINKED record is configured for a container exposing this port, the domain will be parsed and it will be forwarded to the proper container. This allows multiple services to run on port 80 in the same environment.
type HaProxyConfigSetFrontendMode string

// HaProxyLbType defines model for HaProxyLbType.
type HaProxyLbType struct {
	// BindHost Binds the load balancer to the host server IP address.
	//
	// **Pros**: This allows for significantly lower cost (utilizing fewer IPv4 addresses), and enables building out a true edge network with lower latency.
	// **Cons**: Only 1 environment is allowed on the host. This is because the load balancer is the only ingress point for an environment, and if it is sharing
	// the same IP as the host, that host can only operate under that environment.
	BindHost *bool                 `json:"bind_host"`
	Details  HaProxyLbType_Details `json:"details"`

	// Ipv4 Allow / disallow traffic to be routed via IPv4.
	Ipv4 bool `json:"ipv4"`

	// Ipv6 Allow / disallow traffic to be routed via IPv6.
	Ipv6 bool              `json:"ipv6"`
	Type HaProxyLbTypeType `json:"type"`
}

// HaProxyLbTypeDetails1 defines model for .
type HaProxyLbTypeDetails1 = map[string]interface{}

// HaProxyLbType_Details defines model for HaProxyLbType.Details.
type HaProxyLbType_Details struct {
	union json.RawMessage
}

// HaProxyLbTypeType defines model for HaProxyLbType.Type.
type HaProxyLbTypeType string

// HttpRouterConfig Additional configuration options for HTTP mode routers.
type HttpRouterConfig struct {
	Details struct {
		Caching *struct {
			Files *[]struct {
				// Match Regex string that describes the files to cache.
				Match string `json:"match"`

				// Ttl A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
				Ttl Duration `json:"ttl"`
			} `json:"files"`
		} `json:"caching"`
		Forward *struct {
			// ContentMod Allows the load balancer to modify content before it reaches the user.
			ContentMod *struct {
				// Replace An array that describes a list of replacement match/value pairs.
				Replace *[]struct {
					// Match String that will be replaced.
					Match string `json:"match"`

					// Value Replacement value.
					Value string `json:"value"`
				} `json:"replace"`
			} `json:"content_mod"`
			Scheme *string `json:"scheme"`

			// Url The URL to forward the request to.
			//
			// Given a path match of `^/example/(.*)$`, a route such as `/example/wow.jpg` would be forwarded as /wow.jpg.
			Url *string `json:"url,omitempty"`
		} `json:"forward"`
		Proxy *struct {
			// ContentMod Allows the load balancer to modify content before it reaches the user.
			ContentMod *struct {
				// Replace An array that describes a list of replacement match/value pairs.
				Replace *[]struct {
					// Match String that will be replaced.
					Match string `json:"match"`

					// Value Replacement value.
					Value string `json:"value"`
				} `json:"replace"`
			} `json:"content_mod"`

			// Domain The proxy domain for this router.
			Domain *string `json:"domain"`
		} `json:"proxy"`

		// Redirect Defines a built-in redirect for HTTP mode routers
		Redirect *struct {
			// AutoHttpsRedirect If enabled and a sibling controller exists for port 443, requests will be auto redirected to it. Essentially sets up automatic TLS redirection for this router.
			AutoHttpsRedirect bool `json:"auto_https_redirect"`

			// Port The port to redirect traffic to.
			Port *int `json:"port"`

			// RemoveWww If true, any request comes in with "www" prefix will be permanently redirected to the same path without www.
			RemoveWww bool `json:"remove_www"`

			// Scheme The scheme to redirect to. (i.e. `https`)
			Scheme *string `json:"scheme"`

			// Url A specific URL to redirect to.
			Url *string `json:"url"`
		} `json:"redirect"`
	} `json:"details"`
	Type HttpRouterConfigType `json:"type"`
}

// HttpRouterConfigType defines model for HttpRouterConfig.Type.
type HttpRouterConfigType string

// HttpTransportConfig Additional configuration options for the HTTP transport mode.
type HttpTransportConfig struct {
	Details struct {
		// Connections Defines extra configuration options connections to the load balancer
		Connections struct {
			// MaxIdleConnsPerConnection Maximum number of simultaneous connections (via http/2) per connection.
			MaxIdleConnsPerConnection *int `json:"max_idle_conns_per_connection"`
		} `json:"connections"`

		// Telemetry Configuration options for how telemetry is handled.
		Telemetry struct {
			// IgnorePaths An array of paths to exclude from tracking.
			IgnorePaths *[]string `json:"ignore_paths"`

			// MaxTrackableUrls Determines how many URLs the load balancer will track at one time. Defaults to 150.
			MaxTrackableUrls *int `json:"max_trackable_urls"`

			// TrackInvalidRequests Whether or not to track invalid requests. An invalid request is a request that came in that no router existed for. Usually this means bot requests. Defaults to false.
			TrackInvalidRequests *bool `json:"track_invalid_requests"`
		} `json:"telemetry"`
	} `json:"details"`
	Type HttpTransportConfigType `json:"type"`
}

// HttpTransportConfigType defines model for HttpTransportConfig.Type.
type HttpTransportConfigType string

// HubID The unique ID of the Hub this resource was created in.
type HubID = string

// HybridIdentifier Either a resource ID (objectid - i.e. 651586fca6078e98982dbd90) or a resource Identifier (human-readable)
type HybridIdentifier = string

// ID A 24 character hex string used to identify a unique resource.
type ID = string

// IPNet defines model for IPNet.
type IPNet struct {
	// Cidr The CIDR notation, describing the range of IP addresses.
	Cidr string `json:"cidr"`

	// Ip The IP address.
	Ip string `json:"ip"`
}

// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
// have the identifier of `my-container` and is automatically created by the platform.
//
// The identifier does not have to be unique.
type Identifier = string

// Job A job resource.
type Job struct {
	// Caption A short description of the job.
	Caption string `json:"caption"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the job's lifetime.
	Events struct {
		Completed DateTime `json:"completed"`
		Queued    DateTime `json:"queued"`
		Started   DateTime `json:"started"`
	} `json:"events"`
	Expires DateTime `json:"expires"`

	// Hash A combination of the individual task details and job details.
	Hash string `json:"hash"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// LimitDuplicates A boolean where true represents the job is set to prevent duplicates of itself quickly after creation.
	LimitDuplicates bool `json:"limit_duplicates"`

	// Queue A dash separated string showing the environment_id where the job is taking place.
	Queue    string   `json:"queue"`
	Schedule DateTime `json:"schedule"`
	State    JobState `json:"state"`

	// Tasks An array of job tasks.
	Tasks []JobTask `json:"tasks"`
}

// JobDescriptor A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
type JobDescriptor struct {
	// Action The action that was taken.
	Action string `json:"action"`

	// Job Contains some basic information about the job associated with this task.
	Job *struct {
		// Accepted Describes if the job has been accepted
		Accepted bool `json:"accepted"`

		// Id The ID of the job
		Id       string `json:"id"`
		Parallel struct {
			SubQueue *string `json:"sub_queue"`
			Tasks    bool    `json:"tasks"`
		} `json:"parallel"`

		// Queue Describes the queue this job is a part of.
		Queue    string   `json:"queue"`
		Schedule DateTime `json:"schedule"`
		Tasks    *[]struct {
			// Caption A short description of the task.
			Caption string `json:"caption"`

			// Header The API function called.
			Header string `json:"header"`

			// Input Input information used for the job tasks.
			Input map[string]interface{} `json:"input"`

			// Steps An array of job task steps.
			Steps *[]TaskStep `json:"steps"`
		} `json:"tasks"`
	} `json:"job,omitempty"`
}

// JobIncludes defines model for JobIncludes.
type JobIncludes struct {
	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`
}

// JobState defines model for JobState.
type JobState struct {
	Changed *DateTime `json:"changed,omitempty"`

	// Current The current state of the job.
	Current JobStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this job.
	Error *struct {
		// Message Details about the error that has occurred.
		Message string `json:"message"`
	} `json:"error"`
}

// JobStateCurrent The current state of the job.
type JobStateCurrent string

// JobTask Information about a job task.
type JobTask struct {
	// Caption A short description of the task.
	Caption string `json:"caption"`

	// Error An error object describing issues with the job.
	Error *struct {
		// Message An error message
		Message string `json:"message"`
	} `json:"error"`

	// Events A collection of timestamps for each event in the job's lifetime.
	Events struct {
		Completed DateTime `json:"completed"`
		Queued    DateTime `json:"queued"`
		Started   DateTime `json:"started"`
	} `json:"events"`

	// Header The API function called.
	Header string `json:"header"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Input Input information used for the job tasks.
	Input map[string]interface{} `json:"input"`

	// Output Output informaiton used for the job tasks.
	Output *map[string]string `json:"output"`
	State  TaskState          `json:"state"`

	// Steps An array of job task steps.
	Steps *[]TaskStep `json:"steps"`
}

// LegacyNetwork Legacy network information for an Environment.
type LegacyNetwork struct {
	// Ipv4 IPv4 information available from environments using legacy networking.
	Ipv4 *LegacyNetwork_Ipv4 `json:"ipv4,omitempty"`

	// Subnet The IPv4 subnet Id.
	Subnet int `json:"subnet"`
}

// LegacyNetworkIpv41 defines model for .
type LegacyNetworkIpv41 = map[string]interface{}

// LegacyNetwork_Ipv4 IPv4 information available from environments using legacy networking.
type LegacyNetwork_Ipv4 struct {
	union json.RawMessage
}

// LoadBalancerConfig The config object for the loadbalancer service.
type LoadBalancerConfig struct {
	union json.RawMessage
}

// LoadBalancerEnvironmentService Information about the environments loadbalancer service(s).
type LoadBalancerEnvironmentService struct {
	// AutoUpdate A boolean representing if this service container is set to autoupdate or not
	AutoUpdate *bool                                 `json:"auto_update,omitempty"`
	Config     LoadBalancerEnvironmentService_Config `json:"config"`

	// ContainerId The ID of the loadbalancer service container
	ContainerId *string `json:"container_id"`

	// Enable Whether or not the loadbalancer service is enabled.
	Enable bool `json:"enable"`

	// HighAvailability A boolean representing if this service container is set to high availability mode or not.
	HighAvailability bool `json:"high_availability"`
}

// LoadBalancerEnvironmentServiceConfig1 defines model for .
type LoadBalancerEnvironmentServiceConfig1 = map[string]interface{}

// LoadBalancerEnvironmentService_Config defines model for LoadBalancerEnvironmentService.Config.
type LoadBalancerEnvironmentService_Config struct {
	union json.RawMessage
}

// MonitoringTierDetails Detailed information about a monitoring tier's features.
type MonitoringTierDetails struct {
	// CostMills The monthly cost (in mills) of enabling this tier on an environment.
	CostMills int `json:"cost_mills"`

	// Enabled Whether or not this tier is a selectable monitoring tier for an environment. A disabled tier may be either one coming in the future, or a legacy tier that is no longer available, but saved for historical reasons.
	Enabled bool `json:"enabled"`

	// Events Details on how events are handled for this tier.
	Events struct {
		// Custom Whether or not custom user-submitted events are supported on this tier.
		Custom bool `json:"custom"`

		// RetentionPeriod A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
		RetentionPeriod Duration `json:"retention_period"`
	} `json:"events"`

	// Logs Details on how logs are handled for this tier.
	Logs struct {
		// Aggregation Whether or not log aggregation is enabled on this tier.
		Aggregation bool `json:"aggregation"`

		// Analysis Whether or not log analysis is enabled on this tier.
		Analysis bool `json:"analysis"`

		// Custom Whether or not custom user-submitted logs are supported on this tier.
		Custom bool `json:"custom"`
	} `json:"logs"`

	// Metrics Details on how metrics are handled for this tier.
	Metrics struct {
		// ContainerTelemetryGranularity A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
		ContainerTelemetryGranularity Duration `json:"container_telemetry_granularity"`

		// Custom Whether or not custom user-submitted metrics are supported on this tier.
		Custom bool `json:"custom"`

		// DownsamplePeriod A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
		DownsamplePeriod Duration `json:"downsample_period"`

		// RetentionPeriod A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
		RetentionPeriod Duration `json:"retention_period"`

		// ServiceGranularity A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
		ServiceGranularity Duration `json:"service_granularity"`
	} `json:"metrics"`

	// TrackingInterval A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
	TrackingInterval Duration `json:"tracking_interval"`
}

// OciRegistryOrigin An image origin that pulls images fro an OCI-compatible registry. Also used for provider-native registries, such as AWS ECR.
type OciRegistryOrigin struct {
	Details struct {
		// Auth Authentication details for a third party image registry/source.
		Auth *RegistryAuth `json:"auth,omitempty"`

		// Existing In a stack, specifies an image source ID from which Cycle will derive any values not specified in the stack file. This is useful for avoiding direct placement of credentials in a stack file, for example.
		Existing *ExistingSource `json:"existing,omitempty"`

		// Target The image name on the registry.
		Target string `json:"target"`

		// Url The url of the remote registry.
		Url string `json:"url"`
	} `json:"details"`
	Type OciRegistryOriginType `json:"type"`
}

// OciRegistryOriginType defines model for OciRegistryOrigin.Type.
type OciRegistryOriginType string

// Permissions Permissions information for an API Key
type Permissions struct {
	// AllEnvironments A boolean, where true represents this API key is authorized to make requests that involve all of a hubs environments
	AllEnvironments bool `json:"all_environments"`

	// Environments An environment ID and a boolean representing management configuration for an API key
	Environments []struct {
		// Id A 24 character hex string used to identify a unique resource.
		Id ID `json:"id"`

		// Manage A boolean, where true represents the API keys ability to make changes to the environment components
		Manage bool `json:"manage"`
	} `json:"environments"`
}

// PrivateNetwork defines model for PrivateNetwork.
type PrivateNetwork struct {
	Ipv6 struct {
		// Cidr The CIDR notation, describing the range of IP addresses.
		Cidr string `json:"cidr"`

		// Ip The IP address.
		Ip string `json:"ip"`
	} `json:"ipv6"`
	Legacy PrivateNetwork_Legacy `json:"legacy"`

	// Subnet The subnet ID.
	Subnet string `json:"subnet"`

	// VxlanTag The vxlan tag added to each packet to help identify the network.
	VxlanTag int `json:"vxlan_tag"`
}

// PrivateNetworkLegacy1 defines model for .
type PrivateNetworkLegacy1 = map[string]interface{}

// PrivateNetwork_Legacy defines model for PrivateNetwork.Legacy.
type PrivateNetwork_Legacy struct {
	union json.RawMessage
}

// PublicAccount Publicly available information about an account
type PublicAccount struct {
	// Email Email information for an account
	Email struct {
		// Address The email address associated with the account.
		Address string `json:"address"`
	} `json:"email"`
	Events *PublicAccount_Events `json:"events,omitempty"`

	// Id Id information for an account
	Id string `json:"id"`

	// Name The first and last name of an account owner
	Name struct {
		// First The first name of the account owner
		First string `json:"first"`

		// Last The last name of the account owner
		Last string `json:"last"`
	} `json:"name"`
}

// PublicAccount_Events defines model for PublicAccount.Events.
type PublicAccount_Events struct {
	LastLogin            *DateTime           `json:"last_login,omitempty"`
	AdditionalProperties map[string]DateTime `json:"-"`
}

// RegistryAuth Authentication details for a third party image registry/source.
type RegistryAuth struct {
	union json.RawMessage
}

// RegistryAuthProvider Credentials for authentication to a provider-native image registry, such as AWS ECR.
type RegistryAuthProvider struct {
	Details struct {
		Credentials struct {
			ApiKey   *string `json:"api_key,omitempty"`
			ClientId *string `json:"client_id,omitempty"`

			// Config A base64'd string of additional configuration options.
			Config         *string `json:"config,omitempty"`
			Namespace      *string `json:"namespace,omitempty"`
			Region         *string `json:"region,omitempty"`
			Secret         *string `json:"secret,omitempty"`
			SubscriptionId *string `json:"subscription_id,omitempty"`
		} `json:"credentials"`
		Flavor RegistryAuthProviderDetailsFlavor `json:"flavor"`
	} `json:"details"`
	Type RegistryAuthProviderType `json:"type"`
}

// RegistryAuthProviderDetailsFlavor defines model for RegistryAuthProvider.Details.Flavor.
type RegistryAuthProviderDetailsFlavor string

// RegistryAuthProviderType defines model for RegistryAuthProvider.Type.
type RegistryAuthProviderType string

// RegistryAuthUser User/token based credentials for authentication to a third-party image source.
type RegistryAuthUser struct {
	Details struct {
		Token    *string `json:"token,omitempty"`
		Username *string `json:"username,omitempty"`
	} `json:"details"`
	Type RegistryAuthUserType `json:"type"`
}

// RegistryAuthUserType defines model for RegistryAuthUser.Type.
type RegistryAuthUserType string

// RegistryAuthWebhook Webhook-based authentication to the provided URL. This webhook expects to receive a base-64 string that when decoded is in the format `username:password`
type RegistryAuthWebhook struct {
	Details struct {
		Url string `json:"url"`
	} `json:"details"`
	Type RegistryAuthWebhookType `json:"type"`
}

// RegistryAuthWebhookType defines model for RegistryAuthWebhook.Type.
type RegistryAuthWebhookType string

// RepoType Information about the repository.
type RepoType struct {
	Auth *RepoType_Auth `json:"auth,omitempty"`

	// Branch An optional branch arguement.  Default value is `master`.
	Branch *string `json:"branch,omitempty"`

	// Ref Repository reference information.
	Ref *struct {
		// Type The type of reference being used.
		Type string `json:"type"`

		// Value The value for the given reference type.
		Value string `json:"value"`
	} `json:"ref"`

	// Url The URL of the repository.
	Url string `json:"url"`
}

// RepoTypeAuth0 defines model for .
type RepoTypeAuth0 = map[string]interface{}

// RepoTypeAuth1 Authentication information for the repository.
type RepoTypeAuth1 struct {
	union json.RawMessage
}

// RepoType_Auth defines model for RepoType.Auth.
type RepoType_Auth struct {
	union json.RawMessage
}

// SchedulerAccessKey Custom authorization keys for the scheduler service.
type SchedulerAccessKey struct {
	// Ips Whitelisted IPs that are allowed to make requests to the scheduler service.
	Ips *[]string `json:"ips,omitempty"`

	// Name The name given to this access key
	Name string `json:"name"`

	// Secret The access key secret. This should be submitted with requests to a publicly accessible scheduler service.
	Secret string `json:"secret"`
}

// SchedulerConfig Configuration options for the scheduler Environment service.
type SchedulerConfig struct {
	AccessKeys *[]SchedulerAccessKey `json:"access_keys,omitempty"`

	// Public If true, this scheduler will be accessible over the public internet. It will enable a LINKED record to be pointed to the scheduler container, and inbound requests to trigger function containers.
	Public bool `json:"public"`
}

// SchedulerEnvironmentService Information about the environments scheduler service. The scheduler is used by containers with a function deployment strategy to route requests to the correct instances.
type SchedulerEnvironmentService struct {
	// AutoUpdate A boolean where `true` represents the desire to automatically update the environment scheduler service.
	AutoUpdate *bool                               `json:"auto_update,omitempty"`
	Config     *SchedulerEnvironmentService_Config `json:"config,omitempty"`

	// ContainerId The ID of the scheduler service container.
	ContainerId *string `json:"container_id"`

	// Enable Whether or not the scheduler service is enabled.
	Enable bool `json:"enable"`

	// HighAvailability A boolean representing if the scheduler service container is set to high availability. mode or not. As of Jan 2024, this will always be false because HA is not availiable for the scheduler service.
	HighAvailability *bool `json:"high_availability,omitempty"`
}

// SchedulerEnvironmentServiceConfig1 defines model for .
type SchedulerEnvironmentServiceConfig1 = map[string]interface{}

// SchedulerEnvironmentService_Config defines model for SchedulerEnvironmentService.Config.
type SchedulerEnvironmentService_Config struct {
	union json.RawMessage
}

// StackContainer A container template defined within a stack.
type StackContainer struct {
	// Annotations Additional user-provided meta data about the container.
	Annotations *map[string]interface{} `json:"annotations"`

	// Config Configuration options for this container that will be applied when deployed as part of the stack.
	Config struct {
		// Deploy Stack configuration options related to how the container behaves over its lifecycle (startup, shutdown, health checks, etc).
		Deploy       StackContainerConfigDeploy          `json:"deploy"`
		Integrations *StackContainer_Config_Integrations `json:"integrations,omitempty"`

		// Network Stack configuration options related to the container's network.
		Network   StackContainerConfigNetwork      `json:"network"`
		Resources *StackContainer_Config_Resources `json:"resources,omitempty"`
		Runtime   *StackContainer_Config_Runtime   `json:"runtime,omitempty"`

		// Scaling Configuration options for auto-scaling.
		Scaling *StackContainer_Config_Scaling `json:"scaling,omitempty"`
	} `json:"config"`

	// Deprecate If true, the container is marked as `deprecated`, and cannot be started anymore. Deprecated containers also don't count toward resource utilization.
	Deprecate *bool                   `json:"deprecate,omitempty"`
	Image     StackSpecContainerImage `json:"image"`

	// Lock If true, the container is marked as `locked` and cannot be deleted in any way until the lock is lifted.
	Lock *bool `json:"lock,omitempty"`

	// Name The human-readable name of this container.
	Name string `json:"name"`

	// Role The role applied to this container. **Not yet implemented**
	Role *StackContainerRole `json:"role"`

	// Stateful Whether or not to mark the container as stateful when deployed. Stateful containers can utilize volumes (stateful data) and are generally used for running databases or other data management applications.
	Stateful bool `json:"stateful"`

	// Volumes A list of configurations for volumes that will be attached to the container. Only applicable if the container is set to `stateful`.
	Volumes *[]StackContainerVolume `json:"volumes"`
}

// StackContainerConfigIntegrations1 defines model for .
type StackContainerConfigIntegrations1 = map[string]interface{}

// StackContainer_Config_Integrations defines model for StackContainer.Config.Integrations.
type StackContainer_Config_Integrations struct {
	union json.RawMessage
}

// StackContainerConfigResources1 defines model for .
type StackContainerConfigResources1 = map[string]interface{}

// StackContainer_Config_Resources defines model for StackContainer.Config.Resources.
type StackContainer_Config_Resources struct {
	union json.RawMessage
}

// StackContainerConfigRuntime1 defines model for .
type StackContainerConfigRuntime1 = map[string]interface{}

// StackContainer_Config_Runtime defines model for StackContainer.Config.Runtime.
type StackContainer_Config_Runtime struct {
	union json.RawMessage
}

// StackContainerConfigScaling1 defines model for .
type StackContainerConfigScaling1 = map[string]interface{}

// StackContainer_Config_Scaling Configuration options for auto-scaling.
type StackContainer_Config_Scaling struct {
	union json.RawMessage
}

// StackContainerRole The role applied to this container. **Not yet implemented**
type StackContainerRole string

// StackContainerConfigDeploy Stack configuration options related to how the container behaves over its lifecycle (startup, shutdown, health checks, etc).
type StackContainerConfigDeploy struct {
	// Constraints Configuration options that provide the ability to set restrictions on which nodes instances of this container are able to be deployed to. (i.e. if you have a GPU container, it should only go on nodes with a GPU).
	Constraints *struct {
		Node *struct {
			// Tags Tags applied to a node. Cycle generates some automatically, but additional, custom tags can be applied on a per-node basis.
			Tags struct {
				// All A node must have **ALL** of these tags to be considered a valid deployment target for this container.
				All *[]string `json:"all,omitempty"`

				// Any If a node has at least one of these tags, it is considered a valid deployment target for this container.
				Any *[]string `json:"any,omitempty"`
			} `json:"tags"`
		} `json:"node"`
	} `json:"constraints"`

	// Function Configuration options for containers using the 'function' deployment strategy.
	Function *struct {
		// MaxPoolSize The maximum number of instances that Cycle can pre-allocate (includes auto-scaled instances).
		MaxPoolSize *int `json:"max_pool_size"`

		// MaxQueueTime The maximum amount of time Cycle will wait for an instance to be available.
		MaxQueueTime *StackContainerConfigDeploy_Function_MaxQueueTime `json:"max_queue_time,omitempty"`

		// MaxRuntime The maximum amount of time a function instance can run before timing out.
		MaxRuntime *StackContainerConfigDeploy_Function_MaxRuntime `json:"max_runtime,omitempty"`

		// MaxShardConcurrency For each shard (scheduler), the maximum number of tasks it can run in parallel.
		MaxShardConcurrency *int `json:"max_shard_concurrency"`
	} `json:"function"`

	// HealthCheck Configuration options for automated container health checks.
	HealthCheck *struct {
		// Command The command or script to run to verify the health of the container. This script is run inside the container by Cycle.
		// This command accepts two types of entries:
		// - The first is a reference to a script that already lives in the container filesystem. This can be defined by giving the full path to the script as the value.   - The second format is an inline script.  If you need the code to execute within a shell, wrap the commands in escaped quotes like this `"\"curl -s -o /dev/console -w \"%{http_code}\" http://localhost:3000/_health | grep '200'  && exit 0 || exit 1\""`.  Do not use the `/bin/sh -c <commands>` format, this will not be accepted.
		Command string `json:"command"`

		// Delay How long to wait after a container start event before running health checks.
		Delay *StackContainerConfigDeploy_HealthCheck_Delay `json:"delay,omitempty"`

		// Interval A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
		Interval Duration `json:"interval"`

		// Restart A boolean where true represents the desire for the container to restart if any instance is unhealthy.
		Restart bool `json:"restart"`

		// Retries The number of times to retry the command before marking an instance unhealthy.
		Retries int `json:"retries"`

		// Timeout A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
		Timeout Duration `json:"timeout"`
	} `json:"health_check"`

	// Instances The number of desired instances to deploy.
	Instances int `json:"instances"`

	// Restart Configuration options for how Cycle should handle restarting this container (i.e. in case the process inside the container dies).
	Restart *struct {
		// Condition Under what circumstances Cycle should try to restart this container.
		Condition StackContainerConfigDeployRestartCondition `json:"condition"`

		// Delay A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
		Delay Duration `json:"delay"`

		// MaxAttempts The maximum number of restart attempts Cycle will make.
		MaxAttempts int `json:"max_attempts"`
	} `json:"restart"`

	// Shutdown Configuration options for how this container behaves during shutdown.
	Shutdown *struct {
		// GracefulTimeout How long the platform will wait for a container to stop gracefully.
		GracefulTimeout *StackContainerConfigDeploy_Shutdown_GracefulTimeout `json:"graceful_timeout,omitempty"`

		// Signals Signals that should be sent to the container on shutdown.
		Signals *[]StackContainerConfigDeployShutdownSignals `json:"signals,omitempty"`
	} `json:"shutdown"`

	// Startup Configuration options for how this container behaves during startup.
	Startup *struct {
		// Delay How long the platform will wait before sending the start signal to the given container.
		Delay *StackContainerConfigDeploy_Startup_Delay `json:"delay,omitempty"`
	} `json:"startup"`

	// Stateful Configuration options for stateful containers.
	Stateful *struct {
		// Options Stateful container options.
		Options *struct {
			// UseBaseHostname When enabled, instances will utilize stateless base hostnames instead of being prefixed with a unique ID.
			UseBaseHostname *bool `json:"use_base_hostname"`
		} `json:"options"`
	} `json:"stateful"`

	// Strategy The strategy Cycle will apply when deploying instances of this container.
	// - ** resource-density **: Cycle will distribute instances across servers to maintain balanced resource usage. - ** high-availability **: Cycle will deploy instances over servers with an emphasis on geographic and physical separation - ** first-available **: Cycle will deploy one instance to every node that matches the specified criteria. (default) - ** node **: Cycle will deploy one instance to every node that matches the specified criteria. - ** edge **: Cycle will prioritize geographic distribution of instances. - ** function **: Every ingress request/connection receives its own instance.  - ** manual **: Cycle will not make any decisions on where instances are deployed. Instead, instances must be deployed manually using the portal or API.
	Strategy *StackContainerConfigDeployStrategy `json:"strategy"`

	// Telemetry Configuration options for how the instance telemetry (CPU usage, etc) is handled.
	Telemetry *struct {
		// Disable If true, Cycle will not aggregate telemetry for this container's instances.
		Disable bool `json:"disable"`

		// Interval The duration between samples.
		Interval *StackContainerConfigDeploy_Telemetry_Interval `json:"interval,omitempty"`

		// Retention How long telemetry data should be retained.
		Retention *StackContainerConfigDeploy_Telemetry_Retention `json:"retention,omitempty"`

		// Webhook A URL where Cycle will send telemetry data to. The payload will be an instance resource snapshot.
		Webhook *string `json:"webhook"`
	} `json:"telemetry"`

	// Update Configurations for how the container behaves during updates.
	Update *struct {
		// Stagger When set, Cycle will pick a random time from `0 - this duration`, and stagger the instances so they all start at different times (up to the time specified here).
		Stagger *StackContainerConfigDeploy_Update_Stagger `json:"stagger,omitempty"`
	} `json:"update"`
}

// StackContainerConfigDeployFunctionMaxQueueTime1 defines model for .
type StackContainerConfigDeployFunctionMaxQueueTime1 = string

// StackContainerConfigDeploy_Function_MaxQueueTime The maximum amount of time Cycle will wait for an instance to be available.
type StackContainerConfigDeploy_Function_MaxQueueTime struct {
	union json.RawMessage
}

// StackContainerConfigDeployFunctionMaxRuntime1 defines model for .
type StackContainerConfigDeployFunctionMaxRuntime1 = string

// StackContainerConfigDeploy_Function_MaxRuntime The maximum amount of time a function instance can run before timing out.
type StackContainerConfigDeploy_Function_MaxRuntime struct {
	union json.RawMessage
}

// StackContainerConfigDeployHealthCheckDelay1 defines model for .
type StackContainerConfigDeployHealthCheckDelay1 = string

// StackContainerConfigDeploy_HealthCheck_Delay How long to wait after a container start event before running health checks.
type StackContainerConfigDeploy_HealthCheck_Delay struct {
	union json.RawMessage
}

// StackContainerConfigDeployRestartCondition Under what circumstances Cycle should try to restart this container.
type StackContainerConfigDeployRestartCondition string

// StackContainerConfigDeployShutdownGracefulTimeout1 defines model for .
type StackContainerConfigDeployShutdownGracefulTimeout1 = string

// StackContainerConfigDeploy_Shutdown_GracefulTimeout How long the platform will wait for a container to stop gracefully.
type StackContainerConfigDeploy_Shutdown_GracefulTimeout struct {
	union json.RawMessage
}

// StackContainerConfigDeployShutdownSignals defines model for StackContainerConfigDeploy.Shutdown.Signals.
type StackContainerConfigDeployShutdownSignals string

// StackContainerConfigDeployStartupDelay1 defines model for .
type StackContainerConfigDeployStartupDelay1 = string

// StackContainerConfigDeploy_Startup_Delay How long the platform will wait before sending the start signal to the given container.
type StackContainerConfigDeploy_Startup_Delay struct {
	union json.RawMessage
}

// StackContainerConfigDeployStrategy The strategy Cycle will apply when deploying instances of this container.
// - ** resource-density **: Cycle will distribute instances across servers to maintain balanced resource usage. - ** high-availability **: Cycle will deploy instances over servers with an emphasis on geographic and physical separation - ** first-available **: Cycle will deploy one instance to every node that matches the specified criteria. (default) - ** node **: Cycle will deploy one instance to every node that matches the specified criteria. - ** edge **: Cycle will prioritize geographic distribution of instances. - ** function **: Every ingress request/connection receives its own instance.  - ** manual **: Cycle will not make any decisions on where instances are deployed. Instead, instances must be deployed manually using the portal or API.
type StackContainerConfigDeployStrategy string

// StackContainerConfigDeployTelemetryInterval1 defines model for .
type StackContainerConfigDeployTelemetryInterval1 = string

// StackContainerConfigDeploy_Telemetry_Interval The duration between samples.
type StackContainerConfigDeploy_Telemetry_Interval struct {
	union json.RawMessage
}

// StackContainerConfigDeployTelemetryRetention1 defines model for .
type StackContainerConfigDeployTelemetryRetention1 = string

// StackContainerConfigDeploy_Telemetry_Retention How long telemetry data should be retained.
type StackContainerConfigDeploy_Telemetry_Retention struct {
	union json.RawMessage
}

// StackContainerConfigDeployUpdateStagger1 defines model for .
type StackContainerConfigDeployUpdateStagger1 = string

// StackContainerConfigDeploy_Update_Stagger When set, Cycle will pick a random time from `0 - this duration`, and stagger the instances so they all start at different times (up to the time specified here).
type StackContainerConfigDeploy_Update_Stagger struct {
	union json.RawMessage
}

// StackContainerConfigIntegrations Configuration options for additional integrations/features that Cycle provides.
type StackContainerConfigIntegrations struct {
	// Backups When enabled, Cycle will automatically manage backups of this container. This is only available for stateful containers.
	Backups *struct {
		// Backup Configuration options for how the container should be backed up.
		Backup struct {
			// Command The command to run to capture a backup. The output sent to `STDOUT` will be captured and sent to the specified integration.
			Command string `json:"command"`

			// CronString A cron string describing how often to run the backup command.
			CronString *string `json:"cron_string"`

			// Timeout How long the backup will attempt to run before timing out.
			Timeout StackContainerConfigIntegrations_Backups_Backup_Timeout `json:"timeout"`
		} `json:"backup"`

		// IntegrationId Either a resource ID (objectid - i.e. 651586fca6078e98982dbd90) or a resource Identifier (human-readable)
		IntegrationId *HybridIdentifier `json:"integration_id,omitempty"`

		// Restore Configuration options for how the backup should be restored.
		Restore *struct {
			Command string `json:"command"`

			// Timeout The time in seconds for the restore to attempt to complete before timing out.
			Timeout StackContainerConfigIntegrations_Backups_Restore_Timeout `json:"timeout"`
		} `json:"restore"`

		// Retention How long the platform will keep backups. Default is 1 year.
		Retention StackContainerConfigIntegrations_Backups_Retention `json:"retention"`
	} `json:"backups"`

	// Files When enabled, Cycle will fetch and inject remote files into the container at the specified destination during runtime.
	Files *[]struct {
		Destination string `json:"destination"`
		Source      string `json:"source"`
	} `json:"files"`

	// LetsEncrypt When enabled, this integration will configure Let's Encrypt certificates that will be injected into the container at runtime. The certificates will be managed by the platform and renewed automatically.
	LetsEncrypt *struct {
		AdditionalCertsPath *string `json:"additional_certs_path"`
		BundlePath          *string `json:"bundle_path"`
		CertificatePath     *string `json:"certificate_path"`
		ChainPath           *string `json:"chain_path"`
		Enable              bool    `json:"enable"`
		KeyPath             *string `json:"key_path"`
	} `json:"lets_encrypt"`

	// Logs When enabled, allows more customization to be applied to logging for the container.
	Logs *struct {
		// Groups A tag used for applying log filters and analytics.
		Groups *[]Identifier `json:"groups"`
	} `json:"logs"`

	// SharedFileSystems When enabled, Cycle will mount a shared host directory into this container. The directory will be shared with all other containers that mount it.
	SharedFileSystems *map[string]struct {
		MountPoint string `json:"mount_point"`
		Writable   bool   `json:"writable"`
	} `json:"shared_file_systems"`

	// Webhooks Enable additional webhooks that Cycle will call out to during the course of a container's lifetime. All webhooks send a payload as an object containing the instance, container, server, and environment IDs.
	Webhooks *struct {
		// Config The webhook to hit when the container's configuration is changed.
		Config *string `json:"config"`

		// Events Webhooks that are triggered during a container event.
		Events *struct {
			// Deploy Cycle will call this endpoint when the container is deployed.
			Deploy *string `json:"deploy"`

			// Start Cycle will call this endpoint when the container is started.
			Start *string `json:"start"`

			// Stop Cycle will call this endpoint when the container is stopped.
			Stop *string `json:"stop"`
		} `json:"events"`
	} `json:"webhooks"`
}

// StackContainerConfigIntegrationsBackupsBackupTimeout1 defines model for .
type StackContainerConfigIntegrationsBackupsBackupTimeout1 = string

// StackContainerConfigIntegrations_Backups_Backup_Timeout How long the backup will attempt to run before timing out.
type StackContainerConfigIntegrations_Backups_Backup_Timeout struct {
	union json.RawMessage
}

// StackContainerConfigIntegrationsBackupsRestoreTimeout1 defines model for .
type StackContainerConfigIntegrationsBackupsRestoreTimeout1 = string

// StackContainerConfigIntegrations_Backups_Restore_Timeout The time in seconds for the restore to attempt to complete before timing out.
type StackContainerConfigIntegrations_Backups_Restore_Timeout struct {
	union json.RawMessage
}

// StackContainerConfigIntegrationsBackupsRetention1 defines model for .
type StackContainerConfigIntegrationsBackupsRetention1 = string

// StackContainerConfigIntegrations_Backups_Retention How long the platform will keep backups. Default is 1 year.
type StackContainerConfigIntegrations_Backups_Retention struct {
	union json.RawMessage
}

// StackContainerConfigNetwork Stack configuration options related to the container's network.
type StackContainerConfigNetwork struct {
	// Hostname The hostname of the container. This is how it can be referenced by other containers in the same environment.
	Hostname string `json:"hostname"`

	// Ports A list of port mappings on this container.
	Ports *[]string `json:"ports,omitempty"`

	// Public The level of public network access this container should have.
	Public StackContainerConfigNetworkPublic `json:"public"`
}

// StackContainerConfigNetworkPublic The level of public network access this container should have.
type StackContainerConfigNetworkPublic string

// StackContainerConfigResources Configuration options for container resource limits and reserves.
type StackContainerConfigResources struct {
	Cpu struct {
		Cpus   *string `json:"cpus,omitempty"`
		Shares *struct {
			Limit   int `json:"limit"`
			Reserve int `json:"reserve"`
		} `json:"shares,omitempty"`
	} `json:"cpu"`
	Ram struct {
		Limit      *string  `json:"limit,omitempty"`
		Reserve    *string  `json:"reserve,omitempty"`
		Swappiness *float32 `json:"swappiness,omitempty"`
	} `json:"ram"`
}

// StackContainerConfigRuntime Configuration options related to how the container behaves while it is running (environment variables, command overrides, kernel capabilities, etc. )
type StackContainerConfigRuntime struct {
	// Capabilities Additional Linux kernel capabilities to apply to this container process.
	Capabilities *[]StackContainerConfigRuntimeCapabilities `json:"capabilities,omitempty"`

	// Command The command to execute when this container starts. Will override the default specified in the container.
	Command *struct {
		Args *string `json:"args,omitempty"`
		Path *string `json:"path,omitempty"`
	} `json:"command,omitempty"`

	// EnvironmentVars A map of environment variables that will be injected into the container.
	EnvironmentVars *map[string]string `json:"environment_vars,omitempty"`

	// Host Configuration options regarding the underlying host.
	Host *struct {
		// ExposeProc If true, Cycle will mount the `/proc` directory into the container, giving it access to the host metrics. This is useful if you're running i.e. a monitoring agent.
		ExposeProc *bool `json:"expose_proc"`
	} `json:"host"`

	// Namespaces Container namespaces to apply. By default, all are applied. Removing/changing this can have security implications.
	Namespaces *[]StackContainerConfigRuntimeNamespaces `json:"namespaces,omitempty"`

	// Privileged If true, the container process will run in fully-privileged mode. **WARNING** This is considered insecure, and should only be done if you know what you're doing.
	Privileged *bool `json:"privileged,omitempty"`

	// Rlimits RLIMIT options to apply.
	Rlimits *map[string]struct {
		Hard int `json:"hard"`
		Soft int `json:"soft"`
	} `json:"rlimits,omitempty"`

	// Rootfs Configuration options for the root filesystem.
	Rootfs *struct {
		// Readonly If true, the container's filesystem will be read-only.
		Readonly bool `json:"readonly"`
	} `json:"rootfs,omitempty"`

	// Seccomp Configuration options for seccomp. Cycle enables seccomp by default.
	Seccomp *struct {
		Disable bool `json:"disable"`
		Rules   []struct {
			Capabilities struct {
				Excludes string `json:"excludes"`
				Includes string `json:"includes"`
			} `json:"capabilities"`
			Syscall struct {
				Action StackContainerConfigRuntimeSeccompRulesSyscallAction `json:"action"`
				Args   *[]struct {
					Index    int                                                  `json:"index"`
					Op       StackContainerConfigRuntimeSeccompRulesSyscallArgsOp `json:"op"`
					Value    int                                                  `json:"value"`
					Valuetwo *int                                                 `json:"valuetwo,omitempty"`
				} `json:"args,omitempty"`
				ErrnoRet *int     `json:"errnoRet,omitempty"`
				Names    []string `json:"names"`
			} `json:"syscall"`
		} `json:"rules"`
	} `json:"seccomp,omitempty"`

	// Sysctl Sysctl options to apply.
	Sysctl *map[string]string `json:"sysctl,omitempty"`

	// Workdir The working directory to execute the command in.
	Workdir *string `json:"workdir,omitempty"`
}

// StackContainerConfigRuntimeCapabilities defines model for StackContainerConfigRuntime.Capabilities.
type StackContainerConfigRuntimeCapabilities string

// StackContainerConfigRuntimeNamespaces defines model for StackContainerConfigRuntime.Namespaces.
type StackContainerConfigRuntimeNamespaces string

// StackContainerConfigRuntimeSeccompRulesSyscallAction defines model for StackContainerConfigRuntime.Seccomp.Rules.Syscall.Action.
type StackContainerConfigRuntimeSeccompRulesSyscallAction string

// StackContainerConfigRuntimeSeccompRulesSyscallArgsOp defines model for StackContainerConfigRuntime.Seccomp.Rules.Syscall.Args.Op.
type StackContainerConfigRuntimeSeccompRulesSyscallArgsOp string

// StackContainerConfigScaling Stack configuration options for auto-scaling.
type StackContainerConfigScaling struct {
	// AutoscaleGroup The identifier of the auto-scaling group assigned to this container. The auto-scale group determines which infrastructure this container can spin up if it needs more resources to meet demand. Setting it to `null` will limit auto-scaling to only instances.
	AutoscaleGroup StackContainerConfigScaling_AutoscaleGroup `json:"autoscale_group"`

	// Instances Describes the criteria for deploying new instances when an auto-scale criteria is met.
	Instances struct {
		// Max Maximum additional instances the auto-scaler will run at any time.
		Max int `json:"max"`

		// MaxServer Minimum number of instances per server.
		MaxServer int `json:"max_server"`

		// MinTtl A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
		MinTtl Duration `json:"min_ttl"`
	} `json:"instances"`

	// Thresholds An array of rules that dictate when a scaling event will be triggered.
	Thresholds []StackContainerScaleThreshold `json:"thresholds"`

	// Window A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
	Window Duration `json:"window"`
}

// StackContainerConfigScalingAutoscaleGroup1 defines model for .
type StackContainerConfigScalingAutoscaleGroup1 = string

// StackContainerConfigScaling_AutoscaleGroup The identifier of the auto-scaling group assigned to this container. The auto-scale group determines which infrastructure this container can spin up if it needs more resources to meet demand. Setting it to `null` will limit auto-scaling to only instances.
type StackContainerConfigScaling_AutoscaleGroup struct {
	union json.RawMessage
}

// StackContainerScaleThreshold Discriminated union describing the different types of scaling threshold and their respective details
type StackContainerScaleThreshold struct {
	union json.RawMessage
}

// StackContainerScaleThresholdCpu Describes the CPU threshold at which scaling will occur.
type StackContainerScaleThresholdCpu struct {
	Details struct {
		Utilization int `json:"utilization"`
	} `json:"details"`
	Type StackContainerScaleThresholdCpuType `json:"type"`
}

// StackContainerScaleThresholdCpuType defines model for StackContainerScaleThresholdCpu.Type.
type StackContainerScaleThresholdCpuType string

// StackContainerScaleThresholdCustom A custom threshold for defining a scaling event.
type StackContainerScaleThresholdCustom struct {
	Details struct {
		// Webhook A URL describing the destination Cycle should send a POST webhook payload to.
		Webhook WebhookURL `json:"webhook"`
	} `json:"details"`
	Type StackContainerScaleThresholdCustomType `json:"type"`
}

// StackContainerScaleThresholdCustomType defines model for StackContainerScaleThresholdCustom.Type.
type StackContainerScaleThresholdCustomType string

// StackContainerScaleThresholdNetworkConnections Describes the network connections threshold at which scaling will occur.
type StackContainerScaleThresholdNetworkConnections struct {
	Details struct {
		ConnectionsTotal int `json:"connections_total"`
	} `json:"details"`
	Type StackContainerScaleThresholdNetworkConnectionsType `json:"type"`
}

// StackContainerScaleThresholdNetworkConnectionsType defines model for StackContainerScaleThresholdNetworkConnections.Type.
type StackContainerScaleThresholdNetworkConnectionsType string

// StackContainerScaleThresholdNetworkRequests Describes the network requests threshold at which scaling will occur.
type StackContainerScaleThresholdNetworkRequests struct {
	Details struct {
		RequestsTotal int `json:"requests_total"`
	} `json:"details"`
	Type StackContainerScaleThresholdNetworkRequestsType `json:"type"`
}

// StackContainerScaleThresholdNetworkRequestsType defines model for StackContainerScaleThresholdNetworkRequests.Type.
type StackContainerScaleThresholdNetworkRequestsType string

// StackContainerScaleThresholdNetworkThroughput Describes the network throughput threshold at which scaling will occur.
type StackContainerScaleThresholdNetworkThroughput struct {
	Details struct {
		// Bandwidth The limit (maximum) amount of throughput each instance of the given container can use before triggering a scaling event.
		Bandwidth string `json:"bandwidth"`
		Private   bool   `json:"private"`
	} `json:"details"`
	Type StackContainerScaleThresholdNetworkThroughputType `json:"type"`
}

// StackContainerScaleThresholdNetworkThroughputType defines model for StackContainerScaleThresholdNetworkThroughput.Type.
type StackContainerScaleThresholdNetworkThroughputType string

// StackContainerScaleThresholdRam Describes the RAM threshold at which scaling will occur.
type StackContainerScaleThresholdRam struct {
	Details struct {
		// Usage The target average RAM usage of all instances of this container. Going above this threshold will trigger a scaling event. This threshold must be greater than 25MB.
		Usage string `json:"usage"`
	} `json:"details"`
	Type StackContainerScaleThresholdRamType `json:"type"`
}

// StackContainerScaleThresholdRamType defines model for StackContainerScaleThresholdRam.Type.
type StackContainerScaleThresholdRamType string

// StackContainerVolume A container volume configuration.
type StackContainerVolume struct {
	// Destination The path this volume should be mounted at inside the container.
	Destination string `json:"destination"`

	// Local Configuration options for local volumes.
	Local *struct {
		// MaxSize The maximum size this volume can grow to. Container volumes on Cycle are thinly provisioned, meaning this isn't an allocation - the volume will only use the space it needs up to this size.
		MaxSize string `json:"max_size"`

		// StoragePool A boolean where true signifies using the largest drive over 2TB for the target server.
		StoragePool *bool `json:"storage_pool,omitempty"`
	} `json:"local,omitempty"`

	// ReadOnly If true, the container will be unable to write data to the volume.
	ReadOnly bool `json:"read_only"`

	// RemoteAccess Configuration options for setting up remote access to this volume via SFTP.
	RemoteAccess *struct {
		// Enable If true, this volume will be accessible over SFTP.
		Enable bool `json:"enable"`

		// Ips A list of IPs that SFTP access will be limited to.
		Ips *[]string `json:"ips,omitempty"`

		// Password The password used for logging in to this volume via SFTP.
		Password struct {
			// Algorithm The algorithm the password is encoded with. `raw` means the password is plain-text.
			Algorithm StackContainerVolumeRemoteAccessPasswordAlgorithm `json:"algorithm"`

			// Data The password string.
			Data string `json:"data"`
		} `json:"password"`

		// Webhook If set, Cycle will call out to this URL for authentication. Anything other than a 200 response will be considered a validation failure.
		Webhook *string `json:"webhook,omitempty"`
	} `json:"remote_access,omitempty"`
}

// StackContainerVolumeRemoteAccessPasswordAlgorithm The algorithm the password is encoded with. `raw` means the password is plain-text.
type StackContainerVolumeRemoteAccessPasswordAlgorithm string

// StackImageOrigin The origin of the image.
type StackImageOrigin struct {
	union json.RawMessage
}

// StackService Stack spec configuration options common to all environment services. If one of these properties is defined, all must be.
type StackService struct {
	// AutoUpdate Whether or not Cycle should automatically update this service when a new version is released.
	AutoUpdate *bool `json:"auto_update,omitempty"`

	// Enable Whether or not this service should be enabled.
	Enable *bool `json:"enable,omitempty"`

	// HighAvailability Whether or not Cycle should run multiple instances of this service for high availability.
	HighAvailability *bool `json:"high_availability,omitempty"`
}

// StackSpec A Cycle stack file is an "environment as code". Anything that can be done in an environment on Cycle can be described in a stack file and deployed as a new environment.
// Stack files can list multiple containers and their configurations, load balancer settings, scoped variables, and much more.
type StackSpec struct {
	// About Various properties describing this stack.
	About *struct {
		// Description Custom, user-defined details about this stack.
		Description string `json:"description"`

		// Version A custom, user-defined version of the stack.
		Version string `json:"version"`
	} `json:"about"`

	// Annotations Additional meta info about the stack.
	Annotations *map[string]interface{} `json:"annotations,omitempty"`

	// Containers A mapping of containers that will be deployed as a part of this stack. The key is used as the container's identifier.
	Containers map[string]StackContainer `json:"containers"`

	// ScopedVariables Describes variables that are assigned to one or more containers at runtime. Can be assigned as an environment variable, written as a file inside the container(s), or accessed over the internal API.
	ScopedVariables *[]StackSpecScopedVariable `json:"scoped_variables"`

	// Services Settings for any auxillary services deployed as part of the environment, such as load balancer and discovery services.
	Services *struct {
		Discovery    *StackSpec_Services_Discovery    `json:"discovery,omitempty"`
		Loadbalancer *StackSpec_Services_Loadbalancer `json:"loadbalancer,omitempty"`
		Scheduler    *StackSpec_Services_Scheduler    `json:"scheduler,omitempty"`
		Vpn          *StackSpec_Services_Vpn          `json:"vpn,omitempty"`
	} `json:"services"`

	// Version The version of the Cycle stack file used.
	Version StackSpecVersion `json:"version"`
}

// StackSpecServicesDiscovery0 defines model for .
type StackSpecServicesDiscovery0 = map[string]interface{}

// StackSpec_Services_Discovery defines model for StackSpec.Services.Discovery.
type StackSpec_Services_Discovery struct {
	union json.RawMessage
}

// StackSpecServicesLoadbalancer0 defines model for .
type StackSpecServicesLoadbalancer0 = map[string]interface{}

// StackSpec_Services_Loadbalancer defines model for StackSpec.Services.Loadbalancer.
type StackSpec_Services_Loadbalancer struct {
	union json.RawMessage
}

// StackSpecServicesScheduler0 defines model for .
type StackSpecServicesScheduler0 = map[string]interface{}

// StackSpec_Services_Scheduler defines model for StackSpec.Services.Scheduler.
type StackSpec_Services_Scheduler struct {
	union json.RawMessage
}

// StackSpecServicesVpn0 defines model for .
type StackSpecServicesVpn0 = map[string]interface{}

// StackSpec_Services_Vpn defines model for StackSpec.Services.Vpn.
type StackSpec_Services_Vpn struct {
	union json.RawMessage
}

// StackSpecVersion The version of the Cycle stack file used.
type StackSpecVersion string

// StackSpecContainerImage defines model for StackSpecContainerImage.
type StackSpecContainerImage struct {
	// Build Additional details applied when building an image.
	Build *struct {
		// Args A map of build arguments applied to the image at build time.
		Args map[string]string `json:"args"`
	} `json:"build"`

	// Builder A specific builder to use. By default, Cycle uses its factory service and a standard build command to build images, but this can be enhanced by using an image builder integration.
	Builder *struct {
		// IntegrationId Either a resource ID (objectid - i.e. 651586fca6078e98982dbd90) or a resource Identifier (human-readable)
		IntegrationId HybridIdentifier `json:"integration_id"`
	} `json:"builder"`

	// Name The human-readable name of this image.
	Name *string `json:"name"`

	// Origin The origin of the image.
	Origin StackImageOrigin `json:"origin"`
}

// StackSpecDiscoveryConfig defines model for StackSpecDiscoveryConfig.
type StackSpecDiscoveryConfig struct {
	EmptySetDelay *StackSpecDiscoveryConfig_EmptySetDelay `json:"empty_set_delay,omitempty"`

	// Hosts A custom mapping of hosts - for forced resolution of specific IPs for a domain.
	Hosts *map[string]struct {
		Ipv4 *[]string `json:"ipv4"`
		Ipv6 *[]string `json:"ipv6"`
	} `json:"hosts"`
}

// StackSpecDiscoveryConfigEmptySetDelay1 defines model for .
type StackSpecDiscoveryConfigEmptySetDelay1 = string

// StackSpecDiscoveryConfig_EmptySetDelay defines model for StackSpecDiscoveryConfig.EmptySetDelay.
type StackSpecDiscoveryConfig_EmptySetDelay struct {
	union json.RawMessage
}

// StackSpecDiscoveryService Configuration options for the discovery service.
type StackSpecDiscoveryService struct {
	Config  *StackSpecDiscoveryService_Config  `json:"config,omitempty"`
	Service *StackSpecDiscoveryService_Service `json:"service,omitempty"`
}

// StackSpecDiscoveryServiceConfig1 defines model for .
type StackSpecDiscoveryServiceConfig1 = map[string]interface{}

// StackSpecDiscoveryService_Config defines model for StackSpecDiscoveryService.Config.
type StackSpecDiscoveryService_Config struct {
	union json.RawMessage
}

// StackSpecDiscoveryServiceService1 defines model for .
type StackSpecDiscoveryServiceService1 = map[string]interface{}

// StackSpecDiscoveryService_Service defines model for StackSpecDiscoveryService.Service.
type StackSpecDiscoveryService_Service struct {
	union json.RawMessage
}

// StackSpecLoadBalancerConfig The config object for the loadbalancer service.
type StackSpecLoadBalancerConfig struct {
	union json.RawMessage
}

// StackSpecLoadBalancerService Configuration options for the load balancer service.
type StackSpecLoadBalancerService struct {
	Config  *StackSpecLoadBalancerService_Config  `json:"config,omitempty"`
	Service *StackSpecLoadBalancerService_Service `json:"service,omitempty"`
}

// StackSpecLoadBalancerServiceConfig1 defines model for .
type StackSpecLoadBalancerServiceConfig1 = map[string]interface{}

// StackSpecLoadBalancerService_Config defines model for StackSpecLoadBalancerService.Config.
type StackSpecLoadBalancerService_Config struct {
	union json.RawMessage
}

// StackSpecLoadBalancerServiceService1 defines model for .
type StackSpecLoadBalancerServiceService1 = map[string]interface{}

// StackSpecLoadBalancerService_Service defines model for StackSpecLoadBalancerService.Service.
type StackSpecLoadBalancerService_Service struct {
	union json.RawMessage
}

// StackSpecSchedulerAccessKey Custom authorization keys for the scheduler service.
type StackSpecSchedulerAccessKey struct {
	// Ips Whitelisted IPs that are allowed to make requests to the scheduler service.
	Ips *[]string `json:"ips,omitempty"`

	// Name The name given to this access key.
	Name string `json:"name"`

	// Secret The access key secret. This should be submitted with requests to a publicly accessible scheduler service.
	Secret string `json:"secret"`
}

// StackSpecSchedulerConfig Scheduler specific configuration options.
type StackSpecSchedulerConfig struct {
	AccessKeys *[]StackSpecSchedulerAccessKey `json:"access_keys,omitempty"`

	// Public If true, this scheduler will be accessible over the public internet. It will enable a LINKED record to be pointed to the scheduler container, and inbound requests to trigger function containers.
	Public bool `json:"public"`
}

// StackSpecSchedulerService Configuration options for the scheduler service.
type StackSpecSchedulerService struct {
	Config  *StackSpecSchedulerService_Config  `json:"config,omitempty"`
	Service *StackSpecSchedulerService_Service `json:"service,omitempty"`
}

// StackSpecSchedulerServiceConfig1 defines model for .
type StackSpecSchedulerServiceConfig1 = map[string]interface{}

// StackSpecSchedulerService_Config defines model for StackSpecSchedulerService.Config.
type StackSpecSchedulerService_Config struct {
	union json.RawMessage
}

// StackSpecSchedulerServiceService1 defines model for .
type StackSpecSchedulerServiceService1 = map[string]interface{}

// StackSpecSchedulerService_Service defines model for StackSpecSchedulerService.Service.
type StackSpecSchedulerService_Service struct {
	union json.RawMessage
}

// StackSpecScopedVariable defines model for StackSpecScopedVariable.
type StackSpecScopedVariable struct {
	Access struct {
		// EnvVariable Grants access to this variable from within a container as an environment variable.
		EnvVariable *struct {
			// Key The environment variable inside the container that stores the value of the variable.
			Key string `json:"key"`
		} `json:"env_variable"`

		// File Grants access to this variable as a file inside the container.
		File *struct {
			// Decode When true, Cycle will interpret this variable as a base-64 encoded string, and decode it before writing it to the file inside the container.
			Decode bool `json:"decode"`

			// Path The absolute path to write the variable to (including file name). If `null`, it will be written to `/var/run/cycle/variables/{variable-identifier}`.
			Path *string `json:"path"`
		} `json:"file"`

		// InternalApi Grants access to this variable over the Internal API.
		InternalApi *struct {
			// Duration Sets the duration that this variable can be accessed over the Internal API, after container start. Provides additional security as sensitive data can only be accessed for a limited time.
			Duration *StackSpecScopedVariable_Access_InternalApi_Duration `json:"duration,omitempty"`
		} `json:"internal_api"`
	} `json:"access"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier Identifier `json:"identifier"`
	Scope      struct {
		// Containers Describes the containers that have access to this scoped variable.
		Containers struct {
			// Global If true, all containers in the environment will have access to this variable.
			Global bool `json:"global"`

			// Identifiers A list of container identifiers that are granted access to this variable.
			Identifiers *[]Identifier `json:"identifiers"`

			// Ids A list of container IDs that are granted access to this variable.
			Ids *[]string `json:"ids"`
		} `json:"containers"`
	} `json:"scope"`
	Source *StackSpecScopedVariable_Source `json:"source,omitempty"`
}

// StackSpecScopedVariableAccessInternalApiDuration1 defines model for .
type StackSpecScopedVariableAccessInternalApiDuration1 = string

// StackSpecScopedVariable_Access_InternalApi_Duration Sets the duration that this variable can be accessed over the Internal API, after container start. Provides additional security as sensitive data can only be accessed for a limited time.
type StackSpecScopedVariable_Access_InternalApi_Duration struct {
	union json.RawMessage
}

// StackSpecScopedVariableSource0 defines model for .
type StackSpecScopedVariableSource0 = map[string]interface{}

// StackSpecScopedVariableSource1 Describes the source/value of the variable.
// - **raw**: Directly set the value of the variable in the stack. - **url**: Cycle will fetch the variable content from a remote source when the container starts.
type StackSpecScopedVariableSource1 struct {
	union json.RawMessage
}

// StackSpecScopedVariable_Source defines model for StackSpecScopedVariable.Source.
type StackSpecScopedVariable_Source struct {
	union json.RawMessage
}

// StackSpecScopedVariableRawSource A variable with a hard-coded value.
type StackSpecScopedVariableRawSource struct {
	Details struct {
		// Blob A boolean where true represents the text the user is entering will be multi line.
		Blob   bool `json:"blob"`
		Secret *struct {
			// Hint A user specified hint that will suggest what the encryption key might be
			Hint *string `json:"hint,omitempty"`

			// Iv A string describing the IV Hex associated with the encryption of the variable.
			Iv *string `json:"iv,omitempty"`
		} `json:"secret"`

		// Value The value of the variable.
		Value string `json:"value"`
	} `json:"details"`

	// Type The type of scoped variable.
	Type StackSpecScopedVariableRawSourceType `json:"type"`
}

// StackSpecScopedVariableRawSourceType The type of scoped variable.
type StackSpecScopedVariableRawSourceType string

// StackSpecScopedVariableUrlSource A variable who's value is fetched from a URL when the container starts.
type StackSpecScopedVariableUrlSource struct {
	Details struct {
		// AuthTokenUrl A URL that can be provided to authenticate with a third party secret service. Cycle will make a request to this URL before fetching the secret URL, and use the response as the value of an Authorization header when requesting the secret.
		AuthTokenUrl *string `json:"auth_token_url"`

		// Headers Additional headers that can be attached to the URL request. Useful for adding meta-data to third-party services.
		Headers map[string]interface{} `json:"headers"`

		// Url The URL to call to fetch the value.
		Url string `json:"url"`
	} `json:"details"`

	// Type The type of scoped variable.
	Type StackSpecScopedVariableUrlSourceType `json:"type"`
}

// StackSpecScopedVariableUrlSourceType The type of scoped variable.
type StackSpecScopedVariableUrlSourceType string

// StackSpecVpnConfig VPN specific configuraiton options.
type StackSpecVpnConfig struct {
	AllowInternet bool `json:"allow_internet"`
	Auth          struct {
		// CycleAccounts If true, any account with access to this environment on Cycle can use their Cycle credentials to log in to this VPN.
		CycleAccounts bool `json:"cycle_accounts"`

		// VpnAccounts If true, Cycle will allow custom accounts to be created for logging into this VPN.
		VpnAccounts bool `json:"vpn_accounts"`

		// Webhook The endpoint to hit when attempting to authorize a VPN account. If the endpoint returns a 200 response, access is granted. Otherwise it is denied.
		Webhook *string `json:"webhook,omitempty"`
	} `json:"auth"`
}

// StackSpecVpnService Configuration options for the VPN service.
type StackSpecVpnService struct {
	Config  *StackSpecVpnService_Config  `json:"config,omitempty"`
	Service *StackSpecVpnService_Service `json:"service,omitempty"`
}

// StackSpecVpnServiceConfig1 defines model for .
type StackSpecVpnServiceConfig1 = map[string]interface{}

// StackSpecVpnService_Config defines model for StackSpecVpnService.Config.
type StackSpecVpnService_Config struct {
	union json.RawMessage
}

// StackSpecVpnServiceService1 defines model for .
type StackSpecVpnServiceService1 = map[string]interface{}

// StackSpecVpnService_Service defines model for StackSpecVpnService.Service.
type StackSpecVpnService_Service struct {
	union json.RawMessage
}

// State Information regarding the current state of the resource.
type State struct {
	Changed DateTime `json:"changed"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// StateCountSummary A summary of resources by state
type StateCountSummary struct {
	// Available The total number of this resource available, less any deleted ones.
	Available int `json:"available"`

	// State A count of this resource, grouped by state.
	State map[string]int `json:"state"`

	// Total The total number of this resource
	Total int `json:"total"`
}

// TaskState defines model for TaskState.
type TaskState struct {
	Changed *DateTime `json:"changed,omitempty"`

	// Current The current state of the task.
	Current *TaskStateCurrent `json:"current,omitempty"`
}

// TaskStateCurrent The current state of the task.
type TaskStateCurrent string

// TaskStep A step for a given job task.
type TaskStep struct {
	// Caption A short description of the step.
	Caption   string   `json:"caption"`
	Completed DateTime `json:"completed"`

	// Description A more verbose description.
	Description string   `json:"description"`
	Started     DateTime `json:"started"`
}

// TcpRouterConfig Additional configuration options for TCP mode routers
type TcpRouterConfig struct {
	Details map[string]interface{} `json:"details"`
	Type    TcpRouterConfigType    `json:"type"`
}

// TcpRouterConfigType defines model for TcpRouterConfig.Type.
type TcpRouterConfigType string

// TcpTransportConfig Additional configuration options for the TCP transport mode.
type TcpTransportConfig struct {
	Details struct {
		Connections map[string]interface{} `json:"connections"`

		// Telemetry Configuration options for how telemetry is handled on the load balancer.
		Telemetry map[string]interface{} `json:"telemetry"`
	} `json:"details"`
	Type TcpTransportConfigType `json:"type"`
}

// TcpTransportConfigType defines model for TcpTransportConfig.Type.
type TcpTransportConfigType string

// UdpRouterConfig Additional configuration options for UDP mode routers
type UdpRouterConfig struct {
	Details map[string]interface{} `json:"details"`
	Type    UdpRouterConfigType    `json:"type"`
}

// UdpRouterConfigType defines model for UdpRouterConfig.Type.
type UdpRouterConfigType string

// UdpTransportConfig Additional configuration options for the UDP transport mode.
type UdpTransportConfig struct {
	Details struct {
		// Telemetry Configuration options for how telemetry is handled on the load balancer.
		Telemetry map[string]interface{} `json:"telemetry"`
	} `json:"details"`
	Type UdpTransportConfigType `json:"type"`
}

// UdpTransportConfigType defines model for UdpTransportConfig.Type.
type UdpTransportConfigType string

// V1LbConfig defines model for V1LbConfig.
type V1LbConfig struct {
	ControllerTemplate *V1LbConfig_ControllerTemplate `json:"controller_template,omitempty"`

	// Controllers A configuration for a specific port.
	Controllers []V1LbController `json:"controllers"`
	Waf         *V1LbConfig_Waf  `json:"waf,omitempty"`
}

// V1LbConfigControllerTemplate1 defines model for .
type V1LbConfigControllerTemplate1 = map[string]interface{}

// V1LbConfig_ControllerTemplate defines model for V1LbConfig.ControllerTemplate.
type V1LbConfig_ControllerTemplate struct {
	union json.RawMessage
}

// V1LbConfigWaf1 defines model for .
type V1LbConfigWaf1 = map[string]interface{}

// V1LbConfig_Waf defines model for V1LbConfig.Waf.
type V1LbConfig_Waf struct {
	union json.RawMessage
}

// V1LbConfigRouter A specific router configuration that describes how traffic matching the rule is handled.
type V1LbConfigRouter struct {
	Config struct {
		DestinationPrioritization *V1LbConfigRouter_Config_DestinationPrioritization `json:"destination_prioritization,omitempty"`

		// DestinationRetries If a destination is unavailable, retry up to [x] times, instead of immediately failing with a 503/504 error.
		DestinationRetries int                                `json:"destination_retries"`
		Extension          *V1LbConfigRouter_Config_Extension `json:"extension,omitempty"`

		// StickySessions If a request comes in from the same origin, ensure it hits the same destination.
		StickySessions bool `json:"sticky_sessions"`

		// Timeouts Defines how the length of various sorts of timeouts when communicating with the destination.
		Timeouts struct {
			// DestinationConnection A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
			DestinationConnection Duration `json:"destination_connection"`
		} `json:"timeouts"`

		// Tls TLS termination configuration. If null, the platform will use the default configuration. Port 443 by default has TLS termination enabled.
		Tls *struct {
			// AllowInsecure If enabled, accept TLS traffic with an invalid certificate. This is usually done for development/testing, and is not recommended for production use.
			AllowInsecure *bool `json:"allow_insecure"`

			// ClientAuth Defines how to validate the connecting TLS certificate.
			// `none`: Do not require a TLS certificate to be sent
			// `request`: Asks the client to send a TLS certificate, but does not require nor validate it.
			// `require`: Requires a certificate be sent for the request to be valid, but does not validate the certificate.
			// `require-verify`: Requires both that the client send a certificate, and that the certificate is valid. This is required when using https.
			ClientAuth *V1LbConfigRouter_Config_Tls_ClientAuth `json:"client_auth,omitempty"`

			// ClientCertAuth A PEM encoded string of certificates.
			ClientCertAuth *string `json:"client_cert_auth"`

			// ServerName [Advanced] Change the domain the controller listens on.
			ServerName *string `json:"server_name"`
		} `json:"tls"`
	} `json:"config"`

	// Match The ruleset for this router to be selected. If both `domains`` and `internal_port` are null, then this match acts as a wildcard and will match all.
	Match struct {
		// Containers Match traffic destined (or not destined) for a particular container.
		Containers *struct {
			// Exclude Match any traffic that would NOT be routed to one of these containers.
			Exclude *[]HybridIdentifier `json:"exclude"`

			// Include Match any traffic that would be routed to one of these containers.
			Include *[]HybridIdentifier `json:"include"`
		} `json:"containers"`

		// Domains The specific domains to match against.
		Domains *[]string `json:"domains"`

		// InternalPorts The specific ports to match against.
		InternalPorts *[]int  `json:"internal_ports"`
		Path          *string `json:"path"`
	} `json:"match"`

	// Mode How to route the traffic to the destination.
	// `random`: Pick a valid destination at random.
	// `round-robin`: Send each request to the 'next' destination on the list, restarting from the beginning when the last destination is used.
	Mode V1LbConfigRouterMode `json:"mode"`
}

// V1LbConfigRouterConfigDestinationPrioritization0 Hints to the load balancer how to prioritize traffic to instances.
// **random**: Chooses a random instance. **latency**: Prioritizes lower latency instances.
type V1LbConfigRouterConfigDestinationPrioritization0 string

// V1LbConfigRouterConfigDestinationPrioritization1 defines model for .
type V1LbConfigRouterConfigDestinationPrioritization1 = map[string]interface{}

// V1LbConfigRouter_Config_DestinationPrioritization defines model for V1LbConfigRouter.Config.DestinationPrioritization.
type V1LbConfigRouter_Config_DestinationPrioritization struct {
	union json.RawMessage
}

// V1LbConfigRouterConfigExtension0 defines model for .
type V1LbConfigRouterConfigExtension0 = map[string]interface{}

// V1LbConfigRouterConfigExtension1 Additional configuration options specific to the selected mode (tcp/http).
type V1LbConfigRouterConfigExtension1 struct {
	union json.RawMessage
}

// V1LbConfigRouter_Config_Extension defines model for V1LbConfigRouter.Config.Extension.
type V1LbConfigRouter_Config_Extension struct {
	union json.RawMessage
}

// V1LbConfigRouterConfigTlsClientAuth0 defines model for V1LbConfigRouter.Config.Tls.ClientAuth.0.
type V1LbConfigRouterConfigTlsClientAuth0 string

// V1LbConfigRouterConfigTlsClientAuth1 defines model for .
type V1LbConfigRouterConfigTlsClientAuth1 = map[string]interface{}

// V1LbConfigRouter_Config_Tls_ClientAuth Defines how to validate the connecting TLS certificate.
// `none`: Do not require a TLS certificate to be sent
// `request`: Asks the client to send a TLS certificate, but does not require nor validate it.
// `require`: Requires a certificate be sent for the request to be valid, but does not validate the certificate.
// `require-verify`: Requires both that the client send a certificate, and that the certificate is valid. This is required when using https.
type V1LbConfigRouter_Config_Tls_ClientAuth struct {
	union json.RawMessage
}

// V1LbConfigRouterMode How to route the traffic to the destination.
// `random`: Pick a valid destination at random.
// `round-robin`: Send each request to the 'next' destination on the list, restarting from the beginning when the last destination is used.
type V1LbConfigRouterMode string

// V1LbController defines model for V1LbController.
type V1LbController struct {
	// Identifier A human-readable identifier for this controller. It will default to the port, i.e. `port-443`, but can be renamed to anything, such as the service this controller represents.
	Identifier string `json:"identifier"`

	// Port The port inbound trafic is accepted on.
	Port int `json:"port"`

	// Transport Defines how traffic comes in to the load balancer, and how the load balancer handles it.
	Transport *struct {
		// Config Defines how the transport for this controller operates.
		Config struct {
			// Extension Extended configurations for the specified transport mode (http/tcp)
			Extension *V1LbController_Transport_Config_Extension `json:"extension,omitempty"`

			// Ingress Defines how traffic gets into the load balancer.
			Ingress struct {
				Tls *struct {
					// Enable Enables or disables TLS.
					Enable bool `json:"enable"`
				} `json:"tls"`
			} `json:"ingress"`

			// Performance Enable/disable performance mode. If enabled, some telemetry will be disabled to dedicate full processing to handling requests.
			// You will not see per-request breakdowns or URL logging if performance mode is enabled.
			Performance bool `json:"performance"`

			// Timeouts Defines settings for various types of timeouts.
			Timeouts struct {
				// Idle A string signifying a duration of time. Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h", "d", "w", "y".
				Idle Duration `json:"idle"`
			} `json:"timeouts"`

			// Verbosity Verbosity describes the level of logging detail for the controller
			Verbosity V1LbControllerTransportConfigVerbosity `json:"verbosity"`
		} `json:"config"`

		// Disable When true, this controller is disabled and will not be used.
		Disable bool `json:"disable"`

		// Mode The kind of traffic (http/tcp/udp) that will be sent to the load balancer.
		Mode V1LbControllerTransportMode `json:"mode"`

		// Routers Defines where traffic is sent. Many can be defined per controller.
		Routers []V1LbConfigRouter `json:"routers"`
	} `json:"transport"`
	Waf *V1LbController_Waf `json:"waf,omitempty"`
}

// V1LbController_Transport_Config_Extension Extended configurations for the specified transport mode (http/tcp)
type V1LbController_Transport_Config_Extension struct {
	union json.RawMessage
}

// V1LbControllerTransportConfigVerbosity Verbosity describes the level of logging detail for the controller
type V1LbControllerTransportConfigVerbosity string

// V1LbControllerTransportMode The kind of traffic (http/tcp/udp) that will be sent to the load balancer.
type V1LbControllerTransportMode string

// V1LbControllerWaf1 defines model for .
type V1LbControllerWaf1 = map[string]interface{}

// V1LbController_Waf defines model for V1LbController.Waf.
type V1LbController_Waf struct {
	union json.RawMessage
}

// V1LbType defines model for V1LbType.
type V1LbType struct {
	// BindHost Binds the load balancer to the host server IP address.
	//
	// **Pros**: This allows for significantly lower cost (utilizing fewer IPv4 addresses), and enables building out a true edge network with lower latency.
	// **Cons**: Only 1 environment is allowed on the host. This is because the load balancer is the only ingress point for an environment, and if it is sharing
	// the same IP as the host, that host can only operate under that environment.
	BindHost *bool      `json:"bind_host"`
	Details  V1LbConfig `json:"details"`

	// Ipv4 Allow / disallow traffic to be routed via IPv4.
	Ipv4 bool `json:"ipv4"`

	// Ipv6 Allow / disallow traffic to be routed via IPv6.
	Ipv6 bool         `json:"ipv6"`
	Type V1LbTypeType `json:"type"`
}

// V1LbTypeType defines model for V1LbType.Type.
type V1LbTypeType string

// Version Version can be any string, but if it begins with a "v", semantic version will be enforced. A [Semantic Version](https://semver.org/) string. Follows the format vMAJOR.MINOR.PATCH-build.
type Version = string

// VpnEnvironmentService Information about the environments vpn service(s).
type VpnEnvironmentService struct {
	// AutoUpdate A boolean representing if this service container is set to autoupdate or not
	AutoUpdate *bool `json:"auto_update,omitempty"`

	// Config The config object for the VPN service.
	Config *struct {
		// AllowInternet If true, routes all traffic through the VPN, even non-Cycle traffic.
		AllowInternet bool `json:"allow_internet"`

		// Auth Auth configuration for the VPN.
		Auth struct {
			// CycleAccounts If true, allows any Cycle account with access to the environment to log in to the VPN using their Cycle email and password.
			CycleAccounts bool `json:"cycle_accounts"`

			// VpnAccounts If true, allows the custom VPN accounts to log in to the VPN.
			VpnAccounts *bool `json:"vpn_accounts,omitempty"`

			// Webhook A webhook endpoint to hit. Will be passed the login credentials provided to the user, and should return a 200 status if the login is permitted.
			Webhook *string `json:"webhook"`
		} `json:"auth"`
	} `json:"config"`

	// ContainerId The ID of the VPN service container
	ContainerId string `json:"container_id"`

	// Enable Whether or not the VPN service is enabled.
	Enable bool `json:"enable"`
}

// WafConfig Additional configuration options for the web application firewall.
type WafConfig struct {
	Rules []struct {
		Conditions []struct {
			Operator WafConfigRulesConditionsOperator `json:"operator"`
			Type     WafConfigRulesConditionsType     `json:"type"`
			Value    string                           `json:"value"`
		} `json:"conditions"`
		Description string             `json:"description"`
		Skip        bool               `json:"skip"`
		Type        WafConfigRulesType `json:"type"`
	} `json:"rules"`
}

// WafConfigRulesConditionsOperator defines model for WafConfig.Rules.Conditions.Operator.
type WafConfigRulesConditionsOperator string

// WafConfigRulesConditionsType defines model for WafConfig.Rules.Conditions.Type.
type WafConfigRulesConditionsType string

// WafConfigRulesType defines model for WafConfig.Rules.Type.
type WafConfigRulesType string

// WebhookURL A URL describing the destination Cycle should send a POST webhook payload to.
type WebhookURL = string

// Zone DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
type Zone struct {
	Acl *Zone_Acl `json:"acl,omitempty"`

	// Creator The creator scope is embedded in resource objects to describe who created them
	Creator CreatorScope `json:"creator"`

	// Events A collection of timestamps for each event in the DNS zone's lifetime.
	Events struct {
		Created          DateTime `json:"created"`
		Deleted          DateTime `json:"deleted"`
		LastVerification DateTime `json:"last_verification"`
		Updated          DateTime `json:"updated"`
		Verified         DateTime `json:"verified"`
	} `json:"events"`

	// Hosted A boolean where true represents this zone is a hosted zone.
	Hosted bool `json:"hosted"`

	// HubId The unique ID of the Hub this resource was created in.
	HubId HubID `json:"hub_id"`

	// Id A 24 character hex string used to identify a unique resource.
	Id ID `json:"id"`

	// Origin The origin for the given DNS zone.
	Origin string    `json:"origin"`
	State  ZoneState `json:"state"`
}

// ZoneAcl1 defines model for .
type ZoneAcl1 = map[string]interface{}

// Zone_Acl defines model for Zone.Acl.
type Zone_Acl struct {
	union json.RawMessage
}

// ZoneIncludes All includable resources linkable to the given Zone.
type ZoneIncludes struct {
	// Creators An identity that created a resource.
	Creators *CreatorInclude `json:"creators,omitempty"`
}

// ZoneState defines model for ZoneState.
type ZoneState struct {
	Changed DateTime `json:"changed"`

	// Current The current state of the zone.
	Current ZoneStateCurrent `json:"current"`

	// Error An error, if any, that has occurred for this resource.
	Error *struct {
		// Message Details about the error that has occurred.
		Message *string   `json:"message,omitempty"`
		Time    *DateTime `json:"time,omitempty"`
	} `json:"error,omitempty"`
}

// ZoneStateCurrent The current state of the zone.
type ZoneStateCurrent string

// PageParam defines model for PageParam.
type PageParam struct {
	// Number The page to jump to
	Number *float32 `json:"number,omitempty"`

	// Size The number of resources returned per page.
	Size *float32 `json:"size,omitempty"`
}

// SortParam defines model for SortParam.
type SortParam = []string

// DefaultError An error response.
type DefaultError = ErrorEnvelope

// GetDNSZonesParams defines parameters for GetDNSZones.
type GetDNSZonesParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetDNSZonesParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// State `filter[state]=value1,value2` state filtering will allow you to filter by the DNS Zone's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetDNSZonesParamsInclude defines parameters for GetDNSZones.
type GetDNSZonesParamsInclude string

// CreateDNSZoneJSONBody defines parameters for CreateDNSZone.
type CreateDNSZoneJSONBody struct {
	Acl *CreateDNSZoneJSONBody_Acl `json:"acl,omitempty"`

	// Hosted A boolean where true represents the desire for the origin to be of the type `hosted`.
	Hosted bool `json:"hosted"`

	// Origin The origin that will be created.
	Origin string `json:"origin"`
}

// CreateDNSZoneJSONBodyAcl1 defines parameters for CreateDNSZone.
type CreateDNSZoneJSONBodyAcl1 = map[string]interface{}

// CreateDNSZoneJSONBody_Acl defines parameters for CreateDNSZone.
type CreateDNSZoneJSONBody_Acl struct {
	union json.RawMessage
}

// UpdateDNSZoneJSONBody defines parameters for UpdateDNSZone.
type UpdateDNSZoneJSONBody struct {
	// Hosted A boolean where true represents the desire for the origin to be of the type `hosted`.
	Hosted *bool `json:"hosted"`
}

// UpdateDNSZoneParams defines parameters for UpdateDNSZone.
type UpdateDNSZoneParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]UpdateDNSZoneParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// UpdateDNSZoneParamsInclude defines parameters for UpdateDNSZone.
type UpdateDNSZoneParamsInclude string

// UpdateDNSZoneAccessJSONBody defines parameters for UpdateDNSZoneAccess.
type UpdateDNSZoneAccessJSONBody struct {
	Acl *UpdateDNSZoneAccessJSONBody_Acl `json:"acl,omitempty"`
}

// UpdateDNSZoneAccessParams defines parameters for UpdateDNSZoneAccess.
type UpdateDNSZoneAccessParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]UpdateDNSZoneAccessParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// UpdateDNSZoneAccessParamsInclude defines parameters for UpdateDNSZoneAccess.
type UpdateDNSZoneAccessParamsInclude string

// UpdateDNSZoneAccessJSONBodyAcl1 defines parameters for UpdateDNSZoneAccess.
type UpdateDNSZoneAccessJSONBodyAcl1 = map[string]interface{}

// UpdateDNSZoneAccessJSONBody_Acl defines parameters for UpdateDNSZoneAccess.
type UpdateDNSZoneAccessJSONBody_Acl struct {
	union json.RawMessage
}

// CreateDNSZoneJobJSONBody defines parameters for CreateDNSZoneJob.
type CreateDNSZoneJobJSONBody struct {
	// Action The action that the job will take.
	Action CreateDNSZoneJobJSONBodyAction `json:"action"`
}

// CreateDNSZoneJobJSONBodyAction defines parameters for CreateDNSZoneJob.
type CreateDNSZoneJobJSONBodyAction string

// GetEnvironmentsParams defines parameters for GetEnvironments.
type GetEnvironmentsParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetEnvironmentsParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetEnvironmentsParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		// Creator `filter[creator]=account-ID` filter for environments matching a particular creator, such as `account-ID`.
		Creator *string `json:"creator,omitempty"`

		// Identifier `filter[identifier]=value` List only those environments matching this identifier. May return multiple results.
		Identifier *string `json:"identifier,omitempty"`

		// Search `filter[search]=value` search for a value associated with a field on the given environment(s).
		Search *string `json:"search,omitempty"`

		// StackBuild `filter[stack_build]=ID` stack build filtering by ID.  Submit the ID of the stack build you wish to filter for and the return sill be any environments that have the stack build deployed to them.
		StackBuild *string `json:"stack_build,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the environment's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetEnvironmentsParamsMeta defines parameters for GetEnvironments.
type GetEnvironmentsParamsMeta string

// GetEnvironmentsParamsInclude defines parameters for GetEnvironments.
type GetEnvironmentsParamsInclude string

// CreateEnvironmentJSONBody defines parameters for CreateEnvironment.
type CreateEnvironmentJSONBody struct {
	// About Contains details regarding the Environment.
	About struct {
		// Description A custom description for this Environment.
		Description string `json:"description"`
	} `json:"about"`
	Acl *CreateEnvironmentJSONBody_Acl `json:"acl,omitempty"`

	// Cluster The cluster this Environment is associated with.
	Cluster string `json:"cluster"`

	// Features An object representing specialized features configured for this environment.
	Features EnvironmentFeatures `json:"features"`

	// Identifier A human-readable identifier used to refer to a resource, where using the official ID may be inconvenient.
	// The identifier is automatically tokenized from the name/relevant field of the resource if one is not provided. For example, a container named "My Container" will
	// have the identifier of `my-container` and is automatically created by the platform.
	//
	// The identifier does not have to be unique.
	Identifier *Identifier `json:"identifier,omitempty"`

	// Name A user defined name for the Environment.
	Name string `json:"name"`
}

// CreateEnvironmentJSONBodyAcl1 defines parameters for CreateEnvironment.
type CreateEnvironmentJSONBodyAcl1 = map[string]interface{}

// CreateEnvironmentJSONBody_Acl defines parameters for CreateEnvironment.
type CreateEnvironmentJSONBody_Acl struct {
	union json.RawMessage
}

// GetEnvironmentParams defines parameters for GetEnvironment.
type GetEnvironmentParams struct {
	// Meta A comma separated list of meta values. Meta values will show up under a resource's `meta` field. In the case of applying a meta to a collection of resources, each resource will have it's own relevant meta data. In some rare cases, meta may not apply to individual resources, and may appear in the root document. These will be clearly labeled.
	Meta *[]GetEnvironmentParamsMeta `form:"meta,omitempty" json:"meta,omitempty"`

	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetEnvironmentParamsInclude `form:"include,omitempty" json:"include,omitempty"`
}

// GetEnvironmentParamsMeta defines parameters for GetEnvironment.
type GetEnvironmentParamsMeta string

// GetEnvironmentParamsInclude defines parameters for GetEnvironment.
type GetEnvironmentParamsInclude string

// UpdateEnvironmentJSONBody defines parameters for UpdateEnvironment.
type UpdateEnvironmentJSONBody struct {
	About      *UpdateEnvironmentJSONBody_About `json:"about,omitempty"`
	Identifier *string                          `json:"identifier"`

	// Monitoring The level of monitoring to enable for this environment. There is a cost associated with higher levels of monitoring.
	Monitoring *struct {
		Tier UpdateEnvironmentJSONBodyMonitoringTier `json:"tier"`
	} `json:"monitoring"`
	Name    *string `json:"name"`
	Version *string `json:"version"`
}

// UpdateEnvironmentJSONBodyAbout1 defines parameters for UpdateEnvironment.
type UpdateEnvironmentJSONBodyAbout1 = map[string]interface{}

// UpdateEnvironmentJSONBody_About defines parameters for UpdateEnvironment.
type UpdateEnvironmentJSONBody_About struct {
	union json.RawMessage
}

// UpdateEnvironmentJSONBodyMonitoringTier defines parameters for UpdateEnvironment.
type UpdateEnvironmentJSONBodyMonitoringTier string

// UpdateEnvironmentAccessJSONBody defines parameters for UpdateEnvironmentAccess.
type UpdateEnvironmentAccessJSONBody struct {
	Acl *UpdateEnvironmentAccessJSONBody_Acl `json:"acl,omitempty"`
}

// UpdateEnvironmentAccessJSONBodyAcl1 defines parameters for UpdateEnvironmentAccess.
type UpdateEnvironmentAccessJSONBodyAcl1 = map[string]interface{}

// UpdateEnvironmentAccessJSONBody_Acl defines parameters for UpdateEnvironmentAccess.
type UpdateEnvironmentAccessJSONBody_Acl struct {
	union json.RawMessage
}

// ExportStackJSONBody defines parameters for ExportStack.
type ExportStackJSONBody struct {
	// DeploymentTags Defines which deployment containers to include in the stack export. By default, no containers tagged in a deployment are exported.
	// This option includes all containers with the specific, comma separated deployment tags in the final output in addition to the
	// containers that are not part of any deployment.
	DeploymentTags *[]string `json:"deployment_tags,omitempty"`

	// ResolveOrigins When set to true, Cycle will resolve image origins and inline them into the stack, essentially making this stack portable outside the hub it's currently used in.
	// By default, this is set to false, and the export will just reference existing image sources used by this stack in your hub by ID.
	ResolveOrigins *bool `json:"resolve_origins,omitempty"`
}

// CreateEnvironmentJobJSONBody defines parameters for CreateEnvironmentJob.
type CreateEnvironmentJobJSONBody struct {
	union json.RawMessage
}

// GetJobsParams defines parameters for GetJobs.
type GetJobsParams struct {
	// Include A comma separated list of include values. Included resources will show up under the root document's `include` field, with the key being the id of the included resource. In the case of applying an include to a collection of resources, if two resources share the same include, it will only appear once in the return.
	Include *[]GetJobsParamsInclude `form:"include,omitempty" json:"include,omitempty"`

	// Filter The filter field is a key-value object, where the key is what you would like to filter, and the value is the value you're filtering for.
	Filter *struct {
		RangeEnd   *DateTime `json:"range-end,omitempty"`
		RangeStart *DateTime `json:"range-start,omitempty"`

		// Search `filter[search]=value` search jobs for a value associated with a field on the given job(s).
		Search *string `json:"search,omitempty"`

		// State `filter[state]=value1,value2` state filtering will allow you to filter by the job's current state.
		State *string `json:"state,omitempty"`
	} `json:"filter,omitempty"`

	// Sort An array of sort values. To sort descending, put a `-` in front of the value, e.g. `-id`.
	Sort *SortParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Page In a list return, the data associated with the page number and size returned. 20 results per page, page 2 would be `page[size]=20&page[number]=2`
	Page *PageParam `json:"page,omitempty"`
}

// GetJobsParamsInclude defines parameters for GetJobs.
type GetJobsParamsInclude string

// CreateDNSZoneJSONRequestBody defines body for CreateDNSZone for application/json ContentType.
type CreateDNSZoneJSONRequestBody CreateDNSZoneJSONBody

// UpdateDNSZoneJSONRequestBody defines body for UpdateDNSZone for application/json ContentType.
type UpdateDNSZoneJSONRequestBody UpdateDNSZoneJSONBody

// UpdateDNSZoneAccessJSONRequestBody defines body for UpdateDNSZoneAccess for application/json ContentType.
type UpdateDNSZoneAccessJSONRequestBody UpdateDNSZoneAccessJSONBody

// CreateDNSZoneJobJSONRequestBody defines body for CreateDNSZoneJob for application/json ContentType.
type CreateDNSZoneJobJSONRequestBody CreateDNSZoneJobJSONBody

// CreateEnvironmentJSONRequestBody defines body for CreateEnvironment for application/json ContentType.
type CreateEnvironmentJSONRequestBody CreateEnvironmentJSONBody

// UpdateEnvironmentJSONRequestBody defines body for UpdateEnvironment for application/json ContentType.
type UpdateEnvironmentJSONRequestBody UpdateEnvironmentJSONBody

// UpdateEnvironmentAccessJSONRequestBody defines body for UpdateEnvironmentAccess for application/json ContentType.
type UpdateEnvironmentAccessJSONRequestBody UpdateEnvironmentAccessJSONBody

// ExportStackJSONRequestBody defines body for ExportStack for application/json ContentType.
type ExportStackJSONRequestBody ExportStackJSONBody

// CreateEnvironmentJobJSONRequestBody defines body for CreateEnvironmentJob for application/json ContentType.
type CreateEnvironmentJobJSONRequestBody CreateEnvironmentJobJSONBody

// Getter for additional properties for PublicAccount_Events. Returns the specified
// element and whether it was found
func (a PublicAccount_Events) Get(fieldName string) (value DateTime, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PublicAccount_Events
func (a *PublicAccount_Events) Set(fieldName string, value DateTime) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]DateTime)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PublicAccount_Events to handle AdditionalProperties
func (a *PublicAccount_Events) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["last_login"]; found {
		err = json.Unmarshal(raw, &a.LastLogin)
		if err != nil {
			return fmt.Errorf("error reading 'last_login': %w", err)
		}
		delete(object, "last_login")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]DateTime)
		for fieldName, fieldBuf := range object {
			var fieldVal DateTime
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PublicAccount_Events to handle AdditionalProperties
func (a PublicAccount_Events) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.LastLogin != nil {
		object["last_login"], err = json.Marshal(a.LastLogin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'last_login': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsIPNet returns the union data inside the ContainerEnvironmentSummary_Ipv6 as a IPNet
func (t ContainerEnvironmentSummary_Ipv6) AsIPNet() (IPNet, error) {
	var body IPNet
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIPNet overwrites any union data inside the ContainerEnvironmentSummary_Ipv6 as the provided IPNet
func (t *ContainerEnvironmentSummary_Ipv6) FromIPNet(v IPNet) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIPNet performs a merge with any union data inside the ContainerEnvironmentSummary_Ipv6, using the provided IPNet
func (t *ContainerEnvironmentSummary_Ipv6) MergeIPNet(v IPNet) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerEnvironmentSummaryIpv61 returns the union data inside the ContainerEnvironmentSummary_Ipv6 as a ContainerEnvironmentSummaryIpv61
func (t ContainerEnvironmentSummary_Ipv6) AsContainerEnvironmentSummaryIpv61() (ContainerEnvironmentSummaryIpv61, error) {
	var body ContainerEnvironmentSummaryIpv61
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerEnvironmentSummaryIpv61 overwrites any union data inside the ContainerEnvironmentSummary_Ipv6 as the provided ContainerEnvironmentSummaryIpv61
func (t *ContainerEnvironmentSummary_Ipv6) FromContainerEnvironmentSummaryIpv61(v ContainerEnvironmentSummaryIpv61) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerEnvironmentSummaryIpv61 performs a merge with any union data inside the ContainerEnvironmentSummary_Ipv6, using the provided ContainerEnvironmentSummaryIpv61
func (t *ContainerEnvironmentSummary_Ipv6) MergeContainerEnvironmentSummaryIpv61(v ContainerEnvironmentSummaryIpv61) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContainerEnvironmentSummary_Ipv6) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContainerEnvironmentSummary_Ipv6) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLegacyNetwork returns the union data inside the ContainerEnvironmentSummary_Legacy as a LegacyNetwork
func (t ContainerEnvironmentSummary_Legacy) AsLegacyNetwork() (LegacyNetwork, error) {
	var body LegacyNetwork
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegacyNetwork overwrites any union data inside the ContainerEnvironmentSummary_Legacy as the provided LegacyNetwork
func (t *ContainerEnvironmentSummary_Legacy) FromLegacyNetwork(v LegacyNetwork) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegacyNetwork performs a merge with any union data inside the ContainerEnvironmentSummary_Legacy, using the provided LegacyNetwork
func (t *ContainerEnvironmentSummary_Legacy) MergeLegacyNetwork(v LegacyNetwork) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerEnvironmentSummaryLegacy1 returns the union data inside the ContainerEnvironmentSummary_Legacy as a ContainerEnvironmentSummaryLegacy1
func (t ContainerEnvironmentSummary_Legacy) AsContainerEnvironmentSummaryLegacy1() (ContainerEnvironmentSummaryLegacy1, error) {
	var body ContainerEnvironmentSummaryLegacy1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerEnvironmentSummaryLegacy1 overwrites any union data inside the ContainerEnvironmentSummary_Legacy as the provided ContainerEnvironmentSummaryLegacy1
func (t *ContainerEnvironmentSummary_Legacy) FromContainerEnvironmentSummaryLegacy1(v ContainerEnvironmentSummaryLegacy1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerEnvironmentSummaryLegacy1 performs a merge with any union data inside the ContainerEnvironmentSummary_Legacy, using the provided ContainerEnvironmentSummaryLegacy1
func (t *ContainerEnvironmentSummary_Legacy) MergeContainerEnvironmentSummaryLegacy1(v ContainerEnvironmentSummaryLegacy1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContainerEnvironmentSummary_Legacy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContainerEnvironmentSummary_Legacy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsContainerImageSummaryService0 returns the union data inside the ContainerImageSummary_Service as a ContainerImageSummaryService0
func (t ContainerImageSummary_Service) AsContainerImageSummaryService0() (ContainerImageSummaryService0, error) {
	var body ContainerImageSummaryService0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerImageSummaryService0 overwrites any union data inside the ContainerImageSummary_Service as the provided ContainerImageSummaryService0
func (t *ContainerImageSummary_Service) FromContainerImageSummaryService0(v ContainerImageSummaryService0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerImageSummaryService0 performs a merge with any union data inside the ContainerImageSummary_Service, using the provided ContainerImageSummaryService0
func (t *ContainerImageSummary_Service) MergeContainerImageSummaryService0(v ContainerImageSummaryService0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerImageSummaryService1 returns the union data inside the ContainerImageSummary_Service as a ContainerImageSummaryService1
func (t ContainerImageSummary_Service) AsContainerImageSummaryService1() (ContainerImageSummaryService1, error) {
	var body ContainerImageSummaryService1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerImageSummaryService1 overwrites any union data inside the ContainerImageSummary_Service as the provided ContainerImageSummaryService1
func (t *ContainerImageSummary_Service) FromContainerImageSummaryService1(v ContainerImageSummaryService1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerImageSummaryService1 performs a merge with any union data inside the ContainerImageSummary_Service, using the provided ContainerImageSummaryService1
func (t *ContainerImageSummary_Service) MergeContainerImageSummaryService1(v ContainerImageSummaryService1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContainerImageSummary_Service) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContainerImageSummary_Service) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHaProxyConfig returns the union data inside the DefaultLbType_Details as a HaProxyConfig
func (t DefaultLbType_Details) AsHaProxyConfig() (HaProxyConfig, error) {
	var body HaProxyConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHaProxyConfig overwrites any union data inside the DefaultLbType_Details as the provided HaProxyConfig
func (t *DefaultLbType_Details) FromHaProxyConfig(v HaProxyConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHaProxyConfig performs a merge with any union data inside the DefaultLbType_Details, using the provided HaProxyConfig
func (t *DefaultLbType_Details) MergeHaProxyConfig(v HaProxyConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV1LbConfig returns the union data inside the DefaultLbType_Details as a V1LbConfig
func (t DefaultLbType_Details) AsV1LbConfig() (V1LbConfig, error) {
	var body V1LbConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbConfig overwrites any union data inside the DefaultLbType_Details as the provided V1LbConfig
func (t *DefaultLbType_Details) FromV1LbConfig(v V1LbConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbConfig performs a merge with any union data inside the DefaultLbType_Details, using the provided V1LbConfig
func (t *DefaultLbType_Details) MergeV1LbConfig(v V1LbConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDefaultLbTypeDetails2 returns the union data inside the DefaultLbType_Details as a DefaultLbTypeDetails2
func (t DefaultLbType_Details) AsDefaultLbTypeDetails2() (DefaultLbTypeDetails2, error) {
	var body DefaultLbTypeDetails2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDefaultLbTypeDetails2 overwrites any union data inside the DefaultLbType_Details as the provided DefaultLbTypeDetails2
func (t *DefaultLbType_Details) FromDefaultLbTypeDetails2(v DefaultLbTypeDetails2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDefaultLbTypeDetails2 performs a merge with any union data inside the DefaultLbType_Details, using the provided DefaultLbTypeDetails2
func (t *DefaultLbType_Details) MergeDefaultLbTypeDetails2(v DefaultLbTypeDetails2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DefaultLbType_Details) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DefaultLbType_Details) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the DiscoveryConfig_EmptySetDelay as a Duration
func (t DiscoveryConfig_EmptySetDelay) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the DiscoveryConfig_EmptySetDelay as the provided Duration
func (t *DiscoveryConfig_EmptySetDelay) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the DiscoveryConfig_EmptySetDelay, using the provided Duration
func (t *DiscoveryConfig_EmptySetDelay) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDiscoveryConfigEmptySetDelay1 returns the union data inside the DiscoveryConfig_EmptySetDelay as a DiscoveryConfigEmptySetDelay1
func (t DiscoveryConfig_EmptySetDelay) AsDiscoveryConfigEmptySetDelay1() (DiscoveryConfigEmptySetDelay1, error) {
	var body DiscoveryConfigEmptySetDelay1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscoveryConfigEmptySetDelay1 overwrites any union data inside the DiscoveryConfig_EmptySetDelay as the provided DiscoveryConfigEmptySetDelay1
func (t *DiscoveryConfig_EmptySetDelay) FromDiscoveryConfigEmptySetDelay1(v DiscoveryConfigEmptySetDelay1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscoveryConfigEmptySetDelay1 performs a merge with any union data inside the DiscoveryConfig_EmptySetDelay, using the provided DiscoveryConfigEmptySetDelay1
func (t *DiscoveryConfig_EmptySetDelay) MergeDiscoveryConfigEmptySetDelay1(v DiscoveryConfigEmptySetDelay1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DiscoveryConfig_EmptySetDelay) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DiscoveryConfig_EmptySetDelay) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDiscoveryConfig returns the union data inside the DiscoveryEnvironmentService_Config as a DiscoveryConfig
func (t DiscoveryEnvironmentService_Config) AsDiscoveryConfig() (DiscoveryConfig, error) {
	var body DiscoveryConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscoveryConfig overwrites any union data inside the DiscoveryEnvironmentService_Config as the provided DiscoveryConfig
func (t *DiscoveryEnvironmentService_Config) FromDiscoveryConfig(v DiscoveryConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscoveryConfig performs a merge with any union data inside the DiscoveryEnvironmentService_Config, using the provided DiscoveryConfig
func (t *DiscoveryEnvironmentService_Config) MergeDiscoveryConfig(v DiscoveryConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDiscoveryEnvironmentServiceConfig1 returns the union data inside the DiscoveryEnvironmentService_Config as a DiscoveryEnvironmentServiceConfig1
func (t DiscoveryEnvironmentService_Config) AsDiscoveryEnvironmentServiceConfig1() (DiscoveryEnvironmentServiceConfig1, error) {
	var body DiscoveryEnvironmentServiceConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscoveryEnvironmentServiceConfig1 overwrites any union data inside the DiscoveryEnvironmentService_Config as the provided DiscoveryEnvironmentServiceConfig1
func (t *DiscoveryEnvironmentService_Config) FromDiscoveryEnvironmentServiceConfig1(v DiscoveryEnvironmentServiceConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscoveryEnvironmentServiceConfig1 performs a merge with any union data inside the DiscoveryEnvironmentService_Config, using the provided DiscoveryEnvironmentServiceConfig1
func (t *DiscoveryEnvironmentService_Config) MergeDiscoveryEnvironmentServiceConfig1(v DiscoveryEnvironmentServiceConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DiscoveryEnvironmentService_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DiscoveryEnvironmentService_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDockerfileCredentials returns the union data inside the DockerFileOrigin_Details_Credentials as a DockerfileCredentials
func (t DockerFileOrigin_Details_Credentials) AsDockerfileCredentials() (DockerfileCredentials, error) {
	var body DockerfileCredentials
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerfileCredentials overwrites any union data inside the DockerFileOrigin_Details_Credentials as the provided DockerfileCredentials
func (t *DockerFileOrigin_Details_Credentials) FromDockerfileCredentials(v DockerfileCredentials) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerfileCredentials performs a merge with any union data inside the DockerFileOrigin_Details_Credentials, using the provided DockerfileCredentials
func (t *DockerFileOrigin_Details_Credentials) MergeDockerfileCredentials(v DockerfileCredentials) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerFileOriginDetailsCredentials1 returns the union data inside the DockerFileOrigin_Details_Credentials as a DockerFileOriginDetailsCredentials1
func (t DockerFileOrigin_Details_Credentials) AsDockerFileOriginDetailsCredentials1() (DockerFileOriginDetailsCredentials1, error) {
	var body DockerFileOriginDetailsCredentials1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerFileOriginDetailsCredentials1 overwrites any union data inside the DockerFileOrigin_Details_Credentials as the provided DockerFileOriginDetailsCredentials1
func (t *DockerFileOrigin_Details_Credentials) FromDockerFileOriginDetailsCredentials1(v DockerFileOriginDetailsCredentials1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerFileOriginDetailsCredentials1 performs a merge with any union data inside the DockerFileOrigin_Details_Credentials, using the provided DockerFileOriginDetailsCredentials1
func (t *DockerFileOrigin_Details_Credentials) MergeDockerFileOriginDetailsCredentials1(v DockerFileOriginDetailsCredentials1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DockerFileOrigin_Details_Credentials) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DockerFileOrigin_Details_Credentials) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsExistingSource returns the union data inside the DockerFileOrigin_Details_Existing as a ExistingSource
func (t DockerFileOrigin_Details_Existing) AsExistingSource() (ExistingSource, error) {
	var body ExistingSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExistingSource overwrites any union data inside the DockerFileOrigin_Details_Existing as the provided ExistingSource
func (t *DockerFileOrigin_Details_Existing) FromExistingSource(v ExistingSource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExistingSource performs a merge with any union data inside the DockerFileOrigin_Details_Existing, using the provided ExistingSource
func (t *DockerFileOrigin_Details_Existing) MergeExistingSource(v ExistingSource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerFileOriginDetailsExisting1 returns the union data inside the DockerFileOrigin_Details_Existing as a DockerFileOriginDetailsExisting1
func (t DockerFileOrigin_Details_Existing) AsDockerFileOriginDetailsExisting1() (DockerFileOriginDetailsExisting1, error) {
	var body DockerFileOriginDetailsExisting1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerFileOriginDetailsExisting1 overwrites any union data inside the DockerFileOrigin_Details_Existing as the provided DockerFileOriginDetailsExisting1
func (t *DockerFileOrigin_Details_Existing) FromDockerFileOriginDetailsExisting1(v DockerFileOriginDetailsExisting1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerFileOriginDetailsExisting1 performs a merge with any union data inside the DockerFileOrigin_Details_Existing, using the provided DockerFileOriginDetailsExisting1
func (t *DockerFileOrigin_Details_Existing) MergeDockerFileOriginDetailsExisting1(v DockerFileOriginDetailsExisting1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DockerFileOrigin_Details_Existing) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DockerFileOrigin_Details_Existing) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRepoType returns the union data inside the DockerFileOrigin_Details_Repo as a RepoType
func (t DockerFileOrigin_Details_Repo) AsRepoType() (RepoType, error) {
	var body RepoType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRepoType overwrites any union data inside the DockerFileOrigin_Details_Repo as the provided RepoType
func (t *DockerFileOrigin_Details_Repo) FromRepoType(v RepoType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRepoType performs a merge with any union data inside the DockerFileOrigin_Details_Repo, using the provided RepoType
func (t *DockerFileOrigin_Details_Repo) MergeRepoType(v RepoType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerFileOriginDetailsRepo1 returns the union data inside the DockerFileOrigin_Details_Repo as a DockerFileOriginDetailsRepo1
func (t DockerFileOrigin_Details_Repo) AsDockerFileOriginDetailsRepo1() (DockerFileOriginDetailsRepo1, error) {
	var body DockerFileOriginDetailsRepo1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerFileOriginDetailsRepo1 overwrites any union data inside the DockerFileOrigin_Details_Repo as the provided DockerFileOriginDetailsRepo1
func (t *DockerFileOrigin_Details_Repo) FromDockerFileOriginDetailsRepo1(v DockerFileOriginDetailsRepo1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerFileOriginDetailsRepo1 performs a merge with any union data inside the DockerFileOrigin_Details_Repo, using the provided DockerFileOriginDetailsRepo1
func (t *DockerFileOrigin_Details_Repo) MergeDockerFileOriginDetailsRepo1(v DockerFileOriginDetailsRepo1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DockerFileOrigin_Details_Repo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DockerFileOrigin_Details_Repo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsExistingSource returns the union data inside the DockerHubOrigin_Details_Existing as a ExistingSource
func (t DockerHubOrigin_Details_Existing) AsExistingSource() (ExistingSource, error) {
	var body ExistingSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExistingSource overwrites any union data inside the DockerHubOrigin_Details_Existing as the provided ExistingSource
func (t *DockerHubOrigin_Details_Existing) FromExistingSource(v ExistingSource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExistingSource performs a merge with any union data inside the DockerHubOrigin_Details_Existing, using the provided ExistingSource
func (t *DockerHubOrigin_Details_Existing) MergeExistingSource(v ExistingSource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerHubOriginDetailsExisting1 returns the union data inside the DockerHubOrigin_Details_Existing as a DockerHubOriginDetailsExisting1
func (t DockerHubOrigin_Details_Existing) AsDockerHubOriginDetailsExisting1() (DockerHubOriginDetailsExisting1, error) {
	var body DockerHubOriginDetailsExisting1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerHubOriginDetailsExisting1 overwrites any union data inside the DockerHubOrigin_Details_Existing as the provided DockerHubOriginDetailsExisting1
func (t *DockerHubOrigin_Details_Existing) FromDockerHubOriginDetailsExisting1(v DockerHubOriginDetailsExisting1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerHubOriginDetailsExisting1 performs a merge with any union data inside the DockerHubOrigin_Details_Existing, using the provided DockerHubOriginDetailsExisting1
func (t *DockerHubOrigin_Details_Existing) MergeDockerHubOriginDetailsExisting1(v DockerHubOriginDetailsExisting1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DockerHubOrigin_Details_Existing) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DockerHubOrigin_Details_Existing) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsACL returns the union data inside the Environment_Acl as a ACL
func (t Environment_Acl) AsACL() (ACL, error) {
	var body ACL
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromACL overwrites any union data inside the Environment_Acl as the provided ACL
func (t *Environment_Acl) FromACL(v ACL) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeACL performs a merge with any union data inside the Environment_Acl, using the provided ACL
func (t *Environment_Acl) MergeACL(v ACL) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentAcl1 returns the union data inside the Environment_Acl as a EnvironmentAcl1
func (t Environment_Acl) AsEnvironmentAcl1() (EnvironmentAcl1, error) {
	var body EnvironmentAcl1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentAcl1 overwrites any union data inside the Environment_Acl as the provided EnvironmentAcl1
func (t *Environment_Acl) FromEnvironmentAcl1(v EnvironmentAcl1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentAcl1 performs a merge with any union data inside the Environment_Acl, using the provided EnvironmentAcl1
func (t *Environment_Acl) MergeEnvironmentAcl1(v EnvironmentAcl1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Environment_Acl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Environment_Acl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPrivateNetwork returns the union data inside the Environment_PrivateNetwork as a PrivateNetwork
func (t Environment_PrivateNetwork) AsPrivateNetwork() (PrivateNetwork, error) {
	var body PrivateNetwork
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrivateNetwork overwrites any union data inside the Environment_PrivateNetwork as the provided PrivateNetwork
func (t *Environment_PrivateNetwork) FromPrivateNetwork(v PrivateNetwork) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrivateNetwork performs a merge with any union data inside the Environment_PrivateNetwork, using the provided PrivateNetwork
func (t *Environment_PrivateNetwork) MergePrivateNetwork(v PrivateNetwork) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentPrivateNetwork1 returns the union data inside the Environment_PrivateNetwork as a EnvironmentPrivateNetwork1
func (t Environment_PrivateNetwork) AsEnvironmentPrivateNetwork1() (EnvironmentPrivateNetwork1, error) {
	var body EnvironmentPrivateNetwork1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentPrivateNetwork1 overwrites any union data inside the Environment_PrivateNetwork as the provided EnvironmentPrivateNetwork1
func (t *Environment_PrivateNetwork) FromEnvironmentPrivateNetwork1(v EnvironmentPrivateNetwork1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentPrivateNetwork1 performs a merge with any union data inside the Environment_PrivateNetwork, using the provided EnvironmentPrivateNetwork1
func (t *Environment_PrivateNetwork) MergeEnvironmentPrivateNetwork1(v EnvironmentPrivateNetwork1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Environment_PrivateNetwork) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Environment_PrivateNetwork) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsID returns the union data inside the EnvironmentServiceContainerSummary_ContainerId as a ID
func (t EnvironmentServiceContainerSummary_ContainerId) AsID() (ID, error) {
	var body ID
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromID overwrites any union data inside the EnvironmentServiceContainerSummary_ContainerId as the provided ID
func (t *EnvironmentServiceContainerSummary_ContainerId) FromID(v ID) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeID performs a merge with any union data inside the EnvironmentServiceContainerSummary_ContainerId, using the provided ID
func (t *EnvironmentServiceContainerSummary_ContainerId) MergeID(v ID) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentServiceContainerSummaryContainerId1 returns the union data inside the EnvironmentServiceContainerSummary_ContainerId as a EnvironmentServiceContainerSummaryContainerId1
func (t EnvironmentServiceContainerSummary_ContainerId) AsEnvironmentServiceContainerSummaryContainerId1() (EnvironmentServiceContainerSummaryContainerId1, error) {
	var body EnvironmentServiceContainerSummaryContainerId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentServiceContainerSummaryContainerId1 overwrites any union data inside the EnvironmentServiceContainerSummary_ContainerId as the provided EnvironmentServiceContainerSummaryContainerId1
func (t *EnvironmentServiceContainerSummary_ContainerId) FromEnvironmentServiceContainerSummaryContainerId1(v EnvironmentServiceContainerSummaryContainerId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentServiceContainerSummaryContainerId1 performs a merge with any union data inside the EnvironmentServiceContainerSummary_ContainerId, using the provided EnvironmentServiceContainerSummaryContainerId1
func (t *EnvironmentServiceContainerSummary_ContainerId) MergeEnvironmentServiceContainerSummaryContainerId1(v EnvironmentServiceContainerSummaryContainerId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentServiceContainerSummary_ContainerId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentServiceContainerSummary_ContainerId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDiscoveryEnvironmentService returns the union data inside the EnvironmentServices_Discovery as a DiscoveryEnvironmentService
func (t EnvironmentServices_Discovery) AsDiscoveryEnvironmentService() (DiscoveryEnvironmentService, error) {
	var body DiscoveryEnvironmentService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDiscoveryEnvironmentService overwrites any union data inside the EnvironmentServices_Discovery as the provided DiscoveryEnvironmentService
func (t *EnvironmentServices_Discovery) FromDiscoveryEnvironmentService(v DiscoveryEnvironmentService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDiscoveryEnvironmentService performs a merge with any union data inside the EnvironmentServices_Discovery, using the provided DiscoveryEnvironmentService
func (t *EnvironmentServices_Discovery) MergeDiscoveryEnvironmentService(v DiscoveryEnvironmentService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentServicesDiscovery1 returns the union data inside the EnvironmentServices_Discovery as a EnvironmentServicesDiscovery1
func (t EnvironmentServices_Discovery) AsEnvironmentServicesDiscovery1() (EnvironmentServicesDiscovery1, error) {
	var body EnvironmentServicesDiscovery1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentServicesDiscovery1 overwrites any union data inside the EnvironmentServices_Discovery as the provided EnvironmentServicesDiscovery1
func (t *EnvironmentServices_Discovery) FromEnvironmentServicesDiscovery1(v EnvironmentServicesDiscovery1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentServicesDiscovery1 performs a merge with any union data inside the EnvironmentServices_Discovery, using the provided EnvironmentServicesDiscovery1
func (t *EnvironmentServices_Discovery) MergeEnvironmentServicesDiscovery1(v EnvironmentServicesDiscovery1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentServices_Discovery) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentServices_Discovery) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLoadBalancerEnvironmentService returns the union data inside the EnvironmentServices_Loadbalancer as a LoadBalancerEnvironmentService
func (t EnvironmentServices_Loadbalancer) AsLoadBalancerEnvironmentService() (LoadBalancerEnvironmentService, error) {
	var body LoadBalancerEnvironmentService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLoadBalancerEnvironmentService overwrites any union data inside the EnvironmentServices_Loadbalancer as the provided LoadBalancerEnvironmentService
func (t *EnvironmentServices_Loadbalancer) FromLoadBalancerEnvironmentService(v LoadBalancerEnvironmentService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLoadBalancerEnvironmentService performs a merge with any union data inside the EnvironmentServices_Loadbalancer, using the provided LoadBalancerEnvironmentService
func (t *EnvironmentServices_Loadbalancer) MergeLoadBalancerEnvironmentService(v LoadBalancerEnvironmentService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentServicesLoadbalancer1 returns the union data inside the EnvironmentServices_Loadbalancer as a EnvironmentServicesLoadbalancer1
func (t EnvironmentServices_Loadbalancer) AsEnvironmentServicesLoadbalancer1() (EnvironmentServicesLoadbalancer1, error) {
	var body EnvironmentServicesLoadbalancer1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentServicesLoadbalancer1 overwrites any union data inside the EnvironmentServices_Loadbalancer as the provided EnvironmentServicesLoadbalancer1
func (t *EnvironmentServices_Loadbalancer) FromEnvironmentServicesLoadbalancer1(v EnvironmentServicesLoadbalancer1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentServicesLoadbalancer1 performs a merge with any union data inside the EnvironmentServices_Loadbalancer, using the provided EnvironmentServicesLoadbalancer1
func (t *EnvironmentServices_Loadbalancer) MergeEnvironmentServicesLoadbalancer1(v EnvironmentServicesLoadbalancer1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentServices_Loadbalancer) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentServices_Loadbalancer) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSchedulerEnvironmentService returns the union data inside the EnvironmentServices_Scheduler as a SchedulerEnvironmentService
func (t EnvironmentServices_Scheduler) AsSchedulerEnvironmentService() (SchedulerEnvironmentService, error) {
	var body SchedulerEnvironmentService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchedulerEnvironmentService overwrites any union data inside the EnvironmentServices_Scheduler as the provided SchedulerEnvironmentService
func (t *EnvironmentServices_Scheduler) FromSchedulerEnvironmentService(v SchedulerEnvironmentService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchedulerEnvironmentService performs a merge with any union data inside the EnvironmentServices_Scheduler, using the provided SchedulerEnvironmentService
func (t *EnvironmentServices_Scheduler) MergeSchedulerEnvironmentService(v SchedulerEnvironmentService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentServicesScheduler1 returns the union data inside the EnvironmentServices_Scheduler as a EnvironmentServicesScheduler1
func (t EnvironmentServices_Scheduler) AsEnvironmentServicesScheduler1() (EnvironmentServicesScheduler1, error) {
	var body EnvironmentServicesScheduler1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentServicesScheduler1 overwrites any union data inside the EnvironmentServices_Scheduler as the provided EnvironmentServicesScheduler1
func (t *EnvironmentServices_Scheduler) FromEnvironmentServicesScheduler1(v EnvironmentServicesScheduler1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentServicesScheduler1 performs a merge with any union data inside the EnvironmentServices_Scheduler, using the provided EnvironmentServicesScheduler1
func (t *EnvironmentServices_Scheduler) MergeEnvironmentServicesScheduler1(v EnvironmentServicesScheduler1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentServices_Scheduler) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentServices_Scheduler) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVpnEnvironmentService returns the union data inside the EnvironmentServices_Vpn as a VpnEnvironmentService
func (t EnvironmentServices_Vpn) AsVpnEnvironmentService() (VpnEnvironmentService, error) {
	var body VpnEnvironmentService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVpnEnvironmentService overwrites any union data inside the EnvironmentServices_Vpn as the provided VpnEnvironmentService
func (t *EnvironmentServices_Vpn) FromVpnEnvironmentService(v VpnEnvironmentService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVpnEnvironmentService performs a merge with any union data inside the EnvironmentServices_Vpn, using the provided VpnEnvironmentService
func (t *EnvironmentServices_Vpn) MergeVpnEnvironmentService(v VpnEnvironmentService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentServicesVpn1 returns the union data inside the EnvironmentServices_Vpn as a EnvironmentServicesVpn1
func (t EnvironmentServices_Vpn) AsEnvironmentServicesVpn1() (EnvironmentServicesVpn1, error) {
	var body EnvironmentServicesVpn1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentServicesVpn1 overwrites any union data inside the EnvironmentServices_Vpn as the provided EnvironmentServicesVpn1
func (t *EnvironmentServices_Vpn) FromEnvironmentServicesVpn1(v EnvironmentServicesVpn1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentServicesVpn1 performs a merge with any union data inside the EnvironmentServices_Vpn, using the provided EnvironmentServicesVpn1
func (t *EnvironmentServices_Vpn) MergeEnvironmentServicesVpn1(v EnvironmentServicesVpn1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentServices_Vpn) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentServices_Vpn) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentServiceContainerSummary returns the union data inside the EnvironmentSummary_Services_Discovery as a EnvironmentServiceContainerSummary
func (t EnvironmentSummary_Services_Discovery) AsEnvironmentServiceContainerSummary() (EnvironmentServiceContainerSummary, error) {
	var body EnvironmentServiceContainerSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentServiceContainerSummary overwrites any union data inside the EnvironmentSummary_Services_Discovery as the provided EnvironmentServiceContainerSummary
func (t *EnvironmentSummary_Services_Discovery) FromEnvironmentServiceContainerSummary(v EnvironmentServiceContainerSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentServiceContainerSummary performs a merge with any union data inside the EnvironmentSummary_Services_Discovery, using the provided EnvironmentServiceContainerSummary
func (t *EnvironmentSummary_Services_Discovery) MergeEnvironmentServiceContainerSummary(v EnvironmentServiceContainerSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentSummaryServicesDiscovery1 returns the union data inside the EnvironmentSummary_Services_Discovery as a EnvironmentSummaryServicesDiscovery1
func (t EnvironmentSummary_Services_Discovery) AsEnvironmentSummaryServicesDiscovery1() (EnvironmentSummaryServicesDiscovery1, error) {
	var body EnvironmentSummaryServicesDiscovery1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentSummaryServicesDiscovery1 overwrites any union data inside the EnvironmentSummary_Services_Discovery as the provided EnvironmentSummaryServicesDiscovery1
func (t *EnvironmentSummary_Services_Discovery) FromEnvironmentSummaryServicesDiscovery1(v EnvironmentSummaryServicesDiscovery1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentSummaryServicesDiscovery1 performs a merge with any union data inside the EnvironmentSummary_Services_Discovery, using the provided EnvironmentSummaryServicesDiscovery1
func (t *EnvironmentSummary_Services_Discovery) MergeEnvironmentSummaryServicesDiscovery1(v EnvironmentSummaryServicesDiscovery1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentSummary_Services_Discovery) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentSummary_Services_Discovery) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentServiceContainerSummary returns the union data inside the EnvironmentSummary_Services_Loadbalancer as a EnvironmentServiceContainerSummary
func (t EnvironmentSummary_Services_Loadbalancer) AsEnvironmentServiceContainerSummary() (EnvironmentServiceContainerSummary, error) {
	var body EnvironmentServiceContainerSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentServiceContainerSummary overwrites any union data inside the EnvironmentSummary_Services_Loadbalancer as the provided EnvironmentServiceContainerSummary
func (t *EnvironmentSummary_Services_Loadbalancer) FromEnvironmentServiceContainerSummary(v EnvironmentServiceContainerSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentServiceContainerSummary performs a merge with any union data inside the EnvironmentSummary_Services_Loadbalancer, using the provided EnvironmentServiceContainerSummary
func (t *EnvironmentSummary_Services_Loadbalancer) MergeEnvironmentServiceContainerSummary(v EnvironmentServiceContainerSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentSummaryServicesLoadbalancer1 returns the union data inside the EnvironmentSummary_Services_Loadbalancer as a EnvironmentSummaryServicesLoadbalancer1
func (t EnvironmentSummary_Services_Loadbalancer) AsEnvironmentSummaryServicesLoadbalancer1() (EnvironmentSummaryServicesLoadbalancer1, error) {
	var body EnvironmentSummaryServicesLoadbalancer1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentSummaryServicesLoadbalancer1 overwrites any union data inside the EnvironmentSummary_Services_Loadbalancer as the provided EnvironmentSummaryServicesLoadbalancer1
func (t *EnvironmentSummary_Services_Loadbalancer) FromEnvironmentSummaryServicesLoadbalancer1(v EnvironmentSummaryServicesLoadbalancer1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentSummaryServicesLoadbalancer1 performs a merge with any union data inside the EnvironmentSummary_Services_Loadbalancer, using the provided EnvironmentSummaryServicesLoadbalancer1
func (t *EnvironmentSummary_Services_Loadbalancer) MergeEnvironmentSummaryServicesLoadbalancer1(v EnvironmentSummaryServicesLoadbalancer1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentSummary_Services_Loadbalancer) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentSummary_Services_Loadbalancer) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentServiceContainerSummary returns the union data inside the EnvironmentSummary_Services_Scheduler as a EnvironmentServiceContainerSummary
func (t EnvironmentSummary_Services_Scheduler) AsEnvironmentServiceContainerSummary() (EnvironmentServiceContainerSummary, error) {
	var body EnvironmentServiceContainerSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentServiceContainerSummary overwrites any union data inside the EnvironmentSummary_Services_Scheduler as the provided EnvironmentServiceContainerSummary
func (t *EnvironmentSummary_Services_Scheduler) FromEnvironmentServiceContainerSummary(v EnvironmentServiceContainerSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentServiceContainerSummary performs a merge with any union data inside the EnvironmentSummary_Services_Scheduler, using the provided EnvironmentServiceContainerSummary
func (t *EnvironmentSummary_Services_Scheduler) MergeEnvironmentServiceContainerSummary(v EnvironmentServiceContainerSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentSummaryServicesScheduler1 returns the union data inside the EnvironmentSummary_Services_Scheduler as a EnvironmentSummaryServicesScheduler1
func (t EnvironmentSummary_Services_Scheduler) AsEnvironmentSummaryServicesScheduler1() (EnvironmentSummaryServicesScheduler1, error) {
	var body EnvironmentSummaryServicesScheduler1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentSummaryServicesScheduler1 overwrites any union data inside the EnvironmentSummary_Services_Scheduler as the provided EnvironmentSummaryServicesScheduler1
func (t *EnvironmentSummary_Services_Scheduler) FromEnvironmentSummaryServicesScheduler1(v EnvironmentSummaryServicesScheduler1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentSummaryServicesScheduler1 performs a merge with any union data inside the EnvironmentSummary_Services_Scheduler, using the provided EnvironmentSummaryServicesScheduler1
func (t *EnvironmentSummary_Services_Scheduler) MergeEnvironmentSummaryServicesScheduler1(v EnvironmentSummaryServicesScheduler1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentSummary_Services_Scheduler) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentSummary_Services_Scheduler) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEnvironmentServiceContainerSummary returns the union data inside the EnvironmentSummary_Services_Vpn as a EnvironmentServiceContainerSummary
func (t EnvironmentSummary_Services_Vpn) AsEnvironmentServiceContainerSummary() (EnvironmentServiceContainerSummary, error) {
	var body EnvironmentServiceContainerSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentServiceContainerSummary overwrites any union data inside the EnvironmentSummary_Services_Vpn as the provided EnvironmentServiceContainerSummary
func (t *EnvironmentSummary_Services_Vpn) FromEnvironmentServiceContainerSummary(v EnvironmentServiceContainerSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentServiceContainerSummary performs a merge with any union data inside the EnvironmentSummary_Services_Vpn, using the provided EnvironmentServiceContainerSummary
func (t *EnvironmentSummary_Services_Vpn) MergeEnvironmentServiceContainerSummary(v EnvironmentServiceContainerSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEnvironmentSummaryServicesVpn1 returns the union data inside the EnvironmentSummary_Services_Vpn as a EnvironmentSummaryServicesVpn1
func (t EnvironmentSummary_Services_Vpn) AsEnvironmentSummaryServicesVpn1() (EnvironmentSummaryServicesVpn1, error) {
	var body EnvironmentSummaryServicesVpn1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEnvironmentSummaryServicesVpn1 overwrites any union data inside the EnvironmentSummary_Services_Vpn as the provided EnvironmentSummaryServicesVpn1
func (t *EnvironmentSummary_Services_Vpn) FromEnvironmentSummaryServicesVpn1(v EnvironmentSummaryServicesVpn1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEnvironmentSummaryServicesVpn1 performs a merge with any union data inside the EnvironmentSummary_Services_Vpn, using the provided EnvironmentSummaryServicesVpn1
func (t *EnvironmentSummary_Services_Vpn) MergeEnvironmentSummaryServicesVpn1(v EnvironmentSummaryServicesVpn1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EnvironmentSummary_Services_Vpn) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EnvironmentSummary_Services_Vpn) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHaProxyConfig returns the union data inside the HaProxyLbType_Details as a HaProxyConfig
func (t HaProxyLbType_Details) AsHaProxyConfig() (HaProxyConfig, error) {
	var body HaProxyConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHaProxyConfig overwrites any union data inside the HaProxyLbType_Details as the provided HaProxyConfig
func (t *HaProxyLbType_Details) FromHaProxyConfig(v HaProxyConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHaProxyConfig performs a merge with any union data inside the HaProxyLbType_Details, using the provided HaProxyConfig
func (t *HaProxyLbType_Details) MergeHaProxyConfig(v HaProxyConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHaProxyLbTypeDetails1 returns the union data inside the HaProxyLbType_Details as a HaProxyLbTypeDetails1
func (t HaProxyLbType_Details) AsHaProxyLbTypeDetails1() (HaProxyLbTypeDetails1, error) {
	var body HaProxyLbTypeDetails1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHaProxyLbTypeDetails1 overwrites any union data inside the HaProxyLbType_Details as the provided HaProxyLbTypeDetails1
func (t *HaProxyLbType_Details) FromHaProxyLbTypeDetails1(v HaProxyLbTypeDetails1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHaProxyLbTypeDetails1 performs a merge with any union data inside the HaProxyLbType_Details, using the provided HaProxyLbTypeDetails1
func (t *HaProxyLbType_Details) MergeHaProxyLbTypeDetails1(v HaProxyLbTypeDetails1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t HaProxyLbType_Details) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *HaProxyLbType_Details) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIPNet returns the union data inside the LegacyNetwork_Ipv4 as a IPNet
func (t LegacyNetwork_Ipv4) AsIPNet() (IPNet, error) {
	var body IPNet
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIPNet overwrites any union data inside the LegacyNetwork_Ipv4 as the provided IPNet
func (t *LegacyNetwork_Ipv4) FromIPNet(v IPNet) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIPNet performs a merge with any union data inside the LegacyNetwork_Ipv4, using the provided IPNet
func (t *LegacyNetwork_Ipv4) MergeIPNet(v IPNet) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLegacyNetworkIpv41 returns the union data inside the LegacyNetwork_Ipv4 as a LegacyNetworkIpv41
func (t LegacyNetwork_Ipv4) AsLegacyNetworkIpv41() (LegacyNetworkIpv41, error) {
	var body LegacyNetworkIpv41
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegacyNetworkIpv41 overwrites any union data inside the LegacyNetwork_Ipv4 as the provided LegacyNetworkIpv41
func (t *LegacyNetwork_Ipv4) FromLegacyNetworkIpv41(v LegacyNetworkIpv41) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegacyNetworkIpv41 performs a merge with any union data inside the LegacyNetwork_Ipv4, using the provided LegacyNetworkIpv41
func (t *LegacyNetwork_Ipv4) MergeLegacyNetworkIpv41(v LegacyNetworkIpv41) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LegacyNetwork_Ipv4) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LegacyNetwork_Ipv4) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsV1LbType returns the union data inside the LoadBalancerConfig as a V1LbType
func (t LoadBalancerConfig) AsV1LbType() (V1LbType, error) {
	var body V1LbType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbType overwrites any union data inside the LoadBalancerConfig as the provided V1LbType
func (t *LoadBalancerConfig) FromV1LbType(v V1LbType) error {
	v.Type = "v1"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbType performs a merge with any union data inside the LoadBalancerConfig, using the provided V1LbType
func (t *LoadBalancerConfig) MergeV1LbType(v V1LbType) error {
	v.Type = "v1"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHaProxyLbType returns the union data inside the LoadBalancerConfig as a HaProxyLbType
func (t LoadBalancerConfig) AsHaProxyLbType() (HaProxyLbType, error) {
	var body HaProxyLbType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHaProxyLbType overwrites any union data inside the LoadBalancerConfig as the provided HaProxyLbType
func (t *LoadBalancerConfig) FromHaProxyLbType(v HaProxyLbType) error {
	v.Type = "haproxy"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHaProxyLbType performs a merge with any union data inside the LoadBalancerConfig, using the provided HaProxyLbType
func (t *LoadBalancerConfig) MergeHaProxyLbType(v HaProxyLbType) error {
	v.Type = "haproxy"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDefaultLbType returns the union data inside the LoadBalancerConfig as a DefaultLbType
func (t LoadBalancerConfig) AsDefaultLbType() (DefaultLbType, error) {
	var body DefaultLbType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDefaultLbType overwrites any union data inside the LoadBalancerConfig as the provided DefaultLbType
func (t *LoadBalancerConfig) FromDefaultLbType(v DefaultLbType) error {
	v.Type = "default"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDefaultLbType performs a merge with any union data inside the LoadBalancerConfig, using the provided DefaultLbType
func (t *LoadBalancerConfig) MergeDefaultLbType(v DefaultLbType) error {
	v.Type = "default"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LoadBalancerConfig) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t LoadBalancerConfig) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "default":
		return t.AsDefaultLbType()
	case "haproxy":
		return t.AsHaProxyLbType()
	case "v1":
		return t.AsV1LbType()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t LoadBalancerConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LoadBalancerConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLoadBalancerConfig returns the union data inside the LoadBalancerEnvironmentService_Config as a LoadBalancerConfig
func (t LoadBalancerEnvironmentService_Config) AsLoadBalancerConfig() (LoadBalancerConfig, error) {
	var body LoadBalancerConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLoadBalancerConfig overwrites any union data inside the LoadBalancerEnvironmentService_Config as the provided LoadBalancerConfig
func (t *LoadBalancerEnvironmentService_Config) FromLoadBalancerConfig(v LoadBalancerConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLoadBalancerConfig performs a merge with any union data inside the LoadBalancerEnvironmentService_Config, using the provided LoadBalancerConfig
func (t *LoadBalancerEnvironmentService_Config) MergeLoadBalancerConfig(v LoadBalancerConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLoadBalancerEnvironmentServiceConfig1 returns the union data inside the LoadBalancerEnvironmentService_Config as a LoadBalancerEnvironmentServiceConfig1
func (t LoadBalancerEnvironmentService_Config) AsLoadBalancerEnvironmentServiceConfig1() (LoadBalancerEnvironmentServiceConfig1, error) {
	var body LoadBalancerEnvironmentServiceConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLoadBalancerEnvironmentServiceConfig1 overwrites any union data inside the LoadBalancerEnvironmentService_Config as the provided LoadBalancerEnvironmentServiceConfig1
func (t *LoadBalancerEnvironmentService_Config) FromLoadBalancerEnvironmentServiceConfig1(v LoadBalancerEnvironmentServiceConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLoadBalancerEnvironmentServiceConfig1 performs a merge with any union data inside the LoadBalancerEnvironmentService_Config, using the provided LoadBalancerEnvironmentServiceConfig1
func (t *LoadBalancerEnvironmentService_Config) MergeLoadBalancerEnvironmentServiceConfig1(v LoadBalancerEnvironmentServiceConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LoadBalancerEnvironmentService_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LoadBalancerEnvironmentService_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLegacyNetwork returns the union data inside the PrivateNetwork_Legacy as a LegacyNetwork
func (t PrivateNetwork_Legacy) AsLegacyNetwork() (LegacyNetwork, error) {
	var body LegacyNetwork
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegacyNetwork overwrites any union data inside the PrivateNetwork_Legacy as the provided LegacyNetwork
func (t *PrivateNetwork_Legacy) FromLegacyNetwork(v LegacyNetwork) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegacyNetwork performs a merge with any union data inside the PrivateNetwork_Legacy, using the provided LegacyNetwork
func (t *PrivateNetwork_Legacy) MergeLegacyNetwork(v LegacyNetwork) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPrivateNetworkLegacy1 returns the union data inside the PrivateNetwork_Legacy as a PrivateNetworkLegacy1
func (t PrivateNetwork_Legacy) AsPrivateNetworkLegacy1() (PrivateNetworkLegacy1, error) {
	var body PrivateNetworkLegacy1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPrivateNetworkLegacy1 overwrites any union data inside the PrivateNetwork_Legacy as the provided PrivateNetworkLegacy1
func (t *PrivateNetwork_Legacy) FromPrivateNetworkLegacy1(v PrivateNetworkLegacy1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePrivateNetworkLegacy1 performs a merge with any union data inside the PrivateNetwork_Legacy, using the provided PrivateNetworkLegacy1
func (t *PrivateNetwork_Legacy) MergePrivateNetworkLegacy1(v PrivateNetworkLegacy1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PrivateNetwork_Legacy) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PrivateNetwork_Legacy) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRegistryAuthUser returns the union data inside the RegistryAuth as a RegistryAuthUser
func (t RegistryAuth) AsRegistryAuthUser() (RegistryAuthUser, error) {
	var body RegistryAuthUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegistryAuthUser overwrites any union data inside the RegistryAuth as the provided RegistryAuthUser
func (t *RegistryAuth) FromRegistryAuthUser(v RegistryAuthUser) error {
	v.Type = "user"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegistryAuthUser performs a merge with any union data inside the RegistryAuth, using the provided RegistryAuthUser
func (t *RegistryAuth) MergeRegistryAuthUser(v RegistryAuthUser) error {
	v.Type = "user"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRegistryAuthProvider returns the union data inside the RegistryAuth as a RegistryAuthProvider
func (t RegistryAuth) AsRegistryAuthProvider() (RegistryAuthProvider, error) {
	var body RegistryAuthProvider
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegistryAuthProvider overwrites any union data inside the RegistryAuth as the provided RegistryAuthProvider
func (t *RegistryAuth) FromRegistryAuthProvider(v RegistryAuthProvider) error {
	v.Type = "provider"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegistryAuthProvider performs a merge with any union data inside the RegistryAuth, using the provided RegistryAuthProvider
func (t *RegistryAuth) MergeRegistryAuthProvider(v RegistryAuthProvider) error {
	v.Type = "provider"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRegistryAuthWebhook returns the union data inside the RegistryAuth as a RegistryAuthWebhook
func (t RegistryAuth) AsRegistryAuthWebhook() (RegistryAuthWebhook, error) {
	var body RegistryAuthWebhook
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegistryAuthWebhook overwrites any union data inside the RegistryAuth as the provided RegistryAuthWebhook
func (t *RegistryAuth) FromRegistryAuthWebhook(v RegistryAuthWebhook) error {
	v.Type = "webhook"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegistryAuthWebhook performs a merge with any union data inside the RegistryAuth, using the provided RegistryAuthWebhook
func (t *RegistryAuth) MergeRegistryAuthWebhook(v RegistryAuthWebhook) error {
	v.Type = "webhook"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RegistryAuth) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RegistryAuth) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "provider":
		return t.AsRegistryAuthProvider()
	case "user":
		return t.AsRegistryAuthUser()
	case "webhook":
		return t.AsRegistryAuthWebhook()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RegistryAuth) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RegistryAuth) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCredentialsHTTP returns the union data inside the RepoTypeAuth1 as a CredentialsHTTP
func (t RepoTypeAuth1) AsCredentialsHTTP() (CredentialsHTTP, error) {
	var body CredentialsHTTP
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCredentialsHTTP overwrites any union data inside the RepoTypeAuth1 as the provided CredentialsHTTP
func (t *RepoTypeAuth1) FromCredentialsHTTP(v CredentialsHTTP) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCredentialsHTTP performs a merge with any union data inside the RepoTypeAuth1, using the provided CredentialsHTTP
func (t *RepoTypeAuth1) MergeCredentialsHTTP(v CredentialsHTTP) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCredentialsSSH returns the union data inside the RepoTypeAuth1 as a CredentialsSSH
func (t RepoTypeAuth1) AsCredentialsSSH() (CredentialsSSH, error) {
	var body CredentialsSSH
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCredentialsSSH overwrites any union data inside the RepoTypeAuth1 as the provided CredentialsSSH
func (t *RepoTypeAuth1) FromCredentialsSSH(v CredentialsSSH) error {
	v.Type = "ssh"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCredentialsSSH performs a merge with any union data inside the RepoTypeAuth1, using the provided CredentialsSSH
func (t *RepoTypeAuth1) MergeCredentialsSSH(v CredentialsSSH) error {
	v.Type = "ssh"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RepoTypeAuth1) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RepoTypeAuth1) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "http":
		return t.AsCredentialsHTTP()
	case "ssh":
		return t.AsCredentialsSSH()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RepoTypeAuth1) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RepoTypeAuth1) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRepoTypeAuth0 returns the union data inside the RepoType_Auth as a RepoTypeAuth0
func (t RepoType_Auth) AsRepoTypeAuth0() (RepoTypeAuth0, error) {
	var body RepoTypeAuth0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRepoTypeAuth0 overwrites any union data inside the RepoType_Auth as the provided RepoTypeAuth0
func (t *RepoType_Auth) FromRepoTypeAuth0(v RepoTypeAuth0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRepoTypeAuth0 performs a merge with any union data inside the RepoType_Auth, using the provided RepoTypeAuth0
func (t *RepoType_Auth) MergeRepoTypeAuth0(v RepoTypeAuth0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRepoTypeAuth1 returns the union data inside the RepoType_Auth as a RepoTypeAuth1
func (t RepoType_Auth) AsRepoTypeAuth1() (RepoTypeAuth1, error) {
	var body RepoTypeAuth1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRepoTypeAuth1 overwrites any union data inside the RepoType_Auth as the provided RepoTypeAuth1
func (t *RepoType_Auth) FromRepoTypeAuth1(v RepoTypeAuth1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRepoTypeAuth1 performs a merge with any union data inside the RepoType_Auth, using the provided RepoTypeAuth1
func (t *RepoType_Auth) MergeRepoTypeAuth1(v RepoTypeAuth1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RepoType_Auth) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RepoType_Auth) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSchedulerConfig returns the union data inside the SchedulerEnvironmentService_Config as a SchedulerConfig
func (t SchedulerEnvironmentService_Config) AsSchedulerConfig() (SchedulerConfig, error) {
	var body SchedulerConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchedulerConfig overwrites any union data inside the SchedulerEnvironmentService_Config as the provided SchedulerConfig
func (t *SchedulerEnvironmentService_Config) FromSchedulerConfig(v SchedulerConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchedulerConfig performs a merge with any union data inside the SchedulerEnvironmentService_Config, using the provided SchedulerConfig
func (t *SchedulerEnvironmentService_Config) MergeSchedulerConfig(v SchedulerConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchedulerEnvironmentServiceConfig1 returns the union data inside the SchedulerEnvironmentService_Config as a SchedulerEnvironmentServiceConfig1
func (t SchedulerEnvironmentService_Config) AsSchedulerEnvironmentServiceConfig1() (SchedulerEnvironmentServiceConfig1, error) {
	var body SchedulerEnvironmentServiceConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchedulerEnvironmentServiceConfig1 overwrites any union data inside the SchedulerEnvironmentService_Config as the provided SchedulerEnvironmentServiceConfig1
func (t *SchedulerEnvironmentService_Config) FromSchedulerEnvironmentServiceConfig1(v SchedulerEnvironmentServiceConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchedulerEnvironmentServiceConfig1 performs a merge with any union data inside the SchedulerEnvironmentService_Config, using the provided SchedulerEnvironmentServiceConfig1
func (t *SchedulerEnvironmentService_Config) MergeSchedulerEnvironmentServiceConfig1(v SchedulerEnvironmentServiceConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SchedulerEnvironmentService_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SchedulerEnvironmentService_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackContainerConfigIntegrations returns the union data inside the StackContainer_Config_Integrations as a StackContainerConfigIntegrations
func (t StackContainer_Config_Integrations) AsStackContainerConfigIntegrations() (StackContainerConfigIntegrations, error) {
	var body StackContainerConfigIntegrations
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigIntegrations overwrites any union data inside the StackContainer_Config_Integrations as the provided StackContainerConfigIntegrations
func (t *StackContainer_Config_Integrations) FromStackContainerConfigIntegrations(v StackContainerConfigIntegrations) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigIntegrations performs a merge with any union data inside the StackContainer_Config_Integrations, using the provided StackContainerConfigIntegrations
func (t *StackContainer_Config_Integrations) MergeStackContainerConfigIntegrations(v StackContainerConfigIntegrations) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigIntegrations1 returns the union data inside the StackContainer_Config_Integrations as a StackContainerConfigIntegrations1
func (t StackContainer_Config_Integrations) AsStackContainerConfigIntegrations1() (StackContainerConfigIntegrations1, error) {
	var body StackContainerConfigIntegrations1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigIntegrations1 overwrites any union data inside the StackContainer_Config_Integrations as the provided StackContainerConfigIntegrations1
func (t *StackContainer_Config_Integrations) FromStackContainerConfigIntegrations1(v StackContainerConfigIntegrations1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigIntegrations1 performs a merge with any union data inside the StackContainer_Config_Integrations, using the provided StackContainerConfigIntegrations1
func (t *StackContainer_Config_Integrations) MergeStackContainerConfigIntegrations1(v StackContainerConfigIntegrations1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainer_Config_Integrations) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainer_Config_Integrations) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackContainerConfigResources returns the union data inside the StackContainer_Config_Resources as a StackContainerConfigResources
func (t StackContainer_Config_Resources) AsStackContainerConfigResources() (StackContainerConfigResources, error) {
	var body StackContainerConfigResources
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigResources overwrites any union data inside the StackContainer_Config_Resources as the provided StackContainerConfigResources
func (t *StackContainer_Config_Resources) FromStackContainerConfigResources(v StackContainerConfigResources) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigResources performs a merge with any union data inside the StackContainer_Config_Resources, using the provided StackContainerConfigResources
func (t *StackContainer_Config_Resources) MergeStackContainerConfigResources(v StackContainerConfigResources) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigResources1 returns the union data inside the StackContainer_Config_Resources as a StackContainerConfigResources1
func (t StackContainer_Config_Resources) AsStackContainerConfigResources1() (StackContainerConfigResources1, error) {
	var body StackContainerConfigResources1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigResources1 overwrites any union data inside the StackContainer_Config_Resources as the provided StackContainerConfigResources1
func (t *StackContainer_Config_Resources) FromStackContainerConfigResources1(v StackContainerConfigResources1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigResources1 performs a merge with any union data inside the StackContainer_Config_Resources, using the provided StackContainerConfigResources1
func (t *StackContainer_Config_Resources) MergeStackContainerConfigResources1(v StackContainerConfigResources1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainer_Config_Resources) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainer_Config_Resources) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackContainerConfigRuntime returns the union data inside the StackContainer_Config_Runtime as a StackContainerConfigRuntime
func (t StackContainer_Config_Runtime) AsStackContainerConfigRuntime() (StackContainerConfigRuntime, error) {
	var body StackContainerConfigRuntime
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigRuntime overwrites any union data inside the StackContainer_Config_Runtime as the provided StackContainerConfigRuntime
func (t *StackContainer_Config_Runtime) FromStackContainerConfigRuntime(v StackContainerConfigRuntime) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigRuntime performs a merge with any union data inside the StackContainer_Config_Runtime, using the provided StackContainerConfigRuntime
func (t *StackContainer_Config_Runtime) MergeStackContainerConfigRuntime(v StackContainerConfigRuntime) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigRuntime1 returns the union data inside the StackContainer_Config_Runtime as a StackContainerConfigRuntime1
func (t StackContainer_Config_Runtime) AsStackContainerConfigRuntime1() (StackContainerConfigRuntime1, error) {
	var body StackContainerConfigRuntime1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigRuntime1 overwrites any union data inside the StackContainer_Config_Runtime as the provided StackContainerConfigRuntime1
func (t *StackContainer_Config_Runtime) FromStackContainerConfigRuntime1(v StackContainerConfigRuntime1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigRuntime1 performs a merge with any union data inside the StackContainer_Config_Runtime, using the provided StackContainerConfigRuntime1
func (t *StackContainer_Config_Runtime) MergeStackContainerConfigRuntime1(v StackContainerConfigRuntime1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainer_Config_Runtime) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainer_Config_Runtime) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackContainerConfigScaling returns the union data inside the StackContainer_Config_Scaling as a StackContainerConfigScaling
func (t StackContainer_Config_Scaling) AsStackContainerConfigScaling() (StackContainerConfigScaling, error) {
	var body StackContainerConfigScaling
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigScaling overwrites any union data inside the StackContainer_Config_Scaling as the provided StackContainerConfigScaling
func (t *StackContainer_Config_Scaling) FromStackContainerConfigScaling(v StackContainerConfigScaling) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigScaling performs a merge with any union data inside the StackContainer_Config_Scaling, using the provided StackContainerConfigScaling
func (t *StackContainer_Config_Scaling) MergeStackContainerConfigScaling(v StackContainerConfigScaling) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigScaling1 returns the union data inside the StackContainer_Config_Scaling as a StackContainerConfigScaling1
func (t StackContainer_Config_Scaling) AsStackContainerConfigScaling1() (StackContainerConfigScaling1, error) {
	var body StackContainerConfigScaling1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigScaling1 overwrites any union data inside the StackContainer_Config_Scaling as the provided StackContainerConfigScaling1
func (t *StackContainer_Config_Scaling) FromStackContainerConfigScaling1(v StackContainerConfigScaling1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigScaling1 performs a merge with any union data inside the StackContainer_Config_Scaling, using the provided StackContainerConfigScaling1
func (t *StackContainer_Config_Scaling) MergeStackContainerConfigScaling1(v StackContainerConfigScaling1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainer_Config_Scaling) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainer_Config_Scaling) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackContainerConfigDeploy_Function_MaxQueueTime as a Duration
func (t StackContainerConfigDeploy_Function_MaxQueueTime) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackContainerConfigDeploy_Function_MaxQueueTime as the provided Duration
func (t *StackContainerConfigDeploy_Function_MaxQueueTime) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackContainerConfigDeploy_Function_MaxQueueTime, using the provided Duration
func (t *StackContainerConfigDeploy_Function_MaxQueueTime) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigDeployFunctionMaxQueueTime1 returns the union data inside the StackContainerConfigDeploy_Function_MaxQueueTime as a StackContainerConfigDeployFunctionMaxQueueTime1
func (t StackContainerConfigDeploy_Function_MaxQueueTime) AsStackContainerConfigDeployFunctionMaxQueueTime1() (StackContainerConfigDeployFunctionMaxQueueTime1, error) {
	var body StackContainerConfigDeployFunctionMaxQueueTime1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigDeployFunctionMaxQueueTime1 overwrites any union data inside the StackContainerConfigDeploy_Function_MaxQueueTime as the provided StackContainerConfigDeployFunctionMaxQueueTime1
func (t *StackContainerConfigDeploy_Function_MaxQueueTime) FromStackContainerConfigDeployFunctionMaxQueueTime1(v StackContainerConfigDeployFunctionMaxQueueTime1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigDeployFunctionMaxQueueTime1 performs a merge with any union data inside the StackContainerConfigDeploy_Function_MaxQueueTime, using the provided StackContainerConfigDeployFunctionMaxQueueTime1
func (t *StackContainerConfigDeploy_Function_MaxQueueTime) MergeStackContainerConfigDeployFunctionMaxQueueTime1(v StackContainerConfigDeployFunctionMaxQueueTime1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerConfigDeploy_Function_MaxQueueTime) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerConfigDeploy_Function_MaxQueueTime) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackContainerConfigDeploy_Function_MaxRuntime as a Duration
func (t StackContainerConfigDeploy_Function_MaxRuntime) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackContainerConfigDeploy_Function_MaxRuntime as the provided Duration
func (t *StackContainerConfigDeploy_Function_MaxRuntime) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackContainerConfigDeploy_Function_MaxRuntime, using the provided Duration
func (t *StackContainerConfigDeploy_Function_MaxRuntime) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigDeployFunctionMaxRuntime1 returns the union data inside the StackContainerConfigDeploy_Function_MaxRuntime as a StackContainerConfigDeployFunctionMaxRuntime1
func (t StackContainerConfigDeploy_Function_MaxRuntime) AsStackContainerConfigDeployFunctionMaxRuntime1() (StackContainerConfigDeployFunctionMaxRuntime1, error) {
	var body StackContainerConfigDeployFunctionMaxRuntime1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigDeployFunctionMaxRuntime1 overwrites any union data inside the StackContainerConfigDeploy_Function_MaxRuntime as the provided StackContainerConfigDeployFunctionMaxRuntime1
func (t *StackContainerConfigDeploy_Function_MaxRuntime) FromStackContainerConfigDeployFunctionMaxRuntime1(v StackContainerConfigDeployFunctionMaxRuntime1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigDeployFunctionMaxRuntime1 performs a merge with any union data inside the StackContainerConfigDeploy_Function_MaxRuntime, using the provided StackContainerConfigDeployFunctionMaxRuntime1
func (t *StackContainerConfigDeploy_Function_MaxRuntime) MergeStackContainerConfigDeployFunctionMaxRuntime1(v StackContainerConfigDeployFunctionMaxRuntime1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerConfigDeploy_Function_MaxRuntime) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerConfigDeploy_Function_MaxRuntime) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackContainerConfigDeploy_HealthCheck_Delay as a Duration
func (t StackContainerConfigDeploy_HealthCheck_Delay) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackContainerConfigDeploy_HealthCheck_Delay as the provided Duration
func (t *StackContainerConfigDeploy_HealthCheck_Delay) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackContainerConfigDeploy_HealthCheck_Delay, using the provided Duration
func (t *StackContainerConfigDeploy_HealthCheck_Delay) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigDeployHealthCheckDelay1 returns the union data inside the StackContainerConfigDeploy_HealthCheck_Delay as a StackContainerConfigDeployHealthCheckDelay1
func (t StackContainerConfigDeploy_HealthCheck_Delay) AsStackContainerConfigDeployHealthCheckDelay1() (StackContainerConfigDeployHealthCheckDelay1, error) {
	var body StackContainerConfigDeployHealthCheckDelay1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigDeployHealthCheckDelay1 overwrites any union data inside the StackContainerConfigDeploy_HealthCheck_Delay as the provided StackContainerConfigDeployHealthCheckDelay1
func (t *StackContainerConfigDeploy_HealthCheck_Delay) FromStackContainerConfigDeployHealthCheckDelay1(v StackContainerConfigDeployHealthCheckDelay1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigDeployHealthCheckDelay1 performs a merge with any union data inside the StackContainerConfigDeploy_HealthCheck_Delay, using the provided StackContainerConfigDeployHealthCheckDelay1
func (t *StackContainerConfigDeploy_HealthCheck_Delay) MergeStackContainerConfigDeployHealthCheckDelay1(v StackContainerConfigDeployHealthCheckDelay1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerConfigDeploy_HealthCheck_Delay) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerConfigDeploy_HealthCheck_Delay) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackContainerConfigDeploy_Shutdown_GracefulTimeout as a Duration
func (t StackContainerConfigDeploy_Shutdown_GracefulTimeout) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackContainerConfigDeploy_Shutdown_GracefulTimeout as the provided Duration
func (t *StackContainerConfigDeploy_Shutdown_GracefulTimeout) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackContainerConfigDeploy_Shutdown_GracefulTimeout, using the provided Duration
func (t *StackContainerConfigDeploy_Shutdown_GracefulTimeout) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigDeployShutdownGracefulTimeout1 returns the union data inside the StackContainerConfigDeploy_Shutdown_GracefulTimeout as a StackContainerConfigDeployShutdownGracefulTimeout1
func (t StackContainerConfigDeploy_Shutdown_GracefulTimeout) AsStackContainerConfigDeployShutdownGracefulTimeout1() (StackContainerConfigDeployShutdownGracefulTimeout1, error) {
	var body StackContainerConfigDeployShutdownGracefulTimeout1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigDeployShutdownGracefulTimeout1 overwrites any union data inside the StackContainerConfigDeploy_Shutdown_GracefulTimeout as the provided StackContainerConfigDeployShutdownGracefulTimeout1
func (t *StackContainerConfigDeploy_Shutdown_GracefulTimeout) FromStackContainerConfigDeployShutdownGracefulTimeout1(v StackContainerConfigDeployShutdownGracefulTimeout1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigDeployShutdownGracefulTimeout1 performs a merge with any union data inside the StackContainerConfigDeploy_Shutdown_GracefulTimeout, using the provided StackContainerConfigDeployShutdownGracefulTimeout1
func (t *StackContainerConfigDeploy_Shutdown_GracefulTimeout) MergeStackContainerConfigDeployShutdownGracefulTimeout1(v StackContainerConfigDeployShutdownGracefulTimeout1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerConfigDeploy_Shutdown_GracefulTimeout) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerConfigDeploy_Shutdown_GracefulTimeout) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackContainerConfigDeploy_Startup_Delay as a Duration
func (t StackContainerConfigDeploy_Startup_Delay) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackContainerConfigDeploy_Startup_Delay as the provided Duration
func (t *StackContainerConfigDeploy_Startup_Delay) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackContainerConfigDeploy_Startup_Delay, using the provided Duration
func (t *StackContainerConfigDeploy_Startup_Delay) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigDeployStartupDelay1 returns the union data inside the StackContainerConfigDeploy_Startup_Delay as a StackContainerConfigDeployStartupDelay1
func (t StackContainerConfigDeploy_Startup_Delay) AsStackContainerConfigDeployStartupDelay1() (StackContainerConfigDeployStartupDelay1, error) {
	var body StackContainerConfigDeployStartupDelay1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigDeployStartupDelay1 overwrites any union data inside the StackContainerConfigDeploy_Startup_Delay as the provided StackContainerConfigDeployStartupDelay1
func (t *StackContainerConfigDeploy_Startup_Delay) FromStackContainerConfigDeployStartupDelay1(v StackContainerConfigDeployStartupDelay1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigDeployStartupDelay1 performs a merge with any union data inside the StackContainerConfigDeploy_Startup_Delay, using the provided StackContainerConfigDeployStartupDelay1
func (t *StackContainerConfigDeploy_Startup_Delay) MergeStackContainerConfigDeployStartupDelay1(v StackContainerConfigDeployStartupDelay1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerConfigDeploy_Startup_Delay) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerConfigDeploy_Startup_Delay) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackContainerConfigDeploy_Telemetry_Interval as a Duration
func (t StackContainerConfigDeploy_Telemetry_Interval) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackContainerConfigDeploy_Telemetry_Interval as the provided Duration
func (t *StackContainerConfigDeploy_Telemetry_Interval) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackContainerConfigDeploy_Telemetry_Interval, using the provided Duration
func (t *StackContainerConfigDeploy_Telemetry_Interval) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigDeployTelemetryInterval1 returns the union data inside the StackContainerConfigDeploy_Telemetry_Interval as a StackContainerConfigDeployTelemetryInterval1
func (t StackContainerConfigDeploy_Telemetry_Interval) AsStackContainerConfigDeployTelemetryInterval1() (StackContainerConfigDeployTelemetryInterval1, error) {
	var body StackContainerConfigDeployTelemetryInterval1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigDeployTelemetryInterval1 overwrites any union data inside the StackContainerConfigDeploy_Telemetry_Interval as the provided StackContainerConfigDeployTelemetryInterval1
func (t *StackContainerConfigDeploy_Telemetry_Interval) FromStackContainerConfigDeployTelemetryInterval1(v StackContainerConfigDeployTelemetryInterval1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigDeployTelemetryInterval1 performs a merge with any union data inside the StackContainerConfigDeploy_Telemetry_Interval, using the provided StackContainerConfigDeployTelemetryInterval1
func (t *StackContainerConfigDeploy_Telemetry_Interval) MergeStackContainerConfigDeployTelemetryInterval1(v StackContainerConfigDeployTelemetryInterval1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerConfigDeploy_Telemetry_Interval) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerConfigDeploy_Telemetry_Interval) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackContainerConfigDeploy_Telemetry_Retention as a Duration
func (t StackContainerConfigDeploy_Telemetry_Retention) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackContainerConfigDeploy_Telemetry_Retention as the provided Duration
func (t *StackContainerConfigDeploy_Telemetry_Retention) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackContainerConfigDeploy_Telemetry_Retention, using the provided Duration
func (t *StackContainerConfigDeploy_Telemetry_Retention) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigDeployTelemetryRetention1 returns the union data inside the StackContainerConfigDeploy_Telemetry_Retention as a StackContainerConfigDeployTelemetryRetention1
func (t StackContainerConfigDeploy_Telemetry_Retention) AsStackContainerConfigDeployTelemetryRetention1() (StackContainerConfigDeployTelemetryRetention1, error) {
	var body StackContainerConfigDeployTelemetryRetention1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigDeployTelemetryRetention1 overwrites any union data inside the StackContainerConfigDeploy_Telemetry_Retention as the provided StackContainerConfigDeployTelemetryRetention1
func (t *StackContainerConfigDeploy_Telemetry_Retention) FromStackContainerConfigDeployTelemetryRetention1(v StackContainerConfigDeployTelemetryRetention1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigDeployTelemetryRetention1 performs a merge with any union data inside the StackContainerConfigDeploy_Telemetry_Retention, using the provided StackContainerConfigDeployTelemetryRetention1
func (t *StackContainerConfigDeploy_Telemetry_Retention) MergeStackContainerConfigDeployTelemetryRetention1(v StackContainerConfigDeployTelemetryRetention1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerConfigDeploy_Telemetry_Retention) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerConfigDeploy_Telemetry_Retention) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackContainerConfigDeploy_Update_Stagger as a Duration
func (t StackContainerConfigDeploy_Update_Stagger) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackContainerConfigDeploy_Update_Stagger as the provided Duration
func (t *StackContainerConfigDeploy_Update_Stagger) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackContainerConfigDeploy_Update_Stagger, using the provided Duration
func (t *StackContainerConfigDeploy_Update_Stagger) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigDeployUpdateStagger1 returns the union data inside the StackContainerConfigDeploy_Update_Stagger as a StackContainerConfigDeployUpdateStagger1
func (t StackContainerConfigDeploy_Update_Stagger) AsStackContainerConfigDeployUpdateStagger1() (StackContainerConfigDeployUpdateStagger1, error) {
	var body StackContainerConfigDeployUpdateStagger1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigDeployUpdateStagger1 overwrites any union data inside the StackContainerConfigDeploy_Update_Stagger as the provided StackContainerConfigDeployUpdateStagger1
func (t *StackContainerConfigDeploy_Update_Stagger) FromStackContainerConfigDeployUpdateStagger1(v StackContainerConfigDeployUpdateStagger1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigDeployUpdateStagger1 performs a merge with any union data inside the StackContainerConfigDeploy_Update_Stagger, using the provided StackContainerConfigDeployUpdateStagger1
func (t *StackContainerConfigDeploy_Update_Stagger) MergeStackContainerConfigDeployUpdateStagger1(v StackContainerConfigDeployUpdateStagger1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerConfigDeploy_Update_Stagger) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerConfigDeploy_Update_Stagger) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackContainerConfigIntegrations_Backups_Backup_Timeout as a Duration
func (t StackContainerConfigIntegrations_Backups_Backup_Timeout) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackContainerConfigIntegrations_Backups_Backup_Timeout as the provided Duration
func (t *StackContainerConfigIntegrations_Backups_Backup_Timeout) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackContainerConfigIntegrations_Backups_Backup_Timeout, using the provided Duration
func (t *StackContainerConfigIntegrations_Backups_Backup_Timeout) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigIntegrationsBackupsBackupTimeout1 returns the union data inside the StackContainerConfigIntegrations_Backups_Backup_Timeout as a StackContainerConfigIntegrationsBackupsBackupTimeout1
func (t StackContainerConfigIntegrations_Backups_Backup_Timeout) AsStackContainerConfigIntegrationsBackupsBackupTimeout1() (StackContainerConfigIntegrationsBackupsBackupTimeout1, error) {
	var body StackContainerConfigIntegrationsBackupsBackupTimeout1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigIntegrationsBackupsBackupTimeout1 overwrites any union data inside the StackContainerConfigIntegrations_Backups_Backup_Timeout as the provided StackContainerConfigIntegrationsBackupsBackupTimeout1
func (t *StackContainerConfigIntegrations_Backups_Backup_Timeout) FromStackContainerConfigIntegrationsBackupsBackupTimeout1(v StackContainerConfigIntegrationsBackupsBackupTimeout1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigIntegrationsBackupsBackupTimeout1 performs a merge with any union data inside the StackContainerConfigIntegrations_Backups_Backup_Timeout, using the provided StackContainerConfigIntegrationsBackupsBackupTimeout1
func (t *StackContainerConfigIntegrations_Backups_Backup_Timeout) MergeStackContainerConfigIntegrationsBackupsBackupTimeout1(v StackContainerConfigIntegrationsBackupsBackupTimeout1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerConfigIntegrations_Backups_Backup_Timeout) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerConfigIntegrations_Backups_Backup_Timeout) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackContainerConfigIntegrations_Backups_Restore_Timeout as a Duration
func (t StackContainerConfigIntegrations_Backups_Restore_Timeout) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackContainerConfigIntegrations_Backups_Restore_Timeout as the provided Duration
func (t *StackContainerConfigIntegrations_Backups_Restore_Timeout) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackContainerConfigIntegrations_Backups_Restore_Timeout, using the provided Duration
func (t *StackContainerConfigIntegrations_Backups_Restore_Timeout) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigIntegrationsBackupsRestoreTimeout1 returns the union data inside the StackContainerConfigIntegrations_Backups_Restore_Timeout as a StackContainerConfigIntegrationsBackupsRestoreTimeout1
func (t StackContainerConfigIntegrations_Backups_Restore_Timeout) AsStackContainerConfigIntegrationsBackupsRestoreTimeout1() (StackContainerConfigIntegrationsBackupsRestoreTimeout1, error) {
	var body StackContainerConfigIntegrationsBackupsRestoreTimeout1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigIntegrationsBackupsRestoreTimeout1 overwrites any union data inside the StackContainerConfigIntegrations_Backups_Restore_Timeout as the provided StackContainerConfigIntegrationsBackupsRestoreTimeout1
func (t *StackContainerConfigIntegrations_Backups_Restore_Timeout) FromStackContainerConfigIntegrationsBackupsRestoreTimeout1(v StackContainerConfigIntegrationsBackupsRestoreTimeout1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigIntegrationsBackupsRestoreTimeout1 performs a merge with any union data inside the StackContainerConfigIntegrations_Backups_Restore_Timeout, using the provided StackContainerConfigIntegrationsBackupsRestoreTimeout1
func (t *StackContainerConfigIntegrations_Backups_Restore_Timeout) MergeStackContainerConfigIntegrationsBackupsRestoreTimeout1(v StackContainerConfigIntegrationsBackupsRestoreTimeout1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerConfigIntegrations_Backups_Restore_Timeout) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerConfigIntegrations_Backups_Restore_Timeout) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackContainerConfigIntegrations_Backups_Retention as a Duration
func (t StackContainerConfigIntegrations_Backups_Retention) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackContainerConfigIntegrations_Backups_Retention as the provided Duration
func (t *StackContainerConfigIntegrations_Backups_Retention) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackContainerConfigIntegrations_Backups_Retention, using the provided Duration
func (t *StackContainerConfigIntegrations_Backups_Retention) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigIntegrationsBackupsRetention1 returns the union data inside the StackContainerConfigIntegrations_Backups_Retention as a StackContainerConfigIntegrationsBackupsRetention1
func (t StackContainerConfigIntegrations_Backups_Retention) AsStackContainerConfigIntegrationsBackupsRetention1() (StackContainerConfigIntegrationsBackupsRetention1, error) {
	var body StackContainerConfigIntegrationsBackupsRetention1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigIntegrationsBackupsRetention1 overwrites any union data inside the StackContainerConfigIntegrations_Backups_Retention as the provided StackContainerConfigIntegrationsBackupsRetention1
func (t *StackContainerConfigIntegrations_Backups_Retention) FromStackContainerConfigIntegrationsBackupsRetention1(v StackContainerConfigIntegrationsBackupsRetention1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigIntegrationsBackupsRetention1 performs a merge with any union data inside the StackContainerConfigIntegrations_Backups_Retention, using the provided StackContainerConfigIntegrationsBackupsRetention1
func (t *StackContainerConfigIntegrations_Backups_Retention) MergeStackContainerConfigIntegrationsBackupsRetention1(v StackContainerConfigIntegrationsBackupsRetention1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerConfigIntegrations_Backups_Retention) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerConfigIntegrations_Backups_Retention) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIdentifier returns the union data inside the StackContainerConfigScaling_AutoscaleGroup as a Identifier
func (t StackContainerConfigScaling_AutoscaleGroup) AsIdentifier() (Identifier, error) {
	var body Identifier
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIdentifier overwrites any union data inside the StackContainerConfigScaling_AutoscaleGroup as the provided Identifier
func (t *StackContainerConfigScaling_AutoscaleGroup) FromIdentifier(v Identifier) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIdentifier performs a merge with any union data inside the StackContainerConfigScaling_AutoscaleGroup, using the provided Identifier
func (t *StackContainerConfigScaling_AutoscaleGroup) MergeIdentifier(v Identifier) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerConfigScalingAutoscaleGroup1 returns the union data inside the StackContainerConfigScaling_AutoscaleGroup as a StackContainerConfigScalingAutoscaleGroup1
func (t StackContainerConfigScaling_AutoscaleGroup) AsStackContainerConfigScalingAutoscaleGroup1() (StackContainerConfigScalingAutoscaleGroup1, error) {
	var body StackContainerConfigScalingAutoscaleGroup1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerConfigScalingAutoscaleGroup1 overwrites any union data inside the StackContainerConfigScaling_AutoscaleGroup as the provided StackContainerConfigScalingAutoscaleGroup1
func (t *StackContainerConfigScaling_AutoscaleGroup) FromStackContainerConfigScalingAutoscaleGroup1(v StackContainerConfigScalingAutoscaleGroup1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerConfigScalingAutoscaleGroup1 performs a merge with any union data inside the StackContainerConfigScaling_AutoscaleGroup, using the provided StackContainerConfigScalingAutoscaleGroup1
func (t *StackContainerConfigScaling_AutoscaleGroup) MergeStackContainerConfigScalingAutoscaleGroup1(v StackContainerConfigScalingAutoscaleGroup1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerConfigScaling_AutoscaleGroup) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerConfigScaling_AutoscaleGroup) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackContainerScaleThresholdRam returns the union data inside the StackContainerScaleThreshold as a StackContainerScaleThresholdRam
func (t StackContainerScaleThreshold) AsStackContainerScaleThresholdRam() (StackContainerScaleThresholdRam, error) {
	var body StackContainerScaleThresholdRam
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerScaleThresholdRam overwrites any union data inside the StackContainerScaleThreshold as the provided StackContainerScaleThresholdRam
func (t *StackContainerScaleThreshold) FromStackContainerScaleThresholdRam(v StackContainerScaleThresholdRam) error {
	v.Type = "ram"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerScaleThresholdRam performs a merge with any union data inside the StackContainerScaleThreshold, using the provided StackContainerScaleThresholdRam
func (t *StackContainerScaleThreshold) MergeStackContainerScaleThresholdRam(v StackContainerScaleThresholdRam) error {
	v.Type = "ram"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerScaleThresholdCpu returns the union data inside the StackContainerScaleThreshold as a StackContainerScaleThresholdCpu
func (t StackContainerScaleThreshold) AsStackContainerScaleThresholdCpu() (StackContainerScaleThresholdCpu, error) {
	var body StackContainerScaleThresholdCpu
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerScaleThresholdCpu overwrites any union data inside the StackContainerScaleThreshold as the provided StackContainerScaleThresholdCpu
func (t *StackContainerScaleThreshold) FromStackContainerScaleThresholdCpu(v StackContainerScaleThresholdCpu) error {
	v.Type = "cpu"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerScaleThresholdCpu performs a merge with any union data inside the StackContainerScaleThreshold, using the provided StackContainerScaleThresholdCpu
func (t *StackContainerScaleThreshold) MergeStackContainerScaleThresholdCpu(v StackContainerScaleThresholdCpu) error {
	v.Type = "cpu"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerScaleThresholdNetworkConnections returns the union data inside the StackContainerScaleThreshold as a StackContainerScaleThresholdNetworkConnections
func (t StackContainerScaleThreshold) AsStackContainerScaleThresholdNetworkConnections() (StackContainerScaleThresholdNetworkConnections, error) {
	var body StackContainerScaleThresholdNetworkConnections
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerScaleThresholdNetworkConnections overwrites any union data inside the StackContainerScaleThreshold as the provided StackContainerScaleThresholdNetworkConnections
func (t *StackContainerScaleThreshold) FromStackContainerScaleThresholdNetworkConnections(v StackContainerScaleThresholdNetworkConnections) error {
	v.Type = "network-connections"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerScaleThresholdNetworkConnections performs a merge with any union data inside the StackContainerScaleThreshold, using the provided StackContainerScaleThresholdNetworkConnections
func (t *StackContainerScaleThreshold) MergeStackContainerScaleThresholdNetworkConnections(v StackContainerScaleThresholdNetworkConnections) error {
	v.Type = "network-connections"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerScaleThresholdNetworkRequests returns the union data inside the StackContainerScaleThreshold as a StackContainerScaleThresholdNetworkRequests
func (t StackContainerScaleThreshold) AsStackContainerScaleThresholdNetworkRequests() (StackContainerScaleThresholdNetworkRequests, error) {
	var body StackContainerScaleThresholdNetworkRequests
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerScaleThresholdNetworkRequests overwrites any union data inside the StackContainerScaleThreshold as the provided StackContainerScaleThresholdNetworkRequests
func (t *StackContainerScaleThreshold) FromStackContainerScaleThresholdNetworkRequests(v StackContainerScaleThresholdNetworkRequests) error {
	v.Type = "network-requests"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerScaleThresholdNetworkRequests performs a merge with any union data inside the StackContainerScaleThreshold, using the provided StackContainerScaleThresholdNetworkRequests
func (t *StackContainerScaleThreshold) MergeStackContainerScaleThresholdNetworkRequests(v StackContainerScaleThresholdNetworkRequests) error {
	v.Type = "network-requests"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerScaleThresholdNetworkThroughput returns the union data inside the StackContainerScaleThreshold as a StackContainerScaleThresholdNetworkThroughput
func (t StackContainerScaleThreshold) AsStackContainerScaleThresholdNetworkThroughput() (StackContainerScaleThresholdNetworkThroughput, error) {
	var body StackContainerScaleThresholdNetworkThroughput
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerScaleThresholdNetworkThroughput overwrites any union data inside the StackContainerScaleThreshold as the provided StackContainerScaleThresholdNetworkThroughput
func (t *StackContainerScaleThreshold) FromStackContainerScaleThresholdNetworkThroughput(v StackContainerScaleThresholdNetworkThroughput) error {
	v.Type = "network-throughput"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerScaleThresholdNetworkThroughput performs a merge with any union data inside the StackContainerScaleThreshold, using the provided StackContainerScaleThresholdNetworkThroughput
func (t *StackContainerScaleThreshold) MergeStackContainerScaleThresholdNetworkThroughput(v StackContainerScaleThresholdNetworkThroughput) error {
	v.Type = "network-throughput"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackContainerScaleThresholdCustom returns the union data inside the StackContainerScaleThreshold as a StackContainerScaleThresholdCustom
func (t StackContainerScaleThreshold) AsStackContainerScaleThresholdCustom() (StackContainerScaleThresholdCustom, error) {
	var body StackContainerScaleThresholdCustom
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackContainerScaleThresholdCustom overwrites any union data inside the StackContainerScaleThreshold as the provided StackContainerScaleThresholdCustom
func (t *StackContainerScaleThreshold) FromStackContainerScaleThresholdCustom(v StackContainerScaleThresholdCustom) error {
	v.Type = "custom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackContainerScaleThresholdCustom performs a merge with any union data inside the StackContainerScaleThreshold, using the provided StackContainerScaleThresholdCustom
func (t *StackContainerScaleThreshold) MergeStackContainerScaleThresholdCustom(v StackContainerScaleThresholdCustom) error {
	v.Type = "custom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackContainerScaleThreshold) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t StackContainerScaleThreshold) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "cpu":
		return t.AsStackContainerScaleThresholdCpu()
	case "custom":
		return t.AsStackContainerScaleThresholdCustom()
	case "network-connections":
		return t.AsStackContainerScaleThresholdNetworkConnections()
	case "network-requests":
		return t.AsStackContainerScaleThresholdNetworkRequests()
	case "network-throughput":
		return t.AsStackContainerScaleThresholdNetworkThroughput()
	case "ram":
		return t.AsStackContainerScaleThresholdRam()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t StackContainerScaleThreshold) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackContainerScaleThreshold) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDockerHubOrigin returns the union data inside the StackImageOrigin as a DockerHubOrigin
func (t StackImageOrigin) AsDockerHubOrigin() (DockerHubOrigin, error) {
	var body DockerHubOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerHubOrigin overwrites any union data inside the StackImageOrigin as the provided DockerHubOrigin
func (t *StackImageOrigin) FromDockerHubOrigin(v DockerHubOrigin) error {
	v.Type = "docker-hub"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerHubOrigin performs a merge with any union data inside the StackImageOrigin, using the provided DockerHubOrigin
func (t *StackImageOrigin) MergeDockerHubOrigin(v DockerHubOrigin) error {
	v.Type = "docker-hub"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerFileOrigin returns the union data inside the StackImageOrigin as a DockerFileOrigin
func (t StackImageOrigin) AsDockerFileOrigin() (DockerFileOrigin, error) {
	var body DockerFileOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerFileOrigin overwrites any union data inside the StackImageOrigin as the provided DockerFileOrigin
func (t *StackImageOrigin) FromDockerFileOrigin(v DockerFileOrigin) error {
	v.Type = "docker-file"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerFileOrigin performs a merge with any union data inside the StackImageOrigin, using the provided DockerFileOrigin
func (t *StackImageOrigin) MergeDockerFileOrigin(v DockerFileOrigin) error {
	v.Type = "docker-file"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDockerRegistryOrigin returns the union data inside the StackImageOrigin as a DockerRegistryOrigin
func (t StackImageOrigin) AsDockerRegistryOrigin() (DockerRegistryOrigin, error) {
	var body DockerRegistryOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDockerRegistryOrigin overwrites any union data inside the StackImageOrigin as the provided DockerRegistryOrigin
func (t *StackImageOrigin) FromDockerRegistryOrigin(v DockerRegistryOrigin) error {
	v.Type = "docker-registry"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDockerRegistryOrigin performs a merge with any union data inside the StackImageOrigin, using the provided DockerRegistryOrigin
func (t *StackImageOrigin) MergeDockerRegistryOrigin(v DockerRegistryOrigin) error {
	v.Type = "docker-registry"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOciRegistryOrigin returns the union data inside the StackImageOrigin as a OciRegistryOrigin
func (t StackImageOrigin) AsOciRegistryOrigin() (OciRegistryOrigin, error) {
	var body OciRegistryOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOciRegistryOrigin overwrites any union data inside the StackImageOrigin as the provided OciRegistryOrigin
func (t *StackImageOrigin) FromOciRegistryOrigin(v OciRegistryOrigin) error {
	v.Type = "oci-registry"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOciRegistryOrigin performs a merge with any union data inside the StackImageOrigin, using the provided OciRegistryOrigin
func (t *StackImageOrigin) MergeOciRegistryOrigin(v OciRegistryOrigin) error {
	v.Type = "oci-registry"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCycleSourceOrigin returns the union data inside the StackImageOrigin as a CycleSourceOrigin
func (t StackImageOrigin) AsCycleSourceOrigin() (CycleSourceOrigin, error) {
	var body CycleSourceOrigin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCycleSourceOrigin overwrites any union data inside the StackImageOrigin as the provided CycleSourceOrigin
func (t *StackImageOrigin) FromCycleSourceOrigin(v CycleSourceOrigin) error {
	v.Type = "cycle-source"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCycleSourceOrigin performs a merge with any union data inside the StackImageOrigin, using the provided CycleSourceOrigin
func (t *StackImageOrigin) MergeCycleSourceOrigin(v CycleSourceOrigin) error {
	v.Type = "cycle-source"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackImageOrigin) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t StackImageOrigin) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "cycle-source":
		return t.AsCycleSourceOrigin()
	case "docker-file":
		return t.AsDockerFileOrigin()
	case "docker-hub":
		return t.AsDockerHubOrigin()
	case "docker-registry":
		return t.AsDockerRegistryOrigin()
	case "oci-registry":
		return t.AsOciRegistryOrigin()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t StackImageOrigin) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackImageOrigin) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecServicesDiscovery0 returns the union data inside the StackSpec_Services_Discovery as a StackSpecServicesDiscovery0
func (t StackSpec_Services_Discovery) AsStackSpecServicesDiscovery0() (StackSpecServicesDiscovery0, error) {
	var body StackSpecServicesDiscovery0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecServicesDiscovery0 overwrites any union data inside the StackSpec_Services_Discovery as the provided StackSpecServicesDiscovery0
func (t *StackSpec_Services_Discovery) FromStackSpecServicesDiscovery0(v StackSpecServicesDiscovery0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecServicesDiscovery0 performs a merge with any union data inside the StackSpec_Services_Discovery, using the provided StackSpecServicesDiscovery0
func (t *StackSpec_Services_Discovery) MergeStackSpecServicesDiscovery0(v StackSpecServicesDiscovery0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecDiscoveryService returns the union data inside the StackSpec_Services_Discovery as a StackSpecDiscoveryService
func (t StackSpec_Services_Discovery) AsStackSpecDiscoveryService() (StackSpecDiscoveryService, error) {
	var body StackSpecDiscoveryService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecDiscoveryService overwrites any union data inside the StackSpec_Services_Discovery as the provided StackSpecDiscoveryService
func (t *StackSpec_Services_Discovery) FromStackSpecDiscoveryService(v StackSpecDiscoveryService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecDiscoveryService performs a merge with any union data inside the StackSpec_Services_Discovery, using the provided StackSpecDiscoveryService
func (t *StackSpec_Services_Discovery) MergeStackSpecDiscoveryService(v StackSpecDiscoveryService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpec_Services_Discovery) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpec_Services_Discovery) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecServicesLoadbalancer0 returns the union data inside the StackSpec_Services_Loadbalancer as a StackSpecServicesLoadbalancer0
func (t StackSpec_Services_Loadbalancer) AsStackSpecServicesLoadbalancer0() (StackSpecServicesLoadbalancer0, error) {
	var body StackSpecServicesLoadbalancer0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecServicesLoadbalancer0 overwrites any union data inside the StackSpec_Services_Loadbalancer as the provided StackSpecServicesLoadbalancer0
func (t *StackSpec_Services_Loadbalancer) FromStackSpecServicesLoadbalancer0(v StackSpecServicesLoadbalancer0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecServicesLoadbalancer0 performs a merge with any union data inside the StackSpec_Services_Loadbalancer, using the provided StackSpecServicesLoadbalancer0
func (t *StackSpec_Services_Loadbalancer) MergeStackSpecServicesLoadbalancer0(v StackSpecServicesLoadbalancer0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecLoadBalancerService returns the union data inside the StackSpec_Services_Loadbalancer as a StackSpecLoadBalancerService
func (t StackSpec_Services_Loadbalancer) AsStackSpecLoadBalancerService() (StackSpecLoadBalancerService, error) {
	var body StackSpecLoadBalancerService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecLoadBalancerService overwrites any union data inside the StackSpec_Services_Loadbalancer as the provided StackSpecLoadBalancerService
func (t *StackSpec_Services_Loadbalancer) FromStackSpecLoadBalancerService(v StackSpecLoadBalancerService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecLoadBalancerService performs a merge with any union data inside the StackSpec_Services_Loadbalancer, using the provided StackSpecLoadBalancerService
func (t *StackSpec_Services_Loadbalancer) MergeStackSpecLoadBalancerService(v StackSpecLoadBalancerService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpec_Services_Loadbalancer) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpec_Services_Loadbalancer) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecServicesScheduler0 returns the union data inside the StackSpec_Services_Scheduler as a StackSpecServicesScheduler0
func (t StackSpec_Services_Scheduler) AsStackSpecServicesScheduler0() (StackSpecServicesScheduler0, error) {
	var body StackSpecServicesScheduler0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecServicesScheduler0 overwrites any union data inside the StackSpec_Services_Scheduler as the provided StackSpecServicesScheduler0
func (t *StackSpec_Services_Scheduler) FromStackSpecServicesScheduler0(v StackSpecServicesScheduler0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecServicesScheduler0 performs a merge with any union data inside the StackSpec_Services_Scheduler, using the provided StackSpecServicesScheduler0
func (t *StackSpec_Services_Scheduler) MergeStackSpecServicesScheduler0(v StackSpecServicesScheduler0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecSchedulerService returns the union data inside the StackSpec_Services_Scheduler as a StackSpecSchedulerService
func (t StackSpec_Services_Scheduler) AsStackSpecSchedulerService() (StackSpecSchedulerService, error) {
	var body StackSpecSchedulerService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecSchedulerService overwrites any union data inside the StackSpec_Services_Scheduler as the provided StackSpecSchedulerService
func (t *StackSpec_Services_Scheduler) FromStackSpecSchedulerService(v StackSpecSchedulerService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecSchedulerService performs a merge with any union data inside the StackSpec_Services_Scheduler, using the provided StackSpecSchedulerService
func (t *StackSpec_Services_Scheduler) MergeStackSpecSchedulerService(v StackSpecSchedulerService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpec_Services_Scheduler) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpec_Services_Scheduler) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecServicesVpn0 returns the union data inside the StackSpec_Services_Vpn as a StackSpecServicesVpn0
func (t StackSpec_Services_Vpn) AsStackSpecServicesVpn0() (StackSpecServicesVpn0, error) {
	var body StackSpecServicesVpn0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecServicesVpn0 overwrites any union data inside the StackSpec_Services_Vpn as the provided StackSpecServicesVpn0
func (t *StackSpec_Services_Vpn) FromStackSpecServicesVpn0(v StackSpecServicesVpn0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecServicesVpn0 performs a merge with any union data inside the StackSpec_Services_Vpn, using the provided StackSpecServicesVpn0
func (t *StackSpec_Services_Vpn) MergeStackSpecServicesVpn0(v StackSpecServicesVpn0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecVpnService returns the union data inside the StackSpec_Services_Vpn as a StackSpecVpnService
func (t StackSpec_Services_Vpn) AsStackSpecVpnService() (StackSpecVpnService, error) {
	var body StackSpecVpnService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecVpnService overwrites any union data inside the StackSpec_Services_Vpn as the provided StackSpecVpnService
func (t *StackSpec_Services_Vpn) FromStackSpecVpnService(v StackSpecVpnService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecVpnService performs a merge with any union data inside the StackSpec_Services_Vpn, using the provided StackSpecVpnService
func (t *StackSpec_Services_Vpn) MergeStackSpecVpnService(v StackSpecVpnService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpec_Services_Vpn) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpec_Services_Vpn) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackSpecDiscoveryConfig_EmptySetDelay as a Duration
func (t StackSpecDiscoveryConfig_EmptySetDelay) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackSpecDiscoveryConfig_EmptySetDelay as the provided Duration
func (t *StackSpecDiscoveryConfig_EmptySetDelay) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackSpecDiscoveryConfig_EmptySetDelay, using the provided Duration
func (t *StackSpecDiscoveryConfig_EmptySetDelay) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecDiscoveryConfigEmptySetDelay1 returns the union data inside the StackSpecDiscoveryConfig_EmptySetDelay as a StackSpecDiscoveryConfigEmptySetDelay1
func (t StackSpecDiscoveryConfig_EmptySetDelay) AsStackSpecDiscoveryConfigEmptySetDelay1() (StackSpecDiscoveryConfigEmptySetDelay1, error) {
	var body StackSpecDiscoveryConfigEmptySetDelay1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecDiscoveryConfigEmptySetDelay1 overwrites any union data inside the StackSpecDiscoveryConfig_EmptySetDelay as the provided StackSpecDiscoveryConfigEmptySetDelay1
func (t *StackSpecDiscoveryConfig_EmptySetDelay) FromStackSpecDiscoveryConfigEmptySetDelay1(v StackSpecDiscoveryConfigEmptySetDelay1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecDiscoveryConfigEmptySetDelay1 performs a merge with any union data inside the StackSpecDiscoveryConfig_EmptySetDelay, using the provided StackSpecDiscoveryConfigEmptySetDelay1
func (t *StackSpecDiscoveryConfig_EmptySetDelay) MergeStackSpecDiscoveryConfigEmptySetDelay1(v StackSpecDiscoveryConfigEmptySetDelay1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecDiscoveryConfig_EmptySetDelay) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecDiscoveryConfig_EmptySetDelay) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecDiscoveryConfig returns the union data inside the StackSpecDiscoveryService_Config as a StackSpecDiscoveryConfig
func (t StackSpecDiscoveryService_Config) AsStackSpecDiscoveryConfig() (StackSpecDiscoveryConfig, error) {
	var body StackSpecDiscoveryConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecDiscoveryConfig overwrites any union data inside the StackSpecDiscoveryService_Config as the provided StackSpecDiscoveryConfig
func (t *StackSpecDiscoveryService_Config) FromStackSpecDiscoveryConfig(v StackSpecDiscoveryConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecDiscoveryConfig performs a merge with any union data inside the StackSpecDiscoveryService_Config, using the provided StackSpecDiscoveryConfig
func (t *StackSpecDiscoveryService_Config) MergeStackSpecDiscoveryConfig(v StackSpecDiscoveryConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecDiscoveryServiceConfig1 returns the union data inside the StackSpecDiscoveryService_Config as a StackSpecDiscoveryServiceConfig1
func (t StackSpecDiscoveryService_Config) AsStackSpecDiscoveryServiceConfig1() (StackSpecDiscoveryServiceConfig1, error) {
	var body StackSpecDiscoveryServiceConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecDiscoveryServiceConfig1 overwrites any union data inside the StackSpecDiscoveryService_Config as the provided StackSpecDiscoveryServiceConfig1
func (t *StackSpecDiscoveryService_Config) FromStackSpecDiscoveryServiceConfig1(v StackSpecDiscoveryServiceConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecDiscoveryServiceConfig1 performs a merge with any union data inside the StackSpecDiscoveryService_Config, using the provided StackSpecDiscoveryServiceConfig1
func (t *StackSpecDiscoveryService_Config) MergeStackSpecDiscoveryServiceConfig1(v StackSpecDiscoveryServiceConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecDiscoveryService_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecDiscoveryService_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackService returns the union data inside the StackSpecDiscoveryService_Service as a StackService
func (t StackSpecDiscoveryService_Service) AsStackService() (StackService, error) {
	var body StackService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackService overwrites any union data inside the StackSpecDiscoveryService_Service as the provided StackService
func (t *StackSpecDiscoveryService_Service) FromStackService(v StackService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackService performs a merge with any union data inside the StackSpecDiscoveryService_Service, using the provided StackService
func (t *StackSpecDiscoveryService_Service) MergeStackService(v StackService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecDiscoveryServiceService1 returns the union data inside the StackSpecDiscoveryService_Service as a StackSpecDiscoveryServiceService1
func (t StackSpecDiscoveryService_Service) AsStackSpecDiscoveryServiceService1() (StackSpecDiscoveryServiceService1, error) {
	var body StackSpecDiscoveryServiceService1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecDiscoveryServiceService1 overwrites any union data inside the StackSpecDiscoveryService_Service as the provided StackSpecDiscoveryServiceService1
func (t *StackSpecDiscoveryService_Service) FromStackSpecDiscoveryServiceService1(v StackSpecDiscoveryServiceService1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecDiscoveryServiceService1 performs a merge with any union data inside the StackSpecDiscoveryService_Service, using the provided StackSpecDiscoveryServiceService1
func (t *StackSpecDiscoveryService_Service) MergeStackSpecDiscoveryServiceService1(v StackSpecDiscoveryServiceService1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecDiscoveryService_Service) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecDiscoveryService_Service) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHaProxyLbType returns the union data inside the StackSpecLoadBalancerConfig as a HaProxyLbType
func (t StackSpecLoadBalancerConfig) AsHaProxyLbType() (HaProxyLbType, error) {
	var body HaProxyLbType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHaProxyLbType overwrites any union data inside the StackSpecLoadBalancerConfig as the provided HaProxyLbType
func (t *StackSpecLoadBalancerConfig) FromHaProxyLbType(v HaProxyLbType) error {
	v.Type = "haproxy"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHaProxyLbType performs a merge with any union data inside the StackSpecLoadBalancerConfig, using the provided HaProxyLbType
func (t *StackSpecLoadBalancerConfig) MergeHaProxyLbType(v HaProxyLbType) error {
	v.Type = "haproxy"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV1LbType returns the union data inside the StackSpecLoadBalancerConfig as a V1LbType
func (t StackSpecLoadBalancerConfig) AsV1LbType() (V1LbType, error) {
	var body V1LbType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbType overwrites any union data inside the StackSpecLoadBalancerConfig as the provided V1LbType
func (t *StackSpecLoadBalancerConfig) FromV1LbType(v V1LbType) error {
	v.Type = "v1"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbType performs a merge with any union data inside the StackSpecLoadBalancerConfig, using the provided V1LbType
func (t *StackSpecLoadBalancerConfig) MergeV1LbType(v V1LbType) error {
	v.Type = "v1"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDefaultLbType returns the union data inside the StackSpecLoadBalancerConfig as a DefaultLbType
func (t StackSpecLoadBalancerConfig) AsDefaultLbType() (DefaultLbType, error) {
	var body DefaultLbType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDefaultLbType overwrites any union data inside the StackSpecLoadBalancerConfig as the provided DefaultLbType
func (t *StackSpecLoadBalancerConfig) FromDefaultLbType(v DefaultLbType) error {
	v.Type = "default"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDefaultLbType performs a merge with any union data inside the StackSpecLoadBalancerConfig, using the provided DefaultLbType
func (t *StackSpecLoadBalancerConfig) MergeDefaultLbType(v DefaultLbType) error {
	v.Type = "default"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecLoadBalancerConfig) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t StackSpecLoadBalancerConfig) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "default":
		return t.AsDefaultLbType()
	case "haproxy":
		return t.AsHaProxyLbType()
	case "v1":
		return t.AsV1LbType()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t StackSpecLoadBalancerConfig) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecLoadBalancerConfig) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecLoadBalancerConfig returns the union data inside the StackSpecLoadBalancerService_Config as a StackSpecLoadBalancerConfig
func (t StackSpecLoadBalancerService_Config) AsStackSpecLoadBalancerConfig() (StackSpecLoadBalancerConfig, error) {
	var body StackSpecLoadBalancerConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecLoadBalancerConfig overwrites any union data inside the StackSpecLoadBalancerService_Config as the provided StackSpecLoadBalancerConfig
func (t *StackSpecLoadBalancerService_Config) FromStackSpecLoadBalancerConfig(v StackSpecLoadBalancerConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecLoadBalancerConfig performs a merge with any union data inside the StackSpecLoadBalancerService_Config, using the provided StackSpecLoadBalancerConfig
func (t *StackSpecLoadBalancerService_Config) MergeStackSpecLoadBalancerConfig(v StackSpecLoadBalancerConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecLoadBalancerServiceConfig1 returns the union data inside the StackSpecLoadBalancerService_Config as a StackSpecLoadBalancerServiceConfig1
func (t StackSpecLoadBalancerService_Config) AsStackSpecLoadBalancerServiceConfig1() (StackSpecLoadBalancerServiceConfig1, error) {
	var body StackSpecLoadBalancerServiceConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecLoadBalancerServiceConfig1 overwrites any union data inside the StackSpecLoadBalancerService_Config as the provided StackSpecLoadBalancerServiceConfig1
func (t *StackSpecLoadBalancerService_Config) FromStackSpecLoadBalancerServiceConfig1(v StackSpecLoadBalancerServiceConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecLoadBalancerServiceConfig1 performs a merge with any union data inside the StackSpecLoadBalancerService_Config, using the provided StackSpecLoadBalancerServiceConfig1
func (t *StackSpecLoadBalancerService_Config) MergeStackSpecLoadBalancerServiceConfig1(v StackSpecLoadBalancerServiceConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecLoadBalancerService_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecLoadBalancerService_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackService returns the union data inside the StackSpecLoadBalancerService_Service as a StackService
func (t StackSpecLoadBalancerService_Service) AsStackService() (StackService, error) {
	var body StackService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackService overwrites any union data inside the StackSpecLoadBalancerService_Service as the provided StackService
func (t *StackSpecLoadBalancerService_Service) FromStackService(v StackService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackService performs a merge with any union data inside the StackSpecLoadBalancerService_Service, using the provided StackService
func (t *StackSpecLoadBalancerService_Service) MergeStackService(v StackService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecLoadBalancerServiceService1 returns the union data inside the StackSpecLoadBalancerService_Service as a StackSpecLoadBalancerServiceService1
func (t StackSpecLoadBalancerService_Service) AsStackSpecLoadBalancerServiceService1() (StackSpecLoadBalancerServiceService1, error) {
	var body StackSpecLoadBalancerServiceService1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecLoadBalancerServiceService1 overwrites any union data inside the StackSpecLoadBalancerService_Service as the provided StackSpecLoadBalancerServiceService1
func (t *StackSpecLoadBalancerService_Service) FromStackSpecLoadBalancerServiceService1(v StackSpecLoadBalancerServiceService1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecLoadBalancerServiceService1 performs a merge with any union data inside the StackSpecLoadBalancerService_Service, using the provided StackSpecLoadBalancerServiceService1
func (t *StackSpecLoadBalancerService_Service) MergeStackSpecLoadBalancerServiceService1(v StackSpecLoadBalancerServiceService1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecLoadBalancerService_Service) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecLoadBalancerService_Service) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecSchedulerConfig returns the union data inside the StackSpecSchedulerService_Config as a StackSpecSchedulerConfig
func (t StackSpecSchedulerService_Config) AsStackSpecSchedulerConfig() (StackSpecSchedulerConfig, error) {
	var body StackSpecSchedulerConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecSchedulerConfig overwrites any union data inside the StackSpecSchedulerService_Config as the provided StackSpecSchedulerConfig
func (t *StackSpecSchedulerService_Config) FromStackSpecSchedulerConfig(v StackSpecSchedulerConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecSchedulerConfig performs a merge with any union data inside the StackSpecSchedulerService_Config, using the provided StackSpecSchedulerConfig
func (t *StackSpecSchedulerService_Config) MergeStackSpecSchedulerConfig(v StackSpecSchedulerConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecSchedulerServiceConfig1 returns the union data inside the StackSpecSchedulerService_Config as a StackSpecSchedulerServiceConfig1
func (t StackSpecSchedulerService_Config) AsStackSpecSchedulerServiceConfig1() (StackSpecSchedulerServiceConfig1, error) {
	var body StackSpecSchedulerServiceConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecSchedulerServiceConfig1 overwrites any union data inside the StackSpecSchedulerService_Config as the provided StackSpecSchedulerServiceConfig1
func (t *StackSpecSchedulerService_Config) FromStackSpecSchedulerServiceConfig1(v StackSpecSchedulerServiceConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecSchedulerServiceConfig1 performs a merge with any union data inside the StackSpecSchedulerService_Config, using the provided StackSpecSchedulerServiceConfig1
func (t *StackSpecSchedulerService_Config) MergeStackSpecSchedulerServiceConfig1(v StackSpecSchedulerServiceConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecSchedulerService_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecSchedulerService_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackService returns the union data inside the StackSpecSchedulerService_Service as a StackService
func (t StackSpecSchedulerService_Service) AsStackService() (StackService, error) {
	var body StackService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackService overwrites any union data inside the StackSpecSchedulerService_Service as the provided StackService
func (t *StackSpecSchedulerService_Service) FromStackService(v StackService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackService performs a merge with any union data inside the StackSpecSchedulerService_Service, using the provided StackService
func (t *StackSpecSchedulerService_Service) MergeStackService(v StackService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecSchedulerServiceService1 returns the union data inside the StackSpecSchedulerService_Service as a StackSpecSchedulerServiceService1
func (t StackSpecSchedulerService_Service) AsStackSpecSchedulerServiceService1() (StackSpecSchedulerServiceService1, error) {
	var body StackSpecSchedulerServiceService1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecSchedulerServiceService1 overwrites any union data inside the StackSpecSchedulerService_Service as the provided StackSpecSchedulerServiceService1
func (t *StackSpecSchedulerService_Service) FromStackSpecSchedulerServiceService1(v StackSpecSchedulerServiceService1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecSchedulerServiceService1 performs a merge with any union data inside the StackSpecSchedulerService_Service, using the provided StackSpecSchedulerServiceService1
func (t *StackSpecSchedulerService_Service) MergeStackSpecSchedulerServiceService1(v StackSpecSchedulerServiceService1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecSchedulerService_Service) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecSchedulerService_Service) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDuration returns the union data inside the StackSpecScopedVariable_Access_InternalApi_Duration as a Duration
func (t StackSpecScopedVariable_Access_InternalApi_Duration) AsDuration() (Duration, error) {
	var body Duration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDuration overwrites any union data inside the StackSpecScopedVariable_Access_InternalApi_Duration as the provided Duration
func (t *StackSpecScopedVariable_Access_InternalApi_Duration) FromDuration(v Duration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDuration performs a merge with any union data inside the StackSpecScopedVariable_Access_InternalApi_Duration, using the provided Duration
func (t *StackSpecScopedVariable_Access_InternalApi_Duration) MergeDuration(v Duration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecScopedVariableAccessInternalApiDuration1 returns the union data inside the StackSpecScopedVariable_Access_InternalApi_Duration as a StackSpecScopedVariableAccessInternalApiDuration1
func (t StackSpecScopedVariable_Access_InternalApi_Duration) AsStackSpecScopedVariableAccessInternalApiDuration1() (StackSpecScopedVariableAccessInternalApiDuration1, error) {
	var body StackSpecScopedVariableAccessInternalApiDuration1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableAccessInternalApiDuration1 overwrites any union data inside the StackSpecScopedVariable_Access_InternalApi_Duration as the provided StackSpecScopedVariableAccessInternalApiDuration1
func (t *StackSpecScopedVariable_Access_InternalApi_Duration) FromStackSpecScopedVariableAccessInternalApiDuration1(v StackSpecScopedVariableAccessInternalApiDuration1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableAccessInternalApiDuration1 performs a merge with any union data inside the StackSpecScopedVariable_Access_InternalApi_Duration, using the provided StackSpecScopedVariableAccessInternalApiDuration1
func (t *StackSpecScopedVariable_Access_InternalApi_Duration) MergeStackSpecScopedVariableAccessInternalApiDuration1(v StackSpecScopedVariableAccessInternalApiDuration1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Access_InternalApi_Duration) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Access_InternalApi_Duration) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableUrlSource returns the union data inside the StackSpecScopedVariableSource1 as a StackSpecScopedVariableUrlSource
func (t StackSpecScopedVariableSource1) AsStackSpecScopedVariableUrlSource() (StackSpecScopedVariableUrlSource, error) {
	var body StackSpecScopedVariableUrlSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableUrlSource overwrites any union data inside the StackSpecScopedVariableSource1 as the provided StackSpecScopedVariableUrlSource
func (t *StackSpecScopedVariableSource1) FromStackSpecScopedVariableUrlSource(v StackSpecScopedVariableUrlSource) error {
	v.Type = "url"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableUrlSource performs a merge with any union data inside the StackSpecScopedVariableSource1, using the provided StackSpecScopedVariableUrlSource
func (t *StackSpecScopedVariableSource1) MergeStackSpecScopedVariableUrlSource(v StackSpecScopedVariableUrlSource) error {
	v.Type = "url"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecScopedVariableRawSource returns the union data inside the StackSpecScopedVariableSource1 as a StackSpecScopedVariableRawSource
func (t StackSpecScopedVariableSource1) AsStackSpecScopedVariableRawSource() (StackSpecScopedVariableRawSource, error) {
	var body StackSpecScopedVariableRawSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableRawSource overwrites any union data inside the StackSpecScopedVariableSource1 as the provided StackSpecScopedVariableRawSource
func (t *StackSpecScopedVariableSource1) FromStackSpecScopedVariableRawSource(v StackSpecScopedVariableRawSource) error {
	v.Type = "raw"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableRawSource performs a merge with any union data inside the StackSpecScopedVariableSource1, using the provided StackSpecScopedVariableRawSource
func (t *StackSpecScopedVariableSource1) MergeStackSpecScopedVariableRawSource(v StackSpecScopedVariableRawSource) error {
	v.Type = "raw"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariableSource1) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t StackSpecScopedVariableSource1) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "raw":
		return t.AsStackSpecScopedVariableRawSource()
	case "url":
		return t.AsStackSpecScopedVariableUrlSource()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t StackSpecScopedVariableSource1) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariableSource1) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecScopedVariableSource0 returns the union data inside the StackSpecScopedVariable_Source as a StackSpecScopedVariableSource0
func (t StackSpecScopedVariable_Source) AsStackSpecScopedVariableSource0() (StackSpecScopedVariableSource0, error) {
	var body StackSpecScopedVariableSource0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableSource0 overwrites any union data inside the StackSpecScopedVariable_Source as the provided StackSpecScopedVariableSource0
func (t *StackSpecScopedVariable_Source) FromStackSpecScopedVariableSource0(v StackSpecScopedVariableSource0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableSource0 performs a merge with any union data inside the StackSpecScopedVariable_Source, using the provided StackSpecScopedVariableSource0
func (t *StackSpecScopedVariable_Source) MergeStackSpecScopedVariableSource0(v StackSpecScopedVariableSource0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecScopedVariableSource1 returns the union data inside the StackSpecScopedVariable_Source as a StackSpecScopedVariableSource1
func (t StackSpecScopedVariable_Source) AsStackSpecScopedVariableSource1() (StackSpecScopedVariableSource1, error) {
	var body StackSpecScopedVariableSource1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecScopedVariableSource1 overwrites any union data inside the StackSpecScopedVariable_Source as the provided StackSpecScopedVariableSource1
func (t *StackSpecScopedVariable_Source) FromStackSpecScopedVariableSource1(v StackSpecScopedVariableSource1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecScopedVariableSource1 performs a merge with any union data inside the StackSpecScopedVariable_Source, using the provided StackSpecScopedVariableSource1
func (t *StackSpecScopedVariable_Source) MergeStackSpecScopedVariableSource1(v StackSpecScopedVariableSource1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecScopedVariable_Source) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecScopedVariable_Source) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackSpecVpnConfig returns the union data inside the StackSpecVpnService_Config as a StackSpecVpnConfig
func (t StackSpecVpnService_Config) AsStackSpecVpnConfig() (StackSpecVpnConfig, error) {
	var body StackSpecVpnConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecVpnConfig overwrites any union data inside the StackSpecVpnService_Config as the provided StackSpecVpnConfig
func (t *StackSpecVpnService_Config) FromStackSpecVpnConfig(v StackSpecVpnConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecVpnConfig performs a merge with any union data inside the StackSpecVpnService_Config, using the provided StackSpecVpnConfig
func (t *StackSpecVpnService_Config) MergeStackSpecVpnConfig(v StackSpecVpnConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecVpnServiceConfig1 returns the union data inside the StackSpecVpnService_Config as a StackSpecVpnServiceConfig1
func (t StackSpecVpnService_Config) AsStackSpecVpnServiceConfig1() (StackSpecVpnServiceConfig1, error) {
	var body StackSpecVpnServiceConfig1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecVpnServiceConfig1 overwrites any union data inside the StackSpecVpnService_Config as the provided StackSpecVpnServiceConfig1
func (t *StackSpecVpnService_Config) FromStackSpecVpnServiceConfig1(v StackSpecVpnServiceConfig1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecVpnServiceConfig1 performs a merge with any union data inside the StackSpecVpnService_Config, using the provided StackSpecVpnServiceConfig1
func (t *StackSpecVpnService_Config) MergeStackSpecVpnServiceConfig1(v StackSpecVpnServiceConfig1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecVpnService_Config) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecVpnService_Config) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStackService returns the union data inside the StackSpecVpnService_Service as a StackService
func (t StackSpecVpnService_Service) AsStackService() (StackService, error) {
	var body StackService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackService overwrites any union data inside the StackSpecVpnService_Service as the provided StackService
func (t *StackSpecVpnService_Service) FromStackService(v StackService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackService performs a merge with any union data inside the StackSpecVpnService_Service, using the provided StackService
func (t *StackSpecVpnService_Service) MergeStackService(v StackService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStackSpecVpnServiceService1 returns the union data inside the StackSpecVpnService_Service as a StackSpecVpnServiceService1
func (t StackSpecVpnService_Service) AsStackSpecVpnServiceService1() (StackSpecVpnServiceService1, error) {
	var body StackSpecVpnServiceService1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStackSpecVpnServiceService1 overwrites any union data inside the StackSpecVpnService_Service as the provided StackSpecVpnServiceService1
func (t *StackSpecVpnService_Service) FromStackSpecVpnServiceService1(v StackSpecVpnServiceService1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStackSpecVpnServiceService1 performs a merge with any union data inside the StackSpecVpnService_Service, using the provided StackSpecVpnServiceService1
func (t *StackSpecVpnService_Service) MergeStackSpecVpnServiceService1(v StackSpecVpnServiceService1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StackSpecVpnService_Service) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StackSpecVpnService_Service) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsV1LbController returns the union data inside the V1LbConfig_ControllerTemplate as a V1LbController
func (t V1LbConfig_ControllerTemplate) AsV1LbController() (V1LbController, error) {
	var body V1LbController
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbController overwrites any union data inside the V1LbConfig_ControllerTemplate as the provided V1LbController
func (t *V1LbConfig_ControllerTemplate) FromV1LbController(v V1LbController) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbController performs a merge with any union data inside the V1LbConfig_ControllerTemplate, using the provided V1LbController
func (t *V1LbConfig_ControllerTemplate) MergeV1LbController(v V1LbController) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV1LbConfigControllerTemplate1 returns the union data inside the V1LbConfig_ControllerTemplate as a V1LbConfigControllerTemplate1
func (t V1LbConfig_ControllerTemplate) AsV1LbConfigControllerTemplate1() (V1LbConfigControllerTemplate1, error) {
	var body V1LbConfigControllerTemplate1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbConfigControllerTemplate1 overwrites any union data inside the V1LbConfig_ControllerTemplate as the provided V1LbConfigControllerTemplate1
func (t *V1LbConfig_ControllerTemplate) FromV1LbConfigControllerTemplate1(v V1LbConfigControllerTemplate1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbConfigControllerTemplate1 performs a merge with any union data inside the V1LbConfig_ControllerTemplate, using the provided V1LbConfigControllerTemplate1
func (t *V1LbConfig_ControllerTemplate) MergeV1LbConfigControllerTemplate1(v V1LbConfigControllerTemplate1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V1LbConfig_ControllerTemplate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V1LbConfig_ControllerTemplate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWafConfig returns the union data inside the V1LbConfig_Waf as a WafConfig
func (t V1LbConfig_Waf) AsWafConfig() (WafConfig, error) {
	var body WafConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWafConfig overwrites any union data inside the V1LbConfig_Waf as the provided WafConfig
func (t *V1LbConfig_Waf) FromWafConfig(v WafConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWafConfig performs a merge with any union data inside the V1LbConfig_Waf, using the provided WafConfig
func (t *V1LbConfig_Waf) MergeWafConfig(v WafConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV1LbConfigWaf1 returns the union data inside the V1LbConfig_Waf as a V1LbConfigWaf1
func (t V1LbConfig_Waf) AsV1LbConfigWaf1() (V1LbConfigWaf1, error) {
	var body V1LbConfigWaf1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbConfigWaf1 overwrites any union data inside the V1LbConfig_Waf as the provided V1LbConfigWaf1
func (t *V1LbConfig_Waf) FromV1LbConfigWaf1(v V1LbConfigWaf1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbConfigWaf1 performs a merge with any union data inside the V1LbConfig_Waf, using the provided V1LbConfigWaf1
func (t *V1LbConfig_Waf) MergeV1LbConfigWaf1(v V1LbConfigWaf1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V1LbConfig_Waf) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V1LbConfig_Waf) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsV1LbConfigRouterConfigDestinationPrioritization0 returns the union data inside the V1LbConfigRouter_Config_DestinationPrioritization as a V1LbConfigRouterConfigDestinationPrioritization0
func (t V1LbConfigRouter_Config_DestinationPrioritization) AsV1LbConfigRouterConfigDestinationPrioritization0() (V1LbConfigRouterConfigDestinationPrioritization0, error) {
	var body V1LbConfigRouterConfigDestinationPrioritization0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbConfigRouterConfigDestinationPrioritization0 overwrites any union data inside the V1LbConfigRouter_Config_DestinationPrioritization as the provided V1LbConfigRouterConfigDestinationPrioritization0
func (t *V1LbConfigRouter_Config_DestinationPrioritization) FromV1LbConfigRouterConfigDestinationPrioritization0(v V1LbConfigRouterConfigDestinationPrioritization0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbConfigRouterConfigDestinationPrioritization0 performs a merge with any union data inside the V1LbConfigRouter_Config_DestinationPrioritization, using the provided V1LbConfigRouterConfigDestinationPrioritization0
func (t *V1LbConfigRouter_Config_DestinationPrioritization) MergeV1LbConfigRouterConfigDestinationPrioritization0(v V1LbConfigRouterConfigDestinationPrioritization0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV1LbConfigRouterConfigDestinationPrioritization1 returns the union data inside the V1LbConfigRouter_Config_DestinationPrioritization as a V1LbConfigRouterConfigDestinationPrioritization1
func (t V1LbConfigRouter_Config_DestinationPrioritization) AsV1LbConfigRouterConfigDestinationPrioritization1() (V1LbConfigRouterConfigDestinationPrioritization1, error) {
	var body V1LbConfigRouterConfigDestinationPrioritization1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbConfigRouterConfigDestinationPrioritization1 overwrites any union data inside the V1LbConfigRouter_Config_DestinationPrioritization as the provided V1LbConfigRouterConfigDestinationPrioritization1
func (t *V1LbConfigRouter_Config_DestinationPrioritization) FromV1LbConfigRouterConfigDestinationPrioritization1(v V1LbConfigRouterConfigDestinationPrioritization1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbConfigRouterConfigDestinationPrioritization1 performs a merge with any union data inside the V1LbConfigRouter_Config_DestinationPrioritization, using the provided V1LbConfigRouterConfigDestinationPrioritization1
func (t *V1LbConfigRouter_Config_DestinationPrioritization) MergeV1LbConfigRouterConfigDestinationPrioritization1(v V1LbConfigRouterConfigDestinationPrioritization1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V1LbConfigRouter_Config_DestinationPrioritization) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V1LbConfigRouter_Config_DestinationPrioritization) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTcpRouterConfig returns the union data inside the V1LbConfigRouterConfigExtension1 as a TcpRouterConfig
func (t V1LbConfigRouterConfigExtension1) AsTcpRouterConfig() (TcpRouterConfig, error) {
	var body TcpRouterConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTcpRouterConfig overwrites any union data inside the V1LbConfigRouterConfigExtension1 as the provided TcpRouterConfig
func (t *V1LbConfigRouterConfigExtension1) FromTcpRouterConfig(v TcpRouterConfig) error {
	v.Type = "tcp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTcpRouterConfig performs a merge with any union data inside the V1LbConfigRouterConfigExtension1, using the provided TcpRouterConfig
func (t *V1LbConfigRouterConfigExtension1) MergeTcpRouterConfig(v TcpRouterConfig) error {
	v.Type = "tcp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHttpRouterConfig returns the union data inside the V1LbConfigRouterConfigExtension1 as a HttpRouterConfig
func (t V1LbConfigRouterConfigExtension1) AsHttpRouterConfig() (HttpRouterConfig, error) {
	var body HttpRouterConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHttpRouterConfig overwrites any union data inside the V1LbConfigRouterConfigExtension1 as the provided HttpRouterConfig
func (t *V1LbConfigRouterConfigExtension1) FromHttpRouterConfig(v HttpRouterConfig) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHttpRouterConfig performs a merge with any union data inside the V1LbConfigRouterConfigExtension1, using the provided HttpRouterConfig
func (t *V1LbConfigRouterConfigExtension1) MergeHttpRouterConfig(v HttpRouterConfig) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUdpRouterConfig returns the union data inside the V1LbConfigRouterConfigExtension1 as a UdpRouterConfig
func (t V1LbConfigRouterConfigExtension1) AsUdpRouterConfig() (UdpRouterConfig, error) {
	var body UdpRouterConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUdpRouterConfig overwrites any union data inside the V1LbConfigRouterConfigExtension1 as the provided UdpRouterConfig
func (t *V1LbConfigRouterConfigExtension1) FromUdpRouterConfig(v UdpRouterConfig) error {
	v.Type = "udp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUdpRouterConfig performs a merge with any union data inside the V1LbConfigRouterConfigExtension1, using the provided UdpRouterConfig
func (t *V1LbConfigRouterConfigExtension1) MergeUdpRouterConfig(v UdpRouterConfig) error {
	v.Type = "udp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V1LbConfigRouterConfigExtension1) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t V1LbConfigRouterConfigExtension1) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "http":
		return t.AsHttpRouterConfig()
	case "tcp":
		return t.AsTcpRouterConfig()
	case "udp":
		return t.AsUdpRouterConfig()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t V1LbConfigRouterConfigExtension1) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V1LbConfigRouterConfigExtension1) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsV1LbConfigRouterConfigExtension0 returns the union data inside the V1LbConfigRouter_Config_Extension as a V1LbConfigRouterConfigExtension0
func (t V1LbConfigRouter_Config_Extension) AsV1LbConfigRouterConfigExtension0() (V1LbConfigRouterConfigExtension0, error) {
	var body V1LbConfigRouterConfigExtension0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbConfigRouterConfigExtension0 overwrites any union data inside the V1LbConfigRouter_Config_Extension as the provided V1LbConfigRouterConfigExtension0
func (t *V1LbConfigRouter_Config_Extension) FromV1LbConfigRouterConfigExtension0(v V1LbConfigRouterConfigExtension0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbConfigRouterConfigExtension0 performs a merge with any union data inside the V1LbConfigRouter_Config_Extension, using the provided V1LbConfigRouterConfigExtension0
func (t *V1LbConfigRouter_Config_Extension) MergeV1LbConfigRouterConfigExtension0(v V1LbConfigRouterConfigExtension0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV1LbConfigRouterConfigExtension1 returns the union data inside the V1LbConfigRouter_Config_Extension as a V1LbConfigRouterConfigExtension1
func (t V1LbConfigRouter_Config_Extension) AsV1LbConfigRouterConfigExtension1() (V1LbConfigRouterConfigExtension1, error) {
	var body V1LbConfigRouterConfigExtension1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbConfigRouterConfigExtension1 overwrites any union data inside the V1LbConfigRouter_Config_Extension as the provided V1LbConfigRouterConfigExtension1
func (t *V1LbConfigRouter_Config_Extension) FromV1LbConfigRouterConfigExtension1(v V1LbConfigRouterConfigExtension1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbConfigRouterConfigExtension1 performs a merge with any union data inside the V1LbConfigRouter_Config_Extension, using the provided V1LbConfigRouterConfigExtension1
func (t *V1LbConfigRouter_Config_Extension) MergeV1LbConfigRouterConfigExtension1(v V1LbConfigRouterConfigExtension1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V1LbConfigRouter_Config_Extension) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V1LbConfigRouter_Config_Extension) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsV1LbConfigRouterConfigTlsClientAuth0 returns the union data inside the V1LbConfigRouter_Config_Tls_ClientAuth as a V1LbConfigRouterConfigTlsClientAuth0
func (t V1LbConfigRouter_Config_Tls_ClientAuth) AsV1LbConfigRouterConfigTlsClientAuth0() (V1LbConfigRouterConfigTlsClientAuth0, error) {
	var body V1LbConfigRouterConfigTlsClientAuth0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbConfigRouterConfigTlsClientAuth0 overwrites any union data inside the V1LbConfigRouter_Config_Tls_ClientAuth as the provided V1LbConfigRouterConfigTlsClientAuth0
func (t *V1LbConfigRouter_Config_Tls_ClientAuth) FromV1LbConfigRouterConfigTlsClientAuth0(v V1LbConfigRouterConfigTlsClientAuth0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbConfigRouterConfigTlsClientAuth0 performs a merge with any union data inside the V1LbConfigRouter_Config_Tls_ClientAuth, using the provided V1LbConfigRouterConfigTlsClientAuth0
func (t *V1LbConfigRouter_Config_Tls_ClientAuth) MergeV1LbConfigRouterConfigTlsClientAuth0(v V1LbConfigRouterConfigTlsClientAuth0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV1LbConfigRouterConfigTlsClientAuth1 returns the union data inside the V1LbConfigRouter_Config_Tls_ClientAuth as a V1LbConfigRouterConfigTlsClientAuth1
func (t V1LbConfigRouter_Config_Tls_ClientAuth) AsV1LbConfigRouterConfigTlsClientAuth1() (V1LbConfigRouterConfigTlsClientAuth1, error) {
	var body V1LbConfigRouterConfigTlsClientAuth1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbConfigRouterConfigTlsClientAuth1 overwrites any union data inside the V1LbConfigRouter_Config_Tls_ClientAuth as the provided V1LbConfigRouterConfigTlsClientAuth1
func (t *V1LbConfigRouter_Config_Tls_ClientAuth) FromV1LbConfigRouterConfigTlsClientAuth1(v V1LbConfigRouterConfigTlsClientAuth1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbConfigRouterConfigTlsClientAuth1 performs a merge with any union data inside the V1LbConfigRouter_Config_Tls_ClientAuth, using the provided V1LbConfigRouterConfigTlsClientAuth1
func (t *V1LbConfigRouter_Config_Tls_ClientAuth) MergeV1LbConfigRouterConfigTlsClientAuth1(v V1LbConfigRouterConfigTlsClientAuth1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V1LbConfigRouter_Config_Tls_ClientAuth) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V1LbConfigRouter_Config_Tls_ClientAuth) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTcpTransportConfig returns the union data inside the V1LbController_Transport_Config_Extension as a TcpTransportConfig
func (t V1LbController_Transport_Config_Extension) AsTcpTransportConfig() (TcpTransportConfig, error) {
	var body TcpTransportConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTcpTransportConfig overwrites any union data inside the V1LbController_Transport_Config_Extension as the provided TcpTransportConfig
func (t *V1LbController_Transport_Config_Extension) FromTcpTransportConfig(v TcpTransportConfig) error {
	v.Type = "tcp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTcpTransportConfig performs a merge with any union data inside the V1LbController_Transport_Config_Extension, using the provided TcpTransportConfig
func (t *V1LbController_Transport_Config_Extension) MergeTcpTransportConfig(v TcpTransportConfig) error {
	v.Type = "tcp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHttpTransportConfig returns the union data inside the V1LbController_Transport_Config_Extension as a HttpTransportConfig
func (t V1LbController_Transport_Config_Extension) AsHttpTransportConfig() (HttpTransportConfig, error) {
	var body HttpTransportConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHttpTransportConfig overwrites any union data inside the V1LbController_Transport_Config_Extension as the provided HttpTransportConfig
func (t *V1LbController_Transport_Config_Extension) FromHttpTransportConfig(v HttpTransportConfig) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHttpTransportConfig performs a merge with any union data inside the V1LbController_Transport_Config_Extension, using the provided HttpTransportConfig
func (t *V1LbController_Transport_Config_Extension) MergeHttpTransportConfig(v HttpTransportConfig) error {
	v.Type = "http"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUdpTransportConfig returns the union data inside the V1LbController_Transport_Config_Extension as a UdpTransportConfig
func (t V1LbController_Transport_Config_Extension) AsUdpTransportConfig() (UdpTransportConfig, error) {
	var body UdpTransportConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUdpTransportConfig overwrites any union data inside the V1LbController_Transport_Config_Extension as the provided UdpTransportConfig
func (t *V1LbController_Transport_Config_Extension) FromUdpTransportConfig(v UdpTransportConfig) error {
	v.Type = "udp"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUdpTransportConfig performs a merge with any union data inside the V1LbController_Transport_Config_Extension, using the provided UdpTransportConfig
func (t *V1LbController_Transport_Config_Extension) MergeUdpTransportConfig(v UdpTransportConfig) error {
	v.Type = "udp"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V1LbController_Transport_Config_Extension) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t V1LbController_Transport_Config_Extension) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "http":
		return t.AsHttpTransportConfig()
	case "tcp":
		return t.AsTcpTransportConfig()
	case "udp":
		return t.AsUdpTransportConfig()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t V1LbController_Transport_Config_Extension) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V1LbController_Transport_Config_Extension) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWafConfig returns the union data inside the V1LbController_Waf as a WafConfig
func (t V1LbController_Waf) AsWafConfig() (WafConfig, error) {
	var body WafConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWafConfig overwrites any union data inside the V1LbController_Waf as the provided WafConfig
func (t *V1LbController_Waf) FromWafConfig(v WafConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWafConfig performs a merge with any union data inside the V1LbController_Waf, using the provided WafConfig
func (t *V1LbController_Waf) MergeWafConfig(v WafConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV1LbControllerWaf1 returns the union data inside the V1LbController_Waf as a V1LbControllerWaf1
func (t V1LbController_Waf) AsV1LbControllerWaf1() (V1LbControllerWaf1, error) {
	var body V1LbControllerWaf1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV1LbControllerWaf1 overwrites any union data inside the V1LbController_Waf as the provided V1LbControllerWaf1
func (t *V1LbController_Waf) FromV1LbControllerWaf1(v V1LbControllerWaf1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV1LbControllerWaf1 performs a merge with any union data inside the V1LbController_Waf, using the provided V1LbControllerWaf1
func (t *V1LbController_Waf) MergeV1LbControllerWaf1(v V1LbControllerWaf1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V1LbController_Waf) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V1LbController_Waf) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsACL returns the union data inside the Zone_Acl as a ACL
func (t Zone_Acl) AsACL() (ACL, error) {
	var body ACL
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromACL overwrites any union data inside the Zone_Acl as the provided ACL
func (t *Zone_Acl) FromACL(v ACL) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeACL performs a merge with any union data inside the Zone_Acl, using the provided ACL
func (t *Zone_Acl) MergeACL(v ACL) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsZoneAcl1 returns the union data inside the Zone_Acl as a ZoneAcl1
func (t Zone_Acl) AsZoneAcl1() (ZoneAcl1, error) {
	var body ZoneAcl1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromZoneAcl1 overwrites any union data inside the Zone_Acl as the provided ZoneAcl1
func (t *Zone_Acl) FromZoneAcl1(v ZoneAcl1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeZoneAcl1 performs a merge with any union data inside the Zone_Acl, using the provided ZoneAcl1
func (t *Zone_Acl) MergeZoneAcl1(v ZoneAcl1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Zone_Acl) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Zone_Acl) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetDNSZones request
	GetDNSZones(ctx context.Context, params *GetDNSZonesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDNSZoneWithBody request with any body
	CreateDNSZoneWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDNSZone(ctx context.Context, body CreateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDNSZone request
	DeleteDNSZone(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDNSZone request
	GetDNSZone(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDNSZoneWithBody request with any body
	UpdateDNSZoneWithBody(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDNSZone(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, body UpdateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDNSZoneAccessWithBody request with any body
	UpdateDNSZoneAccessWithBody(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDNSZoneAccess(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, body UpdateDNSZoneAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDNSZoneJobWithBody request with any body
	CreateDNSZoneJobWithBody(ctx context.Context, zoneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDNSZoneJob(ctx context.Context, zoneId string, body CreateDNSZoneJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironments request
	GetEnvironments(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEnvironmentWithBody request with any body
	CreateEnvironmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEnvironment(ctx context.Context, body CreateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironmentMonitoringTiers request
	GetEnvironmentMonitoringTiers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEnvironment request
	DeleteEnvironment(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironment request
	GetEnvironment(ctx context.Context, environmentId string, params *GetEnvironmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEnvironmentWithBody request with any body
	UpdateEnvironmentWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEnvironment(ctx context.Context, environmentId string, body UpdateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEnvironmentAccessWithBody request with any body
	UpdateEnvironmentAccessWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEnvironmentAccess(ctx context.Context, environmentId string, body UpdateEnvironmentAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportStackWithBody request with any body
	ExportStackWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportStack(ctx context.Context, environmentId string, body ExportStackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnvironmentSummary request
	GetEnvironmentSummary(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEnvironmentJobWithBody request with any body
	CreateEnvironmentJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEnvironmentJob(ctx context.Context, environmentId string, body CreateEnvironmentJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJobs request
	GetJobs(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestJobs request
	GetLatestJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJob request
	GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetDNSZones(ctx context.Context, params *GetDNSZonesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDNSZonesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNSZoneWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNSZoneRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNSZone(ctx context.Context, body CreateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNSZoneRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDNSZone(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDNSZoneRequest(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDNSZone(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDNSZoneRequest(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNSZoneWithBody(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNSZoneRequestWithBody(c.Server, zoneId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNSZone(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, body UpdateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNSZoneRequest(c.Server, zoneId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNSZoneAccessWithBody(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNSZoneAccessRequestWithBody(c.Server, zoneId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNSZoneAccess(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, body UpdateDNSZoneAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNSZoneAccessRequest(c.Server, zoneId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNSZoneJobWithBody(ctx context.Context, zoneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNSZoneJobRequestWithBody(c.Server, zoneId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNSZoneJob(ctx context.Context, zoneId string, body CreateDNSZoneJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNSZoneJobRequest(c.Server, zoneId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironments(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvironmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvironmentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvironment(ctx context.Context, body CreateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvironmentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironmentMonitoringTiers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentMonitoringTiersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEnvironment(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEnvironmentRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironment(ctx context.Context, environmentId string, params *GetEnvironmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentRequest(c.Server, environmentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvironmentWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvironmentRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvironment(ctx context.Context, environmentId string, body UpdateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvironmentRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvironmentAccessWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvironmentAccessRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvironmentAccess(ctx context.Context, environmentId string, body UpdateEnvironmentAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvironmentAccessRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportStackWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportStackRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportStack(ctx context.Context, environmentId string, body ExportStackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportStackRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnvironmentSummary(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnvironmentSummaryRequest(c.Server, environmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvironmentJobWithBody(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvironmentJobRequestWithBody(c.Server, environmentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEnvironmentJob(ctx context.Context, environmentId string, body CreateEnvironmentJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEnvironmentJobRequest(c.Server, environmentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJobs(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestJobs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestJobsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetDNSZonesRequest generates requests for GetDNSZones
func NewGetDNSZonesRequest(server string, params *GetDNSZonesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDNSZoneRequest calls the generic CreateDNSZone builder with application/json body
func NewCreateDNSZoneRequest(server string, body CreateDNSZoneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDNSZoneRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDNSZoneRequestWithBody generates requests for CreateDNSZone with any type of body
func NewCreateDNSZoneRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDNSZoneRequest generates requests for DeleteDNSZone
func NewDeleteDNSZoneRequest(server string, zoneId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDNSZoneRequest generates requests for GetDNSZone
func NewGetDNSZoneRequest(server string, zoneId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDNSZoneRequest calls the generic UpdateDNSZone builder with application/json body
func NewUpdateDNSZoneRequest(server string, zoneId string, params *UpdateDNSZoneParams, body UpdateDNSZoneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDNSZoneRequestWithBody(server, zoneId, params, "application/json", bodyReader)
}

// NewUpdateDNSZoneRequestWithBody generates requests for UpdateDNSZone with any type of body
func NewUpdateDNSZoneRequestWithBody(server string, zoneId string, params *UpdateDNSZoneParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateDNSZoneAccessRequest calls the generic UpdateDNSZoneAccess builder with application/json body
func NewUpdateDNSZoneAccessRequest(server string, zoneId string, params *UpdateDNSZoneAccessParams, body UpdateDNSZoneAccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDNSZoneAccessRequestWithBody(server, zoneId, params, "application/json", bodyReader)
}

// NewUpdateDNSZoneAccessRequestWithBody generates requests for UpdateDNSZoneAccess with any type of body
func NewUpdateDNSZoneAccessRequestWithBody(server string, zoneId string, params *UpdateDNSZoneAccessParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s/access", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDNSZoneJobRequest calls the generic CreateDNSZoneJob builder with application/json body
func NewCreateDNSZoneJobRequest(server string, zoneId string, body CreateDNSZoneJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDNSZoneJobRequestWithBody(server, zoneId, "application/json", bodyReader)
}

// NewCreateDNSZoneJobRequestWithBody generates requests for CreateDNSZoneJob with any type of body
func NewCreateDNSZoneJobRequestWithBody(server string, zoneId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/dns/zones/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnvironmentsRequest generates requests for GetEnvironments
func NewGetEnvironmentsRequest(server string, params *GetEnvironmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEnvironmentRequest calls the generic CreateEnvironment builder with application/json body
func NewCreateEnvironmentRequest(server string, body CreateEnvironmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEnvironmentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEnvironmentRequestWithBody generates requests for CreateEnvironment with any type of body
func NewCreateEnvironmentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnvironmentMonitoringTiersRequest generates requests for GetEnvironmentMonitoringTiers
func NewGetEnvironmentMonitoringTiersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/monitoring-tiers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteEnvironmentRequest generates requests for DeleteEnvironment
func NewDeleteEnvironmentRequest(server string, environmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEnvironmentRequest generates requests for GetEnvironment
func NewGetEnvironmentRequest(server string, environmentId string, params *GetEnvironmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Meta != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "meta", runtime.ParamLocationQuery, *params.Meta); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEnvironmentRequest calls the generic UpdateEnvironment builder with application/json body
func NewUpdateEnvironmentRequest(server string, environmentId string, body UpdateEnvironmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEnvironmentRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewUpdateEnvironmentRequestWithBody generates requests for UpdateEnvironment with any type of body
func NewUpdateEnvironmentRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateEnvironmentAccessRequest calls the generic UpdateEnvironmentAccess builder with application/json body
func NewUpdateEnvironmentAccessRequest(server string, environmentId string, body UpdateEnvironmentAccessJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEnvironmentAccessRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewUpdateEnvironmentAccessRequestWithBody generates requests for UpdateEnvironmentAccess with any type of body
func NewUpdateEnvironmentAccessRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/access", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExportStackRequest calls the generic ExportStack builder with application/json body
func NewExportStackRequest(server string, environmentId string, body ExportStackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportStackRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewExportStackRequestWithBody generates requests for ExportStack with any type of body
func NewExportStackRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/export/stack", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnvironmentSummaryRequest generates requests for GetEnvironmentSummary
func NewGetEnvironmentSummaryRequest(server string, environmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEnvironmentJobRequest calls the generic CreateEnvironmentJob builder with application/json body
func NewCreateEnvironmentJobRequest(server string, environmentId string, body CreateEnvironmentJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEnvironmentJobRequestWithBody(server, environmentId, "application/json", bodyReader)
}

// NewCreateEnvironmentJobRequestWithBody generates requests for CreateEnvironmentJob with any type of body
func NewCreateEnvironmentJobRequestWithBody(server string, environmentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "environmentId", runtime.ParamLocationPath, environmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/environments/%s/tasks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetJobsRequest generates requests for GetJobs
func NewGetJobsRequest(server string, params *GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLatestJobsRequest generates requests for GetLatestJobs
func NewGetLatestJobsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs/latest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJobRequest generates requests for GetJob
func NewGetJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobId", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetDNSZonesWithResponse request
	GetDNSZonesWithResponse(ctx context.Context, params *GetDNSZonesParams, reqEditors ...RequestEditorFn) (*GetDNSZonesResponse, error)

	// CreateDNSZoneWithBodyWithResponse request with any body
	CreateDNSZoneWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNSZoneResponse, error)

	CreateDNSZoneWithResponse(ctx context.Context, body CreateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNSZoneResponse, error)

	// DeleteDNSZoneWithResponse request
	DeleteDNSZoneWithResponse(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*DeleteDNSZoneResponse, error)

	// GetDNSZoneWithResponse request
	GetDNSZoneWithResponse(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*GetDNSZoneResponse, error)

	// UpdateDNSZoneWithBodyWithResponse request with any body
	UpdateDNSZoneWithBodyWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNSZoneResponse, error)

	UpdateDNSZoneWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, body UpdateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNSZoneResponse, error)

	// UpdateDNSZoneAccessWithBodyWithResponse request with any body
	UpdateDNSZoneAccessWithBodyWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNSZoneAccessResponse, error)

	UpdateDNSZoneAccessWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, body UpdateDNSZoneAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNSZoneAccessResponse, error)

	// CreateDNSZoneJobWithBodyWithResponse request with any body
	CreateDNSZoneJobWithBodyWithResponse(ctx context.Context, zoneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNSZoneJobResponse, error)

	CreateDNSZoneJobWithResponse(ctx context.Context, zoneId string, body CreateDNSZoneJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNSZoneJobResponse, error)

	// GetEnvironmentsWithResponse request
	GetEnvironmentsWithResponse(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*GetEnvironmentsResponse, error)

	// CreateEnvironmentWithBodyWithResponse request with any body
	CreateEnvironmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvironmentResponse, error)

	CreateEnvironmentWithResponse(ctx context.Context, body CreateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvironmentResponse, error)

	// GetEnvironmentMonitoringTiersWithResponse request
	GetEnvironmentMonitoringTiersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEnvironmentMonitoringTiersResponse, error)

	// DeleteEnvironmentWithResponse request
	DeleteEnvironmentWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*DeleteEnvironmentResponse, error)

	// GetEnvironmentWithResponse request
	GetEnvironmentWithResponse(ctx context.Context, environmentId string, params *GetEnvironmentParams, reqEditors ...RequestEditorFn) (*GetEnvironmentResponse, error)

	// UpdateEnvironmentWithBodyWithResponse request with any body
	UpdateEnvironmentWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvironmentResponse, error)

	UpdateEnvironmentWithResponse(ctx context.Context, environmentId string, body UpdateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvironmentResponse, error)

	// UpdateEnvironmentAccessWithBodyWithResponse request with any body
	UpdateEnvironmentAccessWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvironmentAccessResponse, error)

	UpdateEnvironmentAccessWithResponse(ctx context.Context, environmentId string, body UpdateEnvironmentAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvironmentAccessResponse, error)

	// ExportStackWithBodyWithResponse request with any body
	ExportStackWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportStackResponse, error)

	ExportStackWithResponse(ctx context.Context, environmentId string, body ExportStackJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportStackResponse, error)

	// GetEnvironmentSummaryWithResponse request
	GetEnvironmentSummaryWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*GetEnvironmentSummaryResponse, error)

	// CreateEnvironmentJobWithBodyWithResponse request with any body
	CreateEnvironmentJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvironmentJobResponse, error)

	CreateEnvironmentJobWithResponse(ctx context.Context, environmentId string, body CreateEnvironmentJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvironmentJobResponse, error)

	// GetJobsWithResponse request
	GetJobsWithResponse(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*GetJobsResponse, error)

	// GetLatestJobsWithResponse request
	GetLatestJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLatestJobsResponse, error)

	// GetJobWithResponse request
	GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetJobResponse, error)
}

type GetDNSZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Zone `json:"data"`

		// Includes All includable resources linkable to the given Zone.
		Includes *ZoneIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDNSZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDNSZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDNSZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
		Data Zone `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDNSZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDNSZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDNSZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDNSZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDNSZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDNSZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
		Data Zone `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDNSZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDNSZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDNSZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
		Data Zone `json:"data"`

		// Includes All includable resources linkable to the given Zone.
		Includes *ZoneIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateDNSZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDNSZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDNSZoneAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
		Data Zone `json:"data"`

		// Includes All includable resources linkable to the given Zone.
		Includes *ZoneIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateDNSZoneAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDNSZoneAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDNSZoneJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDNSZoneJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDNSZoneJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []Environment `json:"data"`
		Includes *struct {
			// Creators An identity that created a resource.
			Creators *CreatorInclude `json:"creators,omitempty"`
		} `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://docs.cycle.io/environments/overview/).
		Data Environment `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentMonitoringTiersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data map[string]MonitoringTierDetails `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentMonitoringTiersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentMonitoringTiersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://docs.cycle.io/environments/overview/).
		Data     Environment `json:"data"`
		Includes *struct {
			// Creators An identity that created a resource.
			Creators *CreatorInclude `json:"creators,omitempty"`
		} `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://docs.cycle.io/environments/overview/).
		Data Environment `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEnvironmentAccessResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://docs.cycle.io/environments/overview/).
		Data Environment `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r UpdateEnvironmentAccessResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEnvironmentAccessResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportStackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A Cycle stack file is an "environment as code". Anything that can be done in an environment on Cycle can be described in a stack file and deployed as a new environment.
		// Stack files can list multiple containers and their configurations, load balancer settings, scoped variables, and much more.
		Data StackSpec `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r ExportStackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportStackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnvironmentSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Contains useful and relevant data/statistics for an environment that would otherwise be several separate API calls.
		Data EnvironmentSummary `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetEnvironmentSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnvironmentSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEnvironmentJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
		Data JobDescriptor `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateEnvironmentJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEnvironmentJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []Job        `json:"data"`
		Includes *JobIncludes `json:"includes,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []Job `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLatestJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data A job resource.
		Data Job `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetDNSZonesWithResponse request returning *GetDNSZonesResponse
func (c *ClientWithResponses) GetDNSZonesWithResponse(ctx context.Context, params *GetDNSZonesParams, reqEditors ...RequestEditorFn) (*GetDNSZonesResponse, error) {
	rsp, err := c.GetDNSZones(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDNSZonesResponse(rsp)
}

// CreateDNSZoneWithBodyWithResponse request with arbitrary body returning *CreateDNSZoneResponse
func (c *ClientWithResponses) CreateDNSZoneWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNSZoneResponse, error) {
	rsp, err := c.CreateDNSZoneWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNSZoneResponse(rsp)
}

func (c *ClientWithResponses) CreateDNSZoneWithResponse(ctx context.Context, body CreateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNSZoneResponse, error) {
	rsp, err := c.CreateDNSZone(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNSZoneResponse(rsp)
}

// DeleteDNSZoneWithResponse request returning *DeleteDNSZoneResponse
func (c *ClientWithResponses) DeleteDNSZoneWithResponse(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*DeleteDNSZoneResponse, error) {
	rsp, err := c.DeleteDNSZone(ctx, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDNSZoneResponse(rsp)
}

// GetDNSZoneWithResponse request returning *GetDNSZoneResponse
func (c *ClientWithResponses) GetDNSZoneWithResponse(ctx context.Context, zoneId string, reqEditors ...RequestEditorFn) (*GetDNSZoneResponse, error) {
	rsp, err := c.GetDNSZone(ctx, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDNSZoneResponse(rsp)
}

// UpdateDNSZoneWithBodyWithResponse request with arbitrary body returning *UpdateDNSZoneResponse
func (c *ClientWithResponses) UpdateDNSZoneWithBodyWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNSZoneResponse, error) {
	rsp, err := c.UpdateDNSZoneWithBody(ctx, zoneId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNSZoneResponse(rsp)
}

func (c *ClientWithResponses) UpdateDNSZoneWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneParams, body UpdateDNSZoneJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNSZoneResponse, error) {
	rsp, err := c.UpdateDNSZone(ctx, zoneId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNSZoneResponse(rsp)
}

// UpdateDNSZoneAccessWithBodyWithResponse request with arbitrary body returning *UpdateDNSZoneAccessResponse
func (c *ClientWithResponses) UpdateDNSZoneAccessWithBodyWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNSZoneAccessResponse, error) {
	rsp, err := c.UpdateDNSZoneAccessWithBody(ctx, zoneId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNSZoneAccessResponse(rsp)
}

func (c *ClientWithResponses) UpdateDNSZoneAccessWithResponse(ctx context.Context, zoneId string, params *UpdateDNSZoneAccessParams, body UpdateDNSZoneAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNSZoneAccessResponse, error) {
	rsp, err := c.UpdateDNSZoneAccess(ctx, zoneId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNSZoneAccessResponse(rsp)
}

// CreateDNSZoneJobWithBodyWithResponse request with arbitrary body returning *CreateDNSZoneJobResponse
func (c *ClientWithResponses) CreateDNSZoneJobWithBodyWithResponse(ctx context.Context, zoneId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNSZoneJobResponse, error) {
	rsp, err := c.CreateDNSZoneJobWithBody(ctx, zoneId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNSZoneJobResponse(rsp)
}

func (c *ClientWithResponses) CreateDNSZoneJobWithResponse(ctx context.Context, zoneId string, body CreateDNSZoneJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNSZoneJobResponse, error) {
	rsp, err := c.CreateDNSZoneJob(ctx, zoneId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNSZoneJobResponse(rsp)
}

// GetEnvironmentsWithResponse request returning *GetEnvironmentsResponse
func (c *ClientWithResponses) GetEnvironmentsWithResponse(ctx context.Context, params *GetEnvironmentsParams, reqEditors ...RequestEditorFn) (*GetEnvironmentsResponse, error) {
	rsp, err := c.GetEnvironments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentsResponse(rsp)
}

// CreateEnvironmentWithBodyWithResponse request with arbitrary body returning *CreateEnvironmentResponse
func (c *ClientWithResponses) CreateEnvironmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvironmentResponse, error) {
	rsp, err := c.CreateEnvironmentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvironmentResponse(rsp)
}

func (c *ClientWithResponses) CreateEnvironmentWithResponse(ctx context.Context, body CreateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvironmentResponse, error) {
	rsp, err := c.CreateEnvironment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvironmentResponse(rsp)
}

// GetEnvironmentMonitoringTiersWithResponse request returning *GetEnvironmentMonitoringTiersResponse
func (c *ClientWithResponses) GetEnvironmentMonitoringTiersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEnvironmentMonitoringTiersResponse, error) {
	rsp, err := c.GetEnvironmentMonitoringTiers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentMonitoringTiersResponse(rsp)
}

// DeleteEnvironmentWithResponse request returning *DeleteEnvironmentResponse
func (c *ClientWithResponses) DeleteEnvironmentWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*DeleteEnvironmentResponse, error) {
	rsp, err := c.DeleteEnvironment(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEnvironmentResponse(rsp)
}

// GetEnvironmentWithResponse request returning *GetEnvironmentResponse
func (c *ClientWithResponses) GetEnvironmentWithResponse(ctx context.Context, environmentId string, params *GetEnvironmentParams, reqEditors ...RequestEditorFn) (*GetEnvironmentResponse, error) {
	rsp, err := c.GetEnvironment(ctx, environmentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentResponse(rsp)
}

// UpdateEnvironmentWithBodyWithResponse request with arbitrary body returning *UpdateEnvironmentResponse
func (c *ClientWithResponses) UpdateEnvironmentWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvironmentResponse, error) {
	rsp, err := c.UpdateEnvironmentWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvironmentResponse(rsp)
}

func (c *ClientWithResponses) UpdateEnvironmentWithResponse(ctx context.Context, environmentId string, body UpdateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvironmentResponse, error) {
	rsp, err := c.UpdateEnvironment(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvironmentResponse(rsp)
}

// UpdateEnvironmentAccessWithBodyWithResponse request with arbitrary body returning *UpdateEnvironmentAccessResponse
func (c *ClientWithResponses) UpdateEnvironmentAccessWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvironmentAccessResponse, error) {
	rsp, err := c.UpdateEnvironmentAccessWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvironmentAccessResponse(rsp)
}

func (c *ClientWithResponses) UpdateEnvironmentAccessWithResponse(ctx context.Context, environmentId string, body UpdateEnvironmentAccessJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvironmentAccessResponse, error) {
	rsp, err := c.UpdateEnvironmentAccess(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvironmentAccessResponse(rsp)
}

// ExportStackWithBodyWithResponse request with arbitrary body returning *ExportStackResponse
func (c *ClientWithResponses) ExportStackWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportStackResponse, error) {
	rsp, err := c.ExportStackWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportStackResponse(rsp)
}

func (c *ClientWithResponses) ExportStackWithResponse(ctx context.Context, environmentId string, body ExportStackJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportStackResponse, error) {
	rsp, err := c.ExportStack(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportStackResponse(rsp)
}

// GetEnvironmentSummaryWithResponse request returning *GetEnvironmentSummaryResponse
func (c *ClientWithResponses) GetEnvironmentSummaryWithResponse(ctx context.Context, environmentId string, reqEditors ...RequestEditorFn) (*GetEnvironmentSummaryResponse, error) {
	rsp, err := c.GetEnvironmentSummary(ctx, environmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnvironmentSummaryResponse(rsp)
}

// CreateEnvironmentJobWithBodyWithResponse request with arbitrary body returning *CreateEnvironmentJobResponse
func (c *ClientWithResponses) CreateEnvironmentJobWithBodyWithResponse(ctx context.Context, environmentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEnvironmentJobResponse, error) {
	rsp, err := c.CreateEnvironmentJobWithBody(ctx, environmentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvironmentJobResponse(rsp)
}

func (c *ClientWithResponses) CreateEnvironmentJobWithResponse(ctx context.Context, environmentId string, body CreateEnvironmentJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEnvironmentJobResponse, error) {
	rsp, err := c.CreateEnvironmentJob(ctx, environmentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEnvironmentJobResponse(rsp)
}

// GetJobsWithResponse request returning *GetJobsResponse
func (c *ClientWithResponses) GetJobsWithResponse(ctx context.Context, params *GetJobsParams, reqEditors ...RequestEditorFn) (*GetJobsResponse, error) {
	rsp, err := c.GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobsResponse(rsp)
}

// GetLatestJobsWithResponse request returning *GetLatestJobsResponse
func (c *ClientWithResponses) GetLatestJobsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLatestJobsResponse, error) {
	rsp, err := c.GetLatestJobs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestJobsResponse(rsp)
}

// GetJobWithResponse request returning *GetJobResponse
func (c *ClientWithResponses) GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetJobResponse, error) {
	rsp, err := c.GetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJobResponse(rsp)
}

// ParseGetDNSZonesResponse parses an HTTP response from a GetDNSZonesWithResponse call
func ParseGetDNSZonesResponse(rsp *http.Response) (*GetDNSZonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDNSZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Zone `json:"data"`

			// Includes All includable resources linkable to the given Zone.
			Includes *ZoneIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDNSZoneResponse parses an HTTP response from a CreateDNSZoneWithResponse call
func ParseCreateDNSZoneResponse(rsp *http.Response) (*CreateDNSZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDNSZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
			Data Zone `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDNSZoneResponse parses an HTTP response from a DeleteDNSZoneWithResponse call
func ParseDeleteDNSZoneResponse(rsp *http.Response) (*DeleteDNSZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDNSZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDNSZoneResponse parses an HTTP response from a GetDNSZoneWithResponse call
func ParseGetDNSZoneResponse(rsp *http.Response) (*GetDNSZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDNSZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
			Data Zone `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateDNSZoneResponse parses an HTTP response from a UpdateDNSZoneWithResponse call
func ParseUpdateDNSZoneResponse(rsp *http.Response) (*UpdateDNSZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDNSZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
			Data Zone `json:"data"`

			// Includes All includable resources linkable to the given Zone.
			Includes *ZoneIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateDNSZoneAccessResponse parses an HTTP response from a UpdateDNSZoneAccessWithResponse call
func ParseUpdateDNSZoneAccessResponse(rsp *http.Response) (*UpdateDNSZoneAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDNSZoneAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data DNS (Domain Name System), in short, is a decentralized naming system for computers, services, or other resources connected to the internet or a private network. It is what allows the translation of a URL, such as http://example.com, to an IP address.
			Data Zone `json:"data"`

			// Includes All includable resources linkable to the given Zone.
			Includes *ZoneIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDNSZoneJobResponse parses an HTTP response from a CreateDNSZoneJobWithResponse call
func ParseCreateDNSZoneJobResponse(rsp *http.Response) (*CreateDNSZoneJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDNSZoneJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentsResponse parses an HTTP response from a GetEnvironmentsWithResponse call
func ParseGetEnvironmentsResponse(rsp *http.Response) (*GetEnvironmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []Environment `json:"data"`
			Includes *struct {
				// Creators An identity that created a resource.
				Creators *CreatorInclude `json:"creators,omitempty"`
			} `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateEnvironmentResponse parses an HTTP response from a CreateEnvironmentWithResponse call
func ParseCreateEnvironmentResponse(rsp *http.Response) (*CreateEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://docs.cycle.io/environments/overview/).
			Data Environment `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentMonitoringTiersResponse parses an HTTP response from a GetEnvironmentMonitoringTiersWithResponse call
func ParseGetEnvironmentMonitoringTiersResponse(rsp *http.Response) (*GetEnvironmentMonitoringTiersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentMonitoringTiersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data map[string]MonitoringTierDetails `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEnvironmentResponse parses an HTTP response from a DeleteEnvironmentWithResponse call
func ParseDeleteEnvironmentResponse(rsp *http.Response) (*DeleteEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentResponse parses an HTTP response from a GetEnvironmentWithResponse call
func ParseGetEnvironmentResponse(rsp *http.Response) (*GetEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://docs.cycle.io/environments/overview/).
			Data     Environment `json:"data"`
			Includes *struct {
				// Creators An identity that created a resource.
				Creators *CreatorInclude `json:"creators,omitempty"`
			} `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateEnvironmentResponse parses an HTTP response from a UpdateEnvironmentWithResponse call
func ParseUpdateEnvironmentResponse(rsp *http.Response) (*UpdateEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://docs.cycle.io/environments/overview/).
			Data Environment `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateEnvironmentAccessResponse parses an HTTP response from a UpdateEnvironmentAccessWithResponse call
func ParseUpdateEnvironmentAccessResponse(rsp *http.Response) (*UpdateEnvironmentAccessResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEnvironmentAccessResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Environments are groups of containers with a private network built between them. For more information on environments, see the [main docs](https://docs.cycle.io/environments/overview/).
			Data Environment `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExportStackResponse parses an HTTP response from a ExportStackWithResponse call
func ParseExportStackResponse(rsp *http.Response) (*ExportStackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportStackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A Cycle stack file is an "environment as code". Anything that can be done in an environment on Cycle can be described in a stack file and deployed as a new environment.
			// Stack files can list multiple containers and their configurations, load balancer settings, scoped variables, and much more.
			Data StackSpec `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEnvironmentSummaryResponse parses an HTTP response from a GetEnvironmentSummaryWithResponse call
func ParseGetEnvironmentSummaryResponse(rsp *http.Response) (*GetEnvironmentSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnvironmentSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Contains useful and relevant data/statistics for an environment that would otherwise be several separate API calls.
			Data EnvironmentSummary `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateEnvironmentJobResponse parses an HTTP response from a CreateEnvironmentJobWithResponse call
func ParseCreateEnvironmentJobResponse(rsp *http.Response) (*CreateEnvironmentJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEnvironmentJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// Data A Job Descriptor is returned on success by API calls that create jobs. It contains the action that was requested, as well as the ID of the job created as a result.
			Data JobDescriptor `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetJobsResponse parses an HTTP response from a GetJobsWithResponse call
func ParseGetJobsResponse(rsp *http.Response) (*GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []Job        `json:"data"`
			Includes *JobIncludes `json:"includes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLatestJobsResponse parses an HTTP response from a GetLatestJobsWithResponse call
func ParseGetLatestJobsResponse(rsp *http.Response) (*GetLatestJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []Job `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetJobResponse parses an HTTP response from a GetJobWithResponse call
func ParseGetJobResponse(rsp *http.Response) (*GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data A job resource.
			Data Job `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
