// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AggregateLogs invokes aggregateLogs operation.
	//
	// A query for retrieving container instance logs.
	// Allows aggregate narrowing through filtering, searching, and scope parameters.
	// If 'local' is set to true, only cached logs will be queried, and logs in object storage will be
	// ignored.  This leads to much faster performance.
	// Requires the `monitor-view` capability.
	//
	// POST /v1/monitoring/logs/aggregate
	AggregateLogs(ctx context.Context, request OptAggregateLogsReq) (*AggregateLogsOK, error)
	// ChangePassword invokes changePassword operation.
	//
	// Change the password on the Account. Requires the current password of the Account to be submitted.
	//
	// PATCH /v1/account/password
	ChangePassword(ctx context.Context, request OptChangePasswordReq) (*ChangePasswordOK, error)
	// ClonePipeline invokes clonePipeline operation.
	//
	// Requires the `pipelines-manage` capability.
	//
	// POST /v1/pipelines/clone
	ClonePipeline(ctx context.Context, request OptClonePipelineReq) (*ClonePipelineCreated, error)
	// CreateApiKey invokes createApiKey operation.
	//
	// Requires the `api-keys-manage` capability.
	//
	// POST /v1/hubs/current/api-keys
	CreateApiKey(ctx context.Context, request OptCreateApiKeyReq) (*CreateApiKeyCreated, error)
	// CreateAutoScaleGroup invokes createAutoScaleGroup operation.
	//
	// Requires the 'autoscale-groups-manage'.
	//
	// POST /v1/infrastructure/auto-scale/groups
	CreateAutoScaleGroup(ctx context.Context, request OptCreateAutoScaleGroupReq) (*CreateAutoScaleGroupCreated, error)
	// CreateBillingMethod invokes createBillingMethod operation.
	//
	// Requires the `billing-methods-manage` capability.
	//
	// POST /v1/billing/methods
	CreateBillingMethod(ctx context.Context, request OptCreateBillingMethodReq) (*CreateBillingMethodCreated, error)
	// CreateBillingMethodJob invokes createBillingMethodJob operation.
	//
	// Creates a new job for a billing method. Generally used to verify a payment method.
	// Requires the `billing-methods-manage` capability.
	//
	// POST /v1/billing/methods/{methodId}/tasks
	CreateBillingMethodJob(ctx context.Context, request OptCreateBillingMethodJobReq, params CreateBillingMethodJobParams) (*CreateBillingMethodJobAccepted, error)
	// CreateCluster invokes createCluster operation.
	//
	// Requires the `clusters-manage` capability.
	//
	// POST /v1/infrastructure/clusters
	CreateCluster(ctx context.Context, request OptCreateClusterReq) (*CreateClusterCreated, error)
	// CreateContainer invokes createContainer operation.
	//
	// Requires the `containers-deploy` capability.
	//
	// POST /v1/containers
	CreateContainer(ctx context.Context, request OptCreateContainerReq) (*CreateContainerCreated, error)
	// CreateContainerBackupJob invokes createContainerBackupJob operation.
	//
	// Creates a Container Backup Job.
	// Can be used to restore a Container Backup for a given Container Instance.
	// Requires the `containers-backups-manage` capability.
	//
	// POST /v1/containers/{containerId}/backups/{backupId}/tasks
	CreateContainerBackupJob(ctx context.Context, request OptCreateContainerBackupJobReq, params CreateContainerBackupJobParams) (*CreateContainerBackupJobAccepted, error)
	// CreateContainerJob invokes createContainerJob operation.
	//
	// Used to perform different actions on a given Container.
	// Requires the following capabilities based on the task:
	// `start`: `containers-manage`
	// `stop`: `containers-manage`
	// `reconfigure`: `containers-manage`
	// `volumes.reconfigure`: `containers-volumes-manage`
	// `reimage`: `containers-manage`
	// `scale`: `containers-manage`.
	//
	// POST /v1/containers/{containerId}/tasks
	CreateContainerJob(ctx context.Context, request *CreateContainerJobReq, params CreateContainerJobParams) (*CreateContainerJobAccepted, error)
	// CreateDNSZone invokes createDNSZone operation.
	//
	// Requires the `dns-manage` capability.
	//
	// POST /v1/dns/zones
	CreateDNSZone(ctx context.Context, request OptCreateDNSZoneReq) (*CreateDNSZoneCreated, error)
	// CreateDNSZoneJob invokes createDNSZoneJob operation.
	//
	// Used to perform different actions on a given DNS zone.
	// Requires the `dns-manage` capability.
	//
	// POST /v1/dns/zones/{zoneId}/tasks
	CreateDNSZoneJob(ctx context.Context, request OptCreateDNSZoneJobReq, params CreateDNSZoneJobParams) (*CreateDNSZoneJobAccepted, error)
	// CreateDNSZoneRecord invokes createDNSZoneRecord operation.
	//
	// Requires the `dns-manage` capability.
	//
	// POST /v1/dns/zones/{zoneId}/records
	CreateDNSZoneRecord(ctx context.Context, request OptCreateDNSZoneRecordReq, params CreateDNSZoneRecordParams) (*CreateDNSZoneRecordCreated, error)
	// CreateDNSZoneRecordJob invokes createDNSZoneRecordJob operation.
	//
	// Used to perform different actions on a given DNS Zone record.
	// Requires the `dns-manage` capability.
	//
	// POST /v1/dns/zones/{zoneId}/records/{recordId}/tasks
	CreateDNSZoneRecordJob(ctx context.Context, request OptCreateDNSZoneRecordJobReq, params CreateDNSZoneRecordJobParams) (*CreateDNSZoneRecordJobAccepted, error)
	// CreateDiscoveryServiceJob invokes createDiscoveryServiceJob operation.
	//
	// Creates a task that will update the discovery service's configuration.
	//
	// POST /v1/environments/{environmentId}/services/discovery/tasks
	CreateDiscoveryServiceJob(ctx context.Context, request OptCreateDiscoveryServiceJobReq, params CreateDiscoveryServiceJobParams) (*CreateDiscoveryServiceJobAccepted, error)
	// CreateEnvironment invokes createEnvironment operation.
	//
	// Requires the `environments-create` capability.
	//
	// POST /v1/environments
	CreateEnvironment(ctx context.Context, request OptCreateEnvironmentReq) (*CreateEnvironmentCreated, error)
	// CreateEnvironmentJob invokes createEnvironmentJob operation.
	//
	// Create a job for an Environment, such as 'start' or 'stop'.
	// Requires the `environments-manage` capability.
	//
	// POST /v1/environments/{environmentId}/tasks
	CreateEnvironmentJob(ctx context.Context, request *CreateEnvironmentJobReq, params CreateEnvironmentJobParams) (*CreateEnvironmentJobAccepted, error)
	// CreateFunctionJob invokes createFunctionJob operation.
	//
	// Used to perform different actions on a given Function Container.
	// Requires the `containers-functions-trigger` capability.
	//
	// POST /v1/containers/{containerId}/functions/tasks
	CreateFunctionJob(ctx context.Context, request OptTrigger, params CreateFunctionJobParams) (*CreateFunctionJobAccepted, error)
	// CreateHub invokes createHub operation.
	//
	// Create a Hub.
	//
	// POST /v1/hubs
	CreateHub(ctx context.Context, request OptCreateHubReq) (*CreateHubOK, error)
	// CreateHubInvite invokes createHubInvite operation.
	//
	// Requires the `hubs-invites-send` capability.
	//
	// POST /v1/hubs/current/invites
	CreateHubInvite(ctx context.Context, request OptCreateHubInviteReq) (*CreateHubInviteCreated, error)
	// CreateImage invokes createImage operation.
	//
	// Requires the `images-manage` capability.
	//
	// POST /v1/images
	CreateImage(ctx context.Context, request OptCreateImageReq) (*CreateImageCreated, error)
	// CreateImageJob invokes createImageJob operation.
	//
	// Used to perform different actions on a given Image.
	// Requires the `images-import` capability.
	//
	// POST /v1/images/{imageId}/tasks
	CreateImageJob(ctx context.Context, request OptCreateImageJobReq, params CreateImageJobParams) (*CreateImageJobOK, error)
	// CreateImageSource invokes createImageSource operation.
	//
	// Requires the `images-sources-manage` capability.
	//
	// POST /v1/images/sources
	CreateImageSource(ctx context.Context, request OptCreateImageSourceReq) (*CreateImageSourceCreated, error)
	// CreateImagesJob invokes createImagesJob operation.
	//
	// Used to perform different actions on a given image.
	// Requires the `images-manage` capability.
	//
	// POST /v1/images/tasks
	CreateImagesJob(ctx context.Context, request OptCreateImagesJobReq) (*CreateImagesJobAccepted, error)
	// CreateInstanceJob invokes createInstanceJob operation.
	//
	// Used to perform different actions on a given Container Instance. Can be used to migrate or undo a
	// migration of a Container Instance.
	// Requires the `containers-instance-migrate` capability.
	//
	// POST /v1/containers/{containerId}/instances/{instanceId}/tasks
	CreateInstanceJob(ctx context.Context, request *CreateInstanceJobReq, params CreateInstanceJobParams) (*CreateInstanceJobAccepted, error)
	// CreateInstances invokes createInstances operation.
	//
	// Manually create Instances of a Container.
	// Requires the `containers-update` capability.
	//
	// POST /v1/containers/{containerId}/instances
	CreateInstances(ctx context.Context, request []CreateInstancesReqItem, params CreateInstancesParams) (*CreateInstancesAccepted, error)
	// CreateIntegration invokes createIntegration operation.
	//
	// Create an Integration resource within a hub. If the Integration definition specifies that it
	// requires verification, then you must submit a verify task to enable it.
	//
	// POST /v1/hubs/current/integrations
	CreateIntegration(ctx context.Context, request *CreateIntegrationReq, params CreateIntegrationParams) (*CreateIntegrationCreated, error)
	// CreateIntegrationJob invokes createIntegrationJob operation.
	//
	// Creates a new Job targeted at the provided Hub Integration.
	// - Requires a valid hub membership to the target hub.
	// - Requires the `hubs-integrations-manage` capability.
	//
	// POST /v1/hubs/current/integrations/{integrationId}/tasks
	CreateIntegrationJob(ctx context.Context, request OptCreateIntegrationJobReq, params CreateIntegrationJobParams) (*CreateIntegrationJobAccepted, error)
	// CreateInvoiceJob invokes createInvoiceJob operation.
	//
	// Creates a new job for an Invoice. Generally used to make a payment on an invoice.
	// Requires the `billing-invoices-pay` capability.
	//
	// POST /v1/billing/invoices/{invoiceId}/tasks
	CreateInvoiceJob(ctx context.Context, request OptCreateInvoiceJobReq, params CreateInvoiceJobParams) (*CreateInvoiceJobAccepted, error)
	// CreateLoadBalancerServiceJob invokes createLoadBalancerServiceJob operation.
	//
	// Creates a task that will update the load balancer's configuration.
	//
	// POST /v1/environments/{environmentId}/services/lb/tasks
	CreateLoadBalancerServiceJob(ctx context.Context, request OptCreateLoadBalancerServiceJobReq, params CreateLoadBalancerServiceJobParams) (*CreateLoadBalancerServiceJobAccepted, error)
	// CreateNetwork invokes createNetwork operation.
	//
	// Requires the `sdn-networks-manage` capability.
	//
	// POST /v1/sdn/networks
	CreateNetwork(ctx context.Context, request OptCreateNetworkReq, params CreateNetworkParams) (*CreateNetworkCreated, error)
	// CreateNetworkJob invokes createNetworkJob operation.
	//
	// Requires the `sdn-networks-manage` capability.
	//
	// POST /v1/sdn/networks/{networkId}/tasks
	CreateNetworkJob(ctx context.Context, request OptCreateNetworkJobReq, params CreateNetworkJobParams) (*CreateNetworkJobAccepted, error)
	// CreateOrder invokes createOrder operation.
	//
	// Requires the `billing-orders-manage` capability.
	//
	// POST /v1/billing/orders
	CreateOrder(ctx context.Context, request OptCreateOrderReq, params CreateOrderParams) (*CreateOrderCreated, error)
	// CreateOrderJob invokes createOrderJob operation.
	//
	// Used to confirm a Billing Order.
	// Requires the `billing-services-manage` capability.
	//
	// POST /v1/billing/orders/{orderId}/tasks
	CreateOrderJob(ctx context.Context, request OptCreateOrderJobReq, params CreateOrderJobParams) (*CreateOrderJobAccepted, error)
	// CreatePipeline invokes createPipeline operation.
	//
	// Requires the `pipelines-manage` capability.
	//
	// POST /v1/pipelines
	CreatePipeline(ctx context.Context, request OptCreatePipelineReq) (*CreatePipelineCreated, error)
	// CreatePipelineJob invokes createPipelineJob operation.
	//
	// Requires the `pipelines-manage` capability.
	//
	// POST /v1/pipelines/{pipelineId}/tasks
	CreatePipelineJob(ctx context.Context, request *CreatePipelineJobReq, params CreatePipelineJobParams) (*CreatePipelineJobAccepted, error)
	// CreatePipelineTriggerKey invokes createPipelineTriggerKey operation.
	//
	// Requires the `pipelines-manage` capability.
	//
	// POST /v1/pipelines/{pipelineId}/keys
	CreatePipelineTriggerKey(ctx context.Context, request OptCreatePipelineTriggerKeyReq, params CreatePipelineTriggerKeyParams) (*CreatePipelineTriggerKeyCreated, error)
	// CreateRole invokes createRole operation.
	//
	// Creates a custom Role for a Hub.
	// Requires the `hubs-roles-manage` capability.
	//
	// POST /v1/hubs/current/roles
	CreateRole(ctx context.Context, request OptCreateRoleReq) (*CreateRoleCreated, error)
	// CreateSchedulerServiceJob invokes createSchedulerServiceJob operation.
	//
	// Creates a task that will update the scheduler service's configuration.
	//
	// POST /v1/environments/{environmentId}/services/scheduler/tasks
	CreateSchedulerServiceJob(ctx context.Context, request OptCreateSchedulerServiceJobReq, params CreateSchedulerServiceJobParams) (*CreateSchedulerServiceJobAccepted, error)
	// CreateScopedVariable invokes createScopedVariable operation.
	//
	// Requires the `scoped-variables-manage` capability.
	//
	// POST /v1/environments/{environmentId}/scoped-variables
	CreateScopedVariable(ctx context.Context, request OptCreateScopedVariableReq, params CreateScopedVariableParams) (*CreateScopedVariableCreated, error)
	// CreateServer invokes createServer operation.
	//
	// Requires the `servers-provision` capability.
	//
	// POST /v1/infrastructure/servers
	CreateServer(ctx context.Context, request OptCreateServerReq) (*CreateServerAccepted, error)
	// CreateServerJob invokes createServerJob operation.
	//
	// Used to perform different actions on a given Server. Requires the `servers-manage` capability.
	//
	// POST /v1/infrastructure/servers/{serverId}/tasks
	CreateServerJob(ctx context.Context, request *CreateServerJobReq, params CreateServerJobParams) (*CreateServerJobAccepted, error)
	// CreateStack invokes createStack operation.
	//
	// Requires the `stacks-manage` capability.
	//
	// POST /v1/stacks
	CreateStack(ctx context.Context, request OptCreateStackReq) (*CreateStackCreated, error)
	// CreateStackBuild invokes createStackBuild operation.
	//
	// Requires the `stacks-manage` capability.
	//
	// POST /v1/stacks/{stackId}/builds
	CreateStackBuild(ctx context.Context, request OptCreateStackBuildReq, params CreateStackBuildParams) (*CreateStackBuildCreated, error)
	// CreateStackBuildJob invokes createStackBuildJob operation.
	//
	// Requires the `stacks-manage` capability.
	//
	// POST /v1/stacks/{stackId}/builds/{buildId}/tasks
	CreateStackBuildJob(ctx context.Context, request *CreateStackBuildJobReq, params CreateStackBuildJobParams) (*CreateStackBuildJobAccepted, error)
	// CreateStackJob invokes createStackJob operation.
	//
	// Requires the `stacks-manage` capability.
	//
	// POST /v1/stacks/{stackId}/tasks
	CreateStackJob(ctx context.Context, request OptCreateStackJobReq, params CreateStackJobParams) (*CreateStackJobAccepted, error)
	// CreateVPNServiceJob invokes createVPNServiceJob operation.
	//
	// Used to reconfigure or reset the Environment VPN. Requires the `environments-vpn-manage`
	// capability.
	//
	// POST /v1/environments/{environmentId}/services/vpn/tasks
	CreateVPNServiceJob(ctx context.Context, request *CreateVPNServiceJobReq, params CreateVPNServiceJobParams) (*CreateVPNServiceJobAccepted, error)
	// CreateVPNUser invokes createVPNUser operation.
	//
	// Requires the `environments-vpn-manage` capability.
	//
	// POST /v1/environments/{environmentId}/services/vpn/users
	CreateVPNUser(ctx context.Context, request OptCreateVPNUserReq, params CreateVPNUserParams) (*CreateVPNUserCreated, error)
	// CreateVirtualMachine invokes createVirtualMachine operation.
	//
	// Requires the `virtual-machines-deploy` capability.
	//
	// POST /v1/virtual-machines
	CreateVirtualMachine(ctx context.Context, request OptCreateVirtualMachineReq, params CreateVirtualMachineParams) (*CreateVirtualMachineCreated, error)
	// CreateVirtualMachineJob invokes createVirtualMachineJob operation.
	//
	// Used to perform different actions on a virtual machine.
	// Requires the following capabilities based on the task:
	// `start`: `virtual-machines-manage`
	// `stop`: `virtual-machines-manage`.
	//
	// POST /v1/virtual-machines/{virtualMachineId}/tasks
	CreateVirtualMachineJob(ctx context.Context, request *CreateVirtualMachineJobReq, params CreateVirtualMachineJobParams) (*CreateVirtualMachineJobAccepted, error)
	// DeleteAPIKey invokes deleteAPIKey operation.
	//
	// Requires the 'api-keys-manage' capability.
	//
	// DELETE /v1/hubs/current/api-keys/{apikeyId}
	DeleteAPIKey(ctx context.Context, params DeleteAPIKeyParams) (*DeleteAPIKeyOK, error)
	// DeleteAccount invokes deleteAccount operation.
	//
	// Puts the Account into a `deleted` state. This will fail if the Account is the current `OWNER` of
	// an active Hub.
	//
	// DELETE /v1/account
	DeleteAccount(ctx context.Context) (*DeleteAccountAccepted, error)
	// DeleteAutoScaleGroup invokes deleteAutoScaleGroup operation.
	//
	// Requires the `autoscale-group-manage` capability.
	//
	// DELETE /v1/infrastructure/auto-scale/groups/{groupId}
	DeleteAutoScaleGroup(ctx context.Context, params DeleteAutoScaleGroupParams) (*DeleteAutoScaleGroupAccepted, error)
	// DeleteBillingMethod invokes deleteBillingMethod operation.
	//
	// Deletes the Billing Method. However, the primary payment method may not be deleted.
	// Requires the `billing-methods-manage` capability.
	//
	// DELETE /v1/billing/methods/{methodId}
	DeleteBillingMethod(ctx context.Context, params DeleteBillingMethodParams) (*DeleteBillingMethodAccepted, error)
	// DeleteCluster invokes deleteCluster operation.
	//
	// Requires the `clusters-manage` capability.
	//
	// DELETE /v1/infrastructure/clusters/{clusterId}
	DeleteCluster(ctx context.Context, params DeleteClusterParams) (*DeleteClusterAccepted, error)
	// DeleteContainer invokes deleteContainer operation.
	//
	// Requires the `containers-manage` capability.
	//
	// DELETE /v1/containers/{containerId}
	DeleteContainer(ctx context.Context, params DeleteContainerParams) (*DeleteContainerAccepted, error)
	// DeleteContainerBackup invokes deleteContainerBackup operation.
	//
	// Requires the `containers-backups-manage` capability.
	//
	// DELETE /v1/containers/{containerId}/backups/{backupId}
	DeleteContainerBackup(ctx context.Context, params DeleteContainerBackupParams) (*DeleteContainerBackupAccepted, error)
	// DeleteContainerInstances invokes deleteContainerInstances operation.
	//
	// Manually delete Instances of a Container.
	// Requires the `containers-update` capability.
	//
	// DELETE /v1/containers/{containerId}/instances
	DeleteContainerInstances(ctx context.Context, params DeleteContainerInstancesParams) (*DeleteContainerInstancesAccepted, error)
	// DeleteDNSZone invokes deleteDNSZone operation.
	//
	// Requires the `dns-manage` capability.
	//
	// DELETE /v1/dns/zones/{zoneId}
	DeleteDNSZone(ctx context.Context, params DeleteDNSZoneParams) (*DeleteDNSZoneAccepted, error)
	// DeleteDNSZoneRecord invokes deleteDNSZoneRecord operation.
	//
	// Requires the `dns-manage` capability.
	//
	// DELETE /v1/dns/zones/{zoneId}/records/{recordId}
	DeleteDNSZoneRecord(ctx context.Context, params DeleteDNSZoneRecordParams) (*DeleteDNSZoneRecordAccepted, error)
	// DeleteEnvironment invokes deleteEnvironment operation.
	//
	// Requires the `environments-manage` capability.
	//
	// DELETE /v1/environments/{environmentId}
	DeleteEnvironment(ctx context.Context, params DeleteEnvironmentParams) (*DeleteEnvironmentAccepted, error)
	// DeleteHub invokes deleteHub operation.
	//
	// Requires the `hubs-delete` capability. This can only be aquired by being the hub owner.
	//
	// DELETE /v1/hubs/current
	DeleteHub(ctx context.Context) (*DeleteHubAccepted, error)
	// DeleteHubInvite invokes deleteHubInvite operation.
	//
	// Requires the `hub-invites-manage` capability.
	//
	// DELETE /v1/hubs/current/invites/{inviteId}
	DeleteHubInvite(ctx context.Context, params DeleteHubInviteParams) (*DeleteHubInviteOK, error)
	// DeleteHubMember invokes deleteHubMember operation.
	//
	// Requires the `hubs-members-manage` capability.
	//
	// DELETE /v1/hubs/current/members/{memberId}
	DeleteHubMember(ctx context.Context, params DeleteHubMemberParams) (*DeleteHubMemberAccepted, error)
	// DeleteIPPool invokes deleteIPPool operation.
	//
	// Requires the `infrastructure-ips-manage` capability.
	//
	// DELETE /v1/infrastructure/ips/pools/{poolId}
	DeleteIPPool(ctx context.Context, params DeleteIPPoolParams) (*DeleteIPPoolAccepted, error)
	// DeleteImage invokes deleteImage operation.
	//
	// Requires the `images-manage` capability.
	//
	// DELETE /v1/images/{imageId}
	DeleteImage(ctx context.Context, params DeleteImageParams) (*DeleteImageOK, error)
	// DeleteImageSource invokes deleteImageSource operation.
	//
	// Requires the `images-sources-manage` capability.
	//
	// DELETE /v1/images/sources/{sourceId}
	DeleteImageSource(ctx context.Context, params DeleteImageSourceParams) (*DeleteImageSourceAccepted, error)
	// DeleteInstance invokes deleteInstance operation.
	//
	// Requires the `containers-update` capability.
	//
	// DELETE /v1/containers/{containerId}/instances/{instanceId}
	DeleteInstance(ctx context.Context, params DeleteInstanceParams) (*DeleteInstanceAccepted, error)
	// DeleteIntegration invokes deleteIntegration operation.
	//
	// Deletes the specified Integration from the current hub, marking it as deleted and returning the
	// updated Integration.
	//
	// DELETE /v1/hubs/current/integrations/{integrationId}
	DeleteIntegration(ctx context.Context, params DeleteIntegrationParams) (*DeleteIntegrationAccepted, error)
	// DeleteNetwork invokes deleteNetwork operation.
	//
	// Requires the `sdn-networks-manage` capability.
	//
	// DELETE /v1/sdn/networks/{networkId}
	DeleteNetwork(ctx context.Context, params DeleteNetworkParams) (*DeleteNetworkAccepted, error)
	// DeletePipeline invokes deletePipeline operation.
	//
	// Requires the `pipelines-manage` capability.
	//
	// DELETE /v1/pipelines/{pipelineId}
	DeletePipeline(ctx context.Context, params DeletePipelineParams) (*DeletePipelineOK, error)
	// DeletePipelineTriggerKey invokes deletePipelineTriggerKey operation.
	//
	// Requires the `pipelines-manage` capability.
	//
	// DELETE /v1/pipelines/{pipelineId}/keys/{triggerKeyId}
	DeletePipelineTriggerKey(ctx context.Context, params DeletePipelineTriggerKeyParams) (*DeletePipelineTriggerKeyAccepted, error)
	// DeleteRole invokes deleteRole operation.
	//
	// Marks a Role as 'deleted'.
	// Requires the 'hubs-roles-manage' capability.
	//
	// DELETE /v1/hubs/current/roles/{roleId}
	DeleteRole(ctx context.Context, params DeleteRoleParams) (*DeleteRoleAccepted, error)
	// DeleteScopedVariable invokes deleteScopedVariable operation.
	//
	// Requires the `scoped-variables-manage` capability.
	//
	// DELETE /v1/environments/{environmentId}/scoped-variables/{scopedVariableId}
	DeleteScopedVariable(ctx context.Context, params DeleteScopedVariableParams) (*DeleteScopedVariableAccepted, error)
	// DeleteServer invokes deleteServer operation.
	//
	// Requires the `servers-manage` capability.
	//
	// DELETE /v1/infrastructure/servers/{serverId}
	DeleteServer(ctx context.Context, params DeleteServerParams) (*DeleteServerOK, error)
	// DeleteStack invokes deleteStack operation.
	//
	// Requires the `stacks-manage` capability.
	//
	// DELETE /v1/stacks/{stackId}
	DeleteStack(ctx context.Context, params DeleteStackParams) (*DeleteStackAccepted, error)
	// DeleteStackBuild invokes deleteStackBuild operation.
	//
	// Requires the `stacks-manage` capability.
	//
	// DELETE /v1/stacks/{stackId}/builds/{buildId}
	DeleteStackBuild(ctx context.Context, params DeleteStackBuildParams) (*DeleteStackBuildOK, error)
	// DeleteVPNUser invokes deleteVPNUser operation.
	//
	// Requires the `environments-vpn-manage` capability.
	//
	// DELETE /v1/environments/{environmentId}/services/vpn/users/{userId}
	DeleteVPNUser(ctx context.Context, params DeleteVPNUserParams) (*DeleteVPNUserOK, error)
	// DeleteVirtualMachine invokes deleteVirtualMachine operation.
	//
	// Requires the `virtual-machines-manage` capability.
	//
	// DELETE /v1/virtual-machines/{virtualMachineId}
	DeleteVirtualMachine(ctx context.Context, params DeleteVirtualMachineParams) (*DeleteVirtualMachineAccepted, error)
	// DisableTwoFactorAuth invokes disableTwoFactorAuth operation.
	//
	// Disables two-factor auth for the account.
	//
	// POST /v1/account/2fa/disable
	DisableTwoFactorAuth(ctx context.Context, request OptDisableTwoFactorAuthReq) (*DisableTwoFactorAuthOK, error)
	// EnableTwoFactorAuth invokes enableTwoFactorAuth operation.
	//
	// Enables two-factor auth for the Account. Retrieve the token from an authenticator app using the
	// secret from `getTwoFactorAuthSetup`.
	//
	// POST /v1/account/2fa/setup
	EnableTwoFactorAuth(ctx context.Context, request OptEnableTwoFactorAuthReq) (*EnableTwoFactorAuthOK, error)
	// ExpireInstanceSSHCredentials invokes expireInstanceSSHCredentials operation.
	//
	// Instantly expires any SSH credentials generated for this Instance.
	// Requires the `containers-ssh` capability.
	//
	// DELETE /v1/containers/{containerId}/instances/{instanceId}/ssh
	ExpireInstanceSSHCredentials(ctx context.Context, params ExpireInstanceSSHCredentialsParams) (*ExpireInstanceSSHCredentialsOK, error)
	// ExportStack invokes exportStack operation.
	//
	// Exports an environment as a stack file for reuse.
	// Requires the `environments-manage` capability. You must also have management permissions on the
	// target environment ACL.
	//
	// POST /v1/environments/{environmentId}/export/stack
	ExportStack(ctx context.Context, request OptExportStackReq, params ExportStackParams) (*ExportStackOK, error)
	// GenerateAggregatedEvents invokes generateAggregatedEvents operation.
	//
	// Generate an events report using an aggregated pipeline query with Mongo. This endpoint provides
	// ultimate
	// flexibility in generating data for dashboards, charts, graphs, etc.
	// You should always provide a time range filter to this call, either through the filter parameter or
	// in the critera body. The aggregate is limited to 25,000 input documents, so a time frame will give
	// the best results.
	// Requires the `monitor-view` capability.
	//
	// POST /v1/monitoring/events/aggregate
	GenerateAggregatedEvents(ctx context.Context, request OptGenerateAggregatedEventsReq, params GenerateAggregatedEventsParams) (*GenerateAggregatedEventsOK, error)
	// GenerateAggregatedMetrics invokes generateAggregatedMetrics operation.
	//
	// Generate a metric report using an aggregated pipeline query with Mongo. This endpoint provides
	// ultimate
	// flexibility in generating data for dashboards, charts, graphs, etc.
	// You should always provide a time range filter to this call, either through the filter parameter or
	// in the critera body. The aggregate is limited to 25,000 input documents, so a time frame will give
	// the best results.
	// Requires the `monitor-view` capability.
	//
	// POST /v1/monitoring/metrics/aggregate
	GenerateAggregatedMetrics(ctx context.Context, request OptGenerateAggregatedMetricsReq, params GenerateAggregatedMetricsParams) (*GenerateAggregatedMetricsOK, error)
	// GenerateInstanceSSHCredentials invokes generateInstanceSSHCredentials operation.
	//
	// Generates credentials for connecting to an Instance via SSH. The generated endpoint/secret can be
	// used to log in via SSH
	// into the Instance without exposing ports on the container or host.
	// Requires the `containers-ssh` capability.
	//
	// GET /v1/containers/{containerId}/instances/{instanceId}/ssh
	GenerateInstanceSSHCredentials(ctx context.Context, params GenerateInstanceSSHCredentialsParams) (*GenerateInstanceSSHCredentialsOK, error)
	// GetAPIKey invokes getAPIKey operation.
	//
	// Requries the `api-keys-manage` capability.
	//
	// GET /v1/hubs/current/api-keys/{apikeyId}
	GetAPIKey(ctx context.Context, params GetAPIKeyParams) (*GetAPIKeyOK, error)
	// GetAccount invokes getAccount operation.
	//
	// Gets the Account associated with the authenticated bearer token.
	//
	// GET /v1/account
	GetAccount(ctx context.Context) (*GetAccountOK, error)
	// GetAccountInvites invokes getAccountInvites operation.
	//
	// Lists the pending Hub Memberships (also known as Invites) associated with the Account.
	//
	// GET /v1/account/invites
	GetAccountInvites(ctx context.Context, params GetAccountInvitesParams) (*GetAccountInvitesOK, error)
	// GetAccountLogins invokes getAccountLogins operation.
	//
	// Lists logins associated with a given account.
	//
	// GET /v1/account/logins
	GetAccountLogins(ctx context.Context, params GetAccountLoginsParams) (*GetAccountLoginsOK, error)
	// GetAccountMemberships invokes getAccountMemberships operation.
	//
	// Lists the Hub Memberships for a given account.
	//
	// GET /v1/account/memberships
	GetAccountMemberships(ctx context.Context, params GetAccountMembershipsParams) (*GetAccountMembershipsOK, error)
	// GetAnnouncements invokes getAnnouncements operation.
	//
	// Lists any important updates posted by the Cycle team.
	//
	// GET /v1/announcements
	GetAnnouncements(ctx context.Context, params GetAnnouncementsParams) (*GetAnnouncementsOK, error)
	// GetApiKeys invokes getApiKeys operation.
	//
	// Requires the `api-keys-manage` capability.
	//
	// GET /v1/hubs/current/api-keys
	GetApiKeys(ctx context.Context, params GetApiKeysParams) (*GetApiKeysOK, error)
	// GetAutoScaleGroup invokes getAutoScaleGroup operation.
	//
	// Requires the `autoscale-groups-view` capability.
	//
	// GET /v1/infrastructure/auto-scale/groups/{groupId}
	GetAutoScaleGroup(ctx context.Context, params GetAutoScaleGroupParams) (*GetAutoScaleGroupOK, error)
	// GetAutoScaleGroups invokes getAutoScaleGroups operation.
	//
	// Requires the `autoscale-groups-manage` capability.
	//
	// GET /v1/infrastructure/auto-scale/groups
	GetAutoScaleGroups(ctx context.Context, params GetAutoScaleGroupsParams) (*GetAutoScaleGroupsOK, error)
	// GetAvailableIntegrations invokes getAvailableIntegrations operation.
	//
	// Returns a map of available integrations categorized by their type.
	//
	// GET /v1/hubs/current/integrations/available
	GetAvailableIntegrations(ctx context.Context) (*GetAvailableIntegrationsOK, error)
	// GetBillingMethod invokes getBillingMethod operation.
	//
	// Requires the `billing-methods-manage` capability.
	//
	// GET /v1/billing/methods/{methodId}
	GetBillingMethod(ctx context.Context, params GetBillingMethodParams) (*GetBillingMethodOK, error)
	// GetBillingMethods invokes getBillingMethods operation.
	//
	// Lists the Billing Methods associated with the Hub defined in X-Hub-ID.
	// Requires the `billing-methods-manage` capability.
	//
	// GET /v1/billing/methods
	GetBillingMethods(ctx context.Context, params GetBillingMethodsParams) (*GetBillingMethodsOK, error)
	// GetBillingOrder invokes getBillingOrder operation.
	//
	// Requires the `billing-services-manage` capability.
	//
	// GET /v1/billing/orders/{orderId}
	GetBillingOrder(ctx context.Context, params GetBillingOrderParams) (*GetBillingOrderOK, error)
	// GetBillingOverages invokes getBillingOverages operation.
	//
	// List Billing Overages.
	//
	// GET /v1/billing/services/overages
	GetBillingOverages(ctx context.Context, params GetBillingOveragesParams) (*GetBillingOveragesOK, error)
	// GetBillingService invokes getBillingService operation.
	//
	// Requries the `billing-services-view` capability.
	//
	// GET /v1/billing/services/{servicesId}
	GetBillingService(ctx context.Context, params GetBillingServiceParams) (*GetBillingServiceOK, error)
	// GetBillingServices invokes getBillingServices operation.
	//
	// Requries the `billing-services-view` capability.
	//
	// GET /v1/billing/services
	GetBillingServices(ctx context.Context, params GetBillingServicesParams) (*GetBillingServicesOK, error)
	// GetBillingSupportPlans invokes getBillingSupportPlans operation.
	//
	// List Support Plans.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /v1/billing/plans/support
	GetBillingSupportPlans(ctx context.Context, params GetBillingSupportPlansParams) (*GetBillingSupportPlansOK, error)
	// GetBillingTiers invokes getBillingTiers operation.
	//
	// Returns list of availiable Billing Tiers.
	//
	// GET /v1/billing/plans/tiers
	GetBillingTiers(ctx context.Context) (*GetBillingTiersOK, error)
	// GetCluster invokes getCluster operation.
	//
	// Gets a Cluster.
	// Requires the `clusters-view` capability.
	//
	// GET /v1/infrastructure/clusters/{clusterId}
	GetCluster(ctx context.Context, params GetClusterParams) (*GetClusterOK, error)
	// GetClusters invokes getClusters operation.
	//
	// Requires the `clusters-view` capability.
	//
	// GET /v1/infrastructure/clusters
	GetClusters(ctx context.Context, params GetClustersParams) (*GetClustersOK, error)
	// GetCompatibleImages invokes getCompatibleImages operation.
	//
	// Returns a list of Images that are compatible with the specified Container.
	// Used to quickly find Images that can be used for reimaging the Container.
	// Requires the `containers-view` capability.
	//
	// GET /v1/containers/{containerId}/compatible-images
	GetCompatibleImages(ctx context.Context, params GetCompatibleImagesParams) (*GetCompatibleImagesOK, error)
	// GetCompatibleServers invokes getCompatibleServers operation.
	//
	// Gets a list of servers that are compatible with the specified Container and its restrictions (tags,
	//  etc).
	// Requires the `containers-view` capability.
	//
	// GET /v1/containers/{containerId}/servers/usable
	GetCompatibleServers(ctx context.Context, params GetCompatibleServersParams) (*GetCompatibleServersOK, error)
	// GetContainer invokes getContainer operation.
	//
	// Gets a Container.
	// Requires the `containers-view` capability.
	//
	// GET /v1/containers/{containerId}
	GetContainer(ctx context.Context, params GetContainerParams) (*GetContainerOK, error)
	// GetContainerBackup invokes getContainerBackup operation.
	//
	// Gets the specified Container Backup.
	// Requires the `containers-backups-view` capability.
	//
	// GET /v1/containers/{containerId}/backups/{backupId}
	GetContainerBackup(ctx context.Context, params GetContainerBackupParams) (*GetContainerBackupOK, error)
	// GetContainerBackupLogs invokes getContainerBackupLogs operation.
	//
	// Requires the `containers-backups-view` capability.
	//
	// GET /v1/containers/{containerId}/backups/{backupId}/logs
	GetContainerBackupLogs(ctx context.Context, params GetContainerBackupLogsParams) (*GetContainerBackupLogsOK, error)
	// GetContainerBackups invokes getContainerBackups operation.
	//
	// Requires the `containers-backups-view` capability.
	//
	// GET /v1/containers/{containerId}/backups
	GetContainerBackups(ctx context.Context, params GetContainerBackupsParams) (*GetContainerBackupsOK, error)
	// GetContainerServers invokes getContainerServers operation.
	//
	// Lists all Servers that currently have an Instance of this Container deployed to them.
	// Requires the `containers-view` capability.
	//
	// GET /v1/containers/{containerId}/servers
	GetContainerServers(ctx context.Context, params GetContainerServersParams) (*GetContainerServersOK, error)
	// GetContainerSummary invokes getContainerSummary operation.
	//
	// Requires the `containers-view` capability.
	//
	// GET /v1/containers/{containerId}/summary
	GetContainerSummary(ctx context.Context, params GetContainerSummaryParams) (*GetContainerSummaryOK, error)
	// GetContainers invokes getContainers operation.
	//
	// Requires the `containers-view` capability.
	//
	// GET /v1/containers
	GetContainers(ctx context.Context, params GetContainersParams) (*GetContainersOK, error)
	// GetCredit invokes getCredit operation.
	//
	// Requires the `billing-credits-view` capability.
	//
	// GET /v1/billing/credits/{creditsId}
	GetCredit(ctx context.Context, params GetCreditParams) (*GetCreditOK, error)
	// GetCredits invokes getCredits operation.
	//
	// Lists the Billing Credits associated with the current Hub.
	// Requires the `billing-credits-view` capability.
	//
	// GET /v1/billing/credits
	GetCredits(ctx context.Context, params GetCreditsParams) (*GetCreditsOK, error)
	// GetDNSZone invokes getDNSZone operation.
	//
	// Requires the `dns-view` capability.
	//
	// GET /v1/dns/zones/{zoneId}
	GetDNSZone(ctx context.Context, params GetDNSZoneParams) (*GetDNSZoneOK, error)
	// GetDNSZoneRecords invokes getDNSZoneRecords operation.
	//
	// Requires the `dns-view` capability.
	//
	// GET /v1/dns/zones/{zoneId}/records
	GetDNSZoneRecords(ctx context.Context, params GetDNSZoneRecordsParams) (*GetDNSZoneRecordsOK, error)
	// GetDNSZones invokes getDNSZones operation.
	//
	// Requires the `dns-view` capability.
	//
	// GET /v1/dns/zones
	GetDNSZones(ctx context.Context, params GetDNSZonesParams) (*GetDNSZonesOK, error)
	// GetDefaultHubRoles invokes getDefaultHubRoles operation.
	//
	// List Default Hub Roles.
	//
	// GET /v1/hubs/current/roles/defaults
	GetDefaultHubRoles(ctx context.Context) (*GetDefaultHubRolesOK, error)
	// GetDeploymentStrategies invokes getDeploymentStrategies operation.
	//
	// Gets the available deployment strategies that can be used to orchestrate containers.
	//
	// GET /v1/infrastructure/deployment-strategies
	GetDeploymentStrategies(ctx context.Context) (*GetDeploymentStrategiesOK, error)
	// GetEnvironment invokes getEnvironment operation.
	//
	// Requires the `environments-view` capability.
	//
	// GET /v1/environments/{environmentId}
	GetEnvironment(ctx context.Context, params GetEnvironmentParams) (*GetEnvironmentOK, error)
	// GetEnvironmentDeployments invokes getEnvironmentDeployments operation.
	//
	// Gets a list of all deployments in the specified Environment.
	// Requires the `environments-view` capability.
	//
	// GET /v1/environments/{environmentId}/deployments
	GetEnvironmentDeployments(ctx context.Context, params GetEnvironmentDeploymentsParams) (*GetEnvironmentDeploymentsOK, error)
	// GetEnvironmentMonitoringTiers invokes getEnvironmentMonitoringTiers operation.
	//
	// Gets all the available monitoring tiers that can be enabled for an environment.
	//
	// GET /v1/environments/monitoring-tiers
	GetEnvironmentMonitoringTiers(ctx context.Context) (*GetEnvironmentMonitoringTiersOK, error)
	// GetEnvironmentSummary invokes getEnvironmentSummary operation.
	//
	// Gets the summary of an Environment. Contains useful and relevant data/statistics that would
	// otherwise be several separate API calls.
	// Requires the `environments-view` capability.
	//
	// GET /v1/environments/{environmentId}/summary
	GetEnvironmentSummary(ctx context.Context, params GetEnvironmentSummaryParams) (*GetEnvironmentSummaryOK, error)
	// GetEnvironments invokes getEnvironments operation.
	//
	// Requires the `environments-view` capability.
	//
	// GET /v1/environments
	GetEnvironments(ctx context.Context, params GetEnvironmentsParams) (*GetEnvironmentsOK, error)
	// GetEvents invokes getEvents operation.
	//
	// A basic query for retrieving events. For a more complex and granular report, see the
	// `/v1/monitoring/events/aggregate` endpoint.
	// Requires the `monitor-view` capability.
	//
	// GET /v1/monitoring/events
	GetEvents(ctx context.Context) (*GetEventsOK, error)
	// GetHub invokes getHub operation.
	//
	// Requires the `hubs-view` capability.
	//
	// GET /v1/hubs/current
	GetHub(ctx context.Context, params GetHubParams) (*GetHubOK, error)
	// GetHubActivity invokes getHubActivity operation.
	//
	// List Hub Activity.
	//
	// GET /v1/hubs/current/activity
	GetHubActivity(ctx context.Context, params GetHubActivityParams) (*GetHubActivityOK, error)
	// GetHubCapabilities invokes getHubCapabilities operation.
	//
	// List Hub Capabilities.
	//
	// GET /v1/hubs/capabilities
	GetHubCapabilities(ctx context.Context) (*GetHubCapabilitiesOK, error)
	// GetHubInvites invokes getHubInvites operation.
	//
	// Requires the `hubs-invites-manage` capability.
	//
	// GET /v1/hubs/current/invites
	GetHubInvites(ctx context.Context, params GetHubInvitesParams) (*GetHubInvitesOK, error)
	// GetHubMember invokes getHubMember operation.
	//
	// Requires the `hubs-members-view` capability.
	//
	// GET /v1/hubs/current/members/{memberId}
	GetHubMember(ctx context.Context, params GetHubMemberParams) (*GetHubMemberOK, error)
	// GetHubMemberAccount invokes getHubMemberAccount operation.
	//
	// Requires the `hubs-members-view` capability.
	//
	// GET /v1/hubs/current/members/account/{accountId}
	GetHubMemberAccount(ctx context.Context, params GetHubMemberAccountParams) (*GetHubMemberAccountOK, error)
	// GetHubMembers invokes getHubMembers operation.
	//
	// Requires the `hubs-members-view` capability.
	//
	// GET /v1/hubs/current/members
	GetHubMembers(ctx context.Context, params GetHubMembersParams) (*GetHubMembersOK, error)
	// GetHubMembership invokes getHubMembership operation.
	//
	// Gets the Hub Membership for the requesting Account.
	//
	// GET /v1/hubs/current/membership
	GetHubMembership(ctx context.Context, params GetHubMembershipParams) (*GetHubMembershipOK, error)
	// GetHubNotificationSocketAuth invokes getHubNotificationSocketAuth operation.
	//
	// Initializes authorization for the Hub notification pipeline. The Hub notification pipeline is a
	// one-way streaming websocket that
	// sends real-time 'notifications' as things are happening on the Hub. These notifications tell some
	// basic information about an event,
	// and it is up to the user to fetch additional details, if deemed necessary.
	// Requesting this endpoint without a `?token=<token>` URL parameter will result in receiving a short
	// lived token in the response body. That
	// token can then be applied to the URL parameter to the same endpoint to upgrade the connection to a
	// WebSocket.
	// Requires the `apionly-notifications-listen` capability.
	//
	// GET /v1/hubs/current/notifications
	GetHubNotificationSocketAuth(ctx context.Context) (GetHubNotificationSocketAuthRes, error)
	// GetHubUsage invokes getHubUsage operation.
	//
	// Requires the `hubs-view` capability.
	//
	// GET /v1/hubs/current/usage
	GetHubUsage(ctx context.Context, params GetHubUsageParams) (*GetHubUsageOK, error)
	// GetHubs invokes getHubs operation.
	//
	// Lists all associated Hubs.
	//
	// GET /v1/hubs
	GetHubs(ctx context.Context, params GetHubsParams) (*GetHubsOK, error)
	// GetIPPool invokes getIPPool operation.
	//
	// Requires the `infrastructure-ips-manage` capability.
	//
	// GET /v1/infrastructure/ips/pools/{poolId}
	GetIPPool(ctx context.Context, params GetIPPoolParams) (*GetIPPoolOK, error)
	// GetImage invokes getImage operation.
	//
	// Requires the `images-view` capability.
	//
	// GET /v1/images/{imageId}
	GetImage(ctx context.Context, params GetImageParams) (*GetImageOK, error)
	// GetImageBuildLog invokes getImageBuildLog operation.
	//
	// Requires the `images-view` capability.
	//
	// GET /v1/images/{imageId}/build-log
	GetImageBuildLog(ctx context.Context, params GetImageBuildLogParams) (*GetImageBuildLogOK, error)
	// GetImageSource invokes getImageSource operation.
	//
	// Requires the `images-sources-view` capability.
	//
	// GET /v1/images/sources/{sourceId}
	GetImageSource(ctx context.Context, params GetImageSourceParams) (*GetImageSourceOK, error)
	// GetImageSources invokes getImageSources operation.
	//
	// Requires the `images-sources-view` capability.
	//
	// GET /v1/images/sources
	GetImageSources(ctx context.Context, params GetImageSourcesParams) (*GetImageSourcesOK, error)
	// GetImages invokes getImages operation.
	//
	// Requires the `images-view` capability.
	//
	// GET /v1/images
	GetImages(ctx context.Context, params GetImagesParams) (*GetImagesOK, error)
	// GetInfrastructureIPPools invokes getInfrastructureIPPools operation.
	//
	// Requires the `infrastructure-ips-manage` capability.
	//
	// GET /v1/infrastructure/ips/pools
	GetInfrastructureIPPools(ctx context.Context, params GetInfrastructureIPPoolsParams) (*GetInfrastructureIPPoolsOK, error)
	// GetInfrastructureSummary invokes getInfrastructureSummary operation.
	//
	// Requires the `infrastructure-servers-view` capability.
	//
	// GET /v1/infrastructure/summary
	GetInfrastructureSummary(ctx context.Context, params GetInfrastructureSummaryParams) (*GetInfrastructureSummaryOK, error)
	// GetInstance invokes getInstance operation.
	//
	// Requires the `containers-view` capability.
	//
	// GET /v1/containers/{containerId}/instances/{instanceId}
	GetInstance(ctx context.Context, params GetInstanceParams) (*GetInstanceOK, error)
	// GetInstanceConsoleStreamAuth invokes getInstanceConsoleStreamAuth operation.
	//
	// Returns the authorization information necessary to connect to a Container Instance's console.
	// To connect via WebSocket, use the returned address, and append the returned token as a URL
	// parameter: `<address>?token=<token>`.
	// Requires the `containers-console` capability.
	//
	// GET /v1/containers/{containerId}/instances/{instanceId}/console
	GetInstanceConsoleStreamAuth(ctx context.Context, params GetInstanceConsoleStreamAuthParams) (*GetInstanceConsoleStreamAuthOK, error)
	// GetInstanceTelemetryReport invokes getInstanceTelemetryReport operation.
	//
	// Retrieves a point-in-time report of an Instance's resource usage (CPU, RAM, Network, Storage, etc).
	// Requires the `containers-view` capability.
	//
	// GET /v1/containers/{containerId}/instances/{instanceId}/telemetry/resources/report
	GetInstanceTelemetryReport(ctx context.Context, params GetInstanceTelemetryReportParams) (*GetInstanceTelemetryReportOK, error)
	// GetInstanceTelemetryStreamAuth invokes getInstanceTelemetryStreamAuth operation.
	//
	// Retrieves an access token and URL to open a websocket to for streaming instance telemetry live.
	// This connects directly to the compute layer on the server the instance is hosted on, and streams
	// telemetry in real time.
	// Requires the `containers-view` capability.
	//
	// GET /v1/containers/{containerId}/instances/{instanceId}/telemetry/resources/stream
	GetInstanceTelemetryStreamAuth(ctx context.Context, params GetInstanceTelemetryStreamAuthParams) (*GetInstanceTelemetryStreamAuthOK, error)
	// GetInstanceVolumes invokes getInstanceVolumes operation.
	//
	// Requires the `containers-view` capability.
	//
	// GET /v1/containers/{containerId}/instances/{instanceId}/volumes
	GetInstanceVolumes(ctx context.Context, params GetInstanceVolumesParams) (*GetInstanceVolumesOK, error)
	// GetInstances invokes getInstances operation.
	//
	// Requires the `containers-view` capability.
	//
	// GET /v1/containers/{containerId}/instances
	GetInstances(ctx context.Context, params GetInstancesParams) (*GetInstancesOK, error)
	// GetIntegration invokes getIntegration operation.
	//
	// Retrieves details of a single Integration associated with the current hub.
	// Requires the `hubs-integrations-view` capability.
	//
	// GET /v1/hubs/current/integrations/{integrationId}
	GetIntegration(ctx context.Context, params GetIntegrationParams) (*GetIntegrationOK, error)
	// GetIntegrations invokes getIntegrations operation.
	//
	// Lists all integrations associated with the current Hub, with optional filtering.
	// Requires the `hubs-integrations-view` capability.
	//
	// GET /v1/hubs/current/integrations
	GetIntegrations(ctx context.Context, params GetIntegrationsParams) (*GetIntegrationsOK, error)
	// GetInvoice invokes getInvoice operation.
	//
	// Requires the `billing-invoices-view` capability.
	//
	// GET /v1/billing/invoices/{invoiceId}
	GetInvoice(ctx context.Context, params GetInvoiceParams) (*GetInvoiceOK, error)
	// GetInvoices invokes getInvoices operation.
	//
	// List the Invoices assoicated with the Hub.
	// Requires the `billing-invoices-view` capability.
	//
	// GET /v1/billing/invoices
	GetInvoices(ctx context.Context, params GetInvoicesParams) (*GetInvoicesOK, error)
	// GetJob invokes getJob operation.
	//
	// Requires the `apionly-jobs-view` permission.
	//
	// GET /v1/jobs/{jobId}
	GetJob(ctx context.Context, params GetJobParams) (*GetJobOK, error)
	// GetJobs invokes getJobs operation.
	//
	// Requires the `apionly-jobs-view` permission.
	//
	// GET /v1/jobs
	GetJobs(ctx context.Context, params GetJobsParams) (*GetJobsOK, error)
	// GetLatestJobs invokes getLatestJobs operation.
	//
	// Requires the `apionly-jobs-view` permission.
	//
	// GET /v1/jobs/latest
	GetLatestJobs(ctx context.Context) (*GetLatestJobsOK, error)
	// GetLoadBalancerLatestTelemetryReport invokes getLoadBalancerLatestTelemetryReport operation.
	//
	// Fetches the latest telemetry report for Cycle's native load balancer. Provides detailed
	// information on a per-instance basis.
	// Requires the `environments-view` capability. Also requires the user to have access specifically to
	// the requested Environment.
	//
	// GET /v1/environments/{environmentId}/services/lb/telemetry/latest
	GetLoadBalancerLatestTelemetryReport(ctx context.Context, params GetLoadBalancerLatestTelemetryReportParams) (*GetLoadBalancerLatestTelemetryReportOK, error)
	// GetLoadBalancerService invokes getLoadBalancerService operation.
	//
	// Requires the `environments-view` capability.
	//
	// GET /v1/environments/{environmentId}/services/lb
	GetLoadBalancerService(ctx context.Context, params GetLoadBalancerServiceParams) (*GetLoadBalancerServiceOK, error)
	// GetLoadBalancerTelemetryLatestControllers invokes getLoadBalancerTelemetryLatestControllers operation.
	//
	// Gets the controller information for the specified load balancer. Returns a similar struct to the
	// 'latest' load balancer telemetry call, but does NOT return snapshots, just the controller
	// information.
	// Requires the `environments-view` capability. Also requires the user to have access specifically to
	// the requested Environment.
	//
	// GET /v1/environments/{environmentId}/services/lb/telemetry/latest-controllers
	GetLoadBalancerTelemetryLatestControllers(ctx context.Context, params GetLoadBalancerTelemetryLatestControllersParams) (*GetLoadBalancerTelemetryLatestControllersOK, error)
	// GetLoadBalancerTelemetryReport invokes getLoadBalancerTelemetryReport operation.
	//
	// Fetches a telemetry report for Cycle's native load balancer for the specified range.
	// Requires the `environments-view` capability. Also requires the user to have access specifically to
	// the requested Environment.
	//
	// GET /v1/environments/{environmentId}/services/lb/telemetry/report
	GetLoadBalancerTelemetryReport(ctx context.Context, params GetLoadBalancerTelemetryReportParams) (*GetLoadBalancerTelemetryReportOK, error)
	// GetMetrics invokes getMetrics operation.
	//
	// A basic query for retrieving metrics. For a more complex and granular report, see the
	// `/v1/monitoring/metrics/aggregate` endpoint.
	// Requires the `monitor-view` capability.
	//
	// GET /v1/monitoring/metrics
	GetMetrics(ctx context.Context) (*GetMetricsOK, error)
	// GetMonitoringMonitors invokes getMonitoringMonitors operation.
	//
	// Returns location information about the monitors used for Cycle's external monitoring service.
	// These monitors are used for determining the latency between the public internet and environment
	// load balancers.
	//
	// GET /v1/monitoring/monitors
	GetMonitoringMonitors(ctx context.Context) (*GetMonitoringMonitorsOK, error)
	// GetNetwork invokes getNetwork operation.
	//
	// Requires the `sdn-networks-view` capability.
	//
	// GET /v1/sdn/networks/{networkId}
	GetNetwork(ctx context.Context, params GetNetworkParams) (*GetNetworkOK, error)
	// GetNetworks invokes getNetworks operation.
	//
	// Requires the `sdn-networks-view` capability.
	//
	// GET /v1/sdn/networks
	GetNetworks(ctx context.Context, params GetNetworksParams) (*GetNetworksOK, error)
	// GetOrders invokes getOrders operation.
	//
	// Requires the `billing-services-manage` capability.
	//
	// GET /v1/billing/orders
	GetOrders(ctx context.Context, params GetOrdersParams) (*GetOrdersOK, error)
	// GetPipeline invokes getPipeline operation.
	//
	// Requires the `pipelines-view` capability.
	//
	// GET /v1/pipelines/{pipelineId}
	GetPipeline(ctx context.Context, params GetPipelineParams) (*GetPipelineOK, error)
	// GetPipelineRun invokes getPipelineRun operation.
	//
	// Requires the `pipelines-view` capability.
	//
	// GET /v1/pipelines/{pipelineId}/runs/{runId}
	GetPipelineRun(ctx context.Context, params GetPipelineRunParams) (*GetPipelineRunOK, error)
	// GetPipelineRuns invokes getPipelineRuns operation.
	//
	// List information about times this Pipeline has run.
	// Requires the `pipelines-view` capability.
	//
	// GET /v1/pipelines/{pipelineId}/runs
	GetPipelineRuns(ctx context.Context, params GetPipelineRunsParams) (*GetPipelineRunsOK, error)
	// GetPipelineTriggerKey invokes getPipelineTriggerKey operation.
	//
	// Requires the `pipelines-manage` capability.
	//
	// GET /v1/pipelines/{pipelineId}/keys/{triggerKeyId}
	GetPipelineTriggerKey(ctx context.Context, params GetPipelineTriggerKeyParams) (*GetPipelineTriggerKeyOK, error)
	// GetPipelineTriggerKeys invokes getPipelineTriggerKeys operation.
	//
	// Requires the `pipelines-manage` capability.
	//
	// GET /v1/pipelines/{pipelineId}/keys
	GetPipelineTriggerKeys(ctx context.Context, params GetPipelineTriggerKeysParams) (*GetPipelineTriggerKeysOK, error)
	// GetPipelines invokes getPipelines operation.
	//
	// Requires the `pipelines-view` capability.
	//
	// GET /v1/pipelines
	GetPipelines(ctx context.Context, params GetPipelinesParams) (*GetPipelinesOK, error)
	// GetPoolIPs invokes getPoolIPs operation.
	//
	// Requires the `infrastructure-ips-manage` capability.
	//
	// GET /v1/infrastructure/ips/pools/{poolId}/ips
	GetPoolIPs(ctx context.Context, params GetPoolIPsParams) (*GetPoolIPsOK, error)
	// GetProviderLocations invokes getProviderLocations operation.
	//
	// List Provider Locations.
	//
	// GET /v1/infrastructure/providers/{providerVendor}/locations
	GetProviderLocations(ctx context.Context, params GetProviderLocationsParams) (*GetProviderLocationsOK, error)
	// GetProviderServers invokes getProviderServers operation.
	//
	// List Provider Servers.
	//
	// GET /v1/infrastructure/providers/{providerVendor}/servers
	GetProviderServers(ctx context.Context, params GetProviderServersParams) (*GetProviderServersOK, error)
	// GetRole invokes getRole operation.
	//
	// Retrieves the specified Role.
	// Requries the `hubs-roles-manage` capability.
	//
	// GET /v1/hubs/current/roles/{roleId}
	GetRole(ctx context.Context, params GetRoleParams) (*GetRoleOK, error)
	// GetRoles invokes getRoles operation.
	//
	// Lists the Roles that have been created for this Hub.
	// Requires the `hubs-roles-manage` capability.
	//
	// GET /v1/hubs/current/roles
	GetRoles(ctx context.Context, params GetRolesParams) (*GetRolesOK, error)
	// GetScopedVariable invokes getScopedVariable operation.
	//
	// Requires the `scoped-variables-view` capability.
	//
	// GET /v1/environments/{environmentId}/scoped-variables/{scopedVariableId}
	GetScopedVariable(ctx context.Context, params GetScopedVariableParams) (*GetScopedVariableOK, error)
	// GetScopedVariables invokes getScopedVariables operation.
	//
	// Requires the `scoped-variables-view` capability.
	//
	// GET /v1/environments/{environmentId}/scoped-variables
	GetScopedVariables(ctx context.Context, params GetScopedVariablesParams) (*GetScopedVariablesOK, error)
	// GetSearchIndex invokes getSearchIndex operation.
	//
	// Gets a pre-built search index, containing IDs and basic information for many commonly used
	// resources on the Hub.
	// Can be used to build a 'quick search' functionality for referencing the most frequently used
	// resources.
	// Requires the `view` capability for each returned segment, i.e. to retrieve Containers, you must
	// have `containers-view`.
	//
	// GET /v1/search/index
	GetSearchIndex(ctx context.Context) (*GetSearchIndexOK, error)
	// GetServer invokes getServer operation.
	//
	// Requires the `servers-view` capability.
	//
	// GET /v1/infrastructure/servers/{serverId}
	GetServer(ctx context.Context, params GetServerParams) (*GetServerOK, error)
	// GetServerConsole invokes GetServerConsole operation.
	//
	// Gets the authorization information required to connect to a Server console websocket.
	// Requires the `servers-console` capability.
	//
	// GET /v1/infrastructure/servers/{serverId}/console
	GetServerConsole(ctx context.Context, params GetServerConsoleParams) (*GetServerConsoleOK, error)
	// GetServerInstances invokes getServerInstances operation.
	//
	// Requires the `containers-view` capability.
	//
	// GET /v1/infrastructure/servers/{serverId}/instances
	GetServerInstances(ctx context.Context, params GetServerInstancesParams) (*GetServerInstancesOK, error)
	// GetServerTags invokes getServerTags operation.
	//
	// Requires the `servers-view` capability.
	//
	// GET /v1/infrastructure/servers/tags
	GetServerTags(ctx context.Context, params GetServerTagsParams) (*ServerTags, error)
	// GetServerTelemetry invokes getServerTelemetry operation.
	//
	// This call requires the filter query parameter to be used.
	// Requires the `servers-view` capability.
	//
	// GET /v1/infrastructure/servers/{serverId}/telemetry
	GetServerTelemetry(ctx context.Context, params GetServerTelemetryParams) (*GetServerTelemetryOK, error)
	// GetServerUsage invokes GetServerUsage operation.
	//
	// Requires the `servers-view` capability.
	//
	// GET /v1/infrastructure/servers/{serverId}/usage
	GetServerUsage(ctx context.Context, params GetServerUsageParams) (*GetServerUsageOK, error)
	// GetServers invokes getServers operation.
	//
	// Requires the `servers-view` capability.
	//
	// GET /v1/infrastructure/servers
	GetServers(ctx context.Context, params GetServersParams) (*GetServersOK, error)
	// GetStack invokes getStack operation.
	//
	// Requires the `stacks-view` capability.
	//
	// GET /v1/stacks/{stackId}
	GetStack(ctx context.Context, params GetStackParams) (*GetStackOK, error)
	// GetStackBuild invokes getStackBuild operation.
	//
	// Requires the `stacks-view` capability.
	//
	// GET /v1/stacks/{stackId}/builds/{buildId}
	GetStackBuild(ctx context.Context, params GetStackBuildParams) (*GetStackBuildOK, error)
	// GetStackBuilds invokes getStackBuilds operation.
	//
	// Requires the `stacks-view` capability.
	//
	// GET /v1/stacks/{stackId}/builds
	GetStackBuilds(ctx context.Context, params GetStackBuildsParams) (*GetStackBuildsOK, error)
	// GetStacks invokes getStacks operation.
	//
	// Requires the `stacks-view` permission.
	//
	// GET /v1/stacks
	GetStacks(ctx context.Context, params GetStacksParams) (*GetStacksOK, error)
	// GetTLSGenerationAttempts invokes getTLSGenerationAttempts operation.
	//
	// Requires the `dns-view` capability.
	//
	// GET /v1/dns/tls/attempts
	GetTLSGenerationAttempts(ctx context.Context, params GetTLSGenerationAttemptsParams) (*GetTLSGenerationAttemptsOK, error)
	// GetTwoFactorAuthSetup invokes getTwoFactorAuthSetup operation.
	//
	// Gets the barcode and secret required for setting up two-factor authentication for the Account.
	//
	// GET /v1/account/2fa/setup
	GetTwoFactorAuthSetup(ctx context.Context) (*GetTwoFactorAuthSetupOK, error)
	// GetVPNLogins invokes getVPNLogins operation.
	//
	// Requires the `environments-vpn` capability.
	//
	// GET /v1/environments/{environmentId}/services/vpn/logins
	GetVPNLogins(ctx context.Context, params GetVPNLoginsParams) (*GetVPNLoginsOK, error)
	// GetVPNService invokes getVPNService operation.
	//
	// Requires the `environments-vpn` capability.
	//
	// GET /v1/environments/{environmentId}/services/vpn
	GetVPNService(ctx context.Context, params GetVPNServiceParams) (*GetVPNServiceOK, error)
	// GetVPNUsers invokes getVPNUsers operation.
	//
	// Requires the `environments-vpn-manage` capability.
	//
	// GET /v1/environments/{environmentId}/services/vpn/users
	GetVPNUsers(ctx context.Context, params GetVPNUsersParams) (*GetVPNUsersOK, error)
	// GetVirtualMachine invokes getVirtualMachine operation.
	//
	// Retrieves a single virtual machine by ID.
	// Requires the `virtual-machines-view` capability.
	//
	// GET /v1/virtual-machines/{virtualMachineId}
	GetVirtualMachine(ctx context.Context, params GetVirtualMachineParams) (*GetVirtualMachineOK, error)
	// GetVirtualMachineBaseImages invokes getVirtualMachineBaseImages operation.
	//
	// Retrieves the list of available base images for virtual machines provided by Cycle.
	//
	// GET /v1/virtual-machines/images/base
	GetVirtualMachineBaseImages(ctx context.Context) (*GetVirtualMachineBaseImagesOK, error)
	// GetVirtualMachines invokes getVirtualMachines operation.
	//
	// Requires the `virtual-machines-view` capability.
	//
	// GET /v1/virtual-machines
	GetVirtualMachines(ctx context.Context, params GetVirtualMachinesParams) (*GetVirtualMachinesOK, error)
	// LookupComponents invokes lookupComponents operation.
	//
	// Look up a component.
	//
	// POST /v1/utils/components/lookup
	LookupComponents(ctx context.Context, request OptLookupComponentsReq) (*LookupComponentsOK, error)
	// LookupIdentifier invokes lookupIdentifier operation.
	//
	// Given a (base64'd) resource identifier string (i.e. `cluster:production/env:abc`), returns the ID
	// of the matching resource.
	// If more than one resource matches the identifier, or no resource matches the identifier, this
	// endpoint will return an error.
	// Given identifiers are NOT unique, you may need to be more specific to target the exact identifier.
	//
	// GET /v1/utils/resource/lookup
	LookupIdentifier(ctx context.Context, params LookupIdentifierParams) (*LookupIdentifierOK, error)
	// LookupStackBuild invokes lookupStackBuild operation.
	//
	// Look up a Stack Build using only the Build ID, instead of requiring a Stack ID as well.
	// Requires the `stacks-view` capability.
	//
	// GET /v1/stacks/builds/{buildId}
	LookupStackBuild(ctx context.Context, params LookupStackBuildParams) (*LookupStackBuildOK, error)
	// LookupTLSCertificate invokes lookupTLSCertificate operation.
	//
	// Lookup and retrieve a TLS certificate bundle for a specified domain.
	// Requires the `dns-view` capability.
	//
	// GET /v1/dns/tls/certificates/lookup
	LookupTLSCertificate(ctx context.Context, params LookupTLSCertificateParams) (*LookupTLSCertificateOK, error)
	// RecoverTwoFactorAuth invokes recoverTwoFactorAuth operation.
	//
	// Returns a new two-factor auth setup to reset the Account's two-factor auth.
	//
	// POST /v1/account/2fa/recover
	RecoverTwoFactorAuth(ctx context.Context, request OptRecoverTwoFactorAuthReq) (*RecoverTwoFactorAuthOK, error)
	// ResetPassword invokes resetPassword operation.
	//
	// Initiate a password reset for the Account. A confirmation email will be sent to the email
	// associated with the Account, and the token in the email must be passed in a second call to this
	// endpoint.
	//
	// POST /v1/account/reset-password
	ResetPassword(ctx context.Context, request *ResetPasswordReq) (*ResetPasswordOK, error)
	// TriggerPipeline invokes triggerPipeline operation.
	//
	// Trigger Pipeline.
	//
	// POST /v1/pipelines/{pipelineId}/trigger
	TriggerPipeline(ctx context.Context, request OptTriggerPipelineReq, params TriggerPipelineParams) (*TriggerPipelineCreated, error)
	// UpdateAPIKey invokes updateAPIKey operation.
	//
	// Requires the `api-keys-manage` capability.
	//
	// PATCH /v1/hubs/current/api-keys/{apikeyId}
	UpdateAPIKey(ctx context.Context, request OptUpdateAPIKeyReq, params UpdateAPIKeyParams) (*UpdateAPIKeyOK, error)
	// UpdateAccount invokes updateAccount operation.
	//
	// Updates the Account.
	//
	// PATCH /v1/account
	UpdateAccount(ctx context.Context, request OptUpdateAccountReq) (*UpdateAccountOK, error)
	// UpdateAccountInvite invokes updateAccountInvite operation.
	//
	// Accept/reject a pending Invite to join a Hub.
	//
	// PATCH /v1/account/invites/{inviteId}
	UpdateAccountInvite(ctx context.Context, request OptUpdateAccountInviteReq, params UpdateAccountInviteParams) (*UpdateAccountInviteOK, error)
	// UpdateAutoScaleGroup invokes updateAutoScaleGroup operation.
	//
	// Requires the `autoscale-groups-manage` capability.
	//
	// PATCH /v1/infrastructure/auto-scale/groups/{groupId}
	UpdateAutoScaleGroup(ctx context.Context, request OptUpdateAutoScaleGroupReq, params UpdateAutoScaleGroupParams) (*UpdateAutoScaleGroupOK, error)
	// UpdateAutoScaleGroupAccess invokes updateAutoScaleGroupAccess operation.
	//
	// Requires the `autoscale-groups-manage` capability. If an ACL is present, requires the `manage`
	// privilege.
	//
	// PATCH /v1/infrastructure/auto-scale/groups/{groupId}/access
	UpdateAutoScaleGroupAccess(ctx context.Context, request OptUpdateAutoScaleGroupAccessReq, params UpdateAutoScaleGroupAccessParams) (*UpdateAutoScaleGroupAccessOK, error)
	// UpdateBillingMethod invokes updateBillingMethod operation.
	//
	// Requires the `billing-methods-manage` capability.
	//
	// PATCH /v1/billing/methods/{methodId}
	UpdateBillingMethod(ctx context.Context, request OptUpdateBillingMethodReq, params UpdateBillingMethodParams) (*UpdateBillingMethodOK, error)
	// UpdateBillingOrder invokes updateBillingOrder operation.
	//
	// Requires the `billing-services-manage` capability.
	//
	// PATCH /v1/billing/orders/{orderId}
	UpdateBillingOrder(ctx context.Context, request OptUpdateBillingOrderReq, params UpdateBillingOrderParams) (*UpdateBillingOrderOK, error)
	// UpdateCluster invokes updateCluster operation.
	//
	// Requires the `clusters-manage` capability.
	//
	// PATCH /v1/infrastructure/clusters/{clusterId}
	UpdateCluster(ctx context.Context, request *UpdateClusterReq, params UpdateClusterParams) (*UpdateClusterOK, error)
	// UpdateClusterAccess invokes updateClusterAccess operation.
	//
	// Requires the `clusters-manage` capability. If an ACL is present, requires the `manage` privilege.
	//
	// PATCH /v1/infrastructure/clusters/{clusterId}/access
	UpdateClusterAccess(ctx context.Context, request OptUpdateClusterAccessReq, params UpdateClusterAccessParams) (*UpdateClusterAccessOK, error)
	// UpdateContainer invokes updateContainer operation.
	//
	// Updates the specified Container.
	// Requires the `containers-manage` capability.
	//
	// PATCH /v1/containers/{containerId}
	UpdateContainer(ctx context.Context, request OptUpdateContainerReq, params UpdateContainerParams) (*UpdateContainerOK, error)
	// UpdateDNSZone invokes updateDNSZone operation.
	//
	// Requires the `dns-manage` capability.
	//
	// PATCH /v1/dns/zones/{zoneId}
	UpdateDNSZone(ctx context.Context, request OptUpdateDNSZoneReq, params UpdateDNSZoneParams) (*UpdateDNSZoneOK, error)
	// UpdateDNSZoneAccess invokes updateDNSZoneAccess operation.
	//
	// Requires the `dns-manage` capability, and if an ACL is present, the `manage` privilege.
	//
	// PATCH /v1/dns/zones/{zoneId}/access
	UpdateDNSZoneAccess(ctx context.Context, request OptUpdateDNSZoneAccessReq, params UpdateDNSZoneAccessParams) (*UpdateDNSZoneAccessOK, error)
	// UpdateDNSZoneRecord invokes updateDNSZoneRecord operation.
	//
	// Requires the `dns-manage` capability.
	//
	// PATCH /v1/dns/zones/{zoneId}/records/{recordId}
	UpdateDNSZoneRecord(ctx context.Context, request OptUpdateDNSZoneRecordReq, params UpdateDNSZoneRecordParams) (*UpdateDNSZoneRecordOK, error)
	// UpdateEnvironment invokes updateEnvironment operation.
	//
	// Updates the specificed Environment.
	// Requires the `environments-manage` capability.
	//
	// PATCH /v1/environments/{environmentId}
	UpdateEnvironment(ctx context.Context, request OptUpdateEnvironmentReq, params UpdateEnvironmentParams) (*UpdateEnvironmentOK, error)
	// UpdateEnvironmentAccess invokes updateEnvironmentAccess operation.
	//
	// Updates the specificed Environment.
	// Requires the `environments-manage` capability. If an ACL is present, requires the `manage`
	// privilege.
	//
	// PATCH /v1/environments/{environmentId}/access
	UpdateEnvironmentAccess(ctx context.Context, request OptUpdateEnvironmentAccessReq, params UpdateEnvironmentAccessParams) (*UpdateEnvironmentAccessOK, error)
	// UpdateHub invokes updateHub operation.
	//
	// Updates the specified hub, setting the values of the parameters passed.
	//
	// PATCH /v1/hubs/current
	UpdateHub(ctx context.Context, request OptUpdateHubReq) (*UpdateHubOK, error)
	// UpdateHubMember invokes updateHubMember operation.
	//
	// Requires the `hubs-members-manage` capability.
	//
	// PATCH /v1/hubs/current/members/{memberId}
	UpdateHubMember(ctx context.Context, request OptUpdateHubMemberReq, params UpdateHubMemberParams) (*UpdateHubMemberOK, error)
	// UpdateImage invokes updateImage operation.
	//
	// Requires the `images-manage` capability.
	//
	// PATCH /v1/images/{imageId}
	UpdateImage(ctx context.Context, request OptUpdateImageReq, params UpdateImageParams) (*UpdateImageOK, error)
	// UpdateImageSource invokes updateImageSource operation.
	//
	// Requires the `images-sources-manage` capability.
	//
	// PATCH /v1/images/sources/{sourceId}
	UpdateImageSource(ctx context.Context, request OptUpdateImageSourceReq, params UpdateImageSourceParams) (*UpdateImageSourceOK, error)
	// UpdateImageSourceAccess invokes updateImageSourceAccess operation.
	//
	// Requires the `images-sources-manage` capability. If an ACL is present, requires the `manage`
	// privilege.
	//
	// PATCH /v1/images/sources/{sourceId}/access
	UpdateImageSourceAccess(ctx context.Context, request OptUpdateImageSourceAccessReq, params UpdateImageSourceAccessParams) (*UpdateImageSourceAccessOK, error)
	// UpdateIntegration invokes updateIntegration operation.
	//
	// Updates the specified Integration within the current hub. If the Integration definition specifies
	// that it requires verification, then you must submit a verify task to enable it.
	//
	// PATCH /v1/hubs/current/integrations/{integrationId}
	UpdateIntegration(ctx context.Context, request *UpdateIntegrationReq, params UpdateIntegrationParams) (*UpdateIntegrationOK, error)
	// UpdateNetwork invokes updateNetwork operation.
	//
	// Requires the `sdn-networks-manage` capability.
	//
	// PATCH /v1/sdn/networks/{networkId}
	UpdateNetwork(ctx context.Context, request OptUpdateNetworkReq, params UpdateNetworkParams) (*UpdateNetworkOK, error)
	// UpdateNetworkAccess invokes updateNetworkAccess operation.
	//
	// Requires the `sdn-networks-manage` capability. If an ACL is present, requires the `manage`
	// privilege.
	//
	// PATCH /v1/sdn/networks/{networkId}/access
	UpdateNetworkAccess(ctx context.Context, request OptUpdateNetworkAccessReq, params UpdateNetworkAccessParams) (*UpdateNetworkAccessOK, error)
	// UpdatePipeline invokes updatePipeline operation.
	//
	// Requires the `pipelines-manage` capability.
	//
	// PATCH /v1/pipelines/{pipelineId}
	UpdatePipeline(ctx context.Context, request OptUpdatePipelineReq, params UpdatePipelineParams) (*UpdatePipelineOK, error)
	// UpdatePipelineAccess invokes updatePipelineAccess operation.
	//
	// Requires the `pipelines-manage` capability. If an ACL is present, requires the `manage` privilege.
	//
	// PATCH /v1/pipelines/{pipelineId}/access
	UpdatePipelineAccess(ctx context.Context, request OptUpdatePipelineAccessReq, params UpdatePipelineAccessParams) (*UpdatePipelineAccessOK, error)
	// UpdatePipelineTriggerKey invokes updatePipelineTriggerKey operation.
	//
	// Requires the `pipelines-manage` capability.
	//
	// PATCH /v1/pipelines/{pipelineId}/keys/{triggerKeyId}
	UpdatePipelineTriggerKey(ctx context.Context, request OptUpdatePipelineTriggerKeyReq, params UpdatePipelineTriggerKeyParams) (*UpdatePipelineTriggerKeyOK, error)
	// UpdateRole invokes updateRole operation.
	//
	// Updates various properties of a specific Role.
	// Requires the `hubs-roles-manage` capability.
	//
	// PATCH /v1/hubs/current/roles/{roleId}
	UpdateRole(ctx context.Context, request OptUpdateRoleReq, params UpdateRoleParams) (*UpdateRoleOK, error)
	// UpdateScopedVariable invokes updateScopedVariable operation.
	//
	// Requires the `scoped-variables-manage` capability.
	//
	// PATCH /v1/environments/{environmentId}/scoped-variables/{scopedVariableId}
	UpdateScopedVariable(ctx context.Context, request OptUpdateScopedVariableReq, params UpdateScopedVariableParams) (*UpdateScopedVariableOK, error)
	// UpdateServer invokes updateServer operation.
	//
	// Requires the `servers-manage` capability.
	//
	// PATCH /v1/infrastructure/servers/{serverId}
	UpdateServer(ctx context.Context, request OptUpdateServerReq, params UpdateServerParams) (*UpdateServerOK, error)
	// UpdateStack invokes updateStack operation.
	//
	// Requires the `stacks-manage` capability.
	//
	// PATCH /v1/stacks/{stackId}
	UpdateStack(ctx context.Context, request OptUpdateStackReq, params UpdateStackParams) (*UpdateStackOK, error)
	// UpdateStackAccess invokes updateStackAccess operation.
	//
	// Requires the `stacks-manage` capability. If an ACL is present, requires the `manage` privilege.
	//
	// PATCH /v1/stacks/{stackId}/access
	UpdateStackAccess(ctx context.Context, request OptUpdateStackAccessReq, params UpdateStackAccessParams) (*UpdateStackAccessOK, error)
	// UpdateVirtualMachine invokes updateVirtualMachine operation.
	//
	// Updates the specified virtual machine.
	// Requires the `virtual-machines-manage` capability.
	//
	// PATCH /v1/virtual-machines/{virtualMachineId}
	UpdateVirtualMachine(ctx context.Context, request OptUpdateVirtualMachineReq, params UpdateVirtualMachineParams) (*UpdateVirtualMachineOK, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AggregateLogs invokes aggregateLogs operation.
//
// A query for retrieving container instance logs.
// Allows aggregate narrowing through filtering, searching, and scope parameters.
// If 'local' is set to true, only cached logs will be queried, and logs in object storage will be
// ignored.  This leads to much faster performance.
// Requires the `monitor-view` capability.
//
// POST /v1/monitoring/logs/aggregate
func (c *Client) AggregateLogs(ctx context.Context, request OptAggregateLogsReq) (*AggregateLogsOK, error) {
	res, err := c.sendAggregateLogs(ctx, request)
	return res, err
}

func (c *Client) sendAggregateLogs(ctx context.Context, request OptAggregateLogsReq) (res *AggregateLogsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/monitoring/logs/aggregate"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAggregateLogsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "AggregateLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "AggregateLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAggregateLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangePassword invokes changePassword operation.
//
// Change the password on the Account. Requires the current password of the Account to be submitted.
//
// PATCH /v1/account/password
func (c *Client) ChangePassword(ctx context.Context, request OptChangePasswordReq) (*ChangePasswordOK, error) {
	res, err := c.sendChangePassword(ctx, request)
	return res, err
}

func (c *Client) sendChangePassword(ctx context.Context, request OptChangePasswordReq) (res *ChangePasswordOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/account/password"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangePasswordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ChangePassword", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChangePasswordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ClonePipeline invokes clonePipeline operation.
//
// Requires the `pipelines-manage` capability.
//
// POST /v1/pipelines/clone
func (c *Client) ClonePipeline(ctx context.Context, request OptClonePipelineReq) (*ClonePipelineCreated, error) {
	res, err := c.sendClonePipeline(ctx, request)
	return res, err
}

func (c *Client) sendClonePipeline(ctx context.Context, request OptClonePipelineReq) (res *ClonePipelineCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/pipelines/clone"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeClonePipelineRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ClonePipeline", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "ClonePipeline", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeClonePipelineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateApiKey invokes createApiKey operation.
//
// Requires the `api-keys-manage` capability.
//
// POST /v1/hubs/current/api-keys
func (c *Client) CreateApiKey(ctx context.Context, request OptCreateApiKeyReq) (*CreateApiKeyCreated, error) {
	res, err := c.sendCreateApiKey(ctx, request)
	return res, err
}

func (c *Client) sendCreateApiKey(ctx context.Context, request OptCreateApiKeyReq) (res *CreateApiKeyCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/api-keys"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateApiKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateApiKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateApiKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateApiKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateAutoScaleGroup invokes createAutoScaleGroup operation.
//
// Requires the 'autoscale-groups-manage'.
//
// POST /v1/infrastructure/auto-scale/groups
func (c *Client) CreateAutoScaleGroup(ctx context.Context, request OptCreateAutoScaleGroupReq) (*CreateAutoScaleGroupCreated, error) {
	res, err := c.sendCreateAutoScaleGroup(ctx, request)
	return res, err
}

func (c *Client) sendCreateAutoScaleGroup(ctx context.Context, request OptCreateAutoScaleGroupReq) (res *CreateAutoScaleGroupCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/infrastructure/auto-scale/groups"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateAutoScaleGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateAutoScaleGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateAutoScaleGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateAutoScaleGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateBillingMethod invokes createBillingMethod operation.
//
// Requires the `billing-methods-manage` capability.
//
// POST /v1/billing/methods
func (c *Client) CreateBillingMethod(ctx context.Context, request OptCreateBillingMethodReq) (*CreateBillingMethodCreated, error) {
	res, err := c.sendCreateBillingMethod(ctx, request)
	return res, err
}

func (c *Client) sendCreateBillingMethod(ctx context.Context, request OptCreateBillingMethodReq) (res *CreateBillingMethodCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/billing/methods"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateBillingMethodRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateBillingMethod", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateBillingMethod", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateBillingMethodResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateBillingMethodJob invokes createBillingMethodJob operation.
//
// Creates a new job for a billing method. Generally used to verify a payment method.
// Requires the `billing-methods-manage` capability.
//
// POST /v1/billing/methods/{methodId}/tasks
func (c *Client) CreateBillingMethodJob(ctx context.Context, request OptCreateBillingMethodJobReq, params CreateBillingMethodJobParams) (*CreateBillingMethodJobAccepted, error) {
	res, err := c.sendCreateBillingMethodJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateBillingMethodJob(ctx context.Context, request OptCreateBillingMethodJobReq, params CreateBillingMethodJobParams) (res *CreateBillingMethodJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/billing/methods/"
	{
		// Encode "methodId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "methodId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MethodId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateBillingMethodJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateBillingMethodJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateBillingMethodJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateBillingMethodJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateCluster invokes createCluster operation.
//
// Requires the `clusters-manage` capability.
//
// POST /v1/infrastructure/clusters
func (c *Client) CreateCluster(ctx context.Context, request OptCreateClusterReq) (*CreateClusterCreated, error) {
	res, err := c.sendCreateCluster(ctx, request)
	return res, err
}

func (c *Client) sendCreateCluster(ctx context.Context, request OptCreateClusterReq) (res *CreateClusterCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/infrastructure/clusters"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateClusterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateCluster", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateCluster", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateContainer invokes createContainer operation.
//
// Requires the `containers-deploy` capability.
//
// POST /v1/containers
func (c *Client) CreateContainer(ctx context.Context, request OptCreateContainerReq) (*CreateContainerCreated, error) {
	res, err := c.sendCreateContainer(ctx, request)
	return res, err
}

func (c *Client) sendCreateContainer(ctx context.Context, request OptCreateContainerReq) (res *CreateContainerCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/containers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateContainerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateContainer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateContainer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateContainerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateContainerBackupJob invokes createContainerBackupJob operation.
//
// Creates a Container Backup Job.
// Can be used to restore a Container Backup for a given Container Instance.
// Requires the `containers-backups-manage` capability.
//
// POST /v1/containers/{containerId}/backups/{backupId}/tasks
func (c *Client) CreateContainerBackupJob(ctx context.Context, request OptCreateContainerBackupJobReq, params CreateContainerBackupJobParams) (*CreateContainerBackupJobAccepted, error) {
	res, err := c.sendCreateContainerBackupJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateContainerBackupJob(ctx context.Context, request OptCreateContainerBackupJobReq, params CreateContainerBackupJobParams) (res *CreateContainerBackupJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/backups/"
	{
		// Encode "backupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "backupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BackupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateContainerBackupJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateContainerBackupJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateContainerBackupJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateContainerBackupJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateContainerJob invokes createContainerJob operation.
//
// Used to perform different actions on a given Container.
// Requires the following capabilities based on the task:
// `start`: `containers-manage`
// `stop`: `containers-manage`
// `reconfigure`: `containers-manage`
// `volumes.reconfigure`: `containers-volumes-manage`
// `reimage`: `containers-manage`
// `scale`: `containers-manage`.
//
// POST /v1/containers/{containerId}/tasks
func (c *Client) CreateContainerJob(ctx context.Context, request *CreateContainerJobReq, params CreateContainerJobParams) (*CreateContainerJobAccepted, error) {
	res, err := c.sendCreateContainerJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateContainerJob(ctx context.Context, request *CreateContainerJobReq, params CreateContainerJobParams) (res *CreateContainerJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateContainerJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateContainerJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateContainerJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateContainerJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDNSZone invokes createDNSZone operation.
//
// Requires the `dns-manage` capability.
//
// POST /v1/dns/zones
func (c *Client) CreateDNSZone(ctx context.Context, request OptCreateDNSZoneReq) (*CreateDNSZoneCreated, error) {
	res, err := c.sendCreateDNSZone(ctx, request)
	return res, err
}

func (c *Client) sendCreateDNSZone(ctx context.Context, request OptCreateDNSZoneReq) (res *CreateDNSZoneCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/dns/zones"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDNSZoneRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateDNSZone", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateDNSZone", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateDNSZoneResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDNSZoneJob invokes createDNSZoneJob operation.
//
// Used to perform different actions on a given DNS zone.
// Requires the `dns-manage` capability.
//
// POST /v1/dns/zones/{zoneId}/tasks
func (c *Client) CreateDNSZoneJob(ctx context.Context, request OptCreateDNSZoneJobReq, params CreateDNSZoneJobParams) (*CreateDNSZoneJobAccepted, error) {
	res, err := c.sendCreateDNSZoneJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateDNSZoneJob(ctx context.Context, request OptCreateDNSZoneJobReq, params CreateDNSZoneJobParams) (res *CreateDNSZoneJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/dns/zones/"
	{
		// Encode "zoneId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "zoneId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ZoneId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDNSZoneJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateDNSZoneJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateDNSZoneJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateDNSZoneJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDNSZoneRecord invokes createDNSZoneRecord operation.
//
// Requires the `dns-manage` capability.
//
// POST /v1/dns/zones/{zoneId}/records
func (c *Client) CreateDNSZoneRecord(ctx context.Context, request OptCreateDNSZoneRecordReq, params CreateDNSZoneRecordParams) (*CreateDNSZoneRecordCreated, error) {
	res, err := c.sendCreateDNSZoneRecord(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateDNSZoneRecord(ctx context.Context, request OptCreateDNSZoneRecordReq, params CreateDNSZoneRecordParams) (res *CreateDNSZoneRecordCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/dns/zones/"
	{
		// Encode "zoneId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "zoneId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ZoneId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDNSZoneRecordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateDNSZoneRecord", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateDNSZoneRecord", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateDNSZoneRecordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDNSZoneRecordJob invokes createDNSZoneRecordJob operation.
//
// Used to perform different actions on a given DNS Zone record.
// Requires the `dns-manage` capability.
//
// POST /v1/dns/zones/{zoneId}/records/{recordId}/tasks
func (c *Client) CreateDNSZoneRecordJob(ctx context.Context, request OptCreateDNSZoneRecordJobReq, params CreateDNSZoneRecordJobParams) (*CreateDNSZoneRecordJobAccepted, error) {
	res, err := c.sendCreateDNSZoneRecordJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateDNSZoneRecordJob(ctx context.Context, request OptCreateDNSZoneRecordJobReq, params CreateDNSZoneRecordJobParams) (res *CreateDNSZoneRecordJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/dns/zones/"
	{
		// Encode "zoneId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "zoneId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ZoneId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records/"
	{
		// Encode "recordId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDNSZoneRecordJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateDNSZoneRecordJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateDNSZoneRecordJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateDNSZoneRecordJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateDiscoveryServiceJob invokes createDiscoveryServiceJob operation.
//
// Creates a task that will update the discovery service's configuration.
//
// POST /v1/environments/{environmentId}/services/discovery/tasks
func (c *Client) CreateDiscoveryServiceJob(ctx context.Context, request OptCreateDiscoveryServiceJobReq, params CreateDiscoveryServiceJobParams) (*CreateDiscoveryServiceJobAccepted, error) {
	res, err := c.sendCreateDiscoveryServiceJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateDiscoveryServiceJob(ctx context.Context, request OptCreateDiscoveryServiceJobReq, params CreateDiscoveryServiceJobParams) (res *CreateDiscoveryServiceJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/discovery/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateDiscoveryServiceJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateDiscoveryServiceJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateDiscoveryServiceJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateDiscoveryServiceJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEnvironment invokes createEnvironment operation.
//
// Requires the `environments-create` capability.
//
// POST /v1/environments
func (c *Client) CreateEnvironment(ctx context.Context, request OptCreateEnvironmentReq) (*CreateEnvironmentCreated, error) {
	res, err := c.sendCreateEnvironment(ctx, request)
	return res, err
}

func (c *Client) sendCreateEnvironment(ctx context.Context, request OptCreateEnvironmentReq) (res *CreateEnvironmentCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/environments"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEnvironmentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateEnvironment", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateEnvironment", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateEnvironmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateEnvironmentJob invokes createEnvironmentJob operation.
//
// Create a job for an Environment, such as 'start' or 'stop'.
// Requires the `environments-manage` capability.
//
// POST /v1/environments/{environmentId}/tasks
func (c *Client) CreateEnvironmentJob(ctx context.Context, request *CreateEnvironmentJobReq, params CreateEnvironmentJobParams) (*CreateEnvironmentJobAccepted, error) {
	res, err := c.sendCreateEnvironmentJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateEnvironmentJob(ctx context.Context, request *CreateEnvironmentJobReq, params CreateEnvironmentJobParams) (res *CreateEnvironmentJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateEnvironmentJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateEnvironmentJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateEnvironmentJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateEnvironmentJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateFunctionJob invokes createFunctionJob operation.
//
// Used to perform different actions on a given Function Container.
// Requires the `containers-functions-trigger` capability.
//
// POST /v1/containers/{containerId}/functions/tasks
func (c *Client) CreateFunctionJob(ctx context.Context, request OptTrigger, params CreateFunctionJobParams) (*CreateFunctionJobAccepted, error) {
	res, err := c.sendCreateFunctionJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateFunctionJob(ctx context.Context, request OptTrigger, params CreateFunctionJobParams) (res *CreateFunctionJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/functions/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateFunctionJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateFunctionJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateFunctionJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateFunctionJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateHub invokes createHub operation.
//
// Create a Hub.
//
// POST /v1/hubs
func (c *Client) CreateHub(ctx context.Context, request OptCreateHubReq) (*CreateHubOK, error) {
	res, err := c.sendCreateHub(ctx, request)
	return res, err
}

func (c *Client) sendCreateHub(ctx context.Context, request OptCreateHubReq) (res *CreateHubOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateHubRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateHub", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateHubResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateHubInvite invokes createHubInvite operation.
//
// Requires the `hubs-invites-send` capability.
//
// POST /v1/hubs/current/invites
func (c *Client) CreateHubInvite(ctx context.Context, request OptCreateHubInviteReq) (*CreateHubInviteCreated, error) {
	res, err := c.sendCreateHubInvite(ctx, request)
	return res, err
}

func (c *Client) sendCreateHubInvite(ctx context.Context, request OptCreateHubInviteReq) (res *CreateHubInviteCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/invites"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateHubInviteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateHubInvite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateHubInvite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateHubInviteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateImage invokes createImage operation.
//
// Requires the `images-manage` capability.
//
// POST /v1/images
func (c *Client) CreateImage(ctx context.Context, request OptCreateImageReq) (*CreateImageCreated, error) {
	res, err := c.sendCreateImage(ctx, request)
	return res, err
}

func (c *Client) sendCreateImage(ctx context.Context, request OptCreateImageReq) (res *CreateImageCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/images"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateImageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateImage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateImage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateImageJob invokes createImageJob operation.
//
// Used to perform different actions on a given Image.
// Requires the `images-import` capability.
//
// POST /v1/images/{imageId}/tasks
func (c *Client) CreateImageJob(ctx context.Context, request OptCreateImageJobReq, params CreateImageJobParams) (*CreateImageJobOK, error) {
	res, err := c.sendCreateImageJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateImageJob(ctx context.Context, request OptCreateImageJobReq, params CreateImageJobParams) (res *CreateImageJobOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/images/"
	{
		// Encode "imageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "imageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ImageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateImageJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateImageJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateImageJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateImageJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateImageSource invokes createImageSource operation.
//
// Requires the `images-sources-manage` capability.
//
// POST /v1/images/sources
func (c *Client) CreateImageSource(ctx context.Context, request OptCreateImageSourceReq) (*CreateImageSourceCreated, error) {
	res, err := c.sendCreateImageSource(ctx, request)
	return res, err
}

func (c *Client) sendCreateImageSource(ctx context.Context, request OptCreateImageSourceReq) (res *CreateImageSourceCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/images/sources"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateImageSourceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateImageSource", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateImageSource", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateImageSourceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateImagesJob invokes createImagesJob operation.
//
// Used to perform different actions on a given image.
// Requires the `images-manage` capability.
//
// POST /v1/images/tasks
func (c *Client) CreateImagesJob(ctx context.Context, request OptCreateImagesJobReq) (*CreateImagesJobAccepted, error) {
	res, err := c.sendCreateImagesJob(ctx, request)
	return res, err
}

func (c *Client) sendCreateImagesJob(ctx context.Context, request OptCreateImagesJobReq) (res *CreateImagesJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/images/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateImagesJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateImagesJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateImagesJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateImagesJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateInstanceJob invokes createInstanceJob operation.
//
// Used to perform different actions on a given Container Instance. Can be used to migrate or undo a
// migration of a Container Instance.
// Requires the `containers-instance-migrate` capability.
//
// POST /v1/containers/{containerId}/instances/{instanceId}/tasks
func (c *Client) CreateInstanceJob(ctx context.Context, request *CreateInstanceJobReq, params CreateInstanceJobParams) (*CreateInstanceJobAccepted, error) {
	res, err := c.sendCreateInstanceJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateInstanceJob(ctx context.Context, request *CreateInstanceJobReq, params CreateInstanceJobParams) (res *CreateInstanceJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances/"
	{
		// Encode "instanceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instanceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InstanceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateInstanceJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateInstanceJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateInstanceJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateInstanceJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateInstances invokes createInstances operation.
//
// Manually create Instances of a Container.
// Requires the `containers-update` capability.
//
// POST /v1/containers/{containerId}/instances
func (c *Client) CreateInstances(ctx context.Context, request []CreateInstancesReqItem, params CreateInstancesParams) (*CreateInstancesAccepted, error) {
	res, err := c.sendCreateInstances(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateInstances(ctx context.Context, request []CreateInstancesReqItem, params CreateInstancesParams) (res *CreateInstancesAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateInstancesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateInstances", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateInstances", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateInstancesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateIntegration invokes createIntegration operation.
//
// Create an Integration resource within a hub. If the Integration definition specifies that it
// requires verification, then you must submit a verify task to enable it.
//
// POST /v1/hubs/current/integrations
func (c *Client) CreateIntegration(ctx context.Context, request *CreateIntegrationReq, params CreateIntegrationParams) (*CreateIntegrationCreated, error) {
	res, err := c.sendCreateIntegration(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateIntegration(ctx context.Context, request *CreateIntegrationReq, params CreateIntegrationParams) (res *CreateIntegrationCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/integrations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateIntegrationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateIntegration", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateIntegrationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateIntegrationJob invokes createIntegrationJob operation.
//
// Creates a new Job targeted at the provided Hub Integration.
// - Requires a valid hub membership to the target hub.
// - Requires the `hubs-integrations-manage` capability.
//
// POST /v1/hubs/current/integrations/{integrationId}/tasks
func (c *Client) CreateIntegrationJob(ctx context.Context, request OptCreateIntegrationJobReq, params CreateIntegrationJobParams) (*CreateIntegrationJobAccepted, error) {
	res, err := c.sendCreateIntegrationJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateIntegrationJob(ctx context.Context, request OptCreateIntegrationJobReq, params CreateIntegrationJobParams) (res *CreateIntegrationJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/hubs/current/integrations/"
	{
		// Encode "integrationId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "integrationId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IntegrationId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateIntegrationJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateIntegrationJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateIntegrationJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateIntegrationJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateInvoiceJob invokes createInvoiceJob operation.
//
// Creates a new job for an Invoice. Generally used to make a payment on an invoice.
// Requires the `billing-invoices-pay` capability.
//
// POST /v1/billing/invoices/{invoiceId}/tasks
func (c *Client) CreateInvoiceJob(ctx context.Context, request OptCreateInvoiceJobReq, params CreateInvoiceJobParams) (*CreateInvoiceJobAccepted, error) {
	res, err := c.sendCreateInvoiceJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateInvoiceJob(ctx context.Context, request OptCreateInvoiceJobReq, params CreateInvoiceJobParams) (res *CreateInvoiceJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/billing/invoices/"
	{
		// Encode "invoiceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invoiceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InvoiceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateInvoiceJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateInvoiceJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateInvoiceJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateInvoiceJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateLoadBalancerServiceJob invokes createLoadBalancerServiceJob operation.
//
// Creates a task that will update the load balancer's configuration.
//
// POST /v1/environments/{environmentId}/services/lb/tasks
func (c *Client) CreateLoadBalancerServiceJob(ctx context.Context, request OptCreateLoadBalancerServiceJobReq, params CreateLoadBalancerServiceJobParams) (*CreateLoadBalancerServiceJobAccepted, error) {
	res, err := c.sendCreateLoadBalancerServiceJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateLoadBalancerServiceJob(ctx context.Context, request OptCreateLoadBalancerServiceJobReq, params CreateLoadBalancerServiceJobParams) (res *CreateLoadBalancerServiceJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/lb/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateLoadBalancerServiceJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateLoadBalancerServiceJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateLoadBalancerServiceJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateLoadBalancerServiceJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateNetwork invokes createNetwork operation.
//
// Requires the `sdn-networks-manage` capability.
//
// POST /v1/sdn/networks
func (c *Client) CreateNetwork(ctx context.Context, request OptCreateNetworkReq, params CreateNetworkParams) (*CreateNetworkCreated, error) {
	res, err := c.sendCreateNetwork(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateNetwork(ctx context.Context, request OptCreateNetworkReq, params CreateNetworkParams) (res *CreateNetworkCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/sdn/networks"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateNetworkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateNetwork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateNetwork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateNetworkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateNetworkJob invokes createNetworkJob operation.
//
// Requires the `sdn-networks-manage` capability.
//
// POST /v1/sdn/networks/{networkId}/tasks
func (c *Client) CreateNetworkJob(ctx context.Context, request OptCreateNetworkJobReq, params CreateNetworkJobParams) (*CreateNetworkJobAccepted, error) {
	res, err := c.sendCreateNetworkJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateNetworkJob(ctx context.Context, request OptCreateNetworkJobReq, params CreateNetworkJobParams) (res *CreateNetworkJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/sdn/networks/"
	{
		// Encode "networkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "networkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NetworkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateNetworkJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateNetworkJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateNetworkJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateNetworkJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateOrder invokes createOrder operation.
//
// Requires the `billing-orders-manage` capability.
//
// POST /v1/billing/orders
func (c *Client) CreateOrder(ctx context.Context, request OptCreateOrderReq, params CreateOrderParams) (*CreateOrderCreated, error) {
	res, err := c.sendCreateOrder(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateOrder(ctx context.Context, request OptCreateOrderReq, params CreateOrderParams) (res *CreateOrderCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/billing/orders"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateOrderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateOrder", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateOrder", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateOrderJob invokes createOrderJob operation.
//
// Used to confirm a Billing Order.
// Requires the `billing-services-manage` capability.
//
// POST /v1/billing/orders/{orderId}/tasks
func (c *Client) CreateOrderJob(ctx context.Context, request OptCreateOrderJobReq, params CreateOrderJobParams) (*CreateOrderJobAccepted, error) {
	res, err := c.sendCreateOrderJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateOrderJob(ctx context.Context, request OptCreateOrderJobReq, params CreateOrderJobParams) (res *CreateOrderJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/billing/orders/"
	{
		// Encode "orderId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "orderId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrderId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateOrderJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateOrderJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateOrderJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateOrderJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreatePipeline invokes createPipeline operation.
//
// Requires the `pipelines-manage` capability.
//
// POST /v1/pipelines
func (c *Client) CreatePipeline(ctx context.Context, request OptCreatePipelineReq) (*CreatePipelineCreated, error) {
	res, err := c.sendCreatePipeline(ctx, request)
	return res, err
}

func (c *Client) sendCreatePipeline(ctx context.Context, request OptCreatePipelineReq) (res *CreatePipelineCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/pipelines"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreatePipelineRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreatePipeline", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreatePipeline", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreatePipelineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreatePipelineJob invokes createPipelineJob operation.
//
// Requires the `pipelines-manage` capability.
//
// POST /v1/pipelines/{pipelineId}/tasks
func (c *Client) CreatePipelineJob(ctx context.Context, request *CreatePipelineJobReq, params CreatePipelineJobParams) (*CreatePipelineJobAccepted, error) {
	res, err := c.sendCreatePipelineJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreatePipelineJob(ctx context.Context, request *CreatePipelineJobReq, params CreatePipelineJobParams) (res *CreatePipelineJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreatePipelineJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreatePipelineJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreatePipelineJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreatePipelineJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreatePipelineTriggerKey invokes createPipelineTriggerKey operation.
//
// Requires the `pipelines-manage` capability.
//
// POST /v1/pipelines/{pipelineId}/keys
func (c *Client) CreatePipelineTriggerKey(ctx context.Context, request OptCreatePipelineTriggerKeyReq, params CreatePipelineTriggerKeyParams) (*CreatePipelineTriggerKeyCreated, error) {
	res, err := c.sendCreatePipelineTriggerKey(ctx, request, params)
	return res, err
}

func (c *Client) sendCreatePipelineTriggerKey(ctx context.Context, request OptCreatePipelineTriggerKeyReq, params CreatePipelineTriggerKeyParams) (res *CreatePipelineTriggerKeyCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/keys"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreatePipelineTriggerKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreatePipelineTriggerKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreatePipelineTriggerKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreatePipelineTriggerKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateRole invokes createRole operation.
//
// Creates a custom Role for a Hub.
// Requires the `hubs-roles-manage` capability.
//
// POST /v1/hubs/current/roles
func (c *Client) CreateRole(ctx context.Context, request OptCreateRoleReq) (*CreateRoleCreated, error) {
	res, err := c.sendCreateRole(ctx, request)
	return res, err
}

func (c *Client) sendCreateRole(ctx context.Context, request OptCreateRoleReq) (res *CreateRoleCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/roles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateRoleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateRoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateSchedulerServiceJob invokes createSchedulerServiceJob operation.
//
// Creates a task that will update the scheduler service's configuration.
//
// POST /v1/environments/{environmentId}/services/scheduler/tasks
func (c *Client) CreateSchedulerServiceJob(ctx context.Context, request OptCreateSchedulerServiceJobReq, params CreateSchedulerServiceJobParams) (*CreateSchedulerServiceJobAccepted, error) {
	res, err := c.sendCreateSchedulerServiceJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateSchedulerServiceJob(ctx context.Context, request OptCreateSchedulerServiceJobReq, params CreateSchedulerServiceJobParams) (res *CreateSchedulerServiceJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/scheduler/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateSchedulerServiceJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateSchedulerServiceJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateSchedulerServiceJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateSchedulerServiceJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateScopedVariable invokes createScopedVariable operation.
//
// Requires the `scoped-variables-manage` capability.
//
// POST /v1/environments/{environmentId}/scoped-variables
func (c *Client) CreateScopedVariable(ctx context.Context, request OptCreateScopedVariableReq, params CreateScopedVariableParams) (*CreateScopedVariableCreated, error) {
	res, err := c.sendCreateScopedVariable(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateScopedVariable(ctx context.Context, request OptCreateScopedVariableReq, params CreateScopedVariableParams) (res *CreateScopedVariableCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/scoped-variables"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateScopedVariableRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateScopedVariable", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateScopedVariable", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateScopedVariableResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateServer invokes createServer operation.
//
// Requires the `servers-provision` capability.
//
// POST /v1/infrastructure/servers
func (c *Client) CreateServer(ctx context.Context, request OptCreateServerReq) (*CreateServerAccepted, error) {
	res, err := c.sendCreateServer(ctx, request)
	return res, err
}

func (c *Client) sendCreateServer(ctx context.Context, request OptCreateServerReq) (res *CreateServerAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/infrastructure/servers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateServerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateServer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateServer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateServerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateServerJob invokes createServerJob operation.
//
// Used to perform different actions on a given Server. Requires the `servers-manage` capability.
//
// POST /v1/infrastructure/servers/{serverId}/tasks
func (c *Client) CreateServerJob(ctx context.Context, request *CreateServerJobReq, params CreateServerJobParams) (*CreateServerJobAccepted, error) {
	res, err := c.sendCreateServerJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateServerJob(ctx context.Context, request *CreateServerJobReq, params CreateServerJobParams) (res *CreateServerJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/infrastructure/servers/"
	{
		// Encode "serverId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "serverId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateServerJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateServerJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateServerJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateServerJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateStack invokes createStack operation.
//
// Requires the `stacks-manage` capability.
//
// POST /v1/stacks
func (c *Client) CreateStack(ctx context.Context, request OptCreateStackReq) (*CreateStackCreated, error) {
	res, err := c.sendCreateStack(ctx, request)
	return res, err
}

func (c *Client) sendCreateStack(ctx context.Context, request OptCreateStackReq) (res *CreateStackCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/stacks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateStackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateStack", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateStack", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateStackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateStackBuild invokes createStackBuild operation.
//
// Requires the `stacks-manage` capability.
//
// POST /v1/stacks/{stackId}/builds
func (c *Client) CreateStackBuild(ctx context.Context, request OptCreateStackBuildReq, params CreateStackBuildParams) (*CreateStackBuildCreated, error) {
	res, err := c.sendCreateStackBuild(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateStackBuild(ctx context.Context, request OptCreateStackBuildReq, params CreateStackBuildParams) (res *CreateStackBuildCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/stacks/"
	{
		// Encode "stackId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stackId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StackId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/builds"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateStackBuildRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateStackBuild", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateStackBuild", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateStackBuildResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateStackBuildJob invokes createStackBuildJob operation.
//
// Requires the `stacks-manage` capability.
//
// POST /v1/stacks/{stackId}/builds/{buildId}/tasks
func (c *Client) CreateStackBuildJob(ctx context.Context, request *CreateStackBuildJobReq, params CreateStackBuildJobParams) (*CreateStackBuildJobAccepted, error) {
	res, err := c.sendCreateStackBuildJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateStackBuildJob(ctx context.Context, request *CreateStackBuildJobReq, params CreateStackBuildJobParams) (res *CreateStackBuildJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/stacks/"
	{
		// Encode "stackId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stackId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StackId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/builds/"
	{
		// Encode "buildId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "buildId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BuildId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateStackBuildJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateStackBuildJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateStackBuildJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateStackBuildJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateStackJob invokes createStackJob operation.
//
// Requires the `stacks-manage` capability.
//
// POST /v1/stacks/{stackId}/tasks
func (c *Client) CreateStackJob(ctx context.Context, request OptCreateStackJobReq, params CreateStackJobParams) (*CreateStackJobAccepted, error) {
	res, err := c.sendCreateStackJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateStackJob(ctx context.Context, request OptCreateStackJobReq, params CreateStackJobParams) (res *CreateStackJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/stacks/"
	{
		// Encode "stackId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stackId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StackId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateStackJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateStackJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateStackJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateStackJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVPNServiceJob invokes createVPNServiceJob operation.
//
// Used to reconfigure or reset the Environment VPN. Requires the `environments-vpn-manage`
// capability.
//
// POST /v1/environments/{environmentId}/services/vpn/tasks
func (c *Client) CreateVPNServiceJob(ctx context.Context, request *CreateVPNServiceJobReq, params CreateVPNServiceJobParams) (*CreateVPNServiceJobAccepted, error) {
	res, err := c.sendCreateVPNServiceJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateVPNServiceJob(ctx context.Context, request *CreateVPNServiceJobReq, params CreateVPNServiceJobParams) (res *CreateVPNServiceJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/vpn/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVPNServiceJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateVPNServiceJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateVPNServiceJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVPNServiceJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVPNUser invokes createVPNUser operation.
//
// Requires the `environments-vpn-manage` capability.
//
// POST /v1/environments/{environmentId}/services/vpn/users
func (c *Client) CreateVPNUser(ctx context.Context, request OptCreateVPNUserReq, params CreateVPNUserParams) (*CreateVPNUserCreated, error) {
	res, err := c.sendCreateVPNUser(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateVPNUser(ctx context.Context, request OptCreateVPNUserReq, params CreateVPNUserParams) (res *CreateVPNUserCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/vpn/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVPNUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateVPNUser", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateVPNUser", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVPNUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVirtualMachine invokes createVirtualMachine operation.
//
// Requires the `virtual-machines-deploy` capability.
//
// POST /v1/virtual-machines
func (c *Client) CreateVirtualMachine(ctx context.Context, request OptCreateVirtualMachineReq, params CreateVirtualMachineParams) (*CreateVirtualMachineCreated, error) {
	res, err := c.sendCreateVirtualMachine(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateVirtualMachine(ctx context.Context, request OptCreateVirtualMachineReq, params CreateVirtualMachineParams) (res *CreateVirtualMachineCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/virtual-machines"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVirtualMachineRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateVirtualMachine", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateVirtualMachine", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVirtualMachineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVirtualMachineJob invokes createVirtualMachineJob operation.
//
// Used to perform different actions on a virtual machine.
// Requires the following capabilities based on the task:
// `start`: `virtual-machines-manage`
// `stop`: `virtual-machines-manage`.
//
// POST /v1/virtual-machines/{virtualMachineId}/tasks
func (c *Client) CreateVirtualMachineJob(ctx context.Context, request *CreateVirtualMachineJobReq, params CreateVirtualMachineJobParams) (*CreateVirtualMachineJobAccepted, error) {
	res, err := c.sendCreateVirtualMachineJob(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateVirtualMachineJob(ctx context.Context, request *CreateVirtualMachineJobReq, params CreateVirtualMachineJobParams) (res *CreateVirtualMachineJobAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/virtual-machines/"
	{
		// Encode "virtualMachineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "virtualMachineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VirtualMachineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVirtualMachineJobRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "CreateVirtualMachineJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "CreateVirtualMachineJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVirtualMachineJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAPIKey invokes deleteAPIKey operation.
//
// Requires the 'api-keys-manage' capability.
//
// DELETE /v1/hubs/current/api-keys/{apikeyId}
func (c *Client) DeleteAPIKey(ctx context.Context, params DeleteAPIKeyParams) (*DeleteAPIKeyOK, error) {
	res, err := c.sendDeleteAPIKey(ctx, params)
	return res, err
}

func (c *Client) sendDeleteAPIKey(ctx context.Context, params DeleteAPIKeyParams) (res *DeleteAPIKeyOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/api-keys/"
	{
		// Encode "apikeyId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "apikeyId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApikeyId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteAPIKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteAPIKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteAPIKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAccount invokes deleteAccount operation.
//
// Puts the Account into a `deleted` state. This will fail if the Account is the current `OWNER` of
// an active Hub.
//
// DELETE /v1/account
func (c *Client) DeleteAccount(ctx context.Context) (*DeleteAccountAccepted, error) {
	res, err := c.sendDeleteAccount(ctx)
	return res, err
}

func (c *Client) sendDeleteAccount(ctx context.Context) (res *DeleteAccountAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/account"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteAutoScaleGroup invokes deleteAutoScaleGroup operation.
//
// Requires the `autoscale-group-manage` capability.
//
// DELETE /v1/infrastructure/auto-scale/groups/{groupId}
func (c *Client) DeleteAutoScaleGroup(ctx context.Context, params DeleteAutoScaleGroupParams) (*DeleteAutoScaleGroupAccepted, error) {
	res, err := c.sendDeleteAutoScaleGroup(ctx, params)
	return res, err
}

func (c *Client) sendDeleteAutoScaleGroup(ctx context.Context, params DeleteAutoScaleGroupParams) (res *DeleteAutoScaleGroupAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/infrastructure/auto-scale/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteAutoScaleGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteAutoScaleGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteAutoScaleGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteBillingMethod invokes deleteBillingMethod operation.
//
// Deletes the Billing Method. However, the primary payment method may not be deleted.
// Requires the `billing-methods-manage` capability.
//
// DELETE /v1/billing/methods/{methodId}
func (c *Client) DeleteBillingMethod(ctx context.Context, params DeleteBillingMethodParams) (*DeleteBillingMethodAccepted, error) {
	res, err := c.sendDeleteBillingMethod(ctx, params)
	return res, err
}

func (c *Client) sendDeleteBillingMethod(ctx context.Context, params DeleteBillingMethodParams) (res *DeleteBillingMethodAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/billing/methods/"
	{
		// Encode "methodId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "methodId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MethodId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteBillingMethod", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteBillingMethod", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteBillingMethodResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteCluster invokes deleteCluster operation.
//
// Requires the `clusters-manage` capability.
//
// DELETE /v1/infrastructure/clusters/{clusterId}
func (c *Client) DeleteCluster(ctx context.Context, params DeleteClusterParams) (*DeleteClusterAccepted, error) {
	res, err := c.sendDeleteCluster(ctx, params)
	return res, err
}

func (c *Client) sendDeleteCluster(ctx context.Context, params DeleteClusterParams) (res *DeleteClusterAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/infrastructure/clusters/"
	{
		// Encode "clusterId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClusterId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteCluster", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteCluster", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteContainer invokes deleteContainer operation.
//
// Requires the `containers-manage` capability.
//
// DELETE /v1/containers/{containerId}
func (c *Client) DeleteContainer(ctx context.Context, params DeleteContainerParams) (*DeleteContainerAccepted, error) {
	res, err := c.sendDeleteContainer(ctx, params)
	return res, err
}

func (c *Client) sendDeleteContainer(ctx context.Context, params DeleteContainerParams) (res *DeleteContainerAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteContainer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteContainer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteContainerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteContainerBackup invokes deleteContainerBackup operation.
//
// Requires the `containers-backups-manage` capability.
//
// DELETE /v1/containers/{containerId}/backups/{backupId}
func (c *Client) DeleteContainerBackup(ctx context.Context, params DeleteContainerBackupParams) (*DeleteContainerBackupAccepted, error) {
	res, err := c.sendDeleteContainerBackup(ctx, params)
	return res, err
}

func (c *Client) sendDeleteContainerBackup(ctx context.Context, params DeleteContainerBackupParams) (res *DeleteContainerBackupAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/backups/"
	{
		// Encode "backupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "backupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BackupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteContainerBackup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteContainerBackup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteContainerBackupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteContainerInstances invokes deleteContainerInstances operation.
//
// Manually delete Instances of a Container.
// Requires the `containers-update` capability.
//
// DELETE /v1/containers/{containerId}/instances
func (c *Client) DeleteContainerInstances(ctx context.Context, params DeleteContainerInstancesParams) (*DeleteContainerInstancesAccepted, error) {
	res, err := c.sendDeleteContainerInstances(ctx, params)
	return res, err
}

func (c *Client) sendDeleteContainerInstances(ctx context.Context, params DeleteContainerInstancesParams) (res *DeleteContainerInstancesAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteContainerInstances", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteContainerInstances", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteContainerInstancesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDNSZone invokes deleteDNSZone operation.
//
// Requires the `dns-manage` capability.
//
// DELETE /v1/dns/zones/{zoneId}
func (c *Client) DeleteDNSZone(ctx context.Context, params DeleteDNSZoneParams) (*DeleteDNSZoneAccepted, error) {
	res, err := c.sendDeleteDNSZone(ctx, params)
	return res, err
}

func (c *Client) sendDeleteDNSZone(ctx context.Context, params DeleteDNSZoneParams) (res *DeleteDNSZoneAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/dns/zones/"
	{
		// Encode "zoneId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "zoneId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ZoneId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteDNSZone", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteDNSZone", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteDNSZoneResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteDNSZoneRecord invokes deleteDNSZoneRecord operation.
//
// Requires the `dns-manage` capability.
//
// DELETE /v1/dns/zones/{zoneId}/records/{recordId}
func (c *Client) DeleteDNSZoneRecord(ctx context.Context, params DeleteDNSZoneRecordParams) (*DeleteDNSZoneRecordAccepted, error) {
	res, err := c.sendDeleteDNSZoneRecord(ctx, params)
	return res, err
}

func (c *Client) sendDeleteDNSZoneRecord(ctx context.Context, params DeleteDNSZoneRecordParams) (res *DeleteDNSZoneRecordAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/dns/zones/"
	{
		// Encode "zoneId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "zoneId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ZoneId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records/"
	{
		// Encode "recordId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteDNSZoneRecord", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteDNSZoneRecord", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteDNSZoneRecordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteEnvironment invokes deleteEnvironment operation.
//
// Requires the `environments-manage` capability.
//
// DELETE /v1/environments/{environmentId}
func (c *Client) DeleteEnvironment(ctx context.Context, params DeleteEnvironmentParams) (*DeleteEnvironmentAccepted, error) {
	res, err := c.sendDeleteEnvironment(ctx, params)
	return res, err
}

func (c *Client) sendDeleteEnvironment(ctx context.Context, params DeleteEnvironmentParams) (res *DeleteEnvironmentAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteEnvironment", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteEnvironment", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteEnvironmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteHub invokes deleteHub operation.
//
// Requires the `hubs-delete` capability. This can only be aquired by being the hub owner.
//
// DELETE /v1/hubs/current
func (c *Client) DeleteHub(ctx context.Context) (*DeleteHubAccepted, error) {
	res, err := c.sendDeleteHub(ctx)
	return res, err
}

func (c *Client) sendDeleteHub(ctx context.Context) (res *DeleteHubAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteHub", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteHubResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteHubInvite invokes deleteHubInvite operation.
//
// Requires the `hub-invites-manage` capability.
//
// DELETE /v1/hubs/current/invites/{inviteId}
func (c *Client) DeleteHubInvite(ctx context.Context, params DeleteHubInviteParams) (*DeleteHubInviteOK, error) {
	res, err := c.sendDeleteHubInvite(ctx, params)
	return res, err
}

func (c *Client) sendDeleteHubInvite(ctx context.Context, params DeleteHubInviteParams) (res *DeleteHubInviteOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/invites/"
	{
		// Encode "inviteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "inviteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InviteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteHubInvite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteHubInviteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteHubMember invokes deleteHubMember operation.
//
// Requires the `hubs-members-manage` capability.
//
// DELETE /v1/hubs/current/members/{memberId}
func (c *Client) DeleteHubMember(ctx context.Context, params DeleteHubMemberParams) (*DeleteHubMemberAccepted, error) {
	res, err := c.sendDeleteHubMember(ctx, params)
	return res, err
}

func (c *Client) sendDeleteHubMember(ctx context.Context, params DeleteHubMemberParams) (res *DeleteHubMemberAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/members/"
	{
		// Encode "memberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "memberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MemberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteHubMember", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteHubMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteIPPool invokes deleteIPPool operation.
//
// Requires the `infrastructure-ips-manage` capability.
//
// DELETE /v1/infrastructure/ips/pools/{poolId}
func (c *Client) DeleteIPPool(ctx context.Context, params DeleteIPPoolParams) (*DeleteIPPoolAccepted, error) {
	res, err := c.sendDeleteIPPool(ctx, params)
	return res, err
}

func (c *Client) sendDeleteIPPool(ctx context.Context, params DeleteIPPoolParams) (res *DeleteIPPoolAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/infrastructure/ips/pools/"
	{
		// Encode "poolId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "poolId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PoolId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteIPPool", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteIPPool", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteIPPoolResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteImage invokes deleteImage operation.
//
// Requires the `images-manage` capability.
//
// DELETE /v1/images/{imageId}
func (c *Client) DeleteImage(ctx context.Context, params DeleteImageParams) (*DeleteImageOK, error) {
	res, err := c.sendDeleteImage(ctx, params)
	return res, err
}

func (c *Client) sendDeleteImage(ctx context.Context, params DeleteImageParams) (res *DeleteImageOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/images/"
	{
		// Encode "imageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "imageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ImageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteImage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteImage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteImageSource invokes deleteImageSource operation.
//
// Requires the `images-sources-manage` capability.
//
// DELETE /v1/images/sources/{sourceId}
func (c *Client) DeleteImageSource(ctx context.Context, params DeleteImageSourceParams) (*DeleteImageSourceAccepted, error) {
	res, err := c.sendDeleteImageSource(ctx, params)
	return res, err
}

func (c *Client) sendDeleteImageSource(ctx context.Context, params DeleteImageSourceParams) (res *DeleteImageSourceAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/images/sources/"
	{
		// Encode "sourceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sourceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SourceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteImageSource", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteImageSource", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteImageSourceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteInstance invokes deleteInstance operation.
//
// Requires the `containers-update` capability.
//
// DELETE /v1/containers/{containerId}/instances/{instanceId}
func (c *Client) DeleteInstance(ctx context.Context, params DeleteInstanceParams) (*DeleteInstanceAccepted, error) {
	res, err := c.sendDeleteInstance(ctx, params)
	return res, err
}

func (c *Client) sendDeleteInstance(ctx context.Context, params DeleteInstanceParams) (res *DeleteInstanceAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances/"
	{
		// Encode "instanceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instanceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InstanceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteInstance", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteInstance", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteInstanceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteIntegration invokes deleteIntegration operation.
//
// Deletes the specified Integration from the current hub, marking it as deleted and returning the
// updated Integration.
//
// DELETE /v1/hubs/current/integrations/{integrationId}
func (c *Client) DeleteIntegration(ctx context.Context, params DeleteIntegrationParams) (*DeleteIntegrationAccepted, error) {
	res, err := c.sendDeleteIntegration(ctx, params)
	return res, err
}

func (c *Client) sendDeleteIntegration(ctx context.Context, params DeleteIntegrationParams) (res *DeleteIntegrationAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/integrations/"
	{
		// Encode "integrationId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "integrationId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IntegrationId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteIntegration", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteIntegrationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteNetwork invokes deleteNetwork operation.
//
// Requires the `sdn-networks-manage` capability.
//
// DELETE /v1/sdn/networks/{networkId}
func (c *Client) DeleteNetwork(ctx context.Context, params DeleteNetworkParams) (*DeleteNetworkAccepted, error) {
	res, err := c.sendDeleteNetwork(ctx, params)
	return res, err
}

func (c *Client) sendDeleteNetwork(ctx context.Context, params DeleteNetworkParams) (res *DeleteNetworkAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/sdn/networks/"
	{
		// Encode "networkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "networkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NetworkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteNetwork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteNetwork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteNetworkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePipeline invokes deletePipeline operation.
//
// Requires the `pipelines-manage` capability.
//
// DELETE /v1/pipelines/{pipelineId}
func (c *Client) DeletePipeline(ctx context.Context, params DeletePipelineParams) (*DeletePipelineOK, error) {
	res, err := c.sendDeletePipeline(ctx, params)
	return res, err
}

func (c *Client) sendDeletePipeline(ctx context.Context, params DeletePipelineParams) (res *DeletePipelineOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeletePipeline", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeletePipeline", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeletePipelineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeletePipelineTriggerKey invokes deletePipelineTriggerKey operation.
//
// Requires the `pipelines-manage` capability.
//
// DELETE /v1/pipelines/{pipelineId}/keys/{triggerKeyId}
func (c *Client) DeletePipelineTriggerKey(ctx context.Context, params DeletePipelineTriggerKeyParams) (*DeletePipelineTriggerKeyAccepted, error) {
	res, err := c.sendDeletePipelineTriggerKey(ctx, params)
	return res, err
}

func (c *Client) sendDeletePipelineTriggerKey(ctx context.Context, params DeletePipelineTriggerKeyParams) (res *DeletePipelineTriggerKeyAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/keys/"
	{
		// Encode "triggerKeyId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "triggerKeyId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TriggerKeyId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeletePipelineTriggerKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeletePipelineTriggerKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeletePipelineTriggerKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteRole invokes deleteRole operation.
//
// Marks a Role as 'deleted'.
// Requires the 'hubs-roles-manage' capability.
//
// DELETE /v1/hubs/current/roles/{roleId}
func (c *Client) DeleteRole(ctx context.Context, params DeleteRoleParams) (*DeleteRoleAccepted, error) {
	res, err := c.sendDeleteRole(ctx, params)
	return res, err
}

func (c *Client) sendDeleteRole(ctx context.Context, params DeleteRoleParams) (res *DeleteRoleAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/roles/"
	{
		// Encode "roleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteRoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteScopedVariable invokes deleteScopedVariable operation.
//
// Requires the `scoped-variables-manage` capability.
//
// DELETE /v1/environments/{environmentId}/scoped-variables/{scopedVariableId}
func (c *Client) DeleteScopedVariable(ctx context.Context, params DeleteScopedVariableParams) (*DeleteScopedVariableAccepted, error) {
	res, err := c.sendDeleteScopedVariable(ctx, params)
	return res, err
}

func (c *Client) sendDeleteScopedVariable(ctx context.Context, params DeleteScopedVariableParams) (res *DeleteScopedVariableAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/scoped-variables/"
	{
		// Encode "scopedVariableId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scopedVariableId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScopedVariableId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteScopedVariable", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteScopedVariable", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteScopedVariableResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteServer invokes deleteServer operation.
//
// Requires the `servers-manage` capability.
//
// DELETE /v1/infrastructure/servers/{serverId}
func (c *Client) DeleteServer(ctx context.Context, params DeleteServerParams) (*DeleteServerOK, error) {
	res, err := c.sendDeleteServer(ctx, params)
	return res, err
}

func (c *Client) sendDeleteServer(ctx context.Context, params DeleteServerParams) (res *DeleteServerOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/infrastructure/servers/"
	{
		// Encode "serverId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "serverId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteServer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteServer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteServerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteStack invokes deleteStack operation.
//
// Requires the `stacks-manage` capability.
//
// DELETE /v1/stacks/{stackId}
func (c *Client) DeleteStack(ctx context.Context, params DeleteStackParams) (*DeleteStackAccepted, error) {
	res, err := c.sendDeleteStack(ctx, params)
	return res, err
}

func (c *Client) sendDeleteStack(ctx context.Context, params DeleteStackParams) (res *DeleteStackAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/stacks/"
	{
		// Encode "stackId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stackId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StackId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteStack", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteStack", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteStackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteStackBuild invokes deleteStackBuild operation.
//
// Requires the `stacks-manage` capability.
//
// DELETE /v1/stacks/{stackId}/builds/{buildId}
func (c *Client) DeleteStackBuild(ctx context.Context, params DeleteStackBuildParams) (*DeleteStackBuildOK, error) {
	res, err := c.sendDeleteStackBuild(ctx, params)
	return res, err
}

func (c *Client) sendDeleteStackBuild(ctx context.Context, params DeleteStackBuildParams) (res *DeleteStackBuildOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/stacks/"
	{
		// Encode "stackId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stackId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StackId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/builds/"
	{
		// Encode "buildId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "buildId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BuildId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteStackBuild", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteStackBuild", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteStackBuildResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteVPNUser invokes deleteVPNUser operation.
//
// Requires the `environments-vpn-manage` capability.
//
// DELETE /v1/environments/{environmentId}/services/vpn/users/{userId}
func (c *Client) DeleteVPNUser(ctx context.Context, params DeleteVPNUserParams) (*DeleteVPNUserOK, error) {
	res, err := c.sendDeleteVPNUser(ctx, params)
	return res, err
}

func (c *Client) sendDeleteVPNUser(ctx context.Context, params DeleteVPNUserParams) (res *DeleteVPNUserOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/vpn/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteVPNUser", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteVPNUser", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteVPNUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteVirtualMachine invokes deleteVirtualMachine operation.
//
// Requires the `virtual-machines-manage` capability.
//
// DELETE /v1/virtual-machines/{virtualMachineId}
func (c *Client) DeleteVirtualMachine(ctx context.Context, params DeleteVirtualMachineParams) (*DeleteVirtualMachineAccepted, error) {
	res, err := c.sendDeleteVirtualMachine(ctx, params)
	return res, err
}

func (c *Client) sendDeleteVirtualMachine(ctx context.Context, params DeleteVirtualMachineParams) (res *DeleteVirtualMachineAccepted, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/virtual-machines/"
	{
		// Encode "virtualMachineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "virtualMachineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VirtualMachineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DeleteVirtualMachine", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DeleteVirtualMachine", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteVirtualMachineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DisableTwoFactorAuth invokes disableTwoFactorAuth operation.
//
// Disables two-factor auth for the account.
//
// POST /v1/account/2fa/disable
func (c *Client) DisableTwoFactorAuth(ctx context.Context, request OptDisableTwoFactorAuthReq) (*DisableTwoFactorAuthOK, error) {
	res, err := c.sendDisableTwoFactorAuth(ctx, request)
	return res, err
}

func (c *Client) sendDisableTwoFactorAuth(ctx context.Context, request OptDisableTwoFactorAuthReq) (res *DisableTwoFactorAuthOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/account/2fa/disable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeDisableTwoFactorAuthRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "DisableTwoFactorAuth", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "DisableTwoFactorAuth", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDisableTwoFactorAuthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EnableTwoFactorAuth invokes enableTwoFactorAuth operation.
//
// Enables two-factor auth for the Account. Retrieve the token from an authenticator app using the
// secret from `getTwoFactorAuthSetup`.
//
// POST /v1/account/2fa/setup
func (c *Client) EnableTwoFactorAuth(ctx context.Context, request OptEnableTwoFactorAuthReq) (*EnableTwoFactorAuthOK, error) {
	res, err := c.sendEnableTwoFactorAuth(ctx, request)
	return res, err
}

func (c *Client) sendEnableTwoFactorAuth(ctx context.Context, request OptEnableTwoFactorAuthReq) (res *EnableTwoFactorAuthOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/account/2fa/setup"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEnableTwoFactorAuthRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "EnableTwoFactorAuth", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "EnableTwoFactorAuth", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEnableTwoFactorAuthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExpireInstanceSSHCredentials invokes expireInstanceSSHCredentials operation.
//
// Instantly expires any SSH credentials generated for this Instance.
// Requires the `containers-ssh` capability.
//
// DELETE /v1/containers/{containerId}/instances/{instanceId}/ssh
func (c *Client) ExpireInstanceSSHCredentials(ctx context.Context, params ExpireInstanceSSHCredentialsParams) (*ExpireInstanceSSHCredentialsOK, error) {
	res, err := c.sendExpireInstanceSSHCredentials(ctx, params)
	return res, err
}

func (c *Client) sendExpireInstanceSSHCredentials(ctx context.Context, params ExpireInstanceSSHCredentialsParams) (res *ExpireInstanceSSHCredentialsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances/"
	{
		// Encode "instanceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instanceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InstanceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/ssh"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ExpireInstanceSSHCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "ExpireInstanceSSHCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeExpireInstanceSSHCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExportStack invokes exportStack operation.
//
// Exports an environment as a stack file for reuse.
// Requires the `environments-manage` capability. You must also have management permissions on the
// target environment ACL.
//
// POST /v1/environments/{environmentId}/export/stack
func (c *Client) ExportStack(ctx context.Context, request OptExportStackReq, params ExportStackParams) (*ExportStackOK, error) {
	res, err := c.sendExportStack(ctx, request, params)
	return res, err
}

func (c *Client) sendExportStack(ctx context.Context, request OptExportStackReq, params ExportStackParams) (res *ExportStackOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/export/stack"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExportStackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ExportStack", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "ExportStack", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeExportStackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenerateAggregatedEvents invokes generateAggregatedEvents operation.
//
// Generate an events report using an aggregated pipeline query with Mongo. This endpoint provides
// ultimate
// flexibility in generating data for dashboards, charts, graphs, etc.
// You should always provide a time range filter to this call, either through the filter parameter or
// in the critera body. The aggregate is limited to 25,000 input documents, so a time frame will give
// the best results.
// Requires the `monitor-view` capability.
//
// POST /v1/monitoring/events/aggregate
func (c *Client) GenerateAggregatedEvents(ctx context.Context, request OptGenerateAggregatedEventsReq, params GenerateAggregatedEventsParams) (*GenerateAggregatedEventsOK, error) {
	res, err := c.sendGenerateAggregatedEvents(ctx, request, params)
	return res, err
}

func (c *Client) sendGenerateAggregatedEvents(ctx context.Context, request OptGenerateAggregatedEventsReq, params GenerateAggregatedEventsParams) (res *GenerateAggregatedEventsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/monitoring/events/aggregate"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGenerateAggregatedEventsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GenerateAggregatedEvents", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GenerateAggregatedEvents", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGenerateAggregatedEventsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenerateAggregatedMetrics invokes generateAggregatedMetrics operation.
//
// Generate a metric report using an aggregated pipeline query with Mongo. This endpoint provides
// ultimate
// flexibility in generating data for dashboards, charts, graphs, etc.
// You should always provide a time range filter to this call, either through the filter parameter or
// in the critera body. The aggregate is limited to 25,000 input documents, so a time frame will give
// the best results.
// Requires the `monitor-view` capability.
//
// POST /v1/monitoring/metrics/aggregate
func (c *Client) GenerateAggregatedMetrics(ctx context.Context, request OptGenerateAggregatedMetricsReq, params GenerateAggregatedMetricsParams) (*GenerateAggregatedMetricsOK, error) {
	res, err := c.sendGenerateAggregatedMetrics(ctx, request, params)
	return res, err
}

func (c *Client) sendGenerateAggregatedMetrics(ctx context.Context, request OptGenerateAggregatedMetricsReq, params GenerateAggregatedMetricsParams) (res *GenerateAggregatedMetricsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/monitoring/metrics/aggregate"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGenerateAggregatedMetricsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GenerateAggregatedMetrics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GenerateAggregatedMetrics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGenerateAggregatedMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GenerateInstanceSSHCredentials invokes generateInstanceSSHCredentials operation.
//
// Generates credentials for connecting to an Instance via SSH. The generated endpoint/secret can be
// used to log in via SSH
// into the Instance without exposing ports on the container or host.
// Requires the `containers-ssh` capability.
//
// GET /v1/containers/{containerId}/instances/{instanceId}/ssh
func (c *Client) GenerateInstanceSSHCredentials(ctx context.Context, params GenerateInstanceSSHCredentialsParams) (*GenerateInstanceSSHCredentialsOK, error) {
	res, err := c.sendGenerateInstanceSSHCredentials(ctx, params)
	return res, err
}

func (c *Client) sendGenerateInstanceSSHCredentials(ctx context.Context, params GenerateInstanceSSHCredentialsParams) (res *GenerateInstanceSSHCredentialsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances/"
	{
		// Encode "instanceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instanceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InstanceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/ssh"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GenerateInstanceSSHCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GenerateInstanceSSHCredentials", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGenerateInstanceSSHCredentialsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAPIKey invokes getAPIKey operation.
//
// Requries the `api-keys-manage` capability.
//
// GET /v1/hubs/current/api-keys/{apikeyId}
func (c *Client) GetAPIKey(ctx context.Context, params GetAPIKeyParams) (*GetAPIKeyOK, error) {
	res, err := c.sendGetAPIKey(ctx, params)
	return res, err
}

func (c *Client) sendGetAPIKey(ctx context.Context, params GetAPIKeyParams) (res *GetAPIKeyOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/api-keys/"
	{
		// Encode "apikeyId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "apikeyId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApikeyId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetAPIKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetAPIKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAPIKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccount invokes getAccount operation.
//
// Gets the Account associated with the authenticated bearer token.
//
// GET /v1/account
func (c *Client) GetAccount(ctx context.Context) (*GetAccountOK, error) {
	res, err := c.sendGetAccount(ctx)
	return res, err
}

func (c *Client) sendGetAccount(ctx context.Context) (res *GetAccountOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/account"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccountInvites invokes getAccountInvites operation.
//
// Lists the pending Hub Memberships (also known as Invites) associated with the Account.
//
// GET /v1/account/invites
func (c *Client) GetAccountInvites(ctx context.Context, params GetAccountInvitesParams) (*GetAccountInvitesOK, error) {
	res, err := c.sendGetAccountInvites(ctx, params)
	return res, err
}

func (c *Client) sendGetAccountInvites(ctx context.Context, params GetAccountInvitesParams) (res *GetAccountInvitesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/account/invites"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetAccountInvites", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAccountInvitesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccountLogins invokes getAccountLogins operation.
//
// Lists logins associated with a given account.
//
// GET /v1/account/logins
func (c *Client) GetAccountLogins(ctx context.Context, params GetAccountLoginsParams) (*GetAccountLoginsOK, error) {
	res, err := c.sendGetAccountLogins(ctx, params)
	return res, err
}

func (c *Client) sendGetAccountLogins(ctx context.Context, params GetAccountLoginsParams) (res *GetAccountLoginsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/account/logins"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetAccountLogins", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAccountLoginsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAccountMemberships invokes getAccountMemberships operation.
//
// Lists the Hub Memberships for a given account.
//
// GET /v1/account/memberships
func (c *Client) GetAccountMemberships(ctx context.Context, params GetAccountMembershipsParams) (*GetAccountMembershipsOK, error) {
	res, err := c.sendGetAccountMemberships(ctx, params)
	return res, err
}

func (c *Client) sendGetAccountMemberships(ctx context.Context, params GetAccountMembershipsParams) (res *GetAccountMembershipsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/account/memberships"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetAccountMemberships", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAccountMembershipsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAnnouncements invokes getAnnouncements operation.
//
// Lists any important updates posted by the Cycle team.
//
// GET /v1/announcements
func (c *Client) GetAnnouncements(ctx context.Context, params GetAnnouncementsParams) (*GetAnnouncementsOK, error) {
	res, err := c.sendGetAnnouncements(ctx, params)
	return res, err
}

func (c *Client) sendGetAnnouncements(ctx context.Context, params GetAnnouncementsParams) (res *GetAnnouncementsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/announcements"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetAnnouncements", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAnnouncementsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetApiKeys invokes getApiKeys operation.
//
// Requires the `api-keys-manage` capability.
//
// GET /v1/hubs/current/api-keys
func (c *Client) GetApiKeys(ctx context.Context, params GetApiKeysParams) (*GetApiKeysOK, error) {
	res, err := c.sendGetApiKeys(ctx, params)
	return res, err
}

func (c *Client) sendGetApiKeys(ctx context.Context, params GetApiKeysParams) (res *GetApiKeysOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/api-keys"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetApiKeys", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetApiKeys", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetApiKeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAutoScaleGroup invokes getAutoScaleGroup operation.
//
// Requires the `autoscale-groups-view` capability.
//
// GET /v1/infrastructure/auto-scale/groups/{groupId}
func (c *Client) GetAutoScaleGroup(ctx context.Context, params GetAutoScaleGroupParams) (*GetAutoScaleGroupOK, error) {
	res, err := c.sendGetAutoScaleGroup(ctx, params)
	return res, err
}

func (c *Client) sendGetAutoScaleGroup(ctx context.Context, params GetAutoScaleGroupParams) (res *GetAutoScaleGroupOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/infrastructure/auto-scale/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetAutoScaleGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetAutoScaleGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAutoScaleGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAutoScaleGroups invokes getAutoScaleGroups operation.
//
// Requires the `autoscale-groups-manage` capability.
//
// GET /v1/infrastructure/auto-scale/groups
func (c *Client) GetAutoScaleGroups(ctx context.Context, params GetAutoScaleGroupsParams) (*GetAutoScaleGroupsOK, error) {
	res, err := c.sendGetAutoScaleGroups(ctx, params)
	return res, err
}

func (c *Client) sendGetAutoScaleGroups(ctx context.Context, params GetAutoScaleGroupsParams) (res *GetAutoScaleGroupsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/infrastructure/auto-scale/groups"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetAutoScaleGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetAutoScaleGroups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAutoScaleGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetAvailableIntegrations invokes getAvailableIntegrations operation.
//
// Returns a map of available integrations categorized by their type.
//
// GET /v1/hubs/current/integrations/available
func (c *Client) GetAvailableIntegrations(ctx context.Context) (*GetAvailableIntegrationsOK, error) {
	res, err := c.sendGetAvailableIntegrations(ctx)
	return res, err
}

func (c *Client) sendGetAvailableIntegrations(ctx context.Context) (res *GetAvailableIntegrationsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/integrations/available"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetAvailableIntegrations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetAvailableIntegrations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetAvailableIntegrationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBillingMethod invokes getBillingMethod operation.
//
// Requires the `billing-methods-manage` capability.
//
// GET /v1/billing/methods/{methodId}
func (c *Client) GetBillingMethod(ctx context.Context, params GetBillingMethodParams) (*GetBillingMethodOK, error) {
	res, err := c.sendGetBillingMethod(ctx, params)
	return res, err
}

func (c *Client) sendGetBillingMethod(ctx context.Context, params GetBillingMethodParams) (res *GetBillingMethodOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/billing/methods/"
	{
		// Encode "methodId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "methodId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MethodId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetBillingMethod", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetBillingMethod", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBillingMethodResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBillingMethods invokes getBillingMethods operation.
//
// Lists the Billing Methods associated with the Hub defined in X-Hub-ID.
// Requires the `billing-methods-manage` capability.
//
// GET /v1/billing/methods
func (c *Client) GetBillingMethods(ctx context.Context, params GetBillingMethodsParams) (*GetBillingMethodsOK, error) {
	res, err := c.sendGetBillingMethods(ctx, params)
	return res, err
}

func (c *Client) sendGetBillingMethods(ctx context.Context, params GetBillingMethodsParams) (res *GetBillingMethodsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/billing/methods"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetBillingMethods", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetBillingMethods", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBillingMethodsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBillingOrder invokes getBillingOrder operation.
//
// Requires the `billing-services-manage` capability.
//
// GET /v1/billing/orders/{orderId}
func (c *Client) GetBillingOrder(ctx context.Context, params GetBillingOrderParams) (*GetBillingOrderOK, error) {
	res, err := c.sendGetBillingOrder(ctx, params)
	return res, err
}

func (c *Client) sendGetBillingOrder(ctx context.Context, params GetBillingOrderParams) (res *GetBillingOrderOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/billing/orders/"
	{
		// Encode "orderId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "orderId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrderId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetBillingOrder", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetBillingOrder", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBillingOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBillingOverages invokes getBillingOverages operation.
//
// List Billing Overages.
//
// GET /v1/billing/services/overages
func (c *Client) GetBillingOverages(ctx context.Context, params GetBillingOveragesParams) (*GetBillingOveragesOK, error) {
	res, err := c.sendGetBillingOverages(ctx, params)
	return res, err
}

func (c *Client) sendGetBillingOverages(ctx context.Context, params GetBillingOveragesParams) (res *GetBillingOveragesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/billing/services/overages"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetBillingOverages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetBillingOverages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBillingOveragesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBillingService invokes getBillingService operation.
//
// Requries the `billing-services-view` capability.
//
// GET /v1/billing/services/{servicesId}
func (c *Client) GetBillingService(ctx context.Context, params GetBillingServiceParams) (*GetBillingServiceOK, error) {
	res, err := c.sendGetBillingService(ctx, params)
	return res, err
}

func (c *Client) sendGetBillingService(ctx context.Context, params GetBillingServiceParams) (res *GetBillingServiceOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/billing/services/"
	{
		// Encode "servicesId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "servicesId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServicesId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetBillingService", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetBillingService", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBillingServiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBillingServices invokes getBillingServices operation.
//
// Requries the `billing-services-view` capability.
//
// GET /v1/billing/services
func (c *Client) GetBillingServices(ctx context.Context, params GetBillingServicesParams) (*GetBillingServicesOK, error) {
	res, err := c.sendGetBillingServices(ctx, params)
	return res, err
}

func (c *Client) sendGetBillingServices(ctx context.Context, params GetBillingServicesParams) (res *GetBillingServicesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/billing/services"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetBillingServices", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetBillingServices", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBillingServicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBillingSupportPlans invokes getBillingSupportPlans operation.
//
// List Support Plans.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /v1/billing/plans/support
func (c *Client) GetBillingSupportPlans(ctx context.Context, params GetBillingSupportPlansParams) (*GetBillingSupportPlansOK, error) {
	res, err := c.sendGetBillingSupportPlans(ctx, params)
	return res, err
}

func (c *Client) sendGetBillingSupportPlans(ctx context.Context, params GetBillingSupportPlansParams) (res *GetBillingSupportPlansOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/billing/plans/support"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetBillingSupportPlans", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetBillingSupportPlans", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBillingSupportPlansResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBillingTiers invokes getBillingTiers operation.
//
// Returns list of availiable Billing Tiers.
//
// GET /v1/billing/plans/tiers
func (c *Client) GetBillingTiers(ctx context.Context) (*GetBillingTiersOK, error) {
	res, err := c.sendGetBillingTiers(ctx)
	return res, err
}

func (c *Client) sendGetBillingTiers(ctx context.Context) (res *GetBillingTiersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/billing/plans/tiers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetBillingTiers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetBillingTiers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBillingTiersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCluster invokes getCluster operation.
//
// Gets a Cluster.
// Requires the `clusters-view` capability.
//
// GET /v1/infrastructure/clusters/{clusterId}
func (c *Client) GetCluster(ctx context.Context, params GetClusterParams) (*GetClusterOK, error) {
	res, err := c.sendGetCluster(ctx, params)
	return res, err
}

func (c *Client) sendGetCluster(ctx context.Context, params GetClusterParams) (res *GetClusterOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/infrastructure/clusters/"
	{
		// Encode "clusterId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClusterId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetCluster", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetCluster", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClusters invokes getClusters operation.
//
// Requires the `clusters-view` capability.
//
// GET /v1/infrastructure/clusters
func (c *Client) GetClusters(ctx context.Context, params GetClustersParams) (*GetClustersOK, error) {
	res, err := c.sendGetClusters(ctx, params)
	return res, err
}

func (c *Client) sendGetClusters(ctx context.Context, params GetClustersParams) (res *GetClustersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/infrastructure/clusters"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetClusters", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetClusters", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClustersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCompatibleImages invokes getCompatibleImages operation.
//
// Returns a list of Images that are compatible with the specified Container.
// Used to quickly find Images that can be used for reimaging the Container.
// Requires the `containers-view` capability.
//
// GET /v1/containers/{containerId}/compatible-images
func (c *Client) GetCompatibleImages(ctx context.Context, params GetCompatibleImagesParams) (*GetCompatibleImagesOK, error) {
	res, err := c.sendGetCompatibleImages(ctx, params)
	return res, err
}

func (c *Client) sendGetCompatibleImages(ctx context.Context, params GetCompatibleImagesParams) (res *GetCompatibleImagesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/compatible-images"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetCompatibleImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetCompatibleImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCompatibleImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCompatibleServers invokes getCompatibleServers operation.
//
// Gets a list of servers that are compatible with the specified Container and its restrictions (tags,
//
//	etc).
//
// Requires the `containers-view` capability.
//
// GET /v1/containers/{containerId}/servers/usable
func (c *Client) GetCompatibleServers(ctx context.Context, params GetCompatibleServersParams) (*GetCompatibleServersOK, error) {
	res, err := c.sendGetCompatibleServers(ctx, params)
	return res, err
}

func (c *Client) sendGetCompatibleServers(ctx context.Context, params GetCompatibleServersParams) (res *GetCompatibleServersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/servers/usable"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetCompatibleServers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetCompatibleServers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCompatibleServersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetContainer invokes getContainer operation.
//
// Gets a Container.
// Requires the `containers-view` capability.
//
// GET /v1/containers/{containerId}
func (c *Client) GetContainer(ctx context.Context, params GetContainerParams) (*GetContainerOK, error) {
	res, err := c.sendGetContainer(ctx, params)
	return res, err
}

func (c *Client) sendGetContainer(ctx context.Context, params GetContainerParams) (res *GetContainerOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetContainer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetContainer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetContainerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetContainerBackup invokes getContainerBackup operation.
//
// Gets the specified Container Backup.
// Requires the `containers-backups-view` capability.
//
// GET /v1/containers/{containerId}/backups/{backupId}
func (c *Client) GetContainerBackup(ctx context.Context, params GetContainerBackupParams) (*GetContainerBackupOK, error) {
	res, err := c.sendGetContainerBackup(ctx, params)
	return res, err
}

func (c *Client) sendGetContainerBackup(ctx context.Context, params GetContainerBackupParams) (res *GetContainerBackupOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/backups/"
	{
		// Encode "backupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "backupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BackupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetContainerBackup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetContainerBackup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetContainerBackupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetContainerBackupLogs invokes getContainerBackupLogs operation.
//
// Requires the `containers-backups-view` capability.
//
// GET /v1/containers/{containerId}/backups/{backupId}/logs
func (c *Client) GetContainerBackupLogs(ctx context.Context, params GetContainerBackupLogsParams) (*GetContainerBackupLogsOK, error) {
	res, err := c.sendGetContainerBackupLogs(ctx, params)
	return res, err
}

func (c *Client) sendGetContainerBackupLogs(ctx context.Context, params GetContainerBackupLogsParams) (res *GetContainerBackupLogsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/backups/"
	{
		// Encode "backupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "backupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BackupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/logs"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetContainerBackupLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetContainerBackupLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetContainerBackupLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetContainerBackups invokes getContainerBackups operation.
//
// Requires the `containers-backups-view` capability.
//
// GET /v1/containers/{containerId}/backups
func (c *Client) GetContainerBackups(ctx context.Context, params GetContainerBackupsParams) (*GetContainerBackupsOK, error) {
	res, err := c.sendGetContainerBackups(ctx, params)
	return res, err
}

func (c *Client) sendGetContainerBackups(ctx context.Context, params GetContainerBackupsParams) (res *GetContainerBackupsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/backups"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetContainerBackups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetContainerBackups", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetContainerBackupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetContainerServers invokes getContainerServers operation.
//
// Lists all Servers that currently have an Instance of this Container deployed to them.
// Requires the `containers-view` capability.
//
// GET /v1/containers/{containerId}/servers
func (c *Client) GetContainerServers(ctx context.Context, params GetContainerServersParams) (*GetContainerServersOK, error) {
	res, err := c.sendGetContainerServers(ctx, params)
	return res, err
}

func (c *Client) sendGetContainerServers(ctx context.Context, params GetContainerServersParams) (res *GetContainerServersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/servers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetContainerServers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetContainerServers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetContainerServersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetContainerSummary invokes getContainerSummary operation.
//
// Requires the `containers-view` capability.
//
// GET /v1/containers/{containerId}/summary
func (c *Client) GetContainerSummary(ctx context.Context, params GetContainerSummaryParams) (*GetContainerSummaryOK, error) {
	res, err := c.sendGetContainerSummary(ctx, params)
	return res, err
}

func (c *Client) sendGetContainerSummary(ctx context.Context, params GetContainerSummaryParams) (res *GetContainerSummaryOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/summary"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetContainerSummary", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetContainerSummary", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetContainerSummaryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetContainers invokes getContainers operation.
//
// Requires the `containers-view` capability.
//
// GET /v1/containers
func (c *Client) GetContainers(ctx context.Context, params GetContainersParams) (*GetContainersOK, error) {
	res, err := c.sendGetContainers(ctx, params)
	return res, err
}

func (c *Client) sendGetContainers(ctx context.Context, params GetContainersParams) (res *GetContainersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/containers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetContainers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetContainers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetContainersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCredit invokes getCredit operation.
//
// Requires the `billing-credits-view` capability.
//
// GET /v1/billing/credits/{creditsId}
func (c *Client) GetCredit(ctx context.Context, params GetCreditParams) (*GetCreditOK, error) {
	res, err := c.sendGetCredit(ctx, params)
	return res, err
}

func (c *Client) sendGetCredit(ctx context.Context, params GetCreditParams) (res *GetCreditOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/billing/credits/"
	{
		// Encode "creditsId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "creditsId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.CreditsId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetCredit", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetCredit", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCreditResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetCredits invokes getCredits operation.
//
// Lists the Billing Credits associated with the current Hub.
// Requires the `billing-credits-view` capability.
//
// GET /v1/billing/credits
func (c *Client) GetCredits(ctx context.Context, params GetCreditsParams) (*GetCreditsOK, error) {
	res, err := c.sendGetCredits(ctx, params)
	return res, err
}

func (c *Client) sendGetCredits(ctx context.Context, params GetCreditsParams) (res *GetCreditsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/billing/credits"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetCredits", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetCredits", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetCreditsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDNSZone invokes getDNSZone operation.
//
// Requires the `dns-view` capability.
//
// GET /v1/dns/zones/{zoneId}
func (c *Client) GetDNSZone(ctx context.Context, params GetDNSZoneParams) (*GetDNSZoneOK, error) {
	res, err := c.sendGetDNSZone(ctx, params)
	return res, err
}

func (c *Client) sendGetDNSZone(ctx context.Context, params GetDNSZoneParams) (res *GetDNSZoneOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/dns/zones/"
	{
		// Encode "zoneId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "zoneId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ZoneId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetDNSZone", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetDNSZone", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDNSZoneResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDNSZoneRecords invokes getDNSZoneRecords operation.
//
// Requires the `dns-view` capability.
//
// GET /v1/dns/zones/{zoneId}/records
func (c *Client) GetDNSZoneRecords(ctx context.Context, params GetDNSZoneRecordsParams) (*GetDNSZoneRecordsOK, error) {
	res, err := c.sendGetDNSZoneRecords(ctx, params)
	return res, err
}

func (c *Client) sendGetDNSZoneRecords(ctx context.Context, params GetDNSZoneRecordsParams) (res *GetDNSZoneRecordsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/dns/zones/"
	{
		// Encode "zoneId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "zoneId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ZoneId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetDNSZoneRecords", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetDNSZoneRecords", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDNSZoneRecordsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDNSZones invokes getDNSZones operation.
//
// Requires the `dns-view` capability.
//
// GET /v1/dns/zones
func (c *Client) GetDNSZones(ctx context.Context, params GetDNSZonesParams) (*GetDNSZonesOK, error) {
	res, err := c.sendGetDNSZones(ctx, params)
	return res, err
}

func (c *Client) sendGetDNSZones(ctx context.Context, params GetDNSZonesParams) (res *GetDNSZonesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/dns/zones"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetDNSZones", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetDNSZones", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDNSZonesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDefaultHubRoles invokes getDefaultHubRoles operation.
//
// List Default Hub Roles.
//
// GET /v1/hubs/current/roles/defaults
func (c *Client) GetDefaultHubRoles(ctx context.Context) (*GetDefaultHubRolesOK, error) {
	res, err := c.sendGetDefaultHubRoles(ctx)
	return res, err
}

func (c *Client) sendGetDefaultHubRoles(ctx context.Context) (res *GetDefaultHubRolesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/roles/defaults"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDefaultHubRolesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDeploymentStrategies invokes getDeploymentStrategies operation.
//
// Gets the available deployment strategies that can be used to orchestrate containers.
//
// GET /v1/infrastructure/deployment-strategies
func (c *Client) GetDeploymentStrategies(ctx context.Context) (*GetDeploymentStrategiesOK, error) {
	res, err := c.sendGetDeploymentStrategies(ctx)
	return res, err
}

func (c *Client) sendGetDeploymentStrategies(ctx context.Context) (res *GetDeploymentStrategiesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/infrastructure/deployment-strategies"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetDeploymentStrategies", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetDeploymentStrategies", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDeploymentStrategiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEnvironment invokes getEnvironment operation.
//
// Requires the `environments-view` capability.
//
// GET /v1/environments/{environmentId}
func (c *Client) GetEnvironment(ctx context.Context, params GetEnvironmentParams) (*GetEnvironmentOK, error) {
	res, err := c.sendGetEnvironment(ctx, params)
	return res, err
}

func (c *Client) sendGetEnvironment(ctx context.Context, params GetEnvironmentParams) (res *GetEnvironmentOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetEnvironment", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetEnvironment", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEnvironmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEnvironmentDeployments invokes getEnvironmentDeployments operation.
//
// Gets a list of all deployments in the specified Environment.
// Requires the `environments-view` capability.
//
// GET /v1/environments/{environmentId}/deployments
func (c *Client) GetEnvironmentDeployments(ctx context.Context, params GetEnvironmentDeploymentsParams) (*GetEnvironmentDeploymentsOK, error) {
	res, err := c.sendGetEnvironmentDeployments(ctx, params)
	return res, err
}

func (c *Client) sendGetEnvironmentDeployments(ctx context.Context, params GetEnvironmentDeploymentsParams) (res *GetEnvironmentDeploymentsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/deployments"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetEnvironmentDeployments", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetEnvironmentDeployments", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEnvironmentDeploymentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEnvironmentMonitoringTiers invokes getEnvironmentMonitoringTiers operation.
//
// Gets all the available monitoring tiers that can be enabled for an environment.
//
// GET /v1/environments/monitoring-tiers
func (c *Client) GetEnvironmentMonitoringTiers(ctx context.Context) (*GetEnvironmentMonitoringTiersOK, error) {
	res, err := c.sendGetEnvironmentMonitoringTiers(ctx)
	return res, err
}

func (c *Client) sendGetEnvironmentMonitoringTiers(ctx context.Context) (res *GetEnvironmentMonitoringTiersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/environments/monitoring-tiers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetEnvironmentMonitoringTiers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetEnvironmentMonitoringTiers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEnvironmentMonitoringTiersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEnvironmentSummary invokes getEnvironmentSummary operation.
//
// Gets the summary of an Environment. Contains useful and relevant data/statistics that would
// otherwise be several separate API calls.
// Requires the `environments-view` capability.
//
// GET /v1/environments/{environmentId}/summary
func (c *Client) GetEnvironmentSummary(ctx context.Context, params GetEnvironmentSummaryParams) (*GetEnvironmentSummaryOK, error) {
	res, err := c.sendGetEnvironmentSummary(ctx, params)
	return res, err
}

func (c *Client) sendGetEnvironmentSummary(ctx context.Context, params GetEnvironmentSummaryParams) (res *GetEnvironmentSummaryOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/summary"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetEnvironmentSummary", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetEnvironmentSummary", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEnvironmentSummaryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEnvironments invokes getEnvironments operation.
//
// Requires the `environments-view` capability.
//
// GET /v1/environments
func (c *Client) GetEnvironments(ctx context.Context, params GetEnvironmentsParams) (*GetEnvironmentsOK, error) {
	res, err := c.sendGetEnvironments(ctx, params)
	return res, err
}

func (c *Client) sendGetEnvironments(ctx context.Context, params GetEnvironmentsParams) (res *GetEnvironmentsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/environments"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetEnvironments", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetEnvironments", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEnvironmentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetEvents invokes getEvents operation.
//
// A basic query for retrieving events. For a more complex and granular report, see the
// `/v1/monitoring/events/aggregate` endpoint.
// Requires the `monitor-view` capability.
//
// GET /v1/monitoring/events
func (c *Client) GetEvents(ctx context.Context) (*GetEventsOK, error) {
	res, err := c.sendGetEvents(ctx)
	return res, err
}

func (c *Client) sendGetEvents(ctx context.Context) (res *GetEventsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/monitoring/events"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetEvents", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetEvents", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetEventsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHub invokes getHub operation.
//
// Requires the `hubs-view` capability.
//
// GET /v1/hubs/current
func (c *Client) GetHub(ctx context.Context, params GetHubParams) (*GetHubOK, error) {
	res, err := c.sendGetHub(ctx, params)
	return res, err
}

func (c *Client) sendGetHub(ctx context.Context, params GetHubParams) (res *GetHubOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetHub", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHubResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHubActivity invokes getHubActivity operation.
//
// List Hub Activity.
//
// GET /v1/hubs/current/activity
func (c *Client) GetHubActivity(ctx context.Context, params GetHubActivityParams) (*GetHubActivityOK, error) {
	res, err := c.sendGetHubActivity(ctx, params)
	return res, err
}

func (c *Client) sendGetHubActivity(ctx context.Context, params GetHubActivityParams) (res *GetHubActivityOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/activity"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetHubActivity", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetHubActivity", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHubActivityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHubCapabilities invokes getHubCapabilities operation.
//
// List Hub Capabilities.
//
// GET /v1/hubs/capabilities
func (c *Client) GetHubCapabilities(ctx context.Context) (*GetHubCapabilitiesOK, error) {
	res, err := c.sendGetHubCapabilities(ctx)
	return res, err
}

func (c *Client) sendGetHubCapabilities(ctx context.Context) (res *GetHubCapabilitiesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/capabilities"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHubCapabilitiesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHubInvites invokes getHubInvites operation.
//
// Requires the `hubs-invites-manage` capability.
//
// GET /v1/hubs/current/invites
func (c *Client) GetHubInvites(ctx context.Context, params GetHubInvitesParams) (*GetHubInvitesOK, error) {
	res, err := c.sendGetHubInvites(ctx, params)
	return res, err
}

func (c *Client) sendGetHubInvites(ctx context.Context, params GetHubInvitesParams) (res *GetHubInvitesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/invites"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetHubInvites", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHubInvitesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHubMember invokes getHubMember operation.
//
// Requires the `hubs-members-view` capability.
//
// GET /v1/hubs/current/members/{memberId}
func (c *Client) GetHubMember(ctx context.Context, params GetHubMemberParams) (*GetHubMemberOK, error) {
	res, err := c.sendGetHubMember(ctx, params)
	return res, err
}

func (c *Client) sendGetHubMember(ctx context.Context, params GetHubMemberParams) (res *GetHubMemberOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/members/"
	{
		// Encode "memberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "memberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MemberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetHubMember", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHubMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHubMemberAccount invokes getHubMemberAccount operation.
//
// Requires the `hubs-members-view` capability.
//
// GET /v1/hubs/current/members/account/{accountId}
func (c *Client) GetHubMemberAccount(ctx context.Context, params GetHubMemberAccountParams) (*GetHubMemberAccountOK, error) {
	res, err := c.sendGetHubMemberAccount(ctx, params)
	return res, err
}

func (c *Client) sendGetHubMemberAccount(ctx context.Context, params GetHubMemberAccountParams) (res *GetHubMemberAccountOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/members/account/"
	{
		// Encode "accountId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "accountId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.AccountId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetHubMemberAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetHubMemberAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHubMemberAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHubMembers invokes getHubMembers operation.
//
// Requires the `hubs-members-view` capability.
//
// GET /v1/hubs/current/members
func (c *Client) GetHubMembers(ctx context.Context, params GetHubMembersParams) (*GetHubMembersOK, error) {
	res, err := c.sendGetHubMembers(ctx, params)
	return res, err
}

func (c *Client) sendGetHubMembers(ctx context.Context, params GetHubMembersParams) (res *GetHubMembersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/members"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetHubMembers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHubMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHubMembership invokes getHubMembership operation.
//
// Gets the Hub Membership for the requesting Account.
//
// GET /v1/hubs/current/membership
func (c *Client) GetHubMembership(ctx context.Context, params GetHubMembershipParams) (*GetHubMembershipOK, error) {
	res, err := c.sendGetHubMembership(ctx, params)
	return res, err
}

func (c *Client) sendGetHubMembership(ctx context.Context, params GetHubMembershipParams) (res *GetHubMembershipOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/membership"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetHubMembership", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHubMembershipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHubNotificationSocketAuth invokes getHubNotificationSocketAuth operation.
//
// Initializes authorization for the Hub notification pipeline. The Hub notification pipeline is a
// one-way streaming websocket that
// sends real-time 'notifications' as things are happening on the Hub. These notifications tell some
// basic information about an event,
// and it is up to the user to fetch additional details, if deemed necessary.
// Requesting this endpoint without a `?token=<token>` URL parameter will result in receiving a short
// lived token in the response body. That
// token can then be applied to the URL parameter to the same endpoint to upgrade the connection to a
// WebSocket.
// Requires the `apionly-notifications-listen` capability.
//
// GET /v1/hubs/current/notifications
func (c *Client) GetHubNotificationSocketAuth(ctx context.Context) (GetHubNotificationSocketAuthRes, error) {
	res, err := c.sendGetHubNotificationSocketAuth(ctx)
	return res, err
}

func (c *Client) sendGetHubNotificationSocketAuth(ctx context.Context) (res GetHubNotificationSocketAuthRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/notifications"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetHubNotificationSocketAuth", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetHubNotificationSocketAuth", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHubNotificationSocketAuthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHubUsage invokes getHubUsage operation.
//
// Requires the `hubs-view` capability.
//
// GET /v1/hubs/current/usage
func (c *Client) GetHubUsage(ctx context.Context, params GetHubUsageParams) (*GetHubUsageOK, error) {
	res, err := c.sendGetHubUsage(ctx, params)
	return res, err
}

func (c *Client) sendGetHubUsage(ctx context.Context, params GetHubUsageParams) (res *GetHubUsageOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/usage"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetHubUsage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHubUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetHubs invokes getHubs operation.
//
// Lists all associated Hubs.
//
// GET /v1/hubs
func (c *Client) GetHubs(ctx context.Context, params GetHubsParams) (*GetHubsOK, error) {
	res, err := c.sendGetHubs(ctx, params)
	return res, err
}

func (c *Client) sendGetHubs(ctx context.Context, params GetHubsParams) (res *GetHubsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetHubs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetHubsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetIPPool invokes getIPPool operation.
//
// Requires the `infrastructure-ips-manage` capability.
//
// GET /v1/infrastructure/ips/pools/{poolId}
func (c *Client) GetIPPool(ctx context.Context, params GetIPPoolParams) (*GetIPPoolOK, error) {
	res, err := c.sendGetIPPool(ctx, params)
	return res, err
}

func (c *Client) sendGetIPPool(ctx context.Context, params GetIPPoolParams) (res *GetIPPoolOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/infrastructure/ips/pools/"
	{
		// Encode "poolId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "poolId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PoolId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetIPPool", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetIPPool", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetIPPoolResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetImage invokes getImage operation.
//
// Requires the `images-view` capability.
//
// GET /v1/images/{imageId}
func (c *Client) GetImage(ctx context.Context, params GetImageParams) (*GetImageOK, error) {
	res, err := c.sendGetImage(ctx, params)
	return res, err
}

func (c *Client) sendGetImage(ctx context.Context, params GetImageParams) (res *GetImageOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/images/"
	{
		// Encode "imageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "imageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ImageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetImage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetImage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetImageBuildLog invokes getImageBuildLog operation.
//
// Requires the `images-view` capability.
//
// GET /v1/images/{imageId}/build-log
func (c *Client) GetImageBuildLog(ctx context.Context, params GetImageBuildLogParams) (*GetImageBuildLogOK, error) {
	res, err := c.sendGetImageBuildLog(ctx, params)
	return res, err
}

func (c *Client) sendGetImageBuildLog(ctx context.Context, params GetImageBuildLogParams) (res *GetImageBuildLogOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/images/"
	{
		// Encode "imageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "imageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ImageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/build-log"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetImageBuildLog", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetImageBuildLog", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetImageBuildLogResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetImageSource invokes getImageSource operation.
//
// Requires the `images-sources-view` capability.
//
// GET /v1/images/sources/{sourceId}
func (c *Client) GetImageSource(ctx context.Context, params GetImageSourceParams) (*GetImageSourceOK, error) {
	res, err := c.sendGetImageSource(ctx, params)
	return res, err
}

func (c *Client) sendGetImageSource(ctx context.Context, params GetImageSourceParams) (res *GetImageSourceOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/images/sources/"
	{
		// Encode "sourceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sourceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SourceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetImageSource", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetImageSource", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetImageSourceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetImageSources invokes getImageSources operation.
//
// Requires the `images-sources-view` capability.
//
// GET /v1/images/sources
func (c *Client) GetImageSources(ctx context.Context, params GetImageSourcesParams) (*GetImageSourcesOK, error) {
	res, err := c.sendGetImageSources(ctx, params)
	return res, err
}

func (c *Client) sendGetImageSources(ctx context.Context, params GetImageSourcesParams) (res *GetImageSourcesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/images/sources"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetImageSources", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetImageSources", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetImageSourcesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetImages invokes getImages operation.
//
// Requires the `images-view` capability.
//
// GET /v1/images
func (c *Client) GetImages(ctx context.Context, params GetImagesParams) (*GetImagesOK, error) {
	res, err := c.sendGetImages(ctx, params)
	return res, err
}

func (c *Client) sendGetImages(ctx context.Context, params GetImagesParams) (res *GetImagesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/images"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInfrastructureIPPools invokes getInfrastructureIPPools operation.
//
// Requires the `infrastructure-ips-manage` capability.
//
// GET /v1/infrastructure/ips/pools
func (c *Client) GetInfrastructureIPPools(ctx context.Context, params GetInfrastructureIPPoolsParams) (*GetInfrastructureIPPoolsOK, error) {
	res, err := c.sendGetInfrastructureIPPools(ctx, params)
	return res, err
}

func (c *Client) sendGetInfrastructureIPPools(ctx context.Context, params GetInfrastructureIPPoolsParams) (res *GetInfrastructureIPPoolsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/infrastructure/ips/pools"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetInfrastructureIPPools", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetInfrastructureIPPools", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetInfrastructureIPPoolsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInfrastructureSummary invokes getInfrastructureSummary operation.
//
// Requires the `infrastructure-servers-view` capability.
//
// GET /v1/infrastructure/summary
func (c *Client) GetInfrastructureSummary(ctx context.Context, params GetInfrastructureSummaryParams) (*GetInfrastructureSummaryOK, error) {
	res, err := c.sendGetInfrastructureSummary(ctx, params)
	return res, err
}

func (c *Client) sendGetInfrastructureSummary(ctx context.Context, params GetInfrastructureSummaryParams) (res *GetInfrastructureSummaryOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/infrastructure/summary"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetInfrastructureSummary", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetInfrastructureSummary", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetInfrastructureSummaryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInstance invokes getInstance operation.
//
// Requires the `containers-view` capability.
//
// GET /v1/containers/{containerId}/instances/{instanceId}
func (c *Client) GetInstance(ctx context.Context, params GetInstanceParams) (*GetInstanceOK, error) {
	res, err := c.sendGetInstance(ctx, params)
	return res, err
}

func (c *Client) sendGetInstance(ctx context.Context, params GetInstanceParams) (res *GetInstanceOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances/"
	{
		// Encode "instanceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instanceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InstanceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetInstance", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetInstance", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetInstanceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInstanceConsoleStreamAuth invokes getInstanceConsoleStreamAuth operation.
//
// Returns the authorization information necessary to connect to a Container Instance's console.
// To connect via WebSocket, use the returned address, and append the returned token as a URL
// parameter: `<address>?token=<token>`.
// Requires the `containers-console` capability.
//
// GET /v1/containers/{containerId}/instances/{instanceId}/console
func (c *Client) GetInstanceConsoleStreamAuth(ctx context.Context, params GetInstanceConsoleStreamAuthParams) (*GetInstanceConsoleStreamAuthOK, error) {
	res, err := c.sendGetInstanceConsoleStreamAuth(ctx, params)
	return res, err
}

func (c *Client) sendGetInstanceConsoleStreamAuth(ctx context.Context, params GetInstanceConsoleStreamAuthParams) (res *GetInstanceConsoleStreamAuthOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances/"
	{
		// Encode "instanceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instanceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InstanceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/console"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetInstanceConsoleStreamAuth", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetInstanceConsoleStreamAuth", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetInstanceConsoleStreamAuthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInstanceTelemetryReport invokes getInstanceTelemetryReport operation.
//
// Retrieves a point-in-time report of an Instance's resource usage (CPU, RAM, Network, Storage, etc).
// Requires the `containers-view` capability.
//
// GET /v1/containers/{containerId}/instances/{instanceId}/telemetry/resources/report
func (c *Client) GetInstanceTelemetryReport(ctx context.Context, params GetInstanceTelemetryReportParams) (*GetInstanceTelemetryReportOK, error) {
	res, err := c.sendGetInstanceTelemetryReport(ctx, params)
	return res, err
}

func (c *Client) sendGetInstanceTelemetryReport(ctx context.Context, params GetInstanceTelemetryReportParams) (res *GetInstanceTelemetryReportOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances/"
	{
		// Encode "instanceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instanceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InstanceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/telemetry/resources/report"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetInstanceTelemetryReport", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetInstanceTelemetryReport", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetInstanceTelemetryReportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInstanceTelemetryStreamAuth invokes getInstanceTelemetryStreamAuth operation.
//
// Retrieves an access token and URL to open a websocket to for streaming instance telemetry live.
// This connects directly to the compute layer on the server the instance is hosted on, and streams
// telemetry in real time.
// Requires the `containers-view` capability.
//
// GET /v1/containers/{containerId}/instances/{instanceId}/telemetry/resources/stream
func (c *Client) GetInstanceTelemetryStreamAuth(ctx context.Context, params GetInstanceTelemetryStreamAuthParams) (*GetInstanceTelemetryStreamAuthOK, error) {
	res, err := c.sendGetInstanceTelemetryStreamAuth(ctx, params)
	return res, err
}

func (c *Client) sendGetInstanceTelemetryStreamAuth(ctx context.Context, params GetInstanceTelemetryStreamAuthParams) (res *GetInstanceTelemetryStreamAuthOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances/"
	{
		// Encode "instanceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instanceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InstanceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/telemetry/resources/stream"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetInstanceTelemetryStreamAuth", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetInstanceTelemetryStreamAuth", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetInstanceTelemetryStreamAuthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInstanceVolumes invokes getInstanceVolumes operation.
//
// Requires the `containers-view` capability.
//
// GET /v1/containers/{containerId}/instances/{instanceId}/volumes
func (c *Client) GetInstanceVolumes(ctx context.Context, params GetInstanceVolumesParams) (*GetInstanceVolumesOK, error) {
	res, err := c.sendGetInstanceVolumes(ctx, params)
	return res, err
}

func (c *Client) sendGetInstanceVolumes(ctx context.Context, params GetInstanceVolumesParams) (res *GetInstanceVolumesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances/"
	{
		// Encode "instanceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instanceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InstanceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/volumes"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetInstanceVolumes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetInstanceVolumes", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetInstanceVolumesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInstances invokes getInstances operation.
//
// Requires the `containers-view` capability.
//
// GET /v1/containers/{containerId}/instances
func (c *Client) GetInstances(ctx context.Context, params GetInstancesParams) (*GetInstancesOK, error) {
	res, err := c.sendGetInstances(ctx, params)
	return res, err
}

func (c *Client) sendGetInstances(ctx context.Context, params GetInstancesParams) (res *GetInstancesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetInstances", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetInstances", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetInstancesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetIntegration invokes getIntegration operation.
//
// Retrieves details of a single Integration associated with the current hub.
// Requires the `hubs-integrations-view` capability.
//
// GET /v1/hubs/current/integrations/{integrationId}
func (c *Client) GetIntegration(ctx context.Context, params GetIntegrationParams) (*GetIntegrationOK, error) {
	res, err := c.sendGetIntegration(ctx, params)
	return res, err
}

func (c *Client) sendGetIntegration(ctx context.Context, params GetIntegrationParams) (res *GetIntegrationOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/integrations/"
	{
		// Encode "integrationId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "integrationId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IntegrationId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetIntegration", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetIntegrationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetIntegrations invokes getIntegrations operation.
//
// Lists all integrations associated with the current Hub, with optional filtering.
// Requires the `hubs-integrations-view` capability.
//
// GET /v1/hubs/current/integrations
func (c *Client) GetIntegrations(ctx context.Context, params GetIntegrationsParams) (*GetIntegrationsOK, error) {
	res, err := c.sendGetIntegrations(ctx, params)
	return res, err
}

func (c *Client) sendGetIntegrations(ctx context.Context, params GetIntegrationsParams) (res *GetIntegrationsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/integrations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetIntegrations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetIntegrationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInvoice invokes getInvoice operation.
//
// Requires the `billing-invoices-view` capability.
//
// GET /v1/billing/invoices/{invoiceId}
func (c *Client) GetInvoice(ctx context.Context, params GetInvoiceParams) (*GetInvoiceOK, error) {
	res, err := c.sendGetInvoice(ctx, params)
	return res, err
}

func (c *Client) sendGetInvoice(ctx context.Context, params GetInvoiceParams) (res *GetInvoiceOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/billing/invoices/"
	{
		// Encode "invoiceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "invoiceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InvoiceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetInvoice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetInvoice", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetInvoiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetInvoices invokes getInvoices operation.
//
// List the Invoices assoicated with the Hub.
// Requires the `billing-invoices-view` capability.
//
// GET /v1/billing/invoices
func (c *Client) GetInvoices(ctx context.Context, params GetInvoicesParams) (*GetInvoicesOK, error) {
	res, err := c.sendGetInvoices(ctx, params)
	return res, err
}

func (c *Client) sendGetInvoices(ctx context.Context, params GetInvoicesParams) (res *GetInvoicesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/billing/invoices"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetInvoices", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetInvoices", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetInvoicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetJob invokes getJob operation.
//
// Requires the `apionly-jobs-view` permission.
//
// GET /v1/jobs/{jobId}
func (c *Client) GetJob(ctx context.Context, params GetJobParams) (*GetJobOK, error) {
	res, err := c.sendGetJob(ctx, params)
	return res, err
}

func (c *Client) sendGetJob(ctx context.Context, params GetJobParams) (res *GetJobOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/jobs/"
	{
		// Encode "jobId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "jobId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.JobId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetJobs invokes getJobs operation.
//
// Requires the `apionly-jobs-view` permission.
//
// GET /v1/jobs
func (c *Client) GetJobs(ctx context.Context, params GetJobsParams) (*GetJobsOK, error) {
	res, err := c.sendGetJobs(ctx, params)
	return res, err
}

func (c *Client) sendGetJobs(ctx context.Context, params GetJobsParams) (res *GetJobsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/jobs"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetJobs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetJobs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetJobsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLatestJobs invokes getLatestJobs operation.
//
// Requires the `apionly-jobs-view` permission.
//
// GET /v1/jobs/latest
func (c *Client) GetLatestJobs(ctx context.Context) (*GetLatestJobsOK, error) {
	res, err := c.sendGetLatestJobs(ctx)
	return res, err
}

func (c *Client) sendGetLatestJobs(ctx context.Context) (res *GetLatestJobsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/jobs/latest"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetLatestJobs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetLatestJobs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLatestJobsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLoadBalancerLatestTelemetryReport invokes getLoadBalancerLatestTelemetryReport operation.
//
// Fetches the latest telemetry report for Cycle's native load balancer. Provides detailed
// information on a per-instance basis.
// Requires the `environments-view` capability. Also requires the user to have access specifically to
// the requested Environment.
//
// GET /v1/environments/{environmentId}/services/lb/telemetry/latest
func (c *Client) GetLoadBalancerLatestTelemetryReport(ctx context.Context, params GetLoadBalancerLatestTelemetryReportParams) (*GetLoadBalancerLatestTelemetryReportOK, error) {
	res, err := c.sendGetLoadBalancerLatestTelemetryReport(ctx, params)
	return res, err
}

func (c *Client) sendGetLoadBalancerLatestTelemetryReport(ctx context.Context, params GetLoadBalancerLatestTelemetryReportParams) (res *GetLoadBalancerLatestTelemetryReportOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/lb/telemetry/latest"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return params.Filter.EncodeURI(e)
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetLoadBalancerLatestTelemetryReport", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetLoadBalancerLatestTelemetryReport", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLoadBalancerLatestTelemetryReportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLoadBalancerService invokes getLoadBalancerService operation.
//
// Requires the `environments-view` capability.
//
// GET /v1/environments/{environmentId}/services/lb
func (c *Client) GetLoadBalancerService(ctx context.Context, params GetLoadBalancerServiceParams) (*GetLoadBalancerServiceOK, error) {
	res, err := c.sendGetLoadBalancerService(ctx, params)
	return res, err
}

func (c *Client) sendGetLoadBalancerService(ctx context.Context, params GetLoadBalancerServiceParams) (res *GetLoadBalancerServiceOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/lb"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetLoadBalancerService", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetLoadBalancerService", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLoadBalancerServiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLoadBalancerTelemetryLatestControllers invokes getLoadBalancerTelemetryLatestControllers operation.
//
// Gets the controller information for the specified load balancer. Returns a similar struct to the
// 'latest' load balancer telemetry call, but does NOT return snapshots, just the controller
// information.
// Requires the `environments-view` capability. Also requires the user to have access specifically to
// the requested Environment.
//
// GET /v1/environments/{environmentId}/services/lb/telemetry/latest-controllers
func (c *Client) GetLoadBalancerTelemetryLatestControllers(ctx context.Context, params GetLoadBalancerTelemetryLatestControllersParams) (*GetLoadBalancerTelemetryLatestControllersOK, error) {
	res, err := c.sendGetLoadBalancerTelemetryLatestControllers(ctx, params)
	return res, err
}

func (c *Client) sendGetLoadBalancerTelemetryLatestControllers(ctx context.Context, params GetLoadBalancerTelemetryLatestControllersParams) (res *GetLoadBalancerTelemetryLatestControllersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/lb/telemetry/latest-controllers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetLoadBalancerTelemetryLatestControllers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetLoadBalancerTelemetryLatestControllers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLoadBalancerTelemetryLatestControllersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLoadBalancerTelemetryReport invokes getLoadBalancerTelemetryReport operation.
//
// Fetches a telemetry report for Cycle's native load balancer for the specified range.
// Requires the `environments-view` capability. Also requires the user to have access specifically to
// the requested Environment.
//
// GET /v1/environments/{environmentId}/services/lb/telemetry/report
func (c *Client) GetLoadBalancerTelemetryReport(ctx context.Context, params GetLoadBalancerTelemetryReportParams) (*GetLoadBalancerTelemetryReportOK, error) {
	res, err := c.sendGetLoadBalancerTelemetryReport(ctx, params)
	return res, err
}

func (c *Client) sendGetLoadBalancerTelemetryReport(ctx context.Context, params GetLoadBalancerTelemetryReportParams) (res *GetLoadBalancerTelemetryReportOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/lb/telemetry/report"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return params.Filter.EncodeURI(e)
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetLoadBalancerTelemetryReport", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetLoadBalancerTelemetryReport", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLoadBalancerTelemetryReportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMetrics invokes getMetrics operation.
//
// A basic query for retrieving metrics. For a more complex and granular report, see the
// `/v1/monitoring/metrics/aggregate` endpoint.
// Requires the `monitor-view` capability.
//
// GET /v1/monitoring/metrics
func (c *Client) GetMetrics(ctx context.Context) (*GetMetricsOK, error) {
	res, err := c.sendGetMetrics(ctx)
	return res, err
}

func (c *Client) sendGetMetrics(ctx context.Context) (res *GetMetricsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/monitoring/metrics"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetMetrics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetMetrics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMonitoringMonitors invokes getMonitoringMonitors operation.
//
// Returns location information about the monitors used for Cycle's external monitoring service.
// These monitors are used for determining the latency between the public internet and environment
// load balancers.
//
// GET /v1/monitoring/monitors
func (c *Client) GetMonitoringMonitors(ctx context.Context) (*GetMonitoringMonitorsOK, error) {
	res, err := c.sendGetMonitoringMonitors(ctx)
	return res, err
}

func (c *Client) sendGetMonitoringMonitors(ctx context.Context) (res *GetMonitoringMonitorsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/monitoring/monitors"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetMonitoringMonitors", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetMonitoringMonitors", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMonitoringMonitorsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNetwork invokes getNetwork operation.
//
// Requires the `sdn-networks-view` capability.
//
// GET /v1/sdn/networks/{networkId}
func (c *Client) GetNetwork(ctx context.Context, params GetNetworkParams) (*GetNetworkOK, error) {
	res, err := c.sendGetNetwork(ctx, params)
	return res, err
}

func (c *Client) sendGetNetwork(ctx context.Context, params GetNetworkParams) (res *GetNetworkOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/sdn/networks/"
	{
		// Encode "networkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "networkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NetworkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetNetwork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetNetwork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNetworkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNetworks invokes getNetworks operation.
//
// Requires the `sdn-networks-view` capability.
//
// GET /v1/sdn/networks
func (c *Client) GetNetworks(ctx context.Context, params GetNetworksParams) (*GetNetworksOK, error) {
	res, err := c.sendGetNetworks(ctx, params)
	return res, err
}

func (c *Client) sendGetNetworks(ctx context.Context, params GetNetworksParams) (res *GetNetworksOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/sdn/networks"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetNetworks", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetNetworks", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNetworksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOrders invokes getOrders operation.
//
// Requires the `billing-services-manage` capability.
//
// GET /v1/billing/orders
func (c *Client) GetOrders(ctx context.Context, params GetOrdersParams) (*GetOrdersOK, error) {
	res, err := c.sendGetOrders(ctx, params)
	return res, err
}

func (c *Client) sendGetOrders(ctx context.Context, params GetOrdersParams) (res *GetOrdersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/billing/orders"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetOrders", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetOrders", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetOrdersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPipeline invokes getPipeline operation.
//
// Requires the `pipelines-view` capability.
//
// GET /v1/pipelines/{pipelineId}
func (c *Client) GetPipeline(ctx context.Context, params GetPipelineParams) (*GetPipelineOK, error) {
	res, err := c.sendGetPipeline(ctx, params)
	return res, err
}

func (c *Client) sendGetPipeline(ctx context.Context, params GetPipelineParams) (res *GetPipelineOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetPipeline", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetPipeline", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPipelineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPipelineRun invokes getPipelineRun operation.
//
// Requires the `pipelines-view` capability.
//
// GET /v1/pipelines/{pipelineId}/runs/{runId}
func (c *Client) GetPipelineRun(ctx context.Context, params GetPipelineRunParams) (*GetPipelineRunOK, error) {
	res, err := c.sendGetPipelineRun(ctx, params)
	return res, err
}

func (c *Client) sendGetPipelineRun(ctx context.Context, params GetPipelineRunParams) (res *GetPipelineRunOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/runs/"
	{
		// Encode "runId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "runId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RunId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetPipelineRun", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetPipelineRun", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPipelineRunResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPipelineRuns invokes getPipelineRuns operation.
//
// List information about times this Pipeline has run.
// Requires the `pipelines-view` capability.
//
// GET /v1/pipelines/{pipelineId}/runs
func (c *Client) GetPipelineRuns(ctx context.Context, params GetPipelineRunsParams) (*GetPipelineRunsOK, error) {
	res, err := c.sendGetPipelineRuns(ctx, params)
	return res, err
}

func (c *Client) sendGetPipelineRuns(ctx context.Context, params GetPipelineRunsParams) (res *GetPipelineRunsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/runs"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetPipelineRuns", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetPipelineRuns", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPipelineRunsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPipelineTriggerKey invokes getPipelineTriggerKey operation.
//
// Requires the `pipelines-manage` capability.
//
// GET /v1/pipelines/{pipelineId}/keys/{triggerKeyId}
func (c *Client) GetPipelineTriggerKey(ctx context.Context, params GetPipelineTriggerKeyParams) (*GetPipelineTriggerKeyOK, error) {
	res, err := c.sendGetPipelineTriggerKey(ctx, params)
	return res, err
}

func (c *Client) sendGetPipelineTriggerKey(ctx context.Context, params GetPipelineTriggerKeyParams) (res *GetPipelineTriggerKeyOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/keys/"
	{
		// Encode "triggerKeyId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "triggerKeyId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TriggerKeyId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetPipelineTriggerKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetPipelineTriggerKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPipelineTriggerKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPipelineTriggerKeys invokes getPipelineTriggerKeys operation.
//
// Requires the `pipelines-manage` capability.
//
// GET /v1/pipelines/{pipelineId}/keys
func (c *Client) GetPipelineTriggerKeys(ctx context.Context, params GetPipelineTriggerKeysParams) (*GetPipelineTriggerKeysOK, error) {
	res, err := c.sendGetPipelineTriggerKeys(ctx, params)
	return res, err
}

func (c *Client) sendGetPipelineTriggerKeys(ctx context.Context, params GetPipelineTriggerKeysParams) (res *GetPipelineTriggerKeysOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/keys"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetPipelineTriggerKeys", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetPipelineTriggerKeys", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPipelineTriggerKeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPipelines invokes getPipelines operation.
//
// Requires the `pipelines-view` capability.
//
// GET /v1/pipelines
func (c *Client) GetPipelines(ctx context.Context, params GetPipelinesParams) (*GetPipelinesOK, error) {
	res, err := c.sendGetPipelines(ctx, params)
	return res, err
}

func (c *Client) sendGetPipelines(ctx context.Context, params GetPipelinesParams) (res *GetPipelinesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/pipelines"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetPipelines", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetPipelines", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPipelinesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPoolIPs invokes getPoolIPs operation.
//
// Requires the `infrastructure-ips-manage` capability.
//
// GET /v1/infrastructure/ips/pools/{poolId}/ips
func (c *Client) GetPoolIPs(ctx context.Context, params GetPoolIPsParams) (*GetPoolIPsOK, error) {
	res, err := c.sendGetPoolIPs(ctx, params)
	return res, err
}

func (c *Client) sendGetPoolIPs(ctx context.Context, params GetPoolIPsParams) (res *GetPoolIPsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/infrastructure/ips/pools/"
	{
		// Encode "poolId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "poolId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PoolId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/ips"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetPoolIPs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetPoolIPs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPoolIPsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProviderLocations invokes getProviderLocations operation.
//
// List Provider Locations.
//
// GET /v1/infrastructure/providers/{providerVendor}/locations
func (c *Client) GetProviderLocations(ctx context.Context, params GetProviderLocationsParams) (*GetProviderLocationsOK, error) {
	res, err := c.sendGetProviderLocations(ctx, params)
	return res, err
}

func (c *Client) sendGetProviderLocations(ctx context.Context, params GetProviderLocationsParams) (res *GetProviderLocationsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/infrastructure/providers/"
	{
		// Encode "providerVendor" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "providerVendor",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProviderVendor))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/locations"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetProviderLocations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetProviderLocations", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetProviderLocationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProviderServers invokes getProviderServers operation.
//
// List Provider Servers.
//
// GET /v1/infrastructure/providers/{providerVendor}/servers
func (c *Client) GetProviderServers(ctx context.Context, params GetProviderServersParams) (*GetProviderServersOK, error) {
	res, err := c.sendGetProviderServers(ctx, params)
	return res, err
}

func (c *Client) sendGetProviderServers(ctx context.Context, params GetProviderServersParams) (res *GetProviderServersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/infrastructure/providers/"
	{
		// Encode "providerVendor" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "providerVendor",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProviderVendor))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/servers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetProviderServers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetProviderServers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetProviderServersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRole invokes getRole operation.
//
// Retrieves the specified Role.
// Requries the `hubs-roles-manage` capability.
//
// GET /v1/hubs/current/roles/{roleId}
func (c *Client) GetRole(ctx context.Context, params GetRoleParams) (*GetRoleOK, error) {
	res, err := c.sendGetRole(ctx, params)
	return res, err
}

func (c *Client) sendGetRole(ctx context.Context, params GetRoleParams) (res *GetRoleOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/roles/"
	{
		// Encode "roleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRoles invokes getRoles operation.
//
// Lists the Roles that have been created for this Hub.
// Requires the `hubs-roles-manage` capability.
//
// GET /v1/hubs/current/roles
func (c *Client) GetRoles(ctx context.Context, params GetRolesParams) (*GetRolesOK, error) {
	res, err := c.sendGetRoles(ctx, params)
	return res, err
}

func (c *Client) sendGetRoles(ctx context.Context, params GetRolesParams) (res *GetRolesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current/roles"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if v := params.Filter; v != nil {
				return (*v).EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetRoles", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetRoles", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRolesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetScopedVariable invokes getScopedVariable operation.
//
// Requires the `scoped-variables-view` capability.
//
// GET /v1/environments/{environmentId}/scoped-variables/{scopedVariableId}
func (c *Client) GetScopedVariable(ctx context.Context, params GetScopedVariableParams) (*GetScopedVariableOK, error) {
	res, err := c.sendGetScopedVariable(ctx, params)
	return res, err
}

func (c *Client) sendGetScopedVariable(ctx context.Context, params GetScopedVariableParams) (res *GetScopedVariableOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/scoped-variables/"
	{
		// Encode "scopedVariableId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scopedVariableId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScopedVariableId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetScopedVariable", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetScopedVariable", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetScopedVariableResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetScopedVariables invokes getScopedVariables operation.
//
// Requires the `scoped-variables-view` capability.
//
// GET /v1/environments/{environmentId}/scoped-variables
func (c *Client) GetScopedVariables(ctx context.Context, params GetScopedVariablesParams) (*GetScopedVariablesOK, error) {
	res, err := c.sendGetScopedVariables(ctx, params)
	return res, err
}

func (c *Client) sendGetScopedVariables(ctx context.Context, params GetScopedVariablesParams) (res *GetScopedVariablesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/scoped-variables"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetScopedVariables", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetScopedVariables", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetScopedVariablesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSearchIndex invokes getSearchIndex operation.
//
// Gets a pre-built search index, containing IDs and basic information for many commonly used
// resources on the Hub.
// Can be used to build a 'quick search' functionality for referencing the most frequently used
// resources.
// Requires the `view` capability for each returned segment, i.e. to retrieve Containers, you must
// have `containers-view`.
//
// GET /v1/search/index
func (c *Client) GetSearchIndex(ctx context.Context) (*GetSearchIndexOK, error) {
	res, err := c.sendGetSearchIndex(ctx)
	return res, err
}

func (c *Client) sendGetSearchIndex(ctx context.Context) (res *GetSearchIndexOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/search/index"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetSearchIndex", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSearchIndexResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServer invokes getServer operation.
//
// Requires the `servers-view` capability.
//
// GET /v1/infrastructure/servers/{serverId}
func (c *Client) GetServer(ctx context.Context, params GetServerParams) (*GetServerOK, error) {
	res, err := c.sendGetServer(ctx, params)
	return res, err
}

func (c *Client) sendGetServer(ctx context.Context, params GetServerParams) (res *GetServerOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/infrastructure/servers/"
	{
		// Encode "serverId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "serverId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetServer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetServer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServerConsole invokes GetServerConsole operation.
//
// Gets the authorization information required to connect to a Server console websocket.
// Requires the `servers-console` capability.
//
// GET /v1/infrastructure/servers/{serverId}/console
func (c *Client) GetServerConsole(ctx context.Context, params GetServerConsoleParams) (*GetServerConsoleOK, error) {
	res, err := c.sendGetServerConsole(ctx, params)
	return res, err
}

func (c *Client) sendGetServerConsole(ctx context.Context, params GetServerConsoleParams) (res *GetServerConsoleOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/infrastructure/servers/"
	{
		// Encode "serverId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "serverId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/console"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetServerConsole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetServerConsole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServerConsoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServerInstances invokes getServerInstances operation.
//
// Requires the `containers-view` capability.
//
// GET /v1/infrastructure/servers/{serverId}/instances
func (c *Client) GetServerInstances(ctx context.Context, params GetServerInstancesParams) (*GetServerInstancesOK, error) {
	res, err := c.sendGetServerInstances(ctx, params)
	return res, err
}

func (c *Client) sendGetServerInstances(ctx context.Context, params GetServerInstancesParams) (res *GetServerInstancesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/infrastructure/servers/"
	{
		// Encode "serverId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "serverId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instances"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetServerInstances", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetServerInstances", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServerInstancesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServerTags invokes getServerTags operation.
//
// Requires the `servers-view` capability.
//
// GET /v1/infrastructure/servers/tags
func (c *Client) GetServerTags(ctx context.Context, params GetServerTagsParams) (*ServerTags, error) {
	res, err := c.sendGetServerTags(ctx, params)
	return res, err
}

func (c *Client) sendGetServerTags(ctx context.Context, params GetServerTagsParams) (res *ServerTags, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/infrastructure/servers/tags"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetServerTags", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetServerTags", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServerTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServerTelemetry invokes getServerTelemetry operation.
//
// This call requires the filter query parameter to be used.
// Requires the `servers-view` capability.
//
// GET /v1/infrastructure/servers/{serverId}/telemetry
func (c *Client) GetServerTelemetry(ctx context.Context, params GetServerTelemetryParams) (*GetServerTelemetryOK, error) {
	res, err := c.sendGetServerTelemetry(ctx, params)
	return res, err
}

func (c *Client) sendGetServerTelemetry(ctx context.Context, params GetServerTelemetryParams) (res *GetServerTelemetryOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/infrastructure/servers/"
	{
		// Encode "serverId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "serverId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/telemetry"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetServerTelemetry", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetServerTelemetry", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServerTelemetryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServerUsage invokes GetServerUsage operation.
//
// Requires the `servers-view` capability.
//
// GET /v1/infrastructure/servers/{serverId}/usage
func (c *Client) GetServerUsage(ctx context.Context, params GetServerUsageParams) (*GetServerUsageOK, error) {
	res, err := c.sendGetServerUsage(ctx, params)
	return res, err
}

func (c *Client) sendGetServerUsage(ctx context.Context, params GetServerUsageParams) (res *GetServerUsageOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/infrastructure/servers/"
	{
		// Encode "serverId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "serverId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/usage"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetServerUsage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetServerUsage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServerUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServers invokes getServers operation.
//
// Requires the `servers-view` capability.
//
// GET /v1/infrastructure/servers
func (c *Client) GetServers(ctx context.Context, params GetServersParams) (*GetServersOK, error) {
	res, err := c.sendGetServers(ctx, params)
	return res, err
}

func (c *Client) sendGetServers(ctx context.Context, params GetServersParams) (res *GetServersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/infrastructure/servers"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetServers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetServers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStack invokes getStack operation.
//
// Requires the `stacks-view` capability.
//
// GET /v1/stacks/{stackId}
func (c *Client) GetStack(ctx context.Context, params GetStackParams) (*GetStackOK, error) {
	res, err := c.sendGetStack(ctx, params)
	return res, err
}

func (c *Client) sendGetStack(ctx context.Context, params GetStackParams) (res *GetStackOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/stacks/"
	{
		// Encode "stackId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stackId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StackId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetStack", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetStack", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStackBuild invokes getStackBuild operation.
//
// Requires the `stacks-view` capability.
//
// GET /v1/stacks/{stackId}/builds/{buildId}
func (c *Client) GetStackBuild(ctx context.Context, params GetStackBuildParams) (*GetStackBuildOK, error) {
	res, err := c.sendGetStackBuild(ctx, params)
	return res, err
}

func (c *Client) sendGetStackBuild(ctx context.Context, params GetStackBuildParams) (res *GetStackBuildOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/stacks/"
	{
		// Encode "stackId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stackId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StackId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/builds/"
	{
		// Encode "buildId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "buildId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BuildId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetStackBuild", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetStackBuild", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStackBuildResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStackBuilds invokes getStackBuilds operation.
//
// Requires the `stacks-view` capability.
//
// GET /v1/stacks/{stackId}/builds
func (c *Client) GetStackBuilds(ctx context.Context, params GetStackBuildsParams) (*GetStackBuildsOK, error) {
	res, err := c.sendGetStackBuilds(ctx, params)
	return res, err
}

func (c *Client) sendGetStackBuilds(ctx context.Context, params GetStackBuildsParams) (res *GetStackBuildsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/stacks/"
	{
		// Encode "stackId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stackId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StackId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/builds"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetStackBuilds", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetStackBuilds", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStackBuildsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStacks invokes getStacks operation.
//
// Requires the `stacks-view` permission.
//
// GET /v1/stacks
func (c *Client) GetStacks(ctx context.Context, params GetStacksParams) (*GetStacksOK, error) {
	res, err := c.sendGetStacks(ctx, params)
	return res, err
}

func (c *Client) sendGetStacks(ctx context.Context, params GetStacksParams) (res *GetStacksOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/stacks"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetStacks", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetStacks", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStacksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTLSGenerationAttempts invokes getTLSGenerationAttempts operation.
//
// Requires the `dns-view` capability.
//
// GET /v1/dns/tls/attempts
func (c *Client) GetTLSGenerationAttempts(ctx context.Context, params GetTLSGenerationAttemptsParams) (*GetTLSGenerationAttemptsOK, error) {
	res, err := c.sendGetTLSGenerationAttempts(ctx, params)
	return res, err
}

func (c *Client) sendGetTLSGenerationAttempts(ctx context.Context, params GetTLSGenerationAttemptsParams) (res *GetTLSGenerationAttemptsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/dns/tls/attempts"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTLSGenerationAttempts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetTLSGenerationAttempts", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTLSGenerationAttemptsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTwoFactorAuthSetup invokes getTwoFactorAuthSetup operation.
//
// Gets the barcode and secret required for setting up two-factor authentication for the Account.
//
// GET /v1/account/2fa/setup
func (c *Client) GetTwoFactorAuthSetup(ctx context.Context) (*GetTwoFactorAuthSetupOK, error) {
	res, err := c.sendGetTwoFactorAuthSetup(ctx)
	return res, err
}

func (c *Client) sendGetTwoFactorAuthSetup(ctx context.Context) (res *GetTwoFactorAuthSetupOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/account/2fa/setup"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetTwoFactorAuthSetup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetTwoFactorAuthSetup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTwoFactorAuthSetupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVPNLogins invokes getVPNLogins operation.
//
// Requires the `environments-vpn` capability.
//
// GET /v1/environments/{environmentId}/services/vpn/logins
func (c *Client) GetVPNLogins(ctx context.Context, params GetVPNLoginsParams) (*GetVPNLoginsOK, error) {
	res, err := c.sendGetVPNLogins(ctx, params)
	return res, err
}

func (c *Client) sendGetVPNLogins(ctx context.Context, params GetVPNLoginsParams) (res *GetVPNLoginsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/vpn/logins"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetVPNLogins", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetVPNLogins", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVPNLoginsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVPNService invokes getVPNService operation.
//
// Requires the `environments-vpn` capability.
//
// GET /v1/environments/{environmentId}/services/vpn
func (c *Client) GetVPNService(ctx context.Context, params GetVPNServiceParams) (*GetVPNServiceOK, error) {
	res, err := c.sendGetVPNService(ctx, params)
	return res, err
}

func (c *Client) sendGetVPNService(ctx context.Context, params GetVPNServiceParams) (res *GetVPNServiceOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/vpn"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetVPNService", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetVPNService", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVPNServiceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVPNUsers invokes getVPNUsers operation.
//
// Requires the `environments-vpn-manage` capability.
//
// GET /v1/environments/{environmentId}/services/vpn/users
func (c *Client) GetVPNUsers(ctx context.Context, params GetVPNUsersParams) (*GetVPNUsersOK, error) {
	res, err := c.sendGetVPNUsers(ctx, params)
	return res, err
}

func (c *Client) sendGetVPNUsers(ctx context.Context, params GetVPNUsersParams) (res *GetVPNUsersOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/services/vpn/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetVPNUsers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetVPNUsers", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVPNUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVirtualMachine invokes getVirtualMachine operation.
//
// Retrieves a single virtual machine by ID.
// Requires the `virtual-machines-view` capability.
//
// GET /v1/virtual-machines/{virtualMachineId}
func (c *Client) GetVirtualMachine(ctx context.Context, params GetVirtualMachineParams) (*GetVirtualMachineOK, error) {
	res, err := c.sendGetVirtualMachine(ctx, params)
	return res, err
}

func (c *Client) sendGetVirtualMachine(ctx context.Context, params GetVirtualMachineParams) (res *GetVirtualMachineOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/virtual-machines/"
	{
		// Encode "virtualMachineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "virtualMachineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VirtualMachineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetVirtualMachine", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetVirtualMachine", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVirtualMachineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVirtualMachineBaseImages invokes getVirtualMachineBaseImages operation.
//
// Retrieves the list of available base images for virtual machines provided by Cycle.
//
// GET /v1/virtual-machines/images/base
func (c *Client) GetVirtualMachineBaseImages(ctx context.Context) (*GetVirtualMachineBaseImagesOK, error) {
	res, err := c.sendGetVirtualMachineBaseImages(ctx)
	return res, err
}

func (c *Client) sendGetVirtualMachineBaseImages(ctx context.Context) (res *GetVirtualMachineBaseImagesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/virtual-machines/images/base"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetVirtualMachineBaseImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetVirtualMachineBaseImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVirtualMachineBaseImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVirtualMachines invokes getVirtualMachines operation.
//
// Requires the `virtual-machines-view` capability.
//
// GET /v1/virtual-machines
func (c *Client) GetVirtualMachines(ctx context.Context, params GetVirtualMachinesParams) (*GetVirtualMachinesOK, error) {
	res, err := c.sendGetVirtualMachines(ctx, params)
	return res, err
}

func (c *Client) sendGetVirtualMachines(ctx context.Context, params GetVirtualMachinesParams) (res *GetVirtualMachinesOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/virtual-machines"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "filter" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filter",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Filter.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Sort {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "page" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleDeepObject,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Page.Get(); ok {
				return val.EncodeURI(e)
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "GetVirtualMachines", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "GetVirtualMachines", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVirtualMachinesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LookupComponents invokes lookupComponents operation.
//
// Look up a component.
//
// POST /v1/utils/components/lookup
func (c *Client) LookupComponents(ctx context.Context, request OptLookupComponentsReq) (*LookupComponentsOK, error) {
	res, err := c.sendLookupComponents(ctx, request)
	return res, err
}

func (c *Client) sendLookupComponents(ctx context.Context, request OptLookupComponentsReq) (res *LookupComponentsOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/utils/components/lookup"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLookupComponentsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "LookupComponents", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "LookupComponents", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLookupComponentsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LookupIdentifier invokes lookupIdentifier operation.
//
// Given a (base64'd) resource identifier string (i.e. `cluster:production/env:abc`), returns the ID
// of the matching resource.
// If more than one resource matches the identifier, or no resource matches the identifier, this
// endpoint will return an error.
// Given identifiers are NOT unique, you may need to be more specific to target the exact identifier.
//
// GET /v1/utils/resource/lookup
func (c *Client) LookupIdentifier(ctx context.Context, params LookupIdentifierParams) (*LookupIdentifierOK, error) {
	res, err := c.sendLookupIdentifier(ctx, params)
	return res, err
}

func (c *Client) sendLookupIdentifier(ctx context.Context, params LookupIdentifierParams) (res *LookupIdentifierOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/utils/resource/lookup"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "identifier" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "identifier",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Identifier))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "desired-component" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "desired-component",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.DesiredComponent)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "LookupIdentifier", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "LookupIdentifier", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLookupIdentifierResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LookupStackBuild invokes lookupStackBuild operation.
//
// Look up a Stack Build using only the Build ID, instead of requiring a Stack ID as well.
// Requires the `stacks-view` capability.
//
// GET /v1/stacks/builds/{buildId}
func (c *Client) LookupStackBuild(ctx context.Context, params LookupStackBuildParams) (*LookupStackBuildOK, error) {
	res, err := c.sendLookupStackBuild(ctx, params)
	return res, err
}

func (c *Client) sendLookupStackBuild(ctx context.Context, params LookupStackBuildParams) (res *LookupStackBuildOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/stacks/builds/"
	{
		// Encode "buildId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "buildId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.BuildId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "LookupStackBuild", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "LookupStackBuild", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLookupStackBuildResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LookupTLSCertificate invokes lookupTLSCertificate operation.
//
// Lookup and retrieve a TLS certificate bundle for a specified domain.
// Requires the `dns-view` capability.
//
// GET /v1/dns/tls/certificates/lookup
func (c *Client) LookupTLSCertificate(ctx context.Context, params LookupTLSCertificateParams) (*LookupTLSCertificateOK, error) {
	res, err := c.sendLookupTLSCertificate(ctx, params)
	return res, err
}

func (c *Client) sendLookupTLSCertificate(ctx context.Context, params LookupTLSCertificateParams) (res *LookupTLSCertificateOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/dns/tls/certificates/lookup"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "domain" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "domain",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Domain))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "wildcard" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "wildcard",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Wildcard.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "LookupTLSCertificate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "LookupTLSCertificate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLookupTLSCertificateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RecoverTwoFactorAuth invokes recoverTwoFactorAuth operation.
//
// Returns a new two-factor auth setup to reset the Account's two-factor auth.
//
// POST /v1/account/2fa/recover
func (c *Client) RecoverTwoFactorAuth(ctx context.Context, request OptRecoverTwoFactorAuthReq) (*RecoverTwoFactorAuthOK, error) {
	res, err := c.sendRecoverTwoFactorAuth(ctx, request)
	return res, err
}

func (c *Client) sendRecoverTwoFactorAuth(ctx context.Context, request OptRecoverTwoFactorAuthReq) (res *RecoverTwoFactorAuthOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/account/2fa/recover"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRecoverTwoFactorAuthRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "RecoverTwoFactorAuth", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "RecoverTwoFactorAuth", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRecoverTwoFactorAuthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ResetPassword invokes resetPassword operation.
//
// Initiate a password reset for the Account. A confirmation email will be sent to the email
// associated with the Account, and the token in the email must be passed in a second call to this
// endpoint.
//
// POST /v1/account/reset-password
func (c *Client) ResetPassword(ctx context.Context, request *ResetPasswordReq) (*ResetPasswordOK, error) {
	res, err := c.sendResetPassword(ctx, request)
	return res, err
}

func (c *Client) sendResetPassword(ctx context.Context, request *ResetPasswordReq) (res *ResetPasswordOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/account/reset-password"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeResetPasswordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "ResetPassword", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "ResetPassword", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeResetPasswordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TriggerPipeline invokes triggerPipeline operation.
//
// Trigger Pipeline.
//
// POST /v1/pipelines/{pipelineId}/trigger
func (c *Client) TriggerPipeline(ctx context.Context, request OptTriggerPipelineReq, params TriggerPipelineParams) (*TriggerPipelineCreated, error) {
	res, err := c.sendTriggerPipeline(ctx, request, params)
	return res, err
}

func (c *Client) sendTriggerPipeline(ctx context.Context, request OptTriggerPipelineReq, params TriggerPipelineParams) (res *TriggerPipelineCreated, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/trigger"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTriggerPipelineRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "TriggerPipeline", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "TriggerPipeline", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTriggerPipelineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAPIKey invokes updateAPIKey operation.
//
// Requires the `api-keys-manage` capability.
//
// PATCH /v1/hubs/current/api-keys/{apikeyId}
func (c *Client) UpdateAPIKey(ctx context.Context, request OptUpdateAPIKeyReq, params UpdateAPIKeyParams) (*UpdateAPIKeyOK, error) {
	res, err := c.sendUpdateAPIKey(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateAPIKey(ctx context.Context, request OptUpdateAPIKeyReq, params UpdateAPIKeyParams) (res *UpdateAPIKeyOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/api-keys/"
	{
		// Encode "apikeyId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "apikeyId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ApikeyId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAPIKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateAPIKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateAPIKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateAPIKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAccount invokes updateAccount operation.
//
// Updates the Account.
//
// PATCH /v1/account
func (c *Client) UpdateAccount(ctx context.Context, request OptUpdateAccountReq) (*UpdateAccountOK, error) {
	res, err := c.sendUpdateAccount(ctx, request)
	return res, err
}

func (c *Client) sendUpdateAccount(ctx context.Context, request OptUpdateAccountReq) (res *UpdateAccountOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/account"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateAccount", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAccountInvite invokes updateAccountInvite operation.
//
// Accept/reject a pending Invite to join a Hub.
//
// PATCH /v1/account/invites/{inviteId}
func (c *Client) UpdateAccountInvite(ctx context.Context, request OptUpdateAccountInviteReq, params UpdateAccountInviteParams) (*UpdateAccountInviteOK, error) {
	res, err := c.sendUpdateAccountInvite(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateAccountInvite(ctx context.Context, request OptUpdateAccountInviteReq, params UpdateAccountInviteParams) (res *UpdateAccountInviteOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/account/invites/"
	{
		// Encode "inviteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "inviteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.InviteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAccountInviteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateAccountInvite", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateAccountInviteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAutoScaleGroup invokes updateAutoScaleGroup operation.
//
// Requires the `autoscale-groups-manage` capability.
//
// PATCH /v1/infrastructure/auto-scale/groups/{groupId}
func (c *Client) UpdateAutoScaleGroup(ctx context.Context, request OptUpdateAutoScaleGroupReq, params UpdateAutoScaleGroupParams) (*UpdateAutoScaleGroupOK, error) {
	res, err := c.sendUpdateAutoScaleGroup(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateAutoScaleGroup(ctx context.Context, request OptUpdateAutoScaleGroupReq, params UpdateAutoScaleGroupParams) (res *UpdateAutoScaleGroupOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/infrastructure/auto-scale/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAutoScaleGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateAutoScaleGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateAutoScaleGroup", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateAutoScaleGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateAutoScaleGroupAccess invokes updateAutoScaleGroupAccess operation.
//
// Requires the `autoscale-groups-manage` capability. If an ACL is present, requires the `manage`
// privilege.
//
// PATCH /v1/infrastructure/auto-scale/groups/{groupId}/access
func (c *Client) UpdateAutoScaleGroupAccess(ctx context.Context, request OptUpdateAutoScaleGroupAccessReq, params UpdateAutoScaleGroupAccessParams) (*UpdateAutoScaleGroupAccessOK, error) {
	res, err := c.sendUpdateAutoScaleGroupAccess(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateAutoScaleGroupAccess(ctx context.Context, request OptUpdateAutoScaleGroupAccessReq, params UpdateAutoScaleGroupAccessParams) (res *UpdateAutoScaleGroupAccessOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/infrastructure/auto-scale/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/access"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateAutoScaleGroupAccessRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateAutoScaleGroupAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateAutoScaleGroupAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateAutoScaleGroupAccessResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateBillingMethod invokes updateBillingMethod operation.
//
// Requires the `billing-methods-manage` capability.
//
// PATCH /v1/billing/methods/{methodId}
func (c *Client) UpdateBillingMethod(ctx context.Context, request OptUpdateBillingMethodReq, params UpdateBillingMethodParams) (*UpdateBillingMethodOK, error) {
	res, err := c.sendUpdateBillingMethod(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateBillingMethod(ctx context.Context, request OptUpdateBillingMethodReq, params UpdateBillingMethodParams) (res *UpdateBillingMethodOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/billing/methods/"
	{
		// Encode "methodId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "methodId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MethodId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateBillingMethodRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateBillingMethod", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateBillingMethod", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateBillingMethodResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateBillingOrder invokes updateBillingOrder operation.
//
// Requires the `billing-services-manage` capability.
//
// PATCH /v1/billing/orders/{orderId}
func (c *Client) UpdateBillingOrder(ctx context.Context, request OptUpdateBillingOrderReq, params UpdateBillingOrderParams) (*UpdateBillingOrderOK, error) {
	res, err := c.sendUpdateBillingOrder(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateBillingOrder(ctx context.Context, request OptUpdateBillingOrderReq, params UpdateBillingOrderParams) (res *UpdateBillingOrderOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/billing/orders/"
	{
		// Encode "orderId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "orderId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.OrderId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateBillingOrderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateBillingOrder", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateBillingOrder", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateBillingOrderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateCluster invokes updateCluster operation.
//
// Requires the `clusters-manage` capability.
//
// PATCH /v1/infrastructure/clusters/{clusterId}
func (c *Client) UpdateCluster(ctx context.Context, request *UpdateClusterReq, params UpdateClusterParams) (*UpdateClusterOK, error) {
	res, err := c.sendUpdateCluster(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateCluster(ctx context.Context, request *UpdateClusterReq, params UpdateClusterParams) (res *UpdateClusterOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/infrastructure/clusters/"
	{
		// Encode "clusterId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClusterId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateClusterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateCluster", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateCluster", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateClusterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateClusterAccess invokes updateClusterAccess operation.
//
// Requires the `clusters-manage` capability. If an ACL is present, requires the `manage` privilege.
//
// PATCH /v1/infrastructure/clusters/{clusterId}/access
func (c *Client) UpdateClusterAccess(ctx context.Context, request OptUpdateClusterAccessReq, params UpdateClusterAccessParams) (*UpdateClusterAccessOK, error) {
	res, err := c.sendUpdateClusterAccess(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateClusterAccess(ctx context.Context, request OptUpdateClusterAccessReq, params UpdateClusterAccessParams) (res *UpdateClusterAccessOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/infrastructure/clusters/"
	{
		// Encode "clusterId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clusterId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClusterId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/access"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateClusterAccessRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateClusterAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateClusterAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateClusterAccessResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateContainer invokes updateContainer operation.
//
// Updates the specified Container.
// Requires the `containers-manage` capability.
//
// PATCH /v1/containers/{containerId}
func (c *Client) UpdateContainer(ctx context.Context, request OptUpdateContainerReq, params UpdateContainerParams) (*UpdateContainerOK, error) {
	res, err := c.sendUpdateContainer(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateContainer(ctx context.Context, request OptUpdateContainerReq, params UpdateContainerParams) (res *UpdateContainerOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/containers/"
	{
		// Encode "containerId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "containerId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ContainerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateContainerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateContainer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateContainer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateContainerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDNSZone invokes updateDNSZone operation.
//
// Requires the `dns-manage` capability.
//
// PATCH /v1/dns/zones/{zoneId}
func (c *Client) UpdateDNSZone(ctx context.Context, request OptUpdateDNSZoneReq, params UpdateDNSZoneParams) (*UpdateDNSZoneOK, error) {
	res, err := c.sendUpdateDNSZone(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateDNSZone(ctx context.Context, request OptUpdateDNSZoneReq, params UpdateDNSZoneParams) (res *UpdateDNSZoneOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/dns/zones/"
	{
		// Encode "zoneId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "zoneId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ZoneId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDNSZoneRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateDNSZone", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateDNSZone", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateDNSZoneResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDNSZoneAccess invokes updateDNSZoneAccess operation.
//
// Requires the `dns-manage` capability, and if an ACL is present, the `manage` privilege.
//
// PATCH /v1/dns/zones/{zoneId}/access
func (c *Client) UpdateDNSZoneAccess(ctx context.Context, request OptUpdateDNSZoneAccessReq, params UpdateDNSZoneAccessParams) (*UpdateDNSZoneAccessOK, error) {
	res, err := c.sendUpdateDNSZoneAccess(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateDNSZoneAccess(ctx context.Context, request OptUpdateDNSZoneAccessReq, params UpdateDNSZoneAccessParams) (res *UpdateDNSZoneAccessOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/dns/zones/"
	{
		// Encode "zoneId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "zoneId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ZoneId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/access"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDNSZoneAccessRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateDNSZoneAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateDNSZoneAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateDNSZoneAccessResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateDNSZoneRecord invokes updateDNSZoneRecord operation.
//
// Requires the `dns-manage` capability.
//
// PATCH /v1/dns/zones/{zoneId}/records/{recordId}
func (c *Client) UpdateDNSZoneRecord(ctx context.Context, request OptUpdateDNSZoneRecordReq, params UpdateDNSZoneRecordParams) (*UpdateDNSZoneRecordOK, error) {
	res, err := c.sendUpdateDNSZoneRecord(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateDNSZoneRecord(ctx context.Context, request OptUpdateDNSZoneRecordReq, params UpdateDNSZoneRecordParams) (res *UpdateDNSZoneRecordOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/dns/zones/"
	{
		// Encode "zoneId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "zoneId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ZoneId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/records/"
	{
		// Encode "recordId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "recordId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RecordId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateDNSZoneRecordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateDNSZoneRecord", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateDNSZoneRecord", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateDNSZoneRecordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateEnvironment invokes updateEnvironment operation.
//
// Updates the specificed Environment.
// Requires the `environments-manage` capability.
//
// PATCH /v1/environments/{environmentId}
func (c *Client) UpdateEnvironment(ctx context.Context, request OptUpdateEnvironmentReq, params UpdateEnvironmentParams) (*UpdateEnvironmentOK, error) {
	res, err := c.sendUpdateEnvironment(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateEnvironment(ctx context.Context, request OptUpdateEnvironmentReq, params UpdateEnvironmentParams) (res *UpdateEnvironmentOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateEnvironmentRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateEnvironment", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateEnvironment", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateEnvironmentResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateEnvironmentAccess invokes updateEnvironmentAccess operation.
//
// Updates the specificed Environment.
// Requires the `environments-manage` capability. If an ACL is present, requires the `manage`
// privilege.
//
// PATCH /v1/environments/{environmentId}/access
func (c *Client) UpdateEnvironmentAccess(ctx context.Context, request OptUpdateEnvironmentAccessReq, params UpdateEnvironmentAccessParams) (*UpdateEnvironmentAccessOK, error) {
	res, err := c.sendUpdateEnvironmentAccess(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateEnvironmentAccess(ctx context.Context, request OptUpdateEnvironmentAccessReq, params UpdateEnvironmentAccessParams) (res *UpdateEnvironmentAccessOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/access"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateEnvironmentAccessRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateEnvironmentAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateEnvironmentAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateEnvironmentAccessResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateHub invokes updateHub operation.
//
// Updates the specified hub, setting the values of the parameters passed.
//
// PATCH /v1/hubs/current
func (c *Client) UpdateHub(ctx context.Context, request OptUpdateHubReq) (*UpdateHubOK, error) {
	res, err := c.sendUpdateHub(ctx, request)
	return res, err
}

func (c *Client) sendUpdateHub(ctx context.Context, request OptUpdateHubReq) (res *UpdateHubOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/v1/hubs/current"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateHubRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateHub", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateHub", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateHubResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateHubMember invokes updateHubMember operation.
//
// Requires the `hubs-members-manage` capability.
//
// PATCH /v1/hubs/current/members/{memberId}
func (c *Client) UpdateHubMember(ctx context.Context, request OptUpdateHubMemberReq, params UpdateHubMemberParams) (*UpdateHubMemberOK, error) {
	res, err := c.sendUpdateHubMember(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateHubMember(ctx context.Context, request OptUpdateHubMemberReq, params UpdateHubMemberParams) (res *UpdateHubMemberOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/members/"
	{
		// Encode "memberId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "memberId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.MemberId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateHubMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateHubMember", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateHubMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateImage invokes updateImage operation.
//
// Requires the `images-manage` capability.
//
// PATCH /v1/images/{imageId}
func (c *Client) UpdateImage(ctx context.Context, request OptUpdateImageReq, params UpdateImageParams) (*UpdateImageOK, error) {
	res, err := c.sendUpdateImage(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateImage(ctx context.Context, request OptUpdateImageReq, params UpdateImageParams) (res *UpdateImageOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/images/"
	{
		// Encode "imageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "imageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ImageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateImageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateImage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateImage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateImageSource invokes updateImageSource operation.
//
// Requires the `images-sources-manage` capability.
//
// PATCH /v1/images/sources/{sourceId}
func (c *Client) UpdateImageSource(ctx context.Context, request OptUpdateImageSourceReq, params UpdateImageSourceParams) (*UpdateImageSourceOK, error) {
	res, err := c.sendUpdateImageSource(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateImageSource(ctx context.Context, request OptUpdateImageSourceReq, params UpdateImageSourceParams) (res *UpdateImageSourceOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/images/sources/"
	{
		// Encode "sourceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sourceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SourceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateImageSourceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateImageSource", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateImageSource", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateImageSourceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateImageSourceAccess invokes updateImageSourceAccess operation.
//
// Requires the `images-sources-manage` capability. If an ACL is present, requires the `manage`
// privilege.
//
// PATCH /v1/images/sources/{sourceId}/access
func (c *Client) UpdateImageSourceAccess(ctx context.Context, request OptUpdateImageSourceAccessReq, params UpdateImageSourceAccessParams) (*UpdateImageSourceAccessOK, error) {
	res, err := c.sendUpdateImageSourceAccess(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateImageSourceAccess(ctx context.Context, request OptUpdateImageSourceAccessReq, params UpdateImageSourceAccessParams) (res *UpdateImageSourceAccessOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/images/sources/"
	{
		// Encode "sourceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sourceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.SourceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/access"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateImageSourceAccessRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateImageSourceAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateImageSourceAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateImageSourceAccessResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateIntegration invokes updateIntegration operation.
//
// Updates the specified Integration within the current hub. If the Integration definition specifies
// that it requires verification, then you must submit a verify task to enable it.
//
// PATCH /v1/hubs/current/integrations/{integrationId}
func (c *Client) UpdateIntegration(ctx context.Context, request *UpdateIntegrationReq, params UpdateIntegrationParams) (*UpdateIntegrationOK, error) {
	res, err := c.sendUpdateIntegration(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateIntegration(ctx context.Context, request *UpdateIntegrationReq, params UpdateIntegrationParams) (res *UpdateIntegrationOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/integrations/"
	{
		// Encode "integrationId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "integrationId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IntegrationId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "meta" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "meta",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Meta {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateIntegrationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateIntegration", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateIntegrationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateNetwork invokes updateNetwork operation.
//
// Requires the `sdn-networks-manage` capability.
//
// PATCH /v1/sdn/networks/{networkId}
func (c *Client) UpdateNetwork(ctx context.Context, request OptUpdateNetworkReq, params UpdateNetworkParams) (*UpdateNetworkOK, error) {
	res, err := c.sendUpdateNetwork(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateNetwork(ctx context.Context, request OptUpdateNetworkReq, params UpdateNetworkParams) (res *UpdateNetworkOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/sdn/networks/"
	{
		// Encode "networkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "networkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NetworkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateNetworkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateNetwork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateNetwork", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateNetworkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateNetworkAccess invokes updateNetworkAccess operation.
//
// Requires the `sdn-networks-manage` capability. If an ACL is present, requires the `manage`
// privilege.
//
// PATCH /v1/sdn/networks/{networkId}/access
func (c *Client) UpdateNetworkAccess(ctx context.Context, request OptUpdateNetworkAccessReq, params UpdateNetworkAccessParams) (*UpdateNetworkAccessOK, error) {
	res, err := c.sendUpdateNetworkAccess(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateNetworkAccess(ctx context.Context, request OptUpdateNetworkAccessReq, params UpdateNetworkAccessParams) (res *UpdateNetworkAccessOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/sdn/networks/"
	{
		// Encode "networkId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "networkId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.NetworkId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/access"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.Include {
					if err := func() error {
						return e.EncodeValue(conv.StringToString(string(item)))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateNetworkAccessRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateNetworkAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateNetworkAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateNetworkAccessResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePipeline invokes updatePipeline operation.
//
// Requires the `pipelines-manage` capability.
//
// PATCH /v1/pipelines/{pipelineId}
func (c *Client) UpdatePipeline(ctx context.Context, request OptUpdatePipelineReq, params UpdatePipelineParams) (*UpdatePipelineOK, error) {
	res, err := c.sendUpdatePipeline(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdatePipeline(ctx context.Context, request OptUpdatePipelineReq, params UpdatePipelineParams) (res *UpdatePipelineOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePipelineRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdatePipeline", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdatePipeline", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdatePipelineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePipelineAccess invokes updatePipelineAccess operation.
//
// Requires the `pipelines-manage` capability. If an ACL is present, requires the `manage` privilege.
//
// PATCH /v1/pipelines/{pipelineId}/access
func (c *Client) UpdatePipelineAccess(ctx context.Context, request OptUpdatePipelineAccessReq, params UpdatePipelineAccessParams) (*UpdatePipelineAccessOK, error) {
	res, err := c.sendUpdatePipelineAccess(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdatePipelineAccess(ctx context.Context, request OptUpdatePipelineAccessReq, params UpdatePipelineAccessParams) (res *UpdatePipelineAccessOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/access"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePipelineAccessRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdatePipelineAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdatePipelineAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdatePipelineAccessResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdatePipelineTriggerKey invokes updatePipelineTriggerKey operation.
//
// Requires the `pipelines-manage` capability.
//
// PATCH /v1/pipelines/{pipelineId}/keys/{triggerKeyId}
func (c *Client) UpdatePipelineTriggerKey(ctx context.Context, request OptUpdatePipelineTriggerKeyReq, params UpdatePipelineTriggerKeyParams) (*UpdatePipelineTriggerKeyOK, error) {
	res, err := c.sendUpdatePipelineTriggerKey(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdatePipelineTriggerKey(ctx context.Context, request OptUpdatePipelineTriggerKeyReq, params UpdatePipelineTriggerKeyParams) (res *UpdatePipelineTriggerKeyOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/pipelines/"
	{
		// Encode "pipelineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "pipelineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.PipelineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/keys/"
	{
		// Encode "triggerKeyId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "triggerKeyId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TriggerKeyId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdatePipelineTriggerKeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdatePipelineTriggerKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdatePipelineTriggerKey", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdatePipelineTriggerKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateRole invokes updateRole operation.
//
// Updates various properties of a specific Role.
// Requires the `hubs-roles-manage` capability.
//
// PATCH /v1/hubs/current/roles/{roleId}
func (c *Client) UpdateRole(ctx context.Context, request OptUpdateRoleReq, params UpdateRoleParams) (*UpdateRoleOK, error) {
	res, err := c.sendUpdateRole(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateRole(ctx context.Context, request OptUpdateRoleReq, params UpdateRoleParams) (res *UpdateRoleOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/hubs/current/roles/"
	{
		// Encode "roleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RoleId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateRoleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateRole", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateRoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateScopedVariable invokes updateScopedVariable operation.
//
// Requires the `scoped-variables-manage` capability.
//
// PATCH /v1/environments/{environmentId}/scoped-variables/{scopedVariableId}
func (c *Client) UpdateScopedVariable(ctx context.Context, request OptUpdateScopedVariableReq, params UpdateScopedVariableParams) (*UpdateScopedVariableOK, error) {
	res, err := c.sendUpdateScopedVariable(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateScopedVariable(ctx context.Context, request OptUpdateScopedVariableReq, params UpdateScopedVariableParams) (res *UpdateScopedVariableOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/v1/environments/"
	{
		// Encode "environmentId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "environmentId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EnvironmentId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/scoped-variables/"
	{
		// Encode "scopedVariableId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "scopedVariableId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ScopedVariableId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateScopedVariableRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateScopedVariable", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateScopedVariable", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateScopedVariableResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateServer invokes updateServer operation.
//
// Requires the `servers-manage` capability.
//
// PATCH /v1/infrastructure/servers/{serverId}
func (c *Client) UpdateServer(ctx context.Context, request OptUpdateServerReq, params UpdateServerParams) (*UpdateServerOK, error) {
	res, err := c.sendUpdateServer(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateServer(ctx context.Context, request OptUpdateServerReq, params UpdateServerParams) (res *UpdateServerOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/infrastructure/servers/"
	{
		// Encode "serverId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "serverId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ServerId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateServerRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateServer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateServer", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateServerResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateStack invokes updateStack operation.
//
// Requires the `stacks-manage` capability.
//
// PATCH /v1/stacks/{stackId}
func (c *Client) UpdateStack(ctx context.Context, request OptUpdateStackReq, params UpdateStackParams) (*UpdateStackOK, error) {
	res, err := c.sendUpdateStack(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateStack(ctx context.Context, request OptUpdateStackReq, params UpdateStackParams) (res *UpdateStackOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/stacks/"
	{
		// Encode "stackId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stackId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StackId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateStackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateStack", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateStack", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateStackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateStackAccess invokes updateStackAccess operation.
//
// Requires the `stacks-manage` capability. If an ACL is present, requires the `manage` privilege.
//
// PATCH /v1/stacks/{stackId}/access
func (c *Client) UpdateStackAccess(ctx context.Context, request OptUpdateStackAccessReq, params UpdateStackAccessParams) (*UpdateStackAccessOK, error) {
	res, err := c.sendUpdateStackAccess(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateStackAccess(ctx context.Context, request OptUpdateStackAccessReq, params UpdateStackAccessParams) (res *UpdateStackAccessOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/v1/stacks/"
	{
		// Encode "stackId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stackId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.StackId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/access"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateStackAccessRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateStackAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateStackAccess", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateStackAccessResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateVirtualMachine invokes updateVirtualMachine operation.
//
// Updates the specified virtual machine.
// Requires the `virtual-machines-manage` capability.
//
// PATCH /v1/virtual-machines/{virtualMachineId}
func (c *Client) UpdateVirtualMachine(ctx context.Context, request OptUpdateVirtualMachineReq, params UpdateVirtualMachineParams) (*UpdateVirtualMachineOK, error) {
	res, err := c.sendUpdateVirtualMachine(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateVirtualMachine(ctx context.Context, request OptUpdateVirtualMachineReq, params UpdateVirtualMachineParams) (res *UpdateVirtualMachineOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/v1/virtual-machines/"
	{
		// Encode "virtualMachineId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "virtualMachineId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.VirtualMachineId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateVirtualMachineRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBearerAuth(ctx, "UpdateVirtualMachine", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}
		{

			switch err := c.securityHubAuth(ctx, "UpdateVirtualMachine", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"HubAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000011},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateVirtualMachineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
